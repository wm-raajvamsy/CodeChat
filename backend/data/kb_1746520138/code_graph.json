{"nodes": [{"id": "wavemaker-rn-runtime/babel.config.js", "type": "file", "name": "babel.config.js"}, {"id": "wavemaker-rn-runtime/test/jest.setup.js", "type": "file", "name": "jest.setup.js"}, {"id": "wavemaker-rn-runtime/test/index.test.tsx", "type": "file", "name": "index.test.tsx"}, {"id": "wavemaker-rn-runtime/test/__mocks__/navigation.service.ts", "type": "file", "name": "navigation.service.ts"}, {"id": "wavemaker-rn-runtime/test/__mocks__/react-native-animatable.js", "type": "file", "name": "react-native-animatable.js"}, {"id": "wavemaker-rn-runtime/test/core/utils.spec.ts", "type": "file", "name": "utils.spec.ts"}, {"id": "wavemaker-rn-runtime/test/core/base.component.spec.tsx", "type": "file", "name": "base.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/core/props.provider.spec.ts", "type": "file", "name": "props.provider.spec.ts"}, {"id": "wavemaker-rn-runtime/test/core/components/floatinglabel.component.spec.tsx", "type": "file", "name": "floatinglabel.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "type": "file", "name": "textinput.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/runtime/watcher.spec.ts", "type": "file", "name": "watcher.spec.ts"}, {"id": "wavemaker-rn-runtime/test/styles/background.component.spec.tsx", "type": "file", "name": "background.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/styles/theme.spec.ts", "type": "file", "name": "theme.spec.ts"}, {"id": "wavemaker-rn-runtime/test/components/page.component.spec.tsx", "type": "file", "name": "page.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/container.component.spec.tsx", "type": "file", "name": "container.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/advanced/login.component.spec.tsx", "type": "file", "name": "login.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/advanced/webview.component.spec.tsx", "type": "file", "name": "webview.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "type": "file", "name": "carousel.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/advanced/network-info-toaster.component.spec.tsx", "type": "file", "name": "network-info-toaster.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/advanced/carousel/carousel-template.component.spec.tsx", "type": "file", "name": "carousel-template.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/advanced/carousel/carousel-content.component.spec.tsx", "type": "file", "name": "carousel-content.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/page/content.component.spec.tsx", "type": "file", "name": "content.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/page/page-content.component.spec.tsx", "type": "file", "name": "page-content.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/page/left-panel.component.spec.tsx", "type": "file", "name": "left-panel.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/page/tabbar.component.spec.tsx", "type": "file", "name": "tabbar.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/page/partial-container.component.spec.tsx", "type": "file", "name": "partial-container.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/page/partial.component.spec.tsx", "type": "file", "name": "partial.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/input/toggle.component.spec.tsx", "type": "file", "name": "toggle.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/input/switch.component.spec.tsx", "type": "file", "name": "switch.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/input/textarea.component.spec.tsx", "type": "file", "name": "textarea.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/input/calendar.component.spec.tsx", "type": "file", "name": "calendar.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/input/chips.component.spec.tsx", "type": "file", "name": "chips.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/input/checkbox.component.spec.tsx", "type": "file", "name": "checkbox.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/input/select.component.spec.tsx", "type": "file", "name": "select.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "type": "file", "name": "text.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/input/fileupload.component.spec.tsx", "type": "file", "name": "fileupload.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/input/rating.component.spec.tsx", "type": "file", "name": "rating.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/input/radioset.component.spec.tsx", "type": "file", "name": "radioset.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx", "type": "file", "name": "currency.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/input/slider.component.spec.tsx", "type": "file", "name": "slider.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/input/number.component.spec.tsx", "type": "file", "name": "number.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/input/composite.component.spec.tsx", "type": "file", "name": "composite.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/input/checkboxset.component.spec.tsx", "type": "file", "name": "checkboxset.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "type": "file", "name": "date.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx", "type": "file", "name": "datetime.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/input/epoch/time.component.spec.tsx", "type": "file", "name": "time.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/chart/line-chart.component.spec.tsx", "type": "file", "name": "line-chart.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/chart/area-chart.component.spec.tsx", "type": "file", "name": "area-chart.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/chart/stack-chart.component.spec.tsx", "type": "file", "name": "stack-chart.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/chart/pie-chart.component.spec.tsx", "type": "file", "name": "pie-chart.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/chart/legend.component.spec.tsx", "type": "file", "name": "legend.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/chart/bubble-chart.component.spec.tsx", "type": "file", "name": "bubble-chart.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "type": "file", "name": "column-chart.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "type": "file", "name": "bar-chart.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/chart/donut-chart.component.spec.tsx", "type": "file", "name": "donut-chart.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/basic/button.component.spec.tsx", "type": "file", "name": "button.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/basic/spinner.component.spec.tsx", "type": "file", "name": "spinner.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/basic/message.component.spec.tsx", "type": "file", "name": "message.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/basic/anchor.component.spec.tsx", "type": "file", "name": "anchor.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/basic/modal.component.spec.tsx", "type": "file", "name": "modal.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/basic/progress-circle.component.spec.tsx", "type": "file", "name": "progress-circle.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/basic/progress-bar.component.spec.tsx", "type": "file", "name": "progress-bar.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "type": "file", "name": "search.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/basic/picture.component.spec.tsx", "type": "file", "name": "picture.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/basic/skeleton.component.spec.tsx", "type": "file", "name": "skeleton.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/basic/custom.component.spec.tsx", "type": "file", "name": "custom.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/basic/lottie.component.spec.tsx", "type": "file", "name": "lottie.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/basic/tooltip.component.spec.tsx", "type": "file", "name": "tooltip.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/basic/audio.component.spec.tsx", "type": "file", "name": "audio.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/basic/video.component.spec.tsx", "type": "file", "name": "video.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/basic/icon.component.spec.tsx", "type": "file", "name": "icon.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/basic/buttongroup.component.spec.tsx", "type": "file", "name": "buttongroup.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "type": "file", "name": "label.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/navigation/appnavbar.component.spec.tsx", "type": "file", "name": "appnavbar.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/navigation/navitem.component.spec.tsx", "type": "file", "name": "navitem.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/navigation/navbar.component.spec.tsx", "type": "file", "name": "navbar.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/navigation/menu.component.spec.tsx", "type": "file", "name": "menu.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "type": "file", "name": "popover.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "type": "file", "name": "wizard.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/container/linearlayout.component.spec.tsx", "type": "file", "name": "linearlayout.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "type": "file", "name": "tabs.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/container/layoutgrid.component.spec.tsx", "type": "file", "name": "layoutgrid.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/container/tile.component.spec.tsx", "type": "file", "name": "tile.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/container/panel.component.spec.tsx", "type": "file", "name": "panel.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/container/layoutgrid/gridcolumn.component.spec.tsx", "type": "file", "name": "gridcolumn.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/container/layoutgrid/gridrow.component.spec.tsx", "type": "file", "name": "gridrow.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/container/panel/panel-content.component.spec.tsx", "type": "file", "name": "panel-content.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/container/panel/panel-footer.component.spec.tsx", "type": "file", "name": "panel-footer.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/container/accordion/accordion.component.spec.tsx", "type": "file", "name": "accordion.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/container/accordion/accordionpane/accordionpane.component.spec.tsx", "type": "file", "name": "accordionpane.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/container/wizard/wizardstep.component.spec.tsx", "type": "file", "name": "wizardstep.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/container/linearlayout/linearlayoutitem.component.spec.tsx", "type": "file", "name": "linearlayoutitem.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/prefab/prefab-container.component.spec.tsx", "type": "file", "name": "prefab-container.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/dialogs/dialog.component.spec.tsx", "type": "file", "name": "dialog.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/dialogs/dialogcontent.component.spec.tsx", "type": "file", "name": "dialogcontent.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "type": "file", "name": "alertdialog.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/dialogs/dialogactions.component.spec.tsx", "type": "file", "name": "dialogactions.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/dialogs/confirmdialog.component.spec.tsx", "type": "file", "name": "confirmdialog.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/device/camera.component.spec.tsx", "type": "file", "name": "camera.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/device/barcodescanner.component.spec.tsx", "type": "file", "name": "barcodescanner.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/data/list.component.spec.tsx", "type": "file", "name": "list.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "type": "file", "name": "form.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/data/card.component.spec.tsx", "type": "file", "name": "card.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/data/form/form-field.component.spec.tsx", "type": "file", "name": "form-field.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/data/form/form-footer.component.spec.tsx", "type": "file", "name": "form-footer.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/data/form/form-body.component.spec.tsx", "type": "file", "name": "form-body.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/data/card/card-footer.component.spec.tsx", "type": "file", "name": "card-footer.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/data/card/card-content.component.spec.tsx", "type": "file", "name": "card-content.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/data/list/list-action-template.component.spec.tsx", "type": "file", "name": "list-action-template.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/data/list/list-template.component.spec.tsx", "type": "file", "name": "list-template.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/test/components/data/liveform/liveform.component.spec.tsx", "type": "file", "name": "liveform.component.spec.tsx"}, {"id": "wavemaker-rn-runtime/typings/fonts.d.ts", "type": "file", "name": "fonts.d.ts"}, {"id": "wavemaker-rn-runtime/scripts/wavicon-generator.js", "type": "file", "name": "wavicon-generator.js"}, {"id": "wavemaker-rn-runtime/scripts/bootstrap.js", "type": "file", "name": "bootstrap.js"}, {"id": "wavemaker-rn-runtime/scripts/build.js", "type": "file", "name": "build.js"}, {"id": "wavemaker-rn-runtime/scripts/widget.js", "type": "file", "name": "widget.js"}, {"id": "wavemaker-rn-runtime/scripts/combineCoverageHtmlCSS.js", "type": "file", "name": "combineCoverageHtmlCSS.js"}, {"id": "wavemaker-rn-runtime/src/index.ts", "type": "file", "name": "index.ts"}, {"id": "wavemaker-rn-runtime/src/core/fixed-view.component.tsx", "type": "file", "name": "fixed-view.component.tsx"}, {"id": "wavemaker-rn-runtime/src/core/toast.service.ts", "type": "file", "name": "toast.service.ts"}, {"id": "wavemaker-rn-runtime/src/core/navigation.service.ts", "type": "file", "name": "navigation.service.ts"}, {"id": "wavemaker-rn-runtime/src/core/if.component.tsx", "type": "file", "name": "if.component.tsx"}, {"id": "wavemaker-rn-runtime/src/core/sticky-container.component.tsx", "type": "file", "name": "sticky-container.component.tsx"}, {"id": "wavemaker-rn-runtime/src/core/event-notifier.ts", "type": "file", "name": "event-notifier.ts"}, {"id": "wavemaker-rn-runtime/src/core/asset.provider.ts", "type": "file", "name": "asset.provider.ts"}, {"id": "wavemaker-rn-runtime/src/core/accessibility.ts", "type": "file", "name": "accessibility.ts"}, {"id": "wavemaker-rn-runtime/src/core/modal.service.ts", "type": "file", "name": "modal.service.ts"}, {"id": "wavemaker-rn-runtime/src/core/partial.service.ts", "type": "file", "name": "partial.service.ts"}, {"id": "wavemaker-rn-runtime/src/core/currency-constants.ts", "type": "file", "name": "currency-constants.ts"}, {"id": "wavemaker-rn-runtime/src/core/wm-component-tree.ts", "type": "file", "name": "wm-component-tree.ts"}, {"id": "wavemaker-rn-runtime/src/core/testid.provider.ts", "type": "file", "name": "testid.provider.ts"}, {"id": "wavemaker-rn-runtime/src/core/utils.ts", "type": "file", "name": "utils.ts"}, {"id": "wavemaker-rn-runtime/src/core/props.provider.ts", "type": "file", "name": "props.provider.ts"}, {"id": "wavemaker-rn-runtime/src/core/viewport.ts", "type": "file", "name": "viewport.ts"}, {"id": "wavemaker-rn-runtime/src/core/display.manager.ts", "type": "file", "name": "display.manager.ts"}, {"id": "wavemaker-rn-runtime/src/core/tappable.component.tsx", "type": "file", "name": "tappable.component.tsx"}, {"id": "wavemaker-rn-runtime/src/core/ui-preferences.context.ts", "type": "file", "name": "ui-preferences.context.ts"}, {"id": "wavemaker-rn-runtime/src/core/injector.ts", "type": "file", "name": "injector.ts"}, {"id": "wavemaker-rn-runtime/src/core/base.component.tsx", "type": "file", "name": "base.component.tsx"}, {"id": "wavemaker-rn-runtime/src/core/logger.ts", "type": "file", "name": "logger.ts"}, {"id": "wavemaker-rn-runtime/src/core/file-extension-types.ts", "type": "file", "name": "file-extension-types.ts"}, {"id": "wavemaker-rn-runtime/src/core/AppConfig.ts", "type": "file", "name": "AppConfig.ts"}, {"id": "wavemaker-rn-runtime/src/core/scroll-view.component.tsx", "type": "file", "name": "scroll-view.component.tsx"}, {"id": "wavemaker-rn-runtime/src/core/security.service.ts", "type": "file", "name": "security.service.ts"}, {"id": "wavemaker-rn-runtime/src/core/i18n.service.ts", "type": "file", "name": "i18n.service.ts"}, {"id": "wavemaker-rn-runtime/src/core/constant.service.ts", "type": "file", "name": "constant.service.ts"}, {"id": "wavemaker-rn-runtime/src/core/formatters.ts", "type": "file", "name": "formatters.ts"}, {"id": "wavemaker-rn-runtime/src/core/storage.service.ts", "type": "file", "name": "storage.service.ts"}, {"id": "wavemaker-rn-runtime/src/core/network.service.ts", "type": "file", "name": "network.service.ts"}, {"id": "wavemaker-rn-runtime/src/core/imageSizeEstimator.ts", "type": "file", "name": "imageSizeEstimator.ts"}, {"id": "wavemaker-rn-runtime/src/core/spinner.service.ts", "type": "file", "name": "spinner.service.ts"}, {"id": "wavemaker-rn-runtime/src/core/key.extractor.ts", "type": "file", "name": "key.extractor.ts"}, {"id": "wavemaker-rn-runtime/src/core/constants/currency-constants.ts", "type": "file", "name": "currency-constants.ts"}, {"id": "wavemaker-rn-runtime/src/core/components/textinput.component.tsx", "type": "file", "name": "textinput.component.tsx"}, {"id": "wavemaker-rn-runtime/src/core/components/floatinglabel.component.tsx", "type": "file", "name": "floatinglabel.component.tsx"}, {"id": "wavemaker-rn-runtime/src/core/device/location-service.ts", "type": "file", "name": "location-service.ts"}, {"id": "wavemaker-rn-runtime/src/core/device/camera-service.ts", "type": "file", "name": "camera-service.ts"}, {"id": "wavemaker-rn-runtime/src/core/device/contacts-service.ts", "type": "file", "name": "contacts-service.ts"}, {"id": "wavemaker-rn-runtime/src/core/device/calendar-service.ts", "type": "file", "name": "calendar-service.ts"}, {"id": "wavemaker-rn-runtime/src/core/device/scan-service.ts", "type": "file", "name": "scan-service.ts"}, {"id": "wavemaker-rn-runtime/src/runtime/platform.api.ts", "type": "file", "name": "platform.api.ts"}, {"id": "wavemaker-rn-runtime/src/runtime/App.navigator.tsx", "type": "file", "name": "App.navigator.tsx"}, {"id": "wavemaker-rn-runtime/src/runtime/App.tsx", "type": "file", "name": "App.tsx"}, {"id": "wavemaker-rn-runtime/src/runtime/base-prefab.component.tsx", "type": "file", "name": "base-prefab.component.tsx"}, {"id": "wavemaker-rn-runtime/src/runtime/watcher.ts", "type": "file", "name": "watcher.ts"}, {"id": "wavemaker-rn-runtime/src/runtime/lib-patch.ts", "type": "file", "name": "lib-patch.ts"}, {"id": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "type": "file", "name": "base-fragment.component.tsx"}, {"id": "wavemaker-rn-runtime/src/runtime/base-partial.component.tsx", "type": "file", "name": "base-partial.component.tsx"}, {"id": "wavemaker-rn-runtime/src/runtime/memo.component.tsx", "type": "file", "name": "memo.component.tsx"}, {"id": "wavemaker-rn-runtime/src/runtime/base-page.component.tsx", "type": "file", "name": "base-page.component.tsx"}, {"id": "wavemaker-rn-runtime/src/runtime/navigator/drawer.navigator.tsx", "type": "file", "name": "drawer.navigator.tsx"}, {"id": "wavemaker-rn-runtime/src/runtime/navigator/stack.navigator.tsx", "type": "file", "name": "stack.navigator.tsx"}, {"id": "wavemaker-rn-runtime/src/runtime/services/webprocess.service.tsx", "type": "file", "name": "webprocess.service.tsx"}, {"id": "wavemaker-rn-runtime/src/runtime/services/app-modal.service.tsx", "type": "file", "name": "app-modal.service.tsx"}, {"id": "wavemaker-rn-runtime/src/runtime/services/app-toast.service.tsx", "type": "file", "name": "app-toast.service.tsx"}, {"id": "wavemaker-rn-runtime/src/runtime/services/partial.service.tsx", "type": "file", "name": "partial.service.tsx"}, {"id": "wavemaker-rn-runtime/src/runtime/services/app-i18n.service.tsx", "type": "file", "name": "app-i18n.service.tsx"}, {"id": "wavemaker-rn-runtime/src/runtime/services/app-spinner.service.tsx", "type": "file", "name": "app-spinner.service.tsx"}, {"id": "wavemaker-rn-runtime/src/runtime/services/app-display-manager.service.tsx", "type": "file", "name": "app-display-manager.service.tsx"}, {"id": "wavemaker-rn-runtime/src/runtime/services/app-security.service.tsx", "type": "file", "name": "app-security.service.tsx"}, {"id": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "type": "file", "name": "camera-service.tsx"}, {"id": "wavemaker-rn-runtime/src/runtime/services/device/location-service.ts", "type": "file", "name": "location-service.ts"}, {"id": "wavemaker-rn-runtime/src/runtime/services/device/permissions.ts", "type": "file", "name": "permissions.ts"}, {"id": "wavemaker-rn-runtime/src/runtime/services/device/scan-service.tsx", "type": "file", "name": "scan-service.tsx"}, {"id": "wavemaker-rn-runtime/src/runtime/services/device/contacts-service.ts", "type": "file", "name": "contacts-service.ts"}, {"id": "wavemaker-rn-runtime/src/runtime/services/device/calendar-service.ts", "type": "file", "name": "calendar-service.ts"}, {"id": "wavemaker-rn-runtime/src/styles/MediaQueryList.ts", "type": "file", "name": "MediaQueryList.ts"}, {"id": "wavemaker-rn-runtime/src/styles/theme.variables.ts", "type": "file", "name": "theme.variables.ts"}, {"id": "wavemaker-rn-runtime/src/styles/theme.tsx", "type": "file", "name": "theme.tsx"}, {"id": "wavemaker-rn-runtime/src/styles/background.component.tsx", "type": "file", "name": "background.component.tsx"}, {"id": "wavemaker-rn-runtime/src/styles/style-props.ts", "type": "file", "name": "style-props.ts"}, {"id": "wavemaker-rn-runtime/src/styles/style-prop.validator.ts", "type": "file", "name": "style-prop.validator.ts"}, {"id": "wavemaker-rn-runtime/src/components/advanced/webview/webview.component.tsx", "type": "file", "name": "webview.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/advanced/webview/webview.styles.ts", "type": "file", "name": "webview.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/advanced/webview/webview.props.ts", "type": "file", "name": "webview.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.props.ts", "type": "file", "name": "carousel.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.component.tsx", "type": "file", "name": "carousel.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.styles.ts", "type": "file", "name": "carousel.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-template/carousel-template.props.ts", "type": "file", "name": "carousel-template.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-template/carousel-template.styles.ts", "type": "file", "name": "carousel-template.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-template/carousel-template.component.tsx", "type": "file", "name": "carousel-template.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-content/carousel-content.props.ts", "type": "file", "name": "carousel-content.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-content/carousel-content.component.tsx", "type": "file", "name": "carousel-content.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-content/carousel-content.styles.ts", "type": "file", "name": "carousel-content.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/advanced/login/login.component.tsx", "type": "file", "name": "login.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/advanced/login/login.props.ts", "type": "file", "name": "login.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/advanced/login/login.styles.ts", "type": "file", "name": "login.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "type": "file", "name": "network-info-toaster.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.props.ts", "type": "file", "name": "network-info-toaster.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.styles.ts", "type": "file", "name": "network-info-toaster.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/page/page.styles.ts", "type": "file", "name": "page.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/page/page.component.tsx", "type": "file", "name": "page.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/page/page.props.ts", "type": "file", "name": "page.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/page/partial/partial.component.tsx", "type": "file", "name": "partial.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/page/partial/partial.styles.ts", "type": "file", "name": "partial.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/page/partial/partial.props.ts", "type": "file", "name": "partial.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.styles.ts", "type": "file", "name": "tabbar.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "type": "file", "name": "tabbar.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.props.ts", "type": "file", "name": "tabbar.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/page/tabbar/curve.tsx", "type": "file", "name": "curve.tsx"}, {"id": "wavemaker-rn-runtime/src/components/page/content/content.component.tsx", "type": "file", "name": "content.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/page/content/content.styles.ts", "type": "file", "name": "content.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/page/content/content.props.ts", "type": "file", "name": "content.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/page/left-panel/left-panel.component.tsx", "type": "file", "name": "left-panel.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/page/left-panel/left-panel.styles.ts", "type": "file", "name": "left-panel.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/page/left-panel/left-panel.props.ts", "type": "file", "name": "left-panel.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/page/page-content/page-content.styles.ts", "type": "file", "name": "page-content.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/page/page-content/page-content.component.tsx", "type": "file", "name": "page-content.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/page/page-content/page-content.props.ts", "type": "file", "name": "page-content.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/page/partial-container/partial-container.styles.ts", "type": "file", "name": "partial-container.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/page/partial-container/partial-container.props.ts", "type": "file", "name": "partial-container.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/page/partial-container/partial-container.component.tsx", "type": "file", "name": "partial-container.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/radioset/radioset.styles.ts", "type": "file", "name": "radioset.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/radioset/radioset.props.ts", "type": "file", "name": "radioset.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "type": "file", "name": "radioset.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.props.ts", "type": "file", "name": "fileupload.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.styles.ts", "type": "file", "name": "fileupload.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.component.tsx", "type": "file", "name": "fileupload.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/rating/rating.component.tsx", "type": "file", "name": "rating.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/rating/rating.props.ts", "type": "file", "name": "rating.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/rating/rating.styles.ts", "type": "file", "name": "rating.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/calendar/calendar.component.tsx", "type": "file", "name": "calendar.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/calendar/calendar.props.ts", "type": "file", "name": "calendar.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/calendar/calendar.styles.ts", "type": "file", "name": "calendar.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.tsx", "type": "file", "name": "month-view.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.styles.ts", "type": "file", "name": "month-view.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/basedataset/basedataset.props.ts", "type": "file", "name": "basedataset.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/basedataset/basedataset.component.ts", "type": "file", "name": "basedataset.component.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/basedataset/basedataset.styles.ts", "type": "file", "name": "basedataset.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/chips/chips.props.ts", "type": "file", "name": "chips.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "type": "file", "name": "chips.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/chips/chips.styles.ts", "type": "file", "name": "chips.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/basenumber/basenumber.component.ts", "type": "file", "name": "basenumber.component.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/basenumber/basenumber.styles.ts", "type": "file", "name": "basenumber.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/basenumber/basenumber.props.ts", "type": "file", "name": "basenumber.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "type": "file", "name": "base-datetime.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/epoch/wheel-time-picker.component.tsx", "type": "file", "name": "wheel-time-picker.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/epoch/wheel-date-picker.component.tsx", "type": "file", "name": "wheel-date-picker.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/epoch/date-picker.component.tsx", "type": "file", "name": "date-picker.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.component.tsx", "type": "file", "name": "datetime.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.styles.ts", "type": "file", "name": "datetime.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.props.ts", "type": "file", "name": "datetime.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/epoch/date/date.props.ts", "type": "file", "name": "date.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/epoch/date/date.component.tsx", "type": "file", "name": "date.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/epoch/date/date.styles.ts", "type": "file", "name": "date.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/epoch/time/time.props.ts", "type": "file", "name": "time.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/epoch/time/time.component.tsx", "type": "file", "name": "time.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/epoch/time/time.styles.ts", "type": "file", "name": "time.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/epoch/wheelpicker/wheelpicker.props.ts", "type": "file", "name": "wheelpicker.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/epoch/wheelpicker/wheelpicker.styles.ts", "type": "file", "name": "wheelpicker.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/epoch/wheelpicker/wheelpicker.component.tsx", "type": "file", "name": "wheelpicker.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/date/date-picker-modal.props.ts", "type": "file", "name": "date-picker-modal.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/date/date-picker-modal.component.tsx", "type": "file", "name": "date-picker-modal.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/time/time-picker-modal.component.tsx", "type": "file", "name": "time-picker-modal.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/time/time-picker-modal.props.ts", "type": "file", "name": "time-picker-modal.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/styles/datetime-picker-modal.styles.ts", "type": "file", "name": "datetime-picker-modal.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.styles.ts", "type": "file", "name": "checkboxset.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.props.ts", "type": "file", "name": "checkboxset.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx", "type": "file", "name": "checkboxset.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.props.ts", "type": "file", "name": "checkbox.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.styles.ts", "type": "file", "name": "checkbox.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.component.tsx", "type": "file", "name": "checkbox.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/slider/slider.component.tsx", "type": "file", "name": "slider.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/slider/slider.props.ts", "type": "file", "name": "slider.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/slider/slider.styles.ts", "type": "file", "name": "slider.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/baseinput/baseinput.props.ts", "type": "file", "name": "baseinput.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/baseinput/baseinput.component.ts", "type": "file", "name": "baseinput.component.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/baseinput/baseinput.styles.ts", "type": "file", "name": "baseinput.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/composite/composite.component.tsx", "type": "file", "name": "composite.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/composite/composite.styles.ts", "type": "file", "name": "composite.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/composite/composite.props.ts", "type": "file", "name": "composite.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/number/number.styles.ts", "type": "file", "name": "number.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/number/number.component.tsx", "type": "file", "name": "number.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/number/number.props.ts", "type": "file", "name": "number.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/toggle/toggle.styles.ts", "type": "file", "name": "toggle.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/toggle/toggle.props.ts", "type": "file", "name": "toggle.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/toggle/toggle.component.tsx", "type": "file", "name": "toggle.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/textarea/textarea.props.ts", "type": "file", "name": "textarea.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/textarea/textarea.component.tsx", "type": "file", "name": "textarea.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/textarea/textarea.styles.ts", "type": "file", "name": "textarea.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/switch/switch.component.tsx", "type": "file", "name": "switch.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/switch/switch.props.ts", "type": "file", "name": "switch.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/switch/switch.styles.ts", "type": "file", "name": "switch.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/text/text.props.ts", "type": "file", "name": "text.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/text/text.styles.ts", "type": "file", "name": "text.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/text/text.component.tsx", "type": "file", "name": "text.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/select/select.props.ts", "type": "file", "name": "select.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "type": "file", "name": "select.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/select/select.styles.ts", "type": "file", "name": "select.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/currency/currency.component.tsx", "type": "file", "name": "currency.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/input/currency/currency.props.ts", "type": "file", "name": "currency.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/input/currency/currency.styles.ts", "type": "file", "name": "currency.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/chart/staticdata.tsx", "type": "file", "name": "staticdata.tsx"}, {"id": "wavemaker-rn-runtime/src/components/chart/basechart.styles.ts", "type": "file", "name": "basechart.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "type": "file", "name": "basechart.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/chart/basechart.props.ts", "type": "file", "name": "basechart.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.styles.ts", "type": "file", "name": "bubble-chart.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.props.ts", "type": "file", "name": "bubble-chart.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.component.tsx", "type": "file", "name": "bubble-chart.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/chart/legend/legend.component.tsx", "type": "file", "name": "legend.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.component.tsx", "type": "file", "name": "stack-chart.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.props.ts", "type": "file", "name": "stack-chart.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.styles.ts", "type": "file", "name": "stack-chart.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "type": "file", "name": "pie-chart.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.props.ts", "type": "file", "name": "pie-chart.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.styles.ts", "type": "file", "name": "pie-chart.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.styles.ts", "type": "file", "name": "bar-chart.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.component.tsx", "type": "file", "name": "bar-chart.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.props.ts", "type": "file", "name": "bar-chart.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/chart/column-chart/column-chart.styles.ts", "type": "file", "name": "column-chart.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/chart/column-chart/column-chart.props.ts", "type": "file", "name": "column-chart.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/chart/column-chart/column-chart.component.tsx", "type": "file", "name": "column-chart.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/chart/theme/chart.theme.ts", "type": "file", "name": "chart.theme.ts"}, {"id": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.props.ts", "type": "file", "name": "area-chart.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "type": "file", "name": "area-chart.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.styles.ts", "type": "file", "name": "area-chart.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.component.tsx", "type": "file", "name": "line-chart.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.props.ts", "type": "file", "name": "line-chart.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.styles.ts", "type": "file", "name": "line-chart.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/chart/donut-chart/donut-chart.component.tsx", "type": "file", "name": "donut-chart.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/chart/donut-chart/donut-chart.props.ts", "type": "file", "name": "donut-chart.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/chart/donut-chart/donut-chart.styles.ts", "type": "file", "name": "donut-chart.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/animatedview.component.tsx", "type": "file", "name": "animatedview.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.styles.ts", "type": "file", "name": "progress-circle.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.component.tsx", "type": "file", "name": "progress-circle.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.props.ts", "type": "file", "name": "progress-circle.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/video/video.props.ts", "type": "file", "name": "video.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/video/video.styles.ts", "type": "file", "name": "video.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/video/video.component.tsx", "type": "file", "name": "video.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/basic/tooltip/tooltip.props.ts", "type": "file", "name": "tooltip.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/tooltip/tooltip.styles.ts", "type": "file", "name": "tooltip.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/tooltip/tooltip.component.tsx", "type": "file", "name": "tooltip.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/basic/buttongroup/buttongroup.props.ts", "type": "file", "name": "buttongroup.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/buttongroup/buttongroup.styles.ts", "type": "file", "name": "buttongroup.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/buttongroup/buttongroup.component.tsx", "type": "file", "name": "buttongroup.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles.ts", "type": "file", "name": "skeleton.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.props.ts", "type": "file", "name": "skeleton.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.component.tsx", "type": "file", "name": "skeleton.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.props.ts", "type": "file", "name": "progress-bar.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.component.tsx", "type": "file", "name": "progress-bar.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.styles.ts", "type": "file", "name": "progress-bar.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/picture/picture.props.ts", "type": "file", "name": "picture.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/picture/picture.component.tsx", "type": "file", "name": "picture.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/basic/picture/picture.styles.ts", "type": "file", "name": "picture.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/label/label.component.tsx", "type": "file", "name": "label.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/basic/label/label.props.ts", "type": "file", "name": "label.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/label/label.styles.ts", "type": "file", "name": "label.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/message/message.component.tsx", "type": "file", "name": "message.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/basic/message/message.props.ts", "type": "file", "name": "message.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/message/message.styles.ts", "type": "file", "name": "message.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/spinner/spinner.styles.ts", "type": "file", "name": "spinner.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/spinner/spinner.props.ts", "type": "file", "name": "spinner.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/spinner/spinner.component.tsx", "type": "file", "name": "spinner.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/basic/search/search.styles.ts", "type": "file", "name": "search.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "type": "file", "name": "search.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/basic/search/local-data-provider.ts", "type": "file", "name": "local-data-provider.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/search/search.props.ts", "type": "file", "name": "search.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/audio/audio.styles.ts", "type": "file", "name": "audio.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/audio/audio.component.tsx", "type": "file", "name": "audio.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/basic/audio/audio.props.ts", "type": "file", "name": "audio.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/button/button.component.tsx", "type": "file", "name": "button.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/basic/button/button.props.ts", "type": "file", "name": "button.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/button/button.styles.ts", "type": "file", "name": "button.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/lottie/lottie.props.ts", "type": "file", "name": "lottie.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/lottie/lottie.styles.ts", "type": "file", "name": "lottie.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/lottie/lottie.component.tsx", "type": "file", "name": "lottie.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.props.ts", "type": "file", "name": "anchor.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.component.tsx", "type": "file", "name": "anchor.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.styles.ts", "type": "file", "name": "anchor.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/icon/icon.props.ts", "type": "file", "name": "icon.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/icon/icon.styles.ts", "type": "file", "name": "icon.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/icon/icon.component.tsx", "type": "file", "name": "icon.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/basic/icon/wavicon/wavicon.component.tsx", "type": "file", "name": "wavicon.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/basic/icon/streamline-regular-icon/streamline-regular-icon.component.tsx", "type": "file", "name": "streamline-regular-icon.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/basic/icon/streamline-light-icon/streamline-light-icon.component.tsx", "type": "file", "name": "streamline-light-icon.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/basic/modal/modal.component.tsx", "type": "file", "name": "modal.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/basic/modal/modal.styles.ts", "type": "file", "name": "modal.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/modal/modal.props.ts", "type": "file", "name": "modal.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/custom/custom.styles.ts", "type": "file", "name": "custom.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/custom/custom.props.ts", "type": "file", "name": "custom.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/basic/custom/custom.component.tsx", "type": "file", "name": "custom.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.component.tsx", "type": "file", "name": "navbar.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.styles.ts", "type": "file", "name": "navbar.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.props.ts", "type": "file", "name": "navbar.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/navigation/basenav/basenav.props.ts", "type": "file", "name": "basenav.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/navigation/basenav/basenav.component.ts", "type": "file", "name": "basenav.component.ts"}, {"id": "wavemaker-rn-runtime/src/components/navigation/basenav/basenav.styles.ts", "type": "file", "name": "basenav.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/navigation/popover/popover.styles.ts", "type": "file", "name": "popover.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/navigation/popover/popover.component.tsx", "type": "file", "name": "popover.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/navigation/popover/popover.props.ts", "type": "file", "name": "popover.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/navigation/menu/menu.component.tsx", "type": "file", "name": "menu.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/navigation/menu/menu.styles.ts", "type": "file", "name": "menu.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/navigation/menu/menu.props.ts", "type": "file", "name": "menu.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.props.ts", "type": "file", "name": "appnavbar.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "type": "file", "name": "appnavbar.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.styles.ts", "type": "file", "name": "appnavbar.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.props.ts", "type": "file", "name": "navitem.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.component.tsx", "type": "file", "name": "navitem.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.styles.ts", "type": "file", "name": "navitem.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/container.props.ts", "type": "file", "name": "container.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/container.component.tsx", "type": "file", "name": "container.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/container/partial-host.component.tsx", "type": "file", "name": "partial-host.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/container/container.styles.ts", "type": "file", "name": "container.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/tabs/tabs.props.ts", "type": "file", "name": "tabs.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/tabs/tabs.component.tsx", "type": "file", "name": "tabs.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/container/tabs/tabs.styles.ts", "type": "file", "name": "tabs.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/tabs/tabpane/tabpane.styles.ts", "type": "file", "name": "tabpane.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/tabs/tabpane/tabpane.props.ts", "type": "file", "name": "tabpane.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/tabs/tabpane/tabpane.component.tsx", "type": "file", "name": "tabpane.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.component.tsx", "type": "file", "name": "tabheader.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.props.ts", "type": "file", "name": "tabheader.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.styles.ts", "type": "file", "name": "tabheader.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/layoutgrid/layoutgrid.styles.ts", "type": "file", "name": "layoutgrid.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/layoutgrid/layoutgrid.props.ts", "type": "file", "name": "layoutgrid.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/layoutgrid/layoutgrid.component.tsx", "type": "file", "name": "layoutgrid.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridcolumn/gridcolumn.styles.ts", "type": "file", "name": "gridcolumn.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridcolumn/gridcolumn.component.tsx", "type": "file", "name": "gridcolumn.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridcolumn/gridcolumn.props.ts", "type": "file", "name": "gridcolumn.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridrow/gridrow.props.ts", "type": "file", "name": "gridrow.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridrow/gridrow.component.tsx", "type": "file", "name": "gridrow.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridrow/gridrow.styles.ts", "type": "file", "name": "gridrow.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/panel/panel.props.ts", "type": "file", "name": "panel.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/panel/panel.styles.ts", "type": "file", "name": "panel.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/panel/collapsible-pane.component.tsx", "type": "file", "name": "collapsible-pane.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "type": "file", "name": "panel.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/container/panel/panel-content/panel-content.component.tsx", "type": "file", "name": "panel-content.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/container/panel/panel-content/panel-content.styles.ts", "type": "file", "name": "panel-content.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/panel/panel-content/panel-content.props.ts", "type": "file", "name": "panel-content.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/panel/panel-footer/panel-footer.styles.ts", "type": "file", "name": "panel-footer.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/panel/panel-footer/panel-footer.component.tsx", "type": "file", "name": "panel-footer.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/container/panel/panel-footer/panel-footer.props.ts", "type": "file", "name": "panel-footer.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/accordion/accordion.props.ts", "type": "file", "name": "accordion.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx", "type": "file", "name": "accordion.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/container/accordion/accordion.styles.ts", "type": "file", "name": "accordion.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/accordion/accordionpane/accordionpane.component.tsx", "type": "file", "name": "accordionpane.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/container/accordion/accordionpane/accordionpane.styles.ts", "type": "file", "name": "accordionpane.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/accordion/accordionpane/accordionpane.props.ts", "type": "file", "name": "accordionpane.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/wizard/wizard.styles.ts", "type": "file", "name": "wizard.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "type": "file", "name": "wizard.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/container/wizard/wizard.props.ts", "type": "file", "name": "wizard.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/wizard/wizardstep/wizardstep.styles.ts", "type": "file", "name": "wizardstep.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/wizard/wizardstep/wizardstep.props.ts", "type": "file", "name": "wizardstep.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/wizard/wizardstep/wizardstep.component.tsx", "type": "file", "name": "wizardstep.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/container/tile/tile.props.ts", "type": "file", "name": "tile.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/tile/tile.styles.ts", "type": "file", "name": "tile.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/tile/tile.component.tsx", "type": "file", "name": "tile.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayout.component.tsx", "type": "file", "name": "linearlayout.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayout.styles.ts", "type": "file", "name": "linearlayout.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayout.props.ts", "type": "file", "name": "linearlayout.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayoutitem/linearlayoutitem.props.ts", "type": "file", "name": "linearlayoutitem.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayoutitem/linearlayoutitem.component.tsx", "type": "file", "name": "linearlayoutitem.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayoutitem/linearlayoutitem.styles.ts", "type": "file", "name": "linearlayoutitem.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/prefab/prefab-container.styles.ts", "type": "file", "name": "prefab-container.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/prefab/prefab-container.props.ts", "type": "file", "name": "prefab-container.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/prefab/prefab-container.component.tsx", "type": "file", "name": "prefab-container.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/dialogs/dialogactions/dialogactions.component.tsx", "type": "file", "name": "dialogactions.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/dialogs/dialogactions/dialogactions.props.ts", "type": "file", "name": "dialogactions.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/dialogs/dialogactions/dialogactions.styles.ts", "type": "file", "name": "dialogactions.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.props.ts", "type": "file", "name": "dialog.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.styles.ts", "type": "file", "name": "dialog.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.component.tsx", "type": "file", "name": "dialog.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.props.ts", "type": "file", "name": "confirmdialog.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.styles.ts", "type": "file", "name": "confirmdialog.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.component.tsx", "type": "file", "name": "confirmdialog.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/dialogs/dialogcontent/dialogcontent.styles.ts", "type": "file", "name": "dialogcontent.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/dialogs/dialogcontent/dialogcontent.props.ts", "type": "file", "name": "dialogcontent.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/dialogs/dialogcontent/dialogcontent.component.tsx", "type": "file", "name": "dialogcontent.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.styles.ts", "type": "file", "name": "alertdialog.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.props.ts", "type": "file", "name": "alertdialog.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.component.tsx", "type": "file", "name": "alertdialog.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/device/camera/camera.props.ts", "type": "file", "name": "camera.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/device/camera/camera.component.tsx", "type": "file", "name": "camera.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/device/camera/camera.styles.ts", "type": "file", "name": "camera.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.styles.ts", "type": "file", "name": "barcodescanner.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.component.tsx", "type": "file", "name": "barcodescanner.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.props.ts", "type": "file", "name": "barcodescanner.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "type": "file", "name": "form.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/data/form/form.props.ts", "type": "file", "name": "form.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/data/form/form.styles.ts", "type": "file", "name": "form.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/data/form/form-footer/form-footer.component.tsx", "type": "file", "name": "form-footer.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/data/form/form-footer/form-footer.styles.ts", "type": "file", "name": "form-footer.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/data/form/form-footer/form-footer.props.ts", "type": "file", "name": "form-footer.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/data/form/form-body/form-body.component.tsx", "type": "file", "name": "form-body.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/data/form/form-body/form-body.styles.ts", "type": "file", "name": "form-body.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/data/form/form-body/form-body.props.ts", "type": "file", "name": "form-body.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/data/form/form-field/form-field.component.tsx", "type": "file", "name": "form-field.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/data/form/form-field/form-field.props.ts", "type": "file", "name": "form-field.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/data/form/form-field/form-field.styles.ts", "type": "file", "name": "form-field.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/data/form/form-action/form-action.component.tsx", "type": "file", "name": "form-action.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/data/form/form-action/form-action.styles.ts", "type": "file", "name": "form-action.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/data/form/form-action/form-action.props.ts", "type": "file", "name": "form-action.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/data/card/card.component.tsx", "type": "file", "name": "card.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/data/card/card.styles.ts", "type": "file", "name": "card.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/data/card/card.props.ts", "type": "file", "name": "card.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/data/card/card-footer/card-footer.component.tsx", "type": "file", "name": "card-footer.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/data/card/card-footer/card-footer.props.ts", "type": "file", "name": "card-footer.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/data/card/card-footer/card-footer.styles.ts", "type": "file", "name": "card-footer.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/data/card/card-content/card-content.props.ts", "type": "file", "name": "card-content.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/data/card/card-content/card-content.component.tsx", "type": "file", "name": "card-content.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/data/card/card-content/card-content.styles.ts", "type": "file", "name": "card-content.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/data/list/list.styles.ts", "type": "file", "name": "list.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "type": "file", "name": "list.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/data/list/list.props.tsx", "type": "file", "name": "list.props.tsx"}, {"id": "wavemaker-rn-runtime/src/components/data/list/list-template/list-template.styles.ts", "type": "file", "name": "list-template.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/data/list/list-template/list-template.component.tsx", "type": "file", "name": "list-template.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/data/list/list-template/list-template.props.ts", "type": "file", "name": "list-template.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/data/list/list-action-template/list-action-template.component.tsx", "type": "file", "name": "list-action-template.component.tsx"}, {"id": "wavemaker-rn-runtime/src/components/data/list/list-action-template/list-action-template.props.ts", "type": "file", "name": "list-action-template.props.ts"}, {"id": "wavemaker-rn-runtime/src/components/data/list/list-action-template/list-action-template.styles.ts", "type": "file", "name": "list-action-template.styles.ts"}, {"id": "wavemaker-rn-runtime/src/components/data/liveform/liveform.component.tsx", "type": "file", "name": "liveform.component.tsx"}, {"id": "wavemaker-rn-runtime/src/variables/device-variable.ts", "type": "file", "name": "device-variable.ts"}, {"id": "wavemaker-rn-runtime/src/variables/model-variable.ts", "type": "file", "name": "model-variable.ts"}, {"id": "wavemaker-rn-runtime/src/variables/http.service.ts", "type": "file", "name": "http.service.ts"}, {"id": "wavemaker-rn-runtime/src/variables/service-variable.ts", "type": "file", "name": "service-variable.ts"}, {"id": "wavemaker-rn-runtime/src/variables/base-variable.ts", "type": "file", "name": "base-variable.ts"}, {"id": "wavemaker-rn-runtime/src/variables/live-variable.ts", "type": "file", "name": "live-variable.ts"}, {"id": "wavemaker-rn-runtime/src/variables/utils/dataset-util.ts", "type": "file", "name": "dataset-util.ts"}, {"id": "wavemaker-rn-runtime/src/variables/utils/inflight-queue.ts", "type": "file", "name": "inflight-queue.ts"}, {"id": "wavemaker-rn-runtime/src/variables/utils/variable.constants.ts", "type": "file", "name": "variable.constants.ts"}, {"id": "wavemaker-rn-runtime/src/variables/utils/variable.utils.ts", "type": "file", "name": "variable.utils.ts"}, {"id": "wavemaker-rn-runtime/src/variables/device/operation.provider.ts", "type": "file", "name": "operation.provider.ts"}, {"id": "wavemaker-rn-runtime/src/variables/device/calendar/delete-event.operation.tsx", "type": "file", "name": "delete-event.operation.tsx"}, {"id": "wavemaker-rn-runtime/src/variables/device/calendar/create-event.operation.tsx", "type": "file", "name": "create-event.operation.tsx"}, {"id": "wavemaker-rn-runtime/src/variables/device/calendar/get-events.operation.tsx", "type": "file", "name": "get-events.operation.tsx"}, {"id": "wavemaker-rn-runtime/src/variables/device/file/upload-file.operation.tsx", "type": "file", "name": "upload-file.operation.tsx"}, {"id": "wavemaker-rn-runtime/src/variables/device/camera/capture-image.operation.tsx", "type": "file", "name": "capture-image.operation.tsx"}, {"id": "wavemaker-rn-runtime/src/variables/device/camera/capture-video.operation.tsx", "type": "file", "name": "capture-video.operation.tsx"}, {"id": "wavemaker-rn-runtime/src/variables/device/contacts/get-contacts.operation.ts", "type": "file", "name": "get-contacts.operation.ts"}, {"id": "wavemaker-rn-runtime/src/variables/device/scan/scan.operation.tsx", "type": "file", "name": "scan.operation.tsx"}, {"id": "wavemaker-rn-runtime/src/variables/device/device/current-geo-position.operation.ts", "type": "file", "name": "current-geo-position.operation.ts"}, {"id": "wavemaker-rn-runtime/src/variables/device/device/vibrate.operation.ts", "type": "file", "name": "vibrate.operation.ts"}, {"id": "wavemaker-rn-runtime/src/variables/device/device/network-info.operation.ts", "type": "file", "name": "network-info.operation.ts"}, {"id": "wavemaker-rn-runtime/src/variables/device/device/app-info.operation.ts", "type": "file", "name": "app-info.operation.ts"}, {"id": "wavemaker-rn-runtime/src/variables/device/device/device-info.operation.ts", "type": "file", "name": "device-info.operation.ts"}, {"id": "wavemaker-rn-runtime/src/gestures/swipe.animation.tsx", "type": "file", "name": "swipe.animation.tsx"}, {"id": "wavemaker-rn-runtime/src/gestures/carousel-swipe.animation.tsx", "type": "file", "name": "carousel-swipe.animation.tsx"}, {"id": "wavemaker-rn-runtime/src/actions/timer-action.ts", "type": "file", "name": "timer-action.ts"}, {"id": "wavemaker-rn-runtime/src/actions/login-action.ts", "type": "file", "name": "login-action.ts"}, {"id": "wavemaker-rn-runtime/src/actions/base-action.ts", "type": "file", "name": "base-action.ts"}, {"id": "wavemaker-rn-runtime/src/actions/index.ts", "type": "file", "name": "index.ts"}, {"id": "wavemaker-rn-runtime/src/actions/logout-action.ts", "type": "file", "name": "logout-action.ts"}, {"id": "wavemaker-rn-runtime/src/actions/notification-action.ts", "type": "file", "name": "notification-action.ts"}, {"id": "wavemaker-rn-runtime/src/actions/navigation-action.ts", "type": "file", "name": "navigation-action.ts"}], "edges": [{"source": "wavemaker-rn-runtime/test/jest.setup.js", "target": "enzyme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/jest.setup.js", "target": "enzyme-adapter-react-16", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/jest.setup.js", "target": "wavemaker-rn-runtime/src/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/jest.setup.js", "target": "@react-native-async-storage/async-storage/jest/async-storage-mock", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/jest.setup.js", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/jest.setup.js", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/jest.setup.js", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/jest.setup.js", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/jest.setup.js", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/jest.setup.js", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/jest.setup.js", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/jest.setup.js", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/index.test.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/index.test.tsx", "target": "react-test-renderer", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/index.test.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/button.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/index.test.tsx", "target": "WMButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/__mocks__/navigation.service.ts", "target": "@wavemaker/app-rn-runtime/core/navigation.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/__mocks__/react-native-animatable.js", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/core/utils.spec.ts", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/core/base.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/core/base.component.spec.tsx", "target": "enzyme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/core/base.component.spec.tsx", "target": "react-test-renderer", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/core/base.component.spec.tsx", "target": "BaseComponent", "type": "extends"}, {"source": "wavemaker-rn-runtime/test/core/base.component.spec.tsx", "target": "SampleProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/base.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/base.component.spec.tsx", "target": "SampleComponent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/props.provider.spec.ts", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/core/props.provider.spec.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/core/props.provider.spec.ts", "target": "@wavemaker/app-rn-runtime/core/props.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/core/props.provider.spec.ts", "target": "TestProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/props.provider.spec.ts", "target": "TestProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/props.provider.spec.ts", "target": "TestProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/props.provider.spec.ts", "target": "TestProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/props.provider.spec.ts", "target": "TestProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/props.provider.spec.ts", "target": "BaseProps", "type": "extends"}, {"source": "wavemaker-rn-runtime/test/core/props.provider.spec.ts", "target": "TestProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/props.provider.spec.ts", "target": "TestProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/floatinglabel.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/core/components/floatinglabel.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/core/components/floatinglabel.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/components/floatinglabel.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/core/components/floatinglabel.component.spec.tsx", "target": "mockdate", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/core/components/floatinglabel.component.spec.tsx", "target": "FloatingLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/floatinglabel.component.spec.tsx", "target": "FloatingLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/floatinglabel.component.spec.tsx", "target": "FloatingLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/floatinglabel.component.spec.tsx", "target": "FloatingLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/floatinglabel.component.spec.tsx", "target": "FloatingLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/floatinglabel.component.spec.tsx", "target": "FloatingLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/components/textinput.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "target": "WMTextInput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "target": "WMTextInput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "target": "WMTextInput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "target": "WMTextInput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "target": "WMTextInput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "target": "WMTextInput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "target": "WMTextInput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "target": "WMTextInput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "target": "WMTextInput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "target": "WMTextInput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "target": "WMTextInput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "target": "WMTextInput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "target": "WMTextInput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "target": "WMTextInput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "target": "WMTextInput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "target": "WMTextInput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "target": "WMTextInput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "target": "WMTextInput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx", "target": "WMTextInput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/runtime/watcher.spec.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/runtime/watcher.spec.ts", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/runtime/watcher.spec.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/runtime/watcher.spec.ts", "target": "prop", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/runtime/watcher.spec.ts", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/runtime/watcher.spec.ts", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/runtime/watcher.spec.ts", "target": "TouchableOpacity", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/runtime/watcher.spec.ts", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/runtime/watcher.spec.ts", "target": "TestWatcherComponent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/runtime/watcher.spec.ts", "target": "TestWatcherComponent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/runtime/watcher.spec.ts", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/runtime/watcher.spec.ts", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/runtime/watcher.spec.ts", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/runtime/watcher.spec.ts", "target": "TestWatcherComponent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/runtime/watcher.spec.ts", "target": "TestWatcherComponent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/styles/background.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/styles/background.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/styles/background.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/styles/background.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/styles/background.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/styles/background.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/asset.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/styles/background.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/styles/background.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/styles/background.component.spec.tsx", "target": "BackgroundComponent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/styles/background.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/styles/background.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/styles/background.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/styles/background.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/styles/background.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/styles/background.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/styles/theme.spec.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/styles/background.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components//page/page.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page.component.spec.tsx", "target": "WmPage", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page.component.spec.tsx", "target": "WmPage", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container.component.spec.tsx", "target": "enzyme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container.component.spec.tsx", "target": "react-test-renderer", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components//container/container.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/container.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container.component.spec.tsx", "target": "react-native-gesture-handler", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container.component.spec.tsx", "target": "WmContainer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container.component.spec.tsx", "target": "WmContainer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/login.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/login.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/advanced/login/login.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/login.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/login.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/advanced/login/login.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/login.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/login.component.spec.tsx", "target": "axios", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/login.component.spec.tsx", "target": "wavemaker-rn-runtime/src/styles/theme.variables", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/login.component.spec.tsx", "target": "ThemeProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/login.component.spec.tsx", "target": "WmLogin", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/login.component.spec.tsx", "target": "WmLogin", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/login.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/login.component.spec.tsx", "target": "WmLogin", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/login.component.spec.tsx", "target": "WmLogin", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/login.component.spec.tsx", "target": "WmLogin", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/login.component.spec.tsx", "target": "WmLogin", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/login.component.spec.tsx", "target": "WmLogin", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/webview.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/webview.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/webview.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/advanced/webview/webview.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/webview.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/webview.component.spec.tsx", "target": "react-native/Libraries/Utilities/__mocks__/BackHandler", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/webview.component.spec.tsx", "target": "WmWebview", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/webview.component.spec.tsx", "target": "WmWebview", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/webview.component.spec.tsx", "target": "WmWebview", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/webview.component.spec.tsx", "target": "WmWebview", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/webview.component.spec.tsx", "target": "WmWebview", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/webview.component.spec.tsx", "target": "WmWebview", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/webview.component.spec.tsx", "target": "WmWebview", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/webview.component.spec.tsx", "target": "WmWebview", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/webview.component.spec.tsx", "target": "WmWebview", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/webview.component.spec.tsx", "target": "WmWebview", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/webview.component.spec.tsx", "target": "WmWebview", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/webview.component.spec.tsx", "target": "WmWebview", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/webview.component.spec.tsx", "target": "WmWebview", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/webview.component.spec.tsx", "target": "WmWebview", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/advanced/carousel/carousel.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "react-native/Libraries/Animated/animations/TimingAnimation", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "originalModule", "type": "extends"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "WmCarousel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/network-info-toaster.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/network-info-toaster.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/network-info-toaster.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/advanced/network-info-toaster/network-info-toaster.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/network-info-toaster.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/network.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/network-info-toaster.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/network-info-toaster.component.spec.tsx", "target": "WmNetworkInfoToaster", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel/carousel-template.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel/carousel-template.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel/carousel-template.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/advanced/carousel/carousel-template/carousel-template.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel/carousel-template.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel/carousel-template.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/styles/background.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel/carousel-template.component.spec.tsx", "target": "WmCarouselTemplate", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel/carousel-template.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel/carousel-template.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel/carousel-content.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel/carousel-content.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel/carousel-content.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/advanced/carousel/carousel-content/carousel-content.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel/carousel-content.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel/carousel-content.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/styles/background.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel/carousel-content.component.spec.tsx", "target": "WmCarouselContent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel/carousel-content.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/advanced/carousel/carousel-content.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/content.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/content.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/page/content/content.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/content.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/content.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/styles/background.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/content.component.spec.tsx", "target": "WmContent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/content.component.spec.tsx", "target": "WmContent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/content.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/content.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/page-content.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/page-content.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/page/page-content/page-content.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/page-content.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/page-content.component.spec.tsx", "target": "react-native-gesture-handler", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/page-content.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/styles/background.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/page-content.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/page/content/content.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/page-content.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/label/label.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/page-content.component.spec.tsx", "target": "React", "type": "extends"}, {"source": "wavemaker-rn-runtime/test/components/page/page-content.component.spec.tsx", "target": "WmPageContent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/page-content.component.spec.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/page-content.component.spec.tsx", "target": "React", "type": "extends"}, {"source": "wavemaker-rn-runtime/test/components/page/page-content.component.spec.tsx", "target": "WmPageContent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/page-content.component.spec.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/page-content.component.spec.tsx", "target": "WmPageContent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/page-content.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/page-content.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/page-content.component.spec.tsx", "target": "WmPageContent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/page-content.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/page-content.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/left-panel.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/left-panel.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/page/left-panel/left-panel.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/left-panel.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/styles/background.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/left-panel.component.spec.tsx", "target": "WmLeftPanel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/left-panel.component.spec.tsx", "target": "WmLeftPanel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/left-panel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/left-panel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/left-panel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/left-panel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/left-panel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/left-panel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/left-panel.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/left-panel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/left-panel.component.spec.tsx", "target": "WmLeftPanel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/tabbar.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/runtime/services/app-modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/tabbar.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/tabbar.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/page/tabbar/tabbar.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/tabbar.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/page/tabbar/tabbar.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/tabbar.component.spec.tsx", "target": "wavemaker-rn-runtime/src/core/navigation.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/tabbar.component.spec.tsx", "target": "wavemaker-rn-runtime/test/__mocks__/navigation.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/tabbar.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/tabbar.component.spec.tsx", "target": "NavigationServiceProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/tabbar.component.spec.tsx", "target": "ModalProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/tabbar.component.spec.tsx", "target": "WmTabbar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/tabbar.component.spec.tsx", "target": "ModalProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/tabbar.component.spec.tsx", "target": "WmTabbar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/tabbar.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/tabbar.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/tabbar.component.spec.tsx", "target": "ModalProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/tabbar.component.spec.tsx", "target": "WmTabbar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/tabbar.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/partial-container.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/partial-container.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/partial-container.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/page/partial-container/partial-container.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/partial-container.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/partial-container.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/styles/background.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/partial-container.component.spec.tsx", "target": "WmPartialContainer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/partial-container.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/partial-container.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/partial.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/partial.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/partial.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/page/partial/partial.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/partial.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/partial.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/styles/background.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/page/partial.component.spec.tsx", "target": "WmPartial", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/partial.component.spec.tsx", "target": "WmPartial", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/partial.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/page/partial.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/toggle.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/toggle.component.spec.tsx", "target": "mockdate", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/toggle.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/toggle/toggle.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/toggle.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/toggle.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/toggle.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/toggle.component.spec.tsx", "target": "WmToggle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/toggle.component.spec.tsx", "target": "WmToggle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/toggle.component.spec.tsx", "target": "WmToggle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/toggle.component.spec.tsx", "target": "WmToggle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/toggle.component.spec.tsx", "target": "WmToggle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/toggle.component.spec.tsx", "target": "WmToggle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/toggle.component.spec.tsx", "target": "WmToggle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/toggle.component.spec.tsx", "target": "WmToggle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/toggle.component.spec.tsx", "target": "WmToggle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/toggle.component.spec.tsx", "target": "WmToggle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/toggle.component.spec.tsx", "target": "WmToggle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/toggle.component.spec.tsx", "target": "WmToggle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/toggle.component.spec.tsx", "target": "WmToggle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/toggle.component.spec.tsx", "target": "WmToggle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/switch.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/switch/switch.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/switch.component.spec.tsx", "target": "@testing-library/jest-native/extend-expect", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/switch.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/switch/switch.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/switch.component.spec.tsx", "target": "wavemaker-rn-runtime/src/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/switch.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/switch.component.spec.tsx", "target": "div", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/switch.component.spec.tsx", "target": "WmSwitch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/switch.component.spec.tsx", "target": "WmSwitch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/switch.component.spec.tsx", "target": "WmSwitch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/switch.component.spec.tsx", "target": "WmSwitch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/switch.component.spec.tsx", "target": "WmSwitch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/switch.component.spec.tsx", "target": "WmSwitch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/switch.component.spec.tsx", "target": "WmSwitch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/switch.component.spec.tsx", "target": "WmSwitch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/switch.component.spec.tsx", "target": "WmSwitch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/switch.component.spec.tsx", "target": "WmSwitch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/switch.component.spec.tsx", "target": "WmSwitch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/switch.component.spec.tsx", "target": "WmSwitch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/switch.component.spec.tsx", "target": "WmSwitch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/textarea.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/textarea/textarea.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/textarea.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/textarea.component.spec.tsx", "target": "WmTextarea", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/textarea.component.spec.tsx", "target": "WmTextarea", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/textarea.component.spec.tsx", "target": "WmTextarea", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/textarea.component.spec.tsx", "target": "WmTextarea", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/textarea.component.spec.tsx", "target": "WmTextarea", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/textarea.component.spec.tsx", "target": "WmTextarea", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/textarea.component.spec.tsx", "target": "WmTextarea", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/textarea.component.spec.tsx", "target": "WmTextarea", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/textarea.component.spec.tsx", "target": "WmTextarea", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/textarea.component.spec.tsx", "target": "WmTextarea", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/textarea.component.spec.tsx", "target": "WmTextarea", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/textarea.component.spec.tsx", "target": "WmTextarea", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/textarea.component.spec.tsx", "target": "WmTextarea", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/textarea.component.spec.tsx", "target": "WmTextarea", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/textarea.component.spec.tsx", "target": "WmTextarea", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/textarea.component.spec.tsx", "target": "WmTextarea", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/textarea.component.spec.tsx", "target": "WmTextarea", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/textarea.component.spec.tsx", "target": "WmTextarea", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/textarea.component.spec.tsx", "target": "WmTextarea", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/calendar.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/calendar.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/calendar/calendar.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/calendar.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/calendar/calendar.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/calendar.component.spec.tsx", "target": "yargs", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/calendar.component.spec.tsx", "target": "WmCalendar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/calendar.component.spec.tsx", "target": "WmCalendar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/calendar.component.spec.tsx", "target": "WmCalendar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/calendar.component.spec.tsx", "target": "WmCalendar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/calendar.component.spec.tsx", "target": "WmCalendar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/calendar.component.spec.tsx", "target": "WmCalendar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/calendar.component.spec.tsx", "target": "WmCalendar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/calendar.component.spec.tsx", "target": "WmCalendar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/calendar.component.spec.tsx", "target": "WmCalendar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/calendar.component.spec.tsx", "target": "WmCalendar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/calendar.component.spec.tsx", "target": "WmCalendar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/chips.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/chips.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/chips/chips.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/chips.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/chips/chips.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/chips.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/chips.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/search/search.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/chips.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/picture/picture.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/chips.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/chips.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/asset.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/chips.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/runtime/services/app-modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/chips.component.spec.tsx", "target": "WmChips", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/chips.component.spec.tsx", "target": "WmChipsProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/chips.component.spec.tsx", "target": "ModalProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/chips.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/chips.component.spec.tsx", "target": "WmChips", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/chips.component.spec.tsx", "target": "WmChips", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/chips.component.spec.tsx", "target": "WmChips", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/chips.component.spec.tsx", "target": "WmChips", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/chips.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/chips.component.spec.tsx", "target": "WmChips", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/chips.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/chips.component.spec.tsx", "target": "WmChips", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkbox.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/checkbox/checkbox.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/checkbox.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/checkbox/checkbox.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/checkbox.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/checkbox.component.spec.tsx", "target": "WmCheckbox", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkbox.component.spec.tsx", "target": "WmCheckbox", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkbox.component.spec.tsx", "target": "WmCheckbox", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkbox.component.spec.tsx", "target": "WmCheckbox", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkbox.component.spec.tsx", "target": "WmCheckbox", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkbox.component.spec.tsx", "target": "WmCheckbox", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkbox.component.spec.tsx", "target": "WmCheckbox", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkbox.component.spec.tsx", "target": "WmCheckbox", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkbox.component.spec.tsx", "target": "WmCheckbox", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkbox.component.spec.tsx", "target": "WmCheckbox", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkbox.component.spec.tsx", "target": "WmCheckbox", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/select.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/select.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/select/select.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/select.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/select/select.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/select.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/select.component.spec.tsx", "target": "wavemaker-rn-runtime/src/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/select.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/runtime/services/app-modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/select.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/asset.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/select.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/select.component.spec.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/select.component.spec.tsx", "target": "ModalProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/select.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/select.component.spec.tsx", "target": "WmSelect", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/select.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/select.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/select.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/select.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/select.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/select.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/select.component.spec.tsx", "target": "WmSelect", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/text/text.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "WmText", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "WmText", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "WmText", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "WmText", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "WmText", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "WmText", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "WmText", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "WmText", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "WmText", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "WmText", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "WmText", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "WmText", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "WmText", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "WmText", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "WmText", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "WmText", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "WmText", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "WmText", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "WmText", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "WmText", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "WmText", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx", "target": "WmText", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/fileupload.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/fileupload/fileupload.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/fileupload.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/fileupload/fileupload.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/fileupload.component.spec.tsx", "target": "expo-document-picker", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/fileupload.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/fileupload.component.spec.tsx", "target": "WmFileupload", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/fileupload.component.spec.tsx", "target": "WmFileupload", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/fileupload.component.spec.tsx", "target": "WmFileupload", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/fileupload.component.spec.tsx", "target": "WmFileupload", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/fileupload.component.spec.tsx", "target": "WmFileupload", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/fileupload.component.spec.tsx", "target": "WmFileupload", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/rating.component.spec.tsx", "target": "react-test-renderer", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/rating.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/rating/rating.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/rating.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/rating/rating.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/rating.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/rating.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/rating.component.spec.tsx", "target": "WmRating", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/rating.component.spec.tsx", "target": "WmRating", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/rating.component.spec.tsx", "target": "WmRating", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/rating.component.spec.tsx", "target": "WmRating", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/rating.component.spec.tsx", "target": "WmRating", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/rating.component.spec.tsx", "target": "WmRating", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/rating.component.spec.tsx", "target": "WmRating", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/rating.component.spec.tsx", "target": "WmRating", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/rating.component.spec.tsx", "target": "WmRating", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/rating.component.spec.tsx", "target": "WmRating", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/rating.component.spec.tsx", "target": "WmRating", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/rating.component.spec.tsx", "target": "WmRating", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/rating.component.spec.tsx", "target": "WmRating", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/radioset.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/radioset.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/radioset/radioset.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/radioset.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/radioset/radioset.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/radioset.component.spec.tsx", "target": "WmRadioset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/radioset.component.spec.tsx", "target": "WmRadioset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/radioset.component.spec.tsx", "target": "WmRadioset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/radioset.component.spec.tsx", "target": "WmRadioset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/radioset.component.spec.tsx", "target": "WmRadioset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/radioset.component.spec.tsx", "target": "WmRadioset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/radioset.component.spec.tsx", "target": "WmRadioset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/radioset.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/radioset.component.spec.tsx", "target": "WmRadioset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/radioset.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/radioset.component.spec.tsx", "target": "WmRadioset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/radioset.component.spec.tsx", "target": "WmRadioset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/radioset.component.spec.tsx", "target": "WmRadioset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/radioset.component.spec.tsx", "target": "WmRadioset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/radioset.component.spec.tsx", "target": "WmRadioset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/radioset.component.spec.tsx", "target": "WmRadioset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/radioset.component.spec.tsx", "target": "WmRadioset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/radioset.component.spec.tsx", "target": "WmRadioset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/currency/currency.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/currency-constants", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx", "target": "WmCurrency", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx", "target": "WmCurrency", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx", "target": "WmCurrency", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx", "target": "WmCurrency", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx", "target": "WmCurrency", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx", "target": "WmCurrency", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx", "target": "WmCurrency", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx", "target": "WmCurrency", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx", "target": "WmCurrency", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx", "target": "WmCurrency", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx", "target": "WmCurrency", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx", "target": "WmCurrency", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx", "target": "WmCurrency", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx", "target": "WmCurrency", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx", "target": "WmCurrency", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx", "target": "WmCurrency", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx", "target": "WmCurrency", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx", "target": "WmCurrency", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx", "target": "WmCurrency", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/slider.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/slider.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/tooltip/tooltip.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/slider.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/slider/slider.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/slider.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/styles/background.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/slider.component.spec.tsx", "target": "react-native-gesture-handler", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/slider.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/slider/slider.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/slider.component.spec.tsx", "target": "GestureHandlerRootView", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/slider.component.spec.tsx", "target": "WmSlider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/slider.component.spec.tsx", "target": "WmSlider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/number.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/number.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/number/number.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/number.component.spec.tsx", "target": "WmNumber", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/number.component.spec.tsx", "target": "WmNumber", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/number.component.spec.tsx", "target": "WmNumber", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/number.component.spec.tsx", "target": "WmNumber", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/number.component.spec.tsx", "target": "WmNumber", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/number.component.spec.tsx", "target": "WmNumber", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/number.component.spec.tsx", "target": "WmNumber", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/number.component.spec.tsx", "target": "WmNumber", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/number.component.spec.tsx", "target": "WmNumber", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/number.component.spec.tsx", "target": "WmNumber", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/number.component.spec.tsx", "target": "WmNumber", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/number.component.spec.tsx", "target": "WmNumber", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/number.component.spec.tsx", "target": "WmNumber", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/number.component.spec.tsx", "target": "WmNumber", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/number.component.spec.tsx", "target": "WmNumber", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/composite.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/composite.component.spec.tsx", "target": "enzyme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/composite.component.spec.tsx", "target": "react-test-renderer", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/composite.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/composite/composite.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/composite.component.spec.tsx", "target": "WmComposite", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkboxset.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/checkboxset.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/checkboxset/checkboxset.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/checkboxset.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/checkboxset/checkboxset.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/checkboxset.component.spec.tsx", "target": "WmCheckboxset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkboxset.component.spec.tsx", "target": "WmCheckboxset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkboxset.component.spec.tsx", "target": "WmCheckboxset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkboxset.component.spec.tsx", "target": "WmCheckboxset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkboxset.component.spec.tsx", "target": "WmCheckboxset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkboxset.component.spec.tsx", "target": "WmCheckboxset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkboxset.component.spec.tsx", "target": "WmCheckboxset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkboxset.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkboxset.component.spec.tsx", "target": "WmCheckboxset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkboxset.component.spec.tsx", "target": "WmCheckboxset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkboxset.component.spec.tsx", "target": "WmCheckboxset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkboxset.component.spec.tsx", "target": "WmCheckboxset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkboxset.component.spec.tsx", "target": "WmCheckboxset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkboxset.component.spec.tsx", "target": "WmCheckboxset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkboxset.component.spec.tsx", "target": "WmCheckboxset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkboxset.component.spec.tsx", "target": "WmCheckboxset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/checkboxset.component.spec.tsx", "target": "WmCheckboxset", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/epoch/date/date.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/epoch/wheelpicker/wheelpicker.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/epoch/date/date.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "react-native-gesture-handler", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/runtime/services/app-modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/asset.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "react-native-safe-area-context", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "react-native-safe-area-context", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "SafeAreaProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "ModalProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "WmDate", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "WmDate", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "WmDate", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "WmDate", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "WmDate", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "WmDate", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "WmDate", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "WmDate", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "WmDate", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "WmDate", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "WmDate", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "ModalProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx", "target": "WmDate", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/epoch/datetime/datetime.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/epoch/datetime/datetime.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx", "target": "react-native-gesture-handler", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/runtime/services/app-modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/asset.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx", "target": "react-native-safe-area-context", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx", "target": "ModalProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx", "target": "WmDatetime", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx", "target": "WmDatetime", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx", "target": "WmDatetime", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx", "target": "WmDatetime", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx", "target": "WmDatetime", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx", "target": "WmDatetime", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx", "target": "WmDatetime", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx", "target": "WmDatetime", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx", "target": "WmDatetime", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/time.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/epoch/time/time.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/time.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/epoch/time/time.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/time.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/time.component.spec.tsx", "target": "react-native-gesture-handler", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/time.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/runtime/services/app-modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/time.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/asset.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/time.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/time.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/time.component.spec.tsx", "target": "react-native-safe-area-context", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/time.component.spec.tsx", "target": "ModalProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/time.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/time.component.spec.tsx", "target": "WmTime", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/time.component.spec.tsx", "target": "WmTime", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/time.component.spec.tsx", "target": "WmTime", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/time.component.spec.tsx", "target": "WmTime", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/time.component.spec.tsx", "target": "WmTime", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/time.component.spec.tsx", "target": "WmTime", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/time.component.spec.tsx", "target": "WmTime", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/time.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/time.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/input/epoch/time.component.spec.tsx", "target": "WmTime", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/line-chart.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/chart/line-chart/line-chart.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/line-chart.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/line-chart.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/chart/staticdata", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/line-chart.component.spec.tsx", "target": "WmLineChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/line-chart.component.spec.tsx", "target": "WmLineChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/line-chart.component.spec.tsx", "target": "WmLineChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/line-chart.component.spec.tsx", "target": "WmLineChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/area-chart.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/chart/area-chart/area-chart.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/area-chart.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/area-chart.component.spec.tsx", "target": "WmAreaChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/area-chart.component.spec.tsx", "target": "WmAreaChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/area-chart.component.spec.tsx", "target": "WmAreaChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/stack-chart.component.spec.tsx", "target": "react-native-svg", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/stack-chart.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/chart/stack-chart/stack-chart.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/stack-chart.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/stack-chart.component.spec.tsx", "target": "react-native/Libraries/NewAppScreen", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/stack-chart.component.spec.tsx", "target": "WmStackChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/stack-chart.component.spec.tsx", "target": "WmStackChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/stack-chart.component.spec.tsx", "target": "WmStackChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/pie-chart.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/chart/pie-chart/pie-chart.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/pie-chart.component.spec.tsx", "target": "react-native-svg", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/pie-chart.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/chart/legend/legend.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/pie-chart.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/pie-chart.component.spec.tsx", "target": "victory-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/pie-chart.component.spec.tsx", "target": "WmPieChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/pie-chart.component.spec.tsx", "target": "WmPieChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/pie-chart.component.spec.tsx", "target": "WmPieChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/pie-chart.component.spec.tsx", "target": "WmPieChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/pie-chart.component.spec.tsx", "target": "WmPieChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/legend.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/legend.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/legend.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/chart/legend/legend.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/legend.component.spec.tsx", "target": "Legend", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/legend.component.spec.tsx", "target": "Legend", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/legend.component.spec.tsx", "target": "Legend", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/legend.component.spec.tsx", "target": "Legend", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/legend.component.spec.tsx", "target": "Legend", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bubble-chart.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/chart/bubble-chart/bubble-chart.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/bubble-chart.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/bubble-chart.component.spec.tsx", "target": "WmBubbleChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bubble-chart.component.spec.tsx", "target": "WmBubbleChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/chart/column-chart/column-chart.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/chart/column-chart/column-chart.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/chart/theme/chart.theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "WmColumnChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "WmColumnChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "WmColumnChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "WmColumnChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "WmColumnChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "WmColumnChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "WmColumnChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "WmColumnChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "WmColumnChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "WmColumnChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "WmColumnChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "WmColumnChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "WmColumnChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "WmColumnChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "WmColumnChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "WmColumnChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "WmColumnChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "WmColumnChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "WmColumnChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx", "target": "WmColumnChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/chart/bar-chart/bar-chart.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/chart/bar-chart/bar-chart.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/chart/theme/chart.theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx", "target": "WmBarChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/donut-chart.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/chart/donut-chart/donut-chart.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/donut-chart.component.spec.tsx", "target": "react-native-svg", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/donut-chart.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/chart/legend/legend.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/donut-chart.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/donut-chart.component.spec.tsx", "target": "victory-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/donut-chart.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/chart/donut-chart.component.spec.tsx", "target": "WmDonutChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/donut-chart.component.spec.tsx", "target": "WmDonutChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/chart/donut-chart.component.spec.tsx", "target": "WmDonutChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/button.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/button.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/button.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/button.component.spec.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/button.component.spec.tsx", "target": "@expo/vector-icons", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/button.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/button.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/button.component.spec.tsx", "target": "WmButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/button.component.spec.tsx", "target": "WmButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/button.component.spec.tsx", "target": "WmButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/button.component.spec.tsx", "target": "WmButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/button.component.spec.tsx", "target": "WmButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/button.component.spec.tsx", "target": "WmButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/button.component.spec.tsx", "target": "WmButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/spinner.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/spinner.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/spinner.component.spec.tsx", "target": "react-lottie-player", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/spinner.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/spinner.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/spinner/spinner.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/spinner.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/asset.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/spinner.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/spinner.component.spec.tsx", "target": "WmSpinner", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/spinner.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/spinner.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/message.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/message.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/message.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/message/message.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/message.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/message/message.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/message.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/message.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/message.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/animatedview.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/message.component.spec.tsx", "target": "ThemeProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/message.component.spec.tsx", "target": "WmMessage", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/message.component.spec.tsx", "target": "WmMessage", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/message.component.spec.tsx", "target": "WmMessage", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/message.component.spec.tsx", "target": "WmMessage", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/message.component.spec.tsx", "target": "WmMessage", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/message.component.spec.tsx", "target": "WmMessage", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/message.component.spec.tsx", "target": "WmMessage", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/message.component.spec.tsx", "target": "WmMessage", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/message.component.spec.tsx", "target": "WmMessage", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/message.component.spec.tsx", "target": "WmMessage", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/message.component.spec.tsx", "target": "WmMessage", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/message.component.spec.tsx", "target": "WmMessage", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/message.component.spec.tsx", "target": "WmMessage", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/anchor.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/anchor.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/anchor/anchor.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/anchor.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/navigation.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/anchor.component.spec.tsx", "target": "wavemaker-rn-runtime/test/__mocks__/navigation.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/anchor.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/asset.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/anchor.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/anchor.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/anchor.component.spec.tsx", "target": "NavigationServiceProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/anchor.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/anchor.component.spec.tsx", "target": "WmAnchor", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/modal.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/modal.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/modal.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/modal/modal.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/modal.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/modal.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/testid.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/modal.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/modal.component.spec.tsx", "target": "TestIdPrefixProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/modal.component.spec.tsx", "target": "WmModal", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/modal.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-circle.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-circle.component.spec.tsx", "target": "@testing-library/jest-native/extend-expect", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-circle.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/progress-circle/progress-circle.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-circle.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/progress-circle/progress-circle.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-circle.component.spec.tsx", "target": "react-native-circular-progress", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-circle.component.spec.tsx", "target": "wavemaker-rn-runtime/src/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-circle.component.spec.tsx", "target": "color", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-circle.component.spec.tsx", "target": "wavemaker-rn-runtime/src/styles/theme.variables", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-circle.component.spec.tsx", "target": "WmProgressCircle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-circle.component.spec.tsx", "target": "WmProgressCircle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-circle.component.spec.tsx", "target": "WmProgressCircle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-circle.component.spec.tsx", "target": "WmProgressCircle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-circle.component.spec.tsx", "target": "WmProgressCircle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-circle.component.spec.tsx", "target": "WmProgressCircle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-circle.component.spec.tsx", "target": "WmProgressCircle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-circle.component.spec.tsx", "target": "WmProgressCircle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-circle.component.spec.tsx", "target": "WmProgressCircle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-circle.component.spec.tsx", "target": "WmProgressCircle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-bar.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-bar.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/progress-bar/progress-bar.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-bar.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/progress-bar/progress-bar.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-bar.component.spec.tsx", "target": "wavemaker-rn-runtime/src/styles/theme.variables", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-bar.component.spec.tsx", "target": "color", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-bar.component.spec.tsx", "target": "WmProgressBar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-bar.component.spec.tsx", "target": "WmProgressBar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-bar.component.spec.tsx", "target": "WmProgressBar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-bar.component.spec.tsx", "target": "WmProgressBar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-bar.component.spec.tsx", "target": "WmProgressBar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-bar.component.spec.tsx", "target": "WmProgressBar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-bar.component.spec.tsx", "target": "WmProgressBar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-bar.component.spec.tsx", "target": "WmProgressBar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-bar.component.spec.tsx", "target": "WmProgressBar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-bar.component.spec.tsx", "target": "WmProgressBar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/progress-bar.component.spec.tsx", "target": "WmProgressBar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/search/search.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/search/local-data-provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/runtime/services/app-modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/asset.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "ModalProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "WmSearch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "WmSearch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "WmSearch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "WmSearch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "WmSearch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "WmSearch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "WmSearch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "WmSearch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "WmSearch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "WmSearch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx", "target": "WmSearch", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/picture.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/picture.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/picture/picture.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/picture.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/picture.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/picture.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/asset.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/picture.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/picture.component.spec.tsx", "target": "WmPicture", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/skeleton.component.spec.tsx", "target": "expo-linear-gradient", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/skeleton.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/skeleton.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/testid.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/skeleton.component.spec.tsx", "target": "TestIdPrefixProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/skeleton.component.spec.tsx", "target": "ThemeProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/skeleton.component.spec.tsx", "target": "WmSkeleton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/custom.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/custom.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/custom.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/custom.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/custom/custom.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/custom.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/custom.component.spec.tsx", "target": "WmCustom", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/custom.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/custom.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/custom.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/custom.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/custom.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/custom.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/custom.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/lottie.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/lottie.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/lottie.component.spec.tsx", "target": "react-lottie-player", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/lottie.component.spec.tsx", "target": "lottie-react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/lottie.component.spec.tsx", "target": "axios", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/lottie.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/lottie/lottie.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/lottie.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/asset.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/lottie.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/lottie.component.spec.tsx", "target": "WmLottie", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/lottie.component.spec.tsx", "target": "WmLottie", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/tooltip.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/tooltip.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/tooltip.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/tooltip.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/tooltip.component.spec.tsx", "target": "WmTooltip", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/tooltip.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/audio.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/audio.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/audio/audio.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/audio.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/audio/audio.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/audio.component.spec.tsx", "target": "expo-av/build/Audio", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/audio.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/asset.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/audio.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/audio.component.spec.tsx", "target": "WmAudio", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/audio.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/audio.component.spec.tsx", "target": "WmAudio", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/video.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/video/video.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/video.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/asset.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/video.component.spec.tsx", "target": "expo-video", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/video.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/video.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/video.component.spec.tsx", "target": "WmVideo", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/icon.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/icon.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/icon.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/icon.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/asset.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/icon.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/testid.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/icon.component.spec.tsx", "target": "TestIdPrefixProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/icon.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/buttongroup.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/buttongroup.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/buttongroup.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/buttongroup/buttongroup.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/buttongroup.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/buttongroup/buttongroup.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/buttongroup.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/buttongroup.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/buttongroup.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/buttongroup.component.spec.tsx", "target": "ThemeProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/buttongroup.component.spec.tsx", "target": "WmButtongroup", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/buttongroup.component.spec.tsx", "target": "WmButtongroup", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/buttongroup.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/buttongroup.component.spec.tsx", "target": "WmButtongroup", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/buttongroup.component.spec.tsx", "target": "WmButtongroup", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/buttongroup.component.spec.tsx", "target": "WmButtongroup", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/buttongroup.component.spec.tsx", "target": "WmButtongroup", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/buttongroup.component.spec.tsx", "target": "WmButtongroup", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/buttongroup.component.spec.tsx", "target": "WmButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/buttongroup.component.spec.tsx", "target": "WmButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/buttongroup.component.spec.tsx", "target": "WmButtongroup", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/buttongroup.component.spec.tsx", "target": "WmButtongroup", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "react-test-renderer", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/label/label.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/label/label.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/navigation.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "wavemaker-rn-runtime/src/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "wavemaker-rn-runtime/src/styles/theme.variables", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "wavemaker-rn-runtime/src/core/navigation.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "wavemaker-rn-runtime/test/__mocks__/navigation.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "wavemaker-rn-runtime/src/core/event-notifier", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "@react-native-masked-view/masked-view", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "expo-linear-gradient", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "NavigationServiceProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "ThemeProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/appnavbar.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/navigation/appnavbar/appnavbar.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/appnavbar.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/picture/picture.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/appnavbar.component.spec.tsx", "target": "WmAppNavbar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/appnavbar.component.spec.tsx", "target": "react-native/Libraries/Utilities/__mocks__/BackHandler", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/appnavbar.component.spec.tsx", "target": "WmAppNavbar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/appnavbar.component.spec.tsx", "target": "WmAppNavbar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/appnavbar.component.spec.tsx", "target": "WmAppNavbar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/appnavbar.component.spec.tsx", "target": "WmAppNavbar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/appnavbar.component.spec.tsx", "target": "WmAppNavbar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/appnavbar.component.spec.tsx", "target": "WmAppNavbar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navitem.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/navigation/navitem/navitem.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navitem.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/navigation/navitem/navitem.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navitem.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/anchor/anchor.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navitem.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navitem.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navitem.component.spec.tsx", "target": "wavemaker-rn-runtime/src/core/navigation.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navitem.component.spec.tsx", "target": "wavemaker-rn-runtime/test/__mocks__/navigation.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navitem.component.spec.tsx", "target": "WmNavItem", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navitem.component.spec.tsx", "target": "WmNavItem", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navitem.component.spec.tsx", "target": "NavigationServiceProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navitem.component.spec.tsx", "target": "WmNavItem", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navitem.component.spec.tsx", "target": "WmNavItem", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navitem.component.spec.tsx", "target": "WmNavItem", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navitem.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navitem.component.spec.tsx", "target": "WmNavItem", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navitem.component.spec.tsx", "target": "WmNavItem", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navitem.component.spec.tsx", "target": "WmNavItem", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navitem.component.spec.tsx", "target": "WmNavItem", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navitem.component.spec.tsx", "target": "WmNavItem", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navbar.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navbar.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/navigation/navbar/navbar.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navbar.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/navigation/navitem/navitem.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navbar.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/navigation/navbar/navbar.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navbar.component.spec.tsx", "target": "wavemaker-rn-runtime/src/core/navigation.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navbar.component.spec.tsx", "target": "wavemaker-rn-runtime/test/__mocks__/navigation.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navbar.component.spec.tsx", "target": "WmNavbar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navbar.component.spec.tsx", "target": "WmNavbar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navbar.component.spec.tsx", "target": "WmNavbar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navbar.component.spec.tsx", "target": "WmNavbar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navbar.component.spec.tsx", "target": "WmNavbar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navbar.component.spec.tsx", "target": "NavigationServiceProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navbar.component.spec.tsx", "target": "WmNavbar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navbar.component.spec.tsx", "target": "WmNavbar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navbar.component.spec.tsx", "target": "WmNavbar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/navbar.component.spec.tsx", "target": "WmNavbar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/menu.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/menu.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/menu.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/navigation/menu/menu.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/menu.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/runtime/services/app-modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/menu.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/menu.component.spec.tsx", "target": "ModalProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/menu.component.spec.tsx", "target": "WmMenu", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/navigation/popover/popover.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/styles/background.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/animatedview.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/runtime/services/app-modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "react-native-gesture-handler", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "ModalProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "WmPopover", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "ModalProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "WmPopover", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "WmPopover", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "WmPopover", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx", "target": "WmPopover", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/wizard/wizard.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/wizard/wizard.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/wizard/wizardstep/wizardstep.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/wizard/wizardstep/wizardstep.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/runtime/services/app-modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "ModalProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "WmWizard", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "WmWizard", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "WmWizardstep", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "WmWizardstep", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "WmWizardstep", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx", "target": "WmWizard", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/linearlayout.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/linearlayout/linearlayout.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/linearlayout.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/linearlayout/linearlayout.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/linearlayout.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/linearlayout.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/linearlayout.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/linearlayout.component.spec.tsx", "target": "WmLinearlayout", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/linearlayout.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/linearlayout.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/tabs/tabs.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/tabs/tabpane/tabpane.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/tabs/tabheader/tabheader.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "WmTabs", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "WmTabpane", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "WmTabpane", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "WmTabpane", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "WmTabs", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "WmTabpane", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "WmTabpane", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "WmTabpane", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "WmTabpane", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "WmTabs", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "WmTabpane", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "WmTabs", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "WmTabpane", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "WmTabs", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "WmTabpane", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "WmTabs", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "WmTabpane", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "WmTabs", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "WmTabpane", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "WmTabheader", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx", "target": "WmTabheader", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/layoutgrid.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/layoutgrid.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/layoutgrid.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/layoutgrid.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/styles/background.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/layoutgrid.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/layoutgrid/layoutgrid.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/layoutgrid.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/layoutgrid/layoutgrid.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/layoutgrid.component.spec.tsx", "target": "WmLayoutgrid", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/layoutgrid.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/layoutgrid.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/layoutgrid.component.spec.tsx", "target": "ChildComponent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tile.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/tile.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/tile/tile.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/tile.component.spec.tsx", "target": "WmTile", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tile.component.spec.tsx", "target": "WmTile", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tile.component.spec.tsx", "target": "WmTile", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tile.component.spec.tsx", "target": "WmButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tile.component.spec.tsx", "target": "WmButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tile.component.spec.tsx", "target": "WmTile", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tile.component.spec.tsx", "target": "WmTile", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tile.component.spec.tsx", "target": "WmTile", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/tile.component.spec.tsx", "target": "WmTile", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/panel.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/panel.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/panel.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/panel.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/panel/panel.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/panel.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/panel/panel.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/panel.component.spec.tsx", "target": "WmPanelProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/panel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/panel.component.spec.tsx", "target": "WmPanel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/panel.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/layoutgrid/gridcolumn.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/layoutgrid/gridcolumn.component.spec.tsx", "target": "enzyme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/layoutgrid/gridcolumn.component.spec.tsx", "target": "react-test-renderer", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/layoutgrid/gridcolumn.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/layoutgrid/gridcolumn/gridcolumn.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/layoutgrid/gridcolumn.component.spec.tsx", "target": "WmGridcolumn", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/layoutgrid/gridrow.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/layoutgrid/gridrow.component.spec.tsx", "target": "enzyme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/layoutgrid/gridrow.component.spec.tsx", "target": "react-test-renderer", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/layoutgrid/gridrow.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/layoutgrid/gridrow/gridrow.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/layoutgrid/gridrow.component.spec.tsx", "target": "WmGridrow", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/panel/panel-content.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/panel/panel-content.component.spec.tsx", "target": "enzyme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/panel/panel-content.component.spec.tsx", "target": "react-test-renderer", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/panel/panel-content.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/panel/panel-content/panel-content.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/panel/panel-content.component.spec.tsx", "target": "WmPanelContent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/panel/panel-footer.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/panel/panel-footer.component.spec.tsx", "target": "enzyme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/panel/panel-footer.component.spec.tsx", "target": "react-test-renderer", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/panel/panel-footer.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/panel/panel-footer/panel-footer.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/panel/panel-footer.component.spec.tsx", "target": "WmPanelFooter", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/accordion/accordion.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/accordion/accordion.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/accordion/accordion.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/accordion/accordionpane/accordionpane.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/accordion/accordion.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/label/label.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/accordion/accordion.component.spec.tsx", "target": "wavemaker-rn-runtime/src/components/container/accordion/accordion.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/accordion/accordion.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/accordion/accordion.component.spec.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/accordion/accordion.component.spec.tsx", "target": "WmAccordion", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/accordion/accordionpane/accordionpane.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/accordion/accordionpane/accordionpane.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/accordion/accordionpane/accordionpane.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/accordion/accordionpane/accordionpane.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/accordion/accordion.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/accordion/accordionpane/accordionpane.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/accordion/accordion.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/accordion/accordionpane/accordionpane.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/label/label.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/accordion/accordionpane/accordionpane.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/accordion/accordionpane/accordionpane.component.spec.tsx", "target": "WmAccordion", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/accordion/accordionpane/accordionpane.component.spec.tsx", "target": "WmAccordion", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/accordion/accordionpane/accordionpane.component.spec.tsx", "target": "WmAccordionpane", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/accordion/accordionpane/accordionpane.component.spec.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/accordion/accordionpane/accordionpane.component.spec.tsx", "target": "WmAccordion", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/accordion/accordionpane/accordionpane.component.spec.tsx", "target": "WmAccordionpane", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/accordion/accordionpane/accordionpane.component.spec.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/wizard/wizardstep.component.spec.tsx", "target": "WmWizardstep", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/linearlayout/linearlayoutitem.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/linearlayout/linearlayoutitem.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/linearlayout/linearlayoutitem.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/linearlayout/linearlayout.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/linearlayout/linearlayoutitem.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/linearlayout/linearlayout.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/linearlayout/linearlayoutitem.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/linearlayout/linearlayoutitem/linearlayoutitem.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/linearlayout/linearlayoutitem.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/container/linearlayout/linearlayoutitem.component.spec.tsx", "target": "WmLinearlayout", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/linearlayout/linearlayoutitem.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/container/linearlayout/linearlayoutitem.component.spec.tsx", "target": "WmLinearlayoutitem", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/prefab/prefab-container.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/prefab/prefab-container.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/prefab/prefab-container.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/prefab/prefab-container.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/prefab/prefab-container.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/prefab/prefab-container.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/asset.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/prefab/prefab-container.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/prefab/prefab-container.component.spec.tsx", "target": "WmPrefabContainer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialog.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialog.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/dialogs/dialog/dialog.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialog.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/runtime/services/app-modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialog.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/asset.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialog.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialog.component.spec.tsx", "target": "ModalProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialog.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialog.component.spec.tsx", "target": "WmDialog", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialog.component.spec.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialog.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialog.component.spec.tsx", "target": "WmDialog", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialog.component.spec.tsx", "target": "WmDialog", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialog.component.spec.tsx", "target": "WmDialog", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialog.component.spec.tsx", "target": "WmDialog", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialog.component.spec.tsx", "target": "WmDialog", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialog.component.spec.tsx", "target": "Component", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialog.component.spec.tsx", "target": "ChildrenComponent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialog.component.spec.tsx", "target": "Component", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialogcontent.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialogcontent.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialogcontent.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialogcontent.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/dialogs/dialogcontent/dialogcontent.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialogcontent.component.spec.tsx", "target": "WmDialogcontent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialogcontent.component.spec.tsx", "target": "WmDialogcontent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialogcontent.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialogcontent.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialogcontent.component.spec.tsx", "target": "WmDialogcontent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialogcontent.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialogcontent.component.spec.tsx", "target": "WmDialogcontent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialogcontent.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/dialogs/alertdialog/alertdialog.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/dialogs/dialog/dialog.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/runtime/services/app-modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/asset.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "target": "ModalProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "target": "WmAlertdialog", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "target": "Component", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "target": "Component", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "target": "Component", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "target": "Component", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "target": "Component", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "target": "Component", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "target": "Component", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "target": "Component", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "target": "Component", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "target": "Component", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "target": "ModalProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "target": "WmAlertdialog", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx", "target": "Component", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialogactions.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialogactions.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialogactions.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialogactions.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/dialogs/dialogactions/dialogactions.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialogactions.component.spec.tsx", "target": "WmDialogactions", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialogactions.component.spec.tsx", "target": "WmDialogactions", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialogactions.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialogactions.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialogactions.component.spec.tsx", "target": "WmDialogactions", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/dialogactions.component.spec.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/confirmdialog.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/confirmdialog.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/confirmdialog.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/dialogs/confirmdialog/confirmdialog.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/confirmdialog.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/dialogs/dialog/dialog.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/confirmdialog.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/runtime/services/app-modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/confirmdialog.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/asset.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/confirmdialog.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/confirmdialog.component.spec.tsx", "target": "ModalProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/confirmdialog.component.spec.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/confirmdialog.component.spec.tsx", "target": "WmConfirmdialog", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/confirmdialog.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/confirmdialog.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/confirmdialog.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/confirmdialog.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/confirmdialog.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/confirmdialog.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/confirmdialog.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/dialogs/confirmdialog.component.spec.tsx", "target": "Content", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/device/camera.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/device/camera.component.spec.tsx", "target": "enzyme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/device/camera.component.spec.tsx", "target": "react-test-renderer", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/device/camera.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/device/camera/camera.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/device/camera.component.spec.tsx", "target": "WmCamera", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/device/barcodescanner.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/device/barcodescanner.component.spec.tsx", "target": "enzyme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/device/barcodescanner.component.spec.tsx", "target": "react-test-renderer", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/device/barcodescanner.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/device/barcodescanner/barcodescanner.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/device/barcodescanner.component.spec.tsx", "target": "WmBarcodescanner", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/list.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/list.component.spec.tsx", "target": "enzyme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/list.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/data/list/list.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/list.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/data/list/list.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/list.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/list.component.spec.tsx", "target": "WmListProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/list.component.spec.tsx", "target": "div", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/list.component.spec.tsx", "target": "WmList", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/list.component.spec.tsx", "target": "WmList", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/list.component.spec.tsx", "target": "WmList", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/list.component.spec.tsx", "target": "WmList", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/list.component.spec.tsx", "target": "WmList", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/data/form/form.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/data/card/card.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/toast.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "React", "type": "extends"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "ToastProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "SampleToastProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WMCard", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx", "target": "WmForm", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/card.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/card.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/card.component.spec.tsx", "target": "enzyme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/card.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/card.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/data/card/card.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/card.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/card.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/card.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/picture/picture.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/card.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/label/label.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/card.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/navigation/menu/menu.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/card.component.spec.tsx", "target": "WmCard", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/card.component.spec.tsx", "target": "WmCard", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/card.component.spec.tsx", "target": "WmCard", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/card.component.spec.tsx", "target": "WMLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/card.component.spec.tsx", "target": "WmCard", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/card.component.spec.tsx", "target": "WmCard", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/card.component.spec.tsx", "target": "WmCard", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/card.component.spec.tsx", "target": "WmCard", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/card.component.spec.tsx", "target": "WmCard", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-field.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-field.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/data/form/form-field/form-field.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-field.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-field.component.spec.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-field.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/core/logger", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-field.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/label/label.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-field.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/input/text/text.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-field.component.spec.tsx", "target": "WmFormField", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-field.component.spec.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-field.component.spec.tsx", "target": "WmFormField", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-field.component.spec.tsx", "target": "WmFormField", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-field.component.spec.tsx", "target": "WmFormField", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-field.component.spec.tsx", "target": "WmFormField", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-field.component.spec.tsx", "target": "WmFormField", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-field.component.spec.tsx", "target": "WmFormField", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-field.component.spec.tsx", "target": "WmFormField", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-field.component.spec.tsx", "target": "WmText", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-field.component.spec.tsx", "target": "WmFormField", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-footer.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-footer.component.spec.tsx", "target": "enzyme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-footer.component.spec.tsx", "target": "react-test-renderer", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-footer.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/data/form/form-footer/form-footer.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-footer.component.spec.tsx", "target": "WmFormFooter", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-body.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-body.component.spec.tsx", "target": "enzyme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-body.component.spec.tsx", "target": "react-test-renderer", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-body.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/data/form/form-body/form-body.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/form/form-body.component.spec.tsx", "target": "WmFormBody", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/card/card-footer.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/card/card-footer.component.spec.tsx", "target": "enzyme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/card/card-footer.component.spec.tsx", "target": "react-test-renderer", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/card/card-footer.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/data/card/card-footer/card-footer.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/card/card-footer.component.spec.tsx", "target": "WmCardFooter", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/card/card-content.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/card/card-content.component.spec.tsx", "target": "enzyme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/card/card-content.component.spec.tsx", "target": "react-test-renderer", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/card/card-content.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/data/card/card-content/card-content.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/card/card-content.component.spec.tsx", "target": "WmCardContent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/list/list-action-template.component.spec.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/list/list-action-template.component.spec.tsx", "target": "react-test-renderer", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/list/list-action-template.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/data/list/list-action-template/list-action-template.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/list/list-action-template.component.spec.tsx", "target": "WmListActionTemplate", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/list/list-template.component.spec.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/list/list-template.component.spec.tsx", "target": "enzyme", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/list/list-template.component.spec.tsx", "target": "react-test-renderer", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/list/list-template.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/data/list/list-template/list-template.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/list/list-template.component.spec.tsx", "target": "WmListTemplate", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/liveform/liveform.component.spec.tsx", "target": "@testing-library/react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/liveform/liveform.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/data/liveform/liveform.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/liveform/liveform.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/data/form/form-action/form-action.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/liveform/liveform.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/data/form/form-body/form-body.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/liveform/liveform.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/data/form/form-footer/form-footer.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/liveform/liveform.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/layoutgrid/gridcolumn/gridcolumn.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/liveform/liveform.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/container/layoutgrid/gridrow/gridrow.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/liveform/liveform.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/label/label.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/liveform/liveform.component.spec.tsx", "target": "@wavemaker/app-rn-runtime/components/data/form/form-field/form-field.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/test/components/data/liveform/liveform.component.spec.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/liveform/liveform.component.spec.tsx", "target": "WmFormBody", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/liveform/liveform.component.spec.tsx", "target": "WmGridrow", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/test/components/data/liveform/liveform.component.spec.tsx", "target": "WmFormFooter", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/scripts/wavicon-generator.js", "target": "wavemaker-rn-runtime/scripts/{{iconSetName}}.ttf", "type": "imports"}, {"source": "wavemaker-rn-runtime/scripts/wavicon-generator.js", "target": "@expo/vector-icons/build/createIconSet", "type": "imports"}, {"source": "wavemaker-rn-runtime/scripts/combineCoverageHtmlCSS.js", "target": "style", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/fixed-view.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/fixed-view.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/fixed-view.component.tsx", "target": "wavemaker-rn-runtime/src/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/fixed-view.component.tsx", "target": "FixedViewContainer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/fixed-view.component.tsx", "target": "FixedViewProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/fixed-view.component.tsx", "target": "ThemeProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/fixed-view.component.tsx", "target": "WrapperView", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/toast.service.ts", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/toast.service.ts", "target": "ToastService", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/navigation.service.ts", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/navigation.service.ts", "target": "void", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/navigation.service.ts", "target": "void", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/navigation.service.ts", "target": "void", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/navigation.service.ts", "target": "NavigationService", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/if.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/if.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/if.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/sticky-container.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/sticky-container.component.tsx", "target": "react-native-safe-area-context", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/sticky-container.component.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/sticky-container.component.tsx", "target": "wavemaker-rn-runtime/src/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/sticky-container.component.tsx", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/sticky-container.component.tsx", "target": "@wavemaker/app-rn-runtime/core/AppConfig", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/sticky-container.component.tsx", "target": "StickyViewContainer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/sticky-container.component.tsx", "target": "AppConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/sticky-container.component.tsx", "target": "ThemeProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/sticky-container.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/sticky-container.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/sticky-container.component.tsx", "target": "AppConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/asset.provider.ts", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/accessibility.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/accessibility.ts", "target": "wavemaker-rn-runtime/src/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/modal.service.ts", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/modal.service.ts", "target": "ModalService", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/partial.service.ts", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/partial.service.ts", "target": "PartialService", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/wm-component-tree.ts", "target": "wavemaker-rn-runtime/src/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/testid.provider.ts", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/testid.provider.ts", "target": "string", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/utils.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/utils.ts", "target": "moment", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/utils.ts", "target": "expo-file-system", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/utils.ts", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/utils.ts", "target": "react-native-mime-types", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/utils.ts", "target": "wavemaker-rn-runtime/src/styles/theme.variables", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/props.provider.ts", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/props.provider.ts", "target": "wavemaker-rn-runtime/src/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/props.provider.ts", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/viewport.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/viewport.ts", "target": "wavemaker-rn-runtime/src/core/event-notifier", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/display.manager.ts", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/display.manager.ts", "target": "DisplayManager", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/tappable.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/tappable.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/tappable.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/tappable.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/tappable.component.tsx", "target": "wavemaker-rn-runtime/src/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/tappable.component.tsx", "target": "react-native-paper", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/tappable.component.tsx", "target": "wavemaker-rn-runtime/src/styles/theme.variables", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/tappable.component.tsx", "target": "wavemaker-rn-runtime/src/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/tappable.component.tsx", "target": "Tappable", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/tappable.component.tsx", "target": "wavemaker-rn-runtime/src/core/ui-preferences.context", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/tappable.component.tsx", "target": "Tappable", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/tappable.component.tsx", "target": "UIPreferencesConsumer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/ui-preferences.context.ts", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/ui-preferences.context.ts", "target": "UI_PREFERENCES", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/injector.ts", "target": "wavemaker-rn-runtime/src/core/i18n.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/injector.ts", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/injector.ts", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/injector.ts", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/injector.ts", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/injector.ts", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/injector.ts", "target": "I18nService", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "react-native-animatable", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "react-native-animatable", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme.variables", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "@wavemaker/app-rn-runtime/styles/style-props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "@wavemaker/app-rn-runtime/styles/background.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "@wavemaker/app-rn-runtime/core/logger", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "wavemaker-rn-runtime/src/core/event-notifier", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "wavemaker-rn-runtime/src/core/props.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "wavemaker-rn-runtime/src/core/if.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "wavemaker-rn-runtime/src/core/asset.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "wavemaker-rn-runtime/src/core/fixed-view.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "wavemaker-rn-runtime/src/core/testid.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "wavemaker-rn-runtime/src/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "wavemaker-rn-runtime/src/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "wavemaker-rn-runtime/src/core/wm-component-tree", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "ViewStyle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "ViewStyle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "FixedView", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "TextIdPrefixConsumer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "AssetConsumer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/base.component.tsx", "target": "ThemeConsumer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/logger.ts", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/logger.ts", "target": "react-native-logs", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/logger.ts", "target": "wavemaker-rn-runtime/src/core/storage.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/scroll-view.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/scroll-view.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/scroll-view.component.tsx", "target": "ScrollView", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/scroll-view.component.tsx", "target": "ScrollViewProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/scroll-view.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/security.service.ts", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/security.service.ts", "target": "SecurityService", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/formatters.ts", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/formatters.ts", "target": "moment", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/formatters.ts", "target": "wavemaker-rn-runtime/src/core/constants/currency-constants", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/formatters.ts", "target": "@wavemaker/variables/src/types/date-formatter", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/formatters.ts", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/storage.service.ts", "target": "@react-native-async-storage/async-storage", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/storage.service.ts", "target": "string", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/storage.service.ts", "target": "void", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/storage.service.ts", "target": "void", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/network.service.ts", "target": "axios", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/network.service.ts", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/network.service.ts", "target": "expo-network", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/network.service.ts", "target": "@react-native-community/netinfo", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/network.service.ts", "target": "wavemaker-rn-runtime/src/core/AppConfig", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/network.service.ts", "target": "wavemaker-rn-runtime/src/core/storage.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/network.service.ts", "target": "wavemaker-rn-runtime/src/core/event-notifier", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/network.service.ts", "target": "wavemaker-rn-runtime/src/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/network.service.ts", "target": "boolean", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/network.service.ts", "target": "boolean", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/network.service.ts", "target": "boolean", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/network.service.ts", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/network.service.ts", "target": "void", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/network.service.ts", "target": "void", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/network.service.ts", "target": "boolean", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/network.service.ts", "target": "boolean", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/network.service.ts", "target": "boolean", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/network.service.ts", "target": "boolean", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/network.service.ts", "target": "boolean", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/imageSizeEstimator.ts", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/imageSizeEstimator.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/spinner.service.ts", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/spinner.service.ts", "target": "SpinnerService", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/components/textinput.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/components/textinput.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/components/textinput.component.tsx", "target": "imask", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/components/textinput.component.tsx", "target": "wavemaker-rn-runtime/src/core/components/floatinglabel.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/components/textinput.component.tsx", "target": "TextInput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/components/textinput.component.tsx", "target": "SelectRange", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/components/textinput.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/components/textinput.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/components/floatinglabel.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/components/floatinglabel.component.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/device/location-service.ts", "target": "@wavemaker/app-rn-runtime/variables/device/operation.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/device/camera-service.ts", "target": "@wavemaker/app-rn-runtime/variables/device/operation.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/device/camera-service.ts", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/device/camera-service.ts", "target": "CameraService", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/core/device/contacts-service.ts", "target": "@wavemaker/app-rn-runtime/variables/device/operation.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/device/calendar-service.ts", "target": "@wavemaker/app-rn-runtime/variables/device/operation.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/device/scan-service.ts", "target": "@wavemaker/app-rn-runtime/variables/device/scan/scan.operation", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/device/scan-service.ts", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/core/device/scan-service.ts", "target": "ScanService", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/platform.api.ts", "target": "@wavemaker/app-rn-runtime/core/logger", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/platform.api.ts", "target": "wavemaker-rn-runtime/src/runtime/watcher", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.navigator.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.navigator.tsx", "target": "@react-navigation/native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.navigator.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.navigator.tsx", "target": "@wavemaker/app-rn-runtime/core/AppConfig", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.navigator.tsx", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.navigator.tsx", "target": "wavemaker-rn-runtime/src/runtime/navigator/drawer.navigator", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.navigator.tsx", "target": "wavemaker-rn-runtime/src/runtime/navigator/stack.navigator", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.navigator.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.navigator.tsx", "target": "wavemaker-rn-runtime/src/styles/theme.variables", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.navigator.tsx", "target": "AppConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.navigator.tsx", "target": "NavigationContainer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "react-native-gesture-handler", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "prop-types", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "react-native-safe-area-context", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "react-native-paper", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "expo-modules-core", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "expo-web-browser", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "@wavemaker/app-rn-runtime/core/logger", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "@wavemaker/app-rn-runtime/core/event-notifier", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "@wavemaker/app-rn-runtime/core/storage.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "@wavemaker/app-rn-runtime/core/constant.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "@wavemaker/app-rn-runtime/core/formatters", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "@wavemaker/app-rn-runtime/core/modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "@wavemaker/app-rn-runtime/core/fixed-view.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "@wavemaker/app-rn-runtime/core/toast.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "@wavemaker/app-rn-runtime/core/partial.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "@wavemaker/app-rn-runtime/components/advanced/network-info-toaster/network-info-toaster.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme.variables", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/message/message.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/animatedview.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "@wavemaker/app-rn-runtime/runtime/services/app-i18n.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "wavemaker-rn-runtime/src/runtime/watcher", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "wavemaker-rn-runtime/src/runtime/lib-patch", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "wavemaker-rn-runtime/src/runtime/services/app-display-manager.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "wavemaker-rn-runtime/src/runtime/services/app-modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "wavemaker-rn-runtime/src/runtime/services/app-toast.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "wavemaker-rn-runtime/src/runtime/services/partial.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "wavemaker-rn-runtime/src/runtime/services/app-spinner.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "wavemaker-rn-runtime/src/runtime/App.navigator", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "wavemaker-rn-runtime/src/core/security.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "wavemaker-rn-runtime/src/core/device/camera-service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "wavemaker-rn-runtime/src/runtime/services/device/camera-service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "wavemaker-rn-runtime/src/core/device/scan-service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "wavemaker-rn-runtime/src/runtime/services/device/scan-service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "wavemaker-rn-runtime/src/runtime/services/app-security.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "@wavemaker/app-rn-runtime/variables/utils/variable.utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "@expo/vector-icons/build/vendor/react-native-vector-icons/Fonts/MaterialCommunityIcons.ttf", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "expo-splash-screen", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "wavemaker-rn-runtime/src/runtime/base-partial.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "wavemaker-rn-runtime/src/runtime/base-page.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "wavemaker-rn-runtime/src/runtime/memo.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "wavemaker-rn-runtime/src/variables/base-variable", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "expo-blur", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "expo-navigation-bar", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "Drawer", "type": "implements"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "AppConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "NavigationServiceProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "ToastProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "PartialProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "SecurityProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "CameraProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "ScanProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "ModalProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "WmMemo", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "ThemeProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "TouchableOpacity", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "WmMessage", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "WmMemo", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "Animatedview", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "GestureHandlerRootView", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "WmMemo", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "ThemeProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "style", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "SafeAreaProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "PaperProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "Wrapper", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "ThemeProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "GestureHandlerRootView", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "FixedViewContainer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/App.tsx", "target": "WmNetworkInfoToaster", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-prefab.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-prefab.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-prefab.component.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-prefab.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-prefab.component.tsx", "target": "@wavemaker/app-rn-runtime/components/prefab/prefab-container.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-prefab.component.tsx", "target": "axios", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-prefab.component.tsx", "target": "wavemaker-rn-runtime/src/runtime/watcher", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-prefab.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/lottie/lottie.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-prefab.component.tsx", "target": "PrefabProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-prefab.component.tsx", "target": "void", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-prefab.component.tsx", "target": "PrefabProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-prefab.component.tsx", "target": "PartialProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-prefab.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/watcher.ts", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/watcher.ts", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/watcher.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "@wavemaker/app-rn-runtime/core/AppConfig", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "@wavemaker/app-rn-runtime/core/formatters", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "@wavemaker/app-rn-runtime/core/testid.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "@wavemaker/app-rn-runtime/variables/base-variable", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "@wavemaker/app-rn-runtime/core/viewport", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "wavemaker-rn-runtime/src/runtime/App", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "@wavemaker/app-rn-runtime/components/data/form/form-field/form-field.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "@wavemaker/app-rn-runtime/components/data/form/form.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "@wavemaker/app-rn-runtime/core/toast.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "@wavemaker/app-rn-runtime/runtime/services/app-spinner.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "wavemaker-rn-runtime/src/runtime/services/app-i18n.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "wavemaker-rn-runtime/src/runtime/watcher", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "@wavemaker/app-rn-runtime/components/data/form/form-action/form-action.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/lottie/lottie.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "@wavemaker/app-rn-runtime/components/page/left-panel/left-panel.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/label/label.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "P", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "AppConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "AppConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "ThemeProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "TextIdPrefixConsumer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "TestIdPrefixProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx", "target": "ToastConsumer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-partial.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-partial.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-partial.component.tsx", "target": "@wavemaker/app-rn-runtime/components/page/partial/partial.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-partial.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-partial.component.tsx", "target": "wavemaker-rn-runtime/src/runtime/base-prefab.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-partial.component.tsx", "target": "wavemaker-rn-runtime/src/runtime/watcher", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-partial.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-partial.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/lottie/lottie.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-partial.component.tsx", "target": "PartialProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-partial.component.tsx", "target": "PartialProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/memo.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/memo.component.tsx", "target": "wavemaker-rn-runtime/src/runtime/watcher", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-page.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-page.component.tsx", "target": "@react-navigation/native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-page.component.tsx", "target": "expo-splash-screen", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-page.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-page.component.tsx", "target": "@wavemaker/app-rn-runtime/components/page/page.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-page.component.tsx", "target": "wavemaker-rn-runtime/src/runtime/services/app-security.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-page.component.tsx", "target": "wavemaker-rn-runtime/src/runtime/services/app-spinner.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-page.component.tsx", "target": "wavemaker-rn-runtime/src/runtime/watcher", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-page.component.tsx", "target": "wavemaker-rn-runtime/src/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/base-page.component.tsx", "target": "PageProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/base-page.component.tsx", "target": "NavigationServiceProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/navigator/drawer.navigator.tsx", "target": "@react-navigation/drawer", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/navigator/drawer.navigator.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme.variables", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/navigator/drawer.navigator.tsx", "target": "React", "type": "extends"}, {"source": "wavemaker-rn-runtime/src/runtime/navigator/stack.navigator.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/navigator/stack.navigator.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/navigator/stack.navigator.tsx", "target": "@react-navigation/stack", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/navigator/stack.navigator.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme.variables", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/navigator/stack.navigator.tsx", "target": "React", "type": "extends"}, {"source": "wavemaker-rn-runtime/src/runtime/services/webprocess.service.tsx", "target": "axios", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/webprocess.service.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/webprocess.service.tsx", "target": "@wavemaker/app-rn-runtime/components/advanced/webview/webview.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/webprocess.service.tsx", "target": "@wavemaker/app-rn-runtime/core/AppConfig", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/webprocess.service.tsx", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/webprocess.service.tsx", "target": "wavemaker-rn-runtime/src/runtime/services/app-display-manager.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/webprocess.service.tsx", "target": "Component", "type": "extends"}, {"source": "wavemaker-rn-runtime/src/runtime/services/webprocess.service.tsx", "target": "WebProcessWebViewProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/webprocess.service.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/webprocess.service.tsx", "target": "WmWebview", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/webprocess.service.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/webprocess.service.tsx", "target": "AppConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/webprocess.service.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/webprocess.service.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-modal.service.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-modal.service.tsx", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-modal.service.tsx", "target": "@wavemaker/app-rn-runtime/core/AppConfig", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-modal.service.tsx", "target": "@wavemaker/app-rn-runtime/core/modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-modal.service.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-modal.service.tsx", "target": "ModalService", "type": "implements"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-modal.service.tsx", "target": "AppConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-toast.service.tsx", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-toast.service.tsx", "target": "@wavemaker/app-rn-runtime/core/AppConfig", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-toast.service.tsx", "target": "@wavemaker/app-rn-runtime/core/toast.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-toast.service.tsx", "target": "ToastService", "type": "implements"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-toast.service.tsx", "target": "AppConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/partial.service.tsx", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/partial.service.tsx", "target": "@wavemaker/app-rn-runtime/core/partial.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/partial.service.tsx", "target": "@wavemaker/app-rn-runtime/core/AppConfig", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/partial.service.tsx", "target": "AppConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-i18n.service.tsx", "target": "@wavemaker/app-rn-runtime/core/storage.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-i18n.service.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-i18n.service.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-i18n.service.tsx", "target": "@wavemaker/app-rn-runtime/core/i18n.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-i18n.service.tsx", "target": "I18nService", "type": "implements"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-spinner.service.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-spinner.service.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-spinner.service.tsx", "target": "@wavemaker/app-rn-runtime/core/spinner.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-spinner.service.tsx", "target": "@wavemaker/app-rn-runtime/core/display.manager", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-spinner.service.tsx", "target": "@wavemaker/app-rn-runtime/runtime/services/app-display-manager.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-spinner.service.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/spinner/spinner.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-spinner.service.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme.variables", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-spinner.service.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-display-manager.service.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-display-manager.service.tsx", "target": "@wavemaker/app-rn-runtime/core/display.manager", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-display-manager.service.tsx", "target": "@wavemaker/app-rn-runtime/core/AppConfig", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-display-manager.service.tsx", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-display-manager.service.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-security.service.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-security.service.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-security.service.tsx", "target": "@wavemaker/app-rn-runtime/core/network.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-security.service.tsx", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-security.service.tsx", "target": "@wavemaker/app-rn-runtime/core/AppConfig", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-security.service.tsx", "target": "@wavemaker/app-rn-runtime/core/storage.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-security.service.tsx", "target": "@wavemaker/app-rn-runtime/core/security.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-security.service.tsx", "target": "wavemaker-rn-runtime/src/runtime/services/webprocess.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-security.service.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-security.service.tsx", "target": "string", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-security.service.tsx", "target": "SecurityService", "type": "implements"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-security.service.tsx", "target": "string", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-security.service.tsx", "target": "AppConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-security.service.tsx", "target": "AppConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/app-security.service.tsx", "target": "String", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "@expo/vector-icons", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "expo-av", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "expo-camera", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "expo-file-system", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "expo-application", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "@wavemaker/app-rn-runtime/core/display.manager", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "@wavemaker/app-rn-runtime/variables/device/camera/capture-video.operation", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "@wavemaker/app-rn-runtime/variables/device/camera/capture-image.operation", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "@wavemaker/app-rn-runtime/runtime/services/device/permissions", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "@wavemaker/app-rn-runtime/core/device/camera-service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "@wavemaker/app-rn-runtime/variables/device/operation.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "@wavemaker/app-rn-runtime/runtime/services/app-display-manager.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "CaptureVideoOutput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "Camera", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "CaptureImageOutput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "Camera", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "string", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "Ionicons", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "TouchableOpacity", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "Ionicons", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "Ionicons", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "ImageBackground", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx", "target": "CameraView", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/location-service.ts", "target": "expo-location", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/location-service.ts", "target": "@wavemaker/app-rn-runtime/runtime/services/device/permissions", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/location-service.ts", "target": "GeoPositionOutput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/permissions.ts", "target": "expo-location", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/permissions.ts", "target": "expo-contacts", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/permissions.ts", "target": "expo-calendar", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/permissions.ts", "target": "expo-camera", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/permissions.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/permissions.ts", "target": "string", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/scan-service.tsx", "target": "expo-camera", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/scan-service.tsx", "target": "@expo/vector-icons", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/scan-service.tsx", "target": "expo-application", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/scan-service.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/scan-service.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/scan-service.tsx", "target": "@wavemaker/app-rn-runtime/variables/device/scan/scan.operation", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/scan-service.tsx", "target": "@wavemaker/app-rn-runtime/core/display.manager", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/scan-service.tsx", "target": "@wavemaker/app-rn-runtime/runtime/services/device/permissions", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/scan-service.tsx", "target": "@wavemaker/app-rn-runtime/runtime/services/app-display-manager.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/scan-service.tsx", "target": "ScanOutput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/scan-service.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/scan-service.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/scan-service.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/scan-service.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/scan-service.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/scan-service.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/scan-service.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/scan-service.tsx", "target": "Ionicons", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/contacts-service.ts", "target": "expo-contacts", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/contacts-service.ts", "target": "@wavemaker/app-rn-runtime/runtime/services/device/permissions", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/contacts-service.ts", "target": "@wavemaker/app-rn-runtime/core/device/contacts-service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/contacts-service.ts", "target": "@wavemaker/app-rn-runtime/variables/device/contacts/get-contacts.operation", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/contacts-service.ts", "target": "ContactsOutput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/contacts-service.ts", "target": "PhoneNumber", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/calendar-service.ts", "target": "expo-calendar", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/calendar-service.ts", "target": "@wavemaker/app-rn-runtime/runtime/services/device/permissions", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/calendar-service.ts", "target": "@wavemaker/app-rn-runtime/core/device/calendar-service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/calendar-service.ts", "target": "@wavemaker/app-rn-runtime/variables/device/calendar/get-events.operation", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/calendar-service.ts", "target": "@wavemaker/app-rn-runtime/variables/device/calendar/delete-event.operation", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/calendar-service.ts", "target": "CalendarEvent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/calendar-service.ts", "target": "string", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/calendar-service.ts", "target": "CalendarEvent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/calendar-service.ts", "target": "CreateEventOutput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/calendar-service.ts", "target": "string", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/calendar-service.ts", "target": "DeleteEventOutput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/runtime/services/device/calendar-service.ts", "target": "string", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/styles/MediaQueryList.ts", "target": "css-mediaquery", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/styles/MediaQueryList.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/styles/MediaQueryList.ts", "target": "@wavemaker/app-rn-runtime/core/viewport", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/styles/theme.variables.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/styles/theme.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/styles/theme.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/styles/theme.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/styles/theme.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/styles/theme.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/styles/theme.tsx", "target": "@wavemaker/app-rn-runtime/core/event-notifier", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/styles/theme.tsx", "target": "wavemaker-rn-runtime/src/styles/MediaQueryList", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/styles/theme.tsx", "target": "wavemaker-rn-runtime/src/styles/theme.variables", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/styles/theme.tsx", "target": "wavemaker-rn-runtime/src/styles/style-prop.validator", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/styles/theme.tsx", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/styles/theme.tsx", "target": "@wavemaker/app-rn-runtime/core/AppConfig", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/styles/theme.tsx", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/styles/theme.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/styles/theme.tsx", "target": "AppConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/styles/theme.tsx", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/styles/theme.tsx", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/styles/theme.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/styles/theme.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/styles/theme.tsx", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/styles/theme.tsx", "target": "Theme", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/styles/background.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/styles/background.component.tsx", "target": "expo-linear-gradient", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/styles/background.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/styles/background.component.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/styles/background.component.tsx", "target": "@wavemaker/app-rn-runtime/core/imageSizeEstimator", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/styles/background.component.tsx", "target": "@wavemaker/app-rn-runtime/core/asset.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/styles/background.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/styles/background.component.tsx", "target": "LinearGradientProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/styles/background.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/styles/background.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/styles/background.component.tsx", "target": "ExpoLinearGradient", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/styles/background.component.tsx", "target": "BackgroundProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/styles/background.component.tsx", "target": "AssetConsumer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/styles/background.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/styles/background.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/styles/background.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/styles/style-prop.validator.ts", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/styles/style-prop.validator.ts", "target": "expo-font", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/webview/webview.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/webview/webview.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/webview/webview.component.tsx", "target": "react-native-webview", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/webview/webview.component.tsx", "target": "@wavemaker/app-rn-runtime/core/if.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/webview/webview.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/webview/webview.component.tsx", "target": "wavemaker-rn-runtime/src/components/advanced/webview/webview.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/webview/webview.component.tsx", "target": "wavemaker-rn-runtime/src/components/advanced/webview/webview.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/webview/webview.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/webview/webview.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/webview/webview.component.tsx", "target": "BaseComponentState", "type": "extends"}, {"source": "wavemaker-rn-runtime/src/components/advanced/webview/webview.component.tsx", "target": "WmWebviewProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/webview/webview.component.tsx", "target": "iframe", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/webview/webview.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/webview/webview.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/webview/webview.props.ts", "target": "wavemaker-rn-runtime/src/components/advanced/webview/webview.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/webview/webview.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.props.ts", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.component.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.component.tsx", "target": "@wavemaker/app-rn-runtime/core/key.extractor", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.component.tsx", "target": "@wavemaker/app-rn-runtime/gestures/carousel-swipe.animation", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.component.tsx", "target": "@wavemaker/app-rn-runtime/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.component.tsx", "target": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.component.tsx", "target": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.component.tsx", "target": "WmCarouselProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.component.tsx", "target": "Tappable", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-template/carousel-template.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-template/carousel-template.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-template/carousel-template.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-template/carousel-template.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-template/carousel-template.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-template/carousel-template.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-template/carousel-template.component.tsx", "target": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-template/carousel-template.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-template/carousel-template.component.tsx", "target": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-template/carousel-template.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-template/carousel-template.component.tsx", "target": "WmCarouselTemplateProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-template/carousel-template.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-content/carousel-content.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-content/carousel-content.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-content/carousel-content.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-content/carousel-content.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-content/carousel-content.component.tsx", "target": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-content/carousel-content.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-content/carousel-content.component.tsx", "target": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-content/carousel-content.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-content/carousel-content.component.tsx", "target": "WmCarouselContentProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-content/carousel-content.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-content/carousel-content.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-content/carousel-content.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/login/login.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/login/login.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/login/login.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/login/login.component.tsx", "target": "wavemaker-rn-runtime/src/components/advanced/login/login.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/login/login.component.tsx", "target": "wavemaker-rn-runtime/src/components/advanced/login/login.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/login/login.component.tsx", "target": "axios", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/login/login.component.tsx", "target": "WmLoginProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/login/login.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/login/login.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/login/login.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/login/login.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/login/login.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme.variables", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "@wavemaker/app-rn-runtime/core/toast.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "WmNetworkInfoToasterProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "TouchableOpacity", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "TouchableOpacity", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "TouchableOpacity", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "TouchableOpacity", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "TouchableOpacity", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx", "target": "ToastConsumer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.styles.ts", "target": "WmNetworkInfoToasterStyles", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/page.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page.component.tsx", "target": "wavemaker-rn-runtime/src/components/page/page.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page.component.tsx", "target": "wavemaker-rn-runtime/src/components/page/page.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page.component.tsx", "target": "react-native-safe-area-context", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page.component.tsx", "target": "@wavemaker/app-rn-runtime/core/sticky-container.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page.component.tsx", "target": "@wavemaker/app-rn-runtime/core/fixed-view.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page.component.tsx", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page.component.tsx", "target": "@wavemaker/app-rn-runtime/core/AppConfig", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page.component.tsx", "target": "WmPageProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/page.component.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/page.component.tsx", "target": "AppConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/page.component.tsx", "target": "NativeScrollEvent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/page.component.tsx", "target": "StickyViewContainer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/page.component.tsx", "target": "FixedViewContainer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/page.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/page.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/partial/partial.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/partial/partial.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/partial/partial.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/partial/partial.component.tsx", "target": "wavemaker-rn-runtime/src/components/page/partial/partial.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/partial/partial.component.tsx", "target": "wavemaker-rn-runtime/src/components/page/partial/partial.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/partial/partial.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/lottie/lottie.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/partial/partial.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/partial/partial.component.tsx", "target": "WmPartialProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/partial/partial.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/partial/partial.component.tsx", "target": "WmLottie", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/partial/partial.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/partial/partial.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/partial/partial.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/partial/partial.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/partial/partial.props.ts", "target": "@wavemaker/app-rn-runtime/runtime/base-fragment.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.styles.ts", "target": "WmTabbarStyles", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "@wavemaker/app-rn-runtime/core/modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "@wavemaker/app-rn-runtime/components/navigation/basenav/basenav.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "@wavemaker/app-rn-runtime/components/navigation/basenav/basenav.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "wavemaker-rn-runtime/src/components/page/tabbar/curve", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme.variables", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "@wavemaker/app-rn-runtime/core/fixed-view.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "react-native-safe-area-context", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "@wavemaker/app-rn-runtime/core/AppConfig", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "WmTabbarProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "AppConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "NativeScrollEvent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "NavigationServiceConsumer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "Svg", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "Path", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "ModalConsumer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "ThemeProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "WmTabbarProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.props.ts", "target": "wavemaker-rn-runtime/src/components/navigation/basenav/basenav.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.props.ts", "target": "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/curve.tsx", "target": "d3-shape", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/curve.tsx", "target": "LineDatum", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/tabbar/curve.tsx", "target": "LineDatum", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/content/content.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/content/content.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/content/content.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/content/content.component.tsx", "target": "react-native-safe-area-context", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/content/content.component.tsx", "target": "wavemaker-rn-runtime/src/components/page/content/content.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/content/content.component.tsx", "target": "wavemaker-rn-runtime/src/components/page/content/content.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/content/content.component.tsx", "target": "WmContentProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/content/content.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/content/content.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/content/content.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/content/content.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/left-panel/left-panel.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/left-panel/left-panel.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/left-panel/left-panel.component.tsx", "target": "wavemaker-rn-runtime/src/components/page/left-panel/left-panel.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/left-panel/left-panel.component.tsx", "target": "wavemaker-rn-runtime/src/components/page/left-panel/left-panel.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/left-panel/left-panel.component.tsx", "target": "react-native-gesture-handler", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/left-panel/left-panel.component.tsx", "target": "@wavemaker/app-rn-runtime/core/fixed-view.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/left-panel/left-panel.component.tsx", "target": "react-native-safe-area-context", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/left-panel/left-panel.component.tsx", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/left-panel/left-panel.component.tsx", "target": "@wavemaker/app-rn-runtime/core/AppConfig", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/left-panel/left-panel.component.tsx", "target": "WmLeftPanelProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/left-panel/left-panel.component.tsx", "target": "AppConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/left-panel/left-panel.component.tsx", "target": "FixedViewContainer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/left-panel/left-panel.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/left-panel/left-panel.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/left-panel/left-panel.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page-content/page-content.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page-content/page-content.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page-content/page-content.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page-content/page-content.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page-content/page-content.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page-content/page-content.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page-content/page-content.component.tsx", "target": "@wavemaker/app-rn-runtime/core/if.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page-content/page-content.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page-content/page-content.component.tsx", "target": "wavemaker-rn-runtime/src/components/page/page-content/page-content.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page-content/page-content.component.tsx", "target": "wavemaker-rn-runtime/src/components/page/page-content/page-content.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page-content/page-content.component.tsx", "target": "react-native-gesture-handler", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page-content/page-content.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/lottie/lottie.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page-content/page-content.component.tsx", "target": "react-native-safe-area-context", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page-content/page-content.component.tsx", "target": "WmPageContentProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/page-content/page-content.component.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/page-content/page-content.component.tsx", "target": "NativeScrollEvent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/page-content/page-content.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/page-content/page-content.component.tsx", "target": "WmLottie", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/page-content/page-content.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/page-content/page-content.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/page-content/page-content.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/page-content/page-content.props.ts", "target": "@wavemaker/app-rn-runtime/runtime/base-fragment.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/partial-container/partial-container.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/partial-container/partial-container.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/partial-container/partial-container.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/partial-container/partial-container.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/partial-container/partial-container.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/partial-container/partial-container.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/partial-container/partial-container.component.tsx", "target": "wavemaker-rn-runtime/src/components/page/partial-container/partial-container.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/partial-container/partial-container.component.tsx", "target": "wavemaker-rn-runtime/src/components/page/partial-container/partial-container.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/partial-container/partial-container.component.tsx", "target": "@wavemaker/app-rn-runtime/core/if.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/page/partial-container/partial-container.component.tsx", "target": "WmPartialContainerProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/partial-container/partial-container.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/page/partial-container/partial-container.component.tsx", "target": "PartialConsumer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.props.ts", "target": "@wavemaker/app-rn-runtime/components/input/basedataset/basedataset.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "react-native-gesture-handler", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/radioset/radioset.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/radioset/radioset.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/label/label.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "WmRadiosetProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "TouchableOpacity", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "ScrollView", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "ScrollView", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.component.tsx", "target": "expo-document-picker", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.component.tsx", "target": "WmFileuploadProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.component.tsx", "target": "WmButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/rating/rating.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/rating/rating.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/rating/rating.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/rating/rating.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/rating/rating.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/rating/rating.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/rating/rating.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/rating/rating.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/rating/rating.component.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/rating/rating.component.tsx", "target": "WmRatingProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/rating/rating.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/rating/rating.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/rating/rating.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/rating/rating.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/rating/rating.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/rating/rating.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/calendar/calendar.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/calendar/calendar.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.component.tsx", "target": "WmCalendarProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/calendar.styles.ts", "target": "WmCalendarStyles", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.tsx", "target": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.tsx", "target": "TouchableOpacity", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.tsx", "target": "TouchableOpacity", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.tsx", "target": "TouchableOpacity", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.tsx", "target": "TouchableOpacity", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/basedataset/basedataset.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/basedataset/basedataset.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/basedataset/basedataset.component.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/basedataset/basedataset.component.ts", "target": "@wavemaker/app-rn-runtime/components/input/basedataset/basedataset.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/basedataset/basedataset.component.ts", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/basedataset/basedataset.component.ts", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/basedataset/basedataset.component.ts", "target": "@wavemaker/app-rn-runtime/components/input/basedataset/basedataset.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/basedataset/basedataset.component.ts", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/basedataset/basedataset.component.ts", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/basedataset/basedataset.component.ts", "target": "void", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/basedataset/basedataset.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/basedataset/basedataset.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.props.ts", "target": "@wavemaker/app-rn-runtime/components/input/basedataset/basedataset.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/chips/chips.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/chips/chips.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/search/search.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/picture/picture.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/label/label.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "WmChipsProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "WmPicture", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/search/search.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/picture/picture.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/chips/chips.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/basenumber/basenumber.component.ts", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/basenumber/basenumber.component.ts", "target": "@wavemaker/app-rn-runtime/components/input/basenumber/basenumber.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/basenumber/basenumber.component.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/basenumber/basenumber.component.ts", "target": "@wavemaker/app-rn-runtime/components/input/basenumber/basenumber.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/basenumber/basenumber.component.ts", "target": "@wavemaker/app-rn-runtime/components/navigation/basenav/basenav.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/basenumber/basenumber.component.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/basenumber/basenumber.component.ts", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/basenumber/basenumber.component.ts", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/basenumber/basenumber.component.ts", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/basenumber/basenumber.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/basenumber/basenumber.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/basenumber/basenumber.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/basenumber/basenumber.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "moment", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/epoch/date-picker.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "@wavemaker/app-rn-runtime/core/modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "@wavemaker/app-rn-runtime/core/components/floatinglabel.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "@wavemaker/app-rn-runtime/runtime/services/app-i18n.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/date/date-picker-modal.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/time/time-picker-modal.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "WmDatetimeProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "WmButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "WmButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "ModalConsumer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "ModalConsumer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheel-time-picker.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheel-time-picker.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/epoch/wheelpicker/wheelpicker.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheel-time-picker.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheel-time-picker.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheel-date-picker.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheel-date-picker.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/epoch/wheelpicker/wheelpicker.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheel-date-picker.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheel-date-picker.component.tsx", "target": "moment", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheel-date-picker.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheel-date-picker.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/date-picker.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/date-picker.component.tsx", "target": "react-native-paper-dates", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/date-picker.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/date-picker.component.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/date-picker.component.tsx", "target": "@wavemaker/app-rn-runtime/core/modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/date-picker.component.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme.variables", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/date-picker.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/date-picker.component.tsx", "target": "ModalConsumer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/date-picker.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/date/date.props.ts", "target": "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/date/date.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/epoch/date/date.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/date/date.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/epoch/date/date.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/date/date.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/date/date.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/date/date.styles.ts", "target": "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/date/date.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/time/time.props.ts", "target": "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/time/time.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/epoch/time/time.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/time/time.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/epoch/time/time.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/time/time.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/time/time.component.tsx", "target": "@react-native-community/datetimepicker", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/time/time.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/time/time.styles.ts", "target": "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/time/time.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpicker/wheelpicker.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpicker/wheelpicker.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpicker/wheelpicker.props.ts", "target": "string", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpicker/wheelpicker.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpicker/wheelpicker.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpicker/wheelpicker.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpicker/wheelpicker.component.tsx", "target": "react-native-gesture-handler", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpicker/wheelpicker.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/epoch/wheelpicker/wheelpicker.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpicker/wheelpicker.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/epoch/wheelpicker/wheelpicker.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpicker/wheelpicker.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpicker/wheelpicker.component.tsx", "target": "WmWheelPickerProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpicker/wheelpicker.component.tsx", "target": "NativeScrollEvent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/date/date-picker-modal.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/date/date-picker-modal.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/date/date-picker-modal.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/date/date-picker-modal.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/epoch/wheel-date-picker.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/date/date-picker-modal.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/button/button.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/date/date-picker-modal.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/date/date-picker-modal.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/date/date-picker-modal.component.tsx", "target": "WmDatePickerModalProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/date/date-picker-modal.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/date/date-picker-modal.component.tsx", "target": "TouchableWithoutFeedback", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/date/date-picker-modal.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/date/date-picker-modal.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/date/date-picker-modal.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/date/date-picker-modal.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/time/time-picker-modal.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/time/time-picker-modal.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/time/time-picker-modal.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/epoch/wheel-time-picker.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/time/time-picker-modal.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/button/button.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/time/time-picker-modal.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/time/time-picker-modal.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/time/time-picker-modal.component.tsx", "target": "WmTimePickerModalProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/time/time-picker-modal.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/time/time-picker-modal.component.tsx", "target": "TouchableWithoutFeedback", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/time/time-picker-modal.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/time/time-picker-modal.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/time/time-picker-modal.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/time/time-picker-modal.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/time/time-picker-modal.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/styles/datetime-picker-modal.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.props.ts", "target": "@wavemaker/app-rn-runtime/components/input/basedataset/basedataset.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx", "target": "react-native-gesture-handler", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/label/label.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx", "target": "WmCheckboxsetProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx", "target": "TouchableOpacity", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx", "target": "ScrollView", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx", "target": "ScrollView", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/label/label.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.component.tsx", "target": "WmCheckboxProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.component.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.component.tsx", "target": "react-native-gesture-handler", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.component.tsx", "target": "@wavemaker/app-rn-runtime/styles/background.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/tooltip/tooltip.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/slider/slider.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/slider/slider.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/basedataset/basedataset.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.component.tsx", "target": "WmSliderProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.component.tsx", "target": "GestureDetector", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.component.tsx", "target": "GestureDetector", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.component.tsx", "target": "GestureDetector", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.props.ts", "target": "wavemaker-rn-runtime/src/components/basic/tooltip/tooltip.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.props.ts", "target": "wavemaker-rn-runtime/src/components/input/basedataset/basedataset.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.props.ts", "target": "string", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/slider/slider.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/baseinput/baseinput.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/baseinput/baseinput.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/baseinput/baseinput.component.ts", "target": "@wavemaker/app-rn-runtime/components/navigation/basenav/basenav.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/baseinput/baseinput.component.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/baseinput/baseinput.component.ts", "target": "wavemaker-rn-runtime/src/components/input/baseinput/baseinput.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/baseinput/baseinput.component.ts", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/baseinput/baseinput.component.ts", "target": "wavemaker-rn-runtime/src/components/input/baseinput/baseinput.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/baseinput/baseinput.component.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/baseinput/baseinput.component.ts", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/baseinput/baseinput.component.ts", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/baseinput/baseinput.component.ts", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/baseinput/baseinput.component.ts", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/baseinput/baseinput.component.ts", "target": "typeof", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/baseinput/baseinput.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/baseinput/baseinput.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/composite/composite.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/composite/composite.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/composite/composite.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/composite/composite.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/composite/composite.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/composite/composite.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/composite/composite.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/composite/composite.component.tsx", "target": "WmCompositeProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/composite/composite.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/composite/composite.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/composite/composite.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/composite/composite.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/number/number.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/number/number.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/number/number.styles.ts", "target": "WmNumberStyles", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/number/number.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/number/number.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/number/number.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/number/number.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/number/number.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/number/number.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/number/number.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/number/number.component.tsx", "target": "@wavemaker/app-rn-runtime/core/components/textinput.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/number/number.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/number/number.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/number/number.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/number/number.component.tsx", "target": "WmNumberProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/number/number.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/number/number.props.ts", "target": "@wavemaker/app-rn-runtime/components/input/basenumber/basenumber.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/toggle/toggle.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/toggle/toggle.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/toggle/toggle.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/toggle/toggle.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/toggle/toggle.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/toggle/toggle.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/toggle/toggle.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/toggle/toggle.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/toggle/toggle.component.tsx", "target": "@wavemaker/app-rn-runtime/styles/background.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/toggle/toggle.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/toggle/toggle.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/toggle/toggle.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/toggle/toggle.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/toggle/toggle.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/toggle/toggle.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/toggle/toggle.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/toggle/toggle.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/toggle/toggle.component.tsx", "target": "WmToggleProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/toggle/toggle.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/textarea/textarea.props.ts", "target": "@wavemaker/app-rn-runtime/components/input/baseinput/baseinput.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/textarea/textarea.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/textarea/textarea.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/textarea/textarea.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/textarea/textarea.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/textarea/textarea.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/textarea/textarea.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/textarea/textarea.component.tsx", "target": "@wavemaker/app-rn-runtime/core/components/textinput.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/textarea/textarea.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/textarea/textarea.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/textarea/textarea.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/textarea/textarea.component.tsx", "target": "WmTextareaProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/textarea/textarea.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/textarea/textarea.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/textarea/textarea.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme.variables", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/switch/switch.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/switch/switch.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/switch/switch.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/switch/switch.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/switch/switch.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/switch/switch.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/switch/switch.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/switch/switch.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/basedataset/basedataset.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/switch/switch.component.tsx", "target": "@wavemaker/app-rn-runtime/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/switch/switch.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/switch/switch.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/switch/switch.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/switch/switch.component.tsx", "target": "WmSwitchProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/switch/switch.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/switch/switch.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/switch/switch.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/switch/switch.props.ts", "target": "wavemaker-rn-runtime/src/components/input/basedataset/basedataset.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/switch/switch.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/switch/switch.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/switch/switch.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/switch/switch.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/switch/switch.styles.ts", "target": "WmSwitchStyles", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/text/text.props.ts", "target": "@wavemaker/app-rn-runtime/components/input/baseinput/baseinput.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/text/text.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/text/text.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/text/text.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/text/text.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/text/text.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/text/text.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/text/text.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/text/text.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/text/text.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/text/text.component.tsx", "target": "@wavemaker/app-rn-runtime/core/components/textinput.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/text/text.component.tsx", "target": "@wavemaker/app-rn-runtime/components/input/baseinput/baseinput.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/text/text.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/text/text.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/text/text.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/text/text.component.tsx", "target": "WmTextProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.props.ts", "target": "@wavemaker/app-rn-runtime/components/input/basedataset/basedataset.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "react-native-gesture-handler", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/select/select.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/select/select.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "@wavemaker/app-rn-runtime/core/modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "@wavemaker/app-rn-runtime/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme.variables", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "@wavemaker/app-rn-runtime/styles/background.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "wavemaker-rn-runtime/src/components/navigation/popover/popover.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "WmSelectProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "Tappable", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "ModalConsumer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "ScrollView", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/select/select.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/currency/currency.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/currency/currency.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/currency/currency.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/currency/currency.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/currency/currency.component.tsx", "target": "@wavemaker/app-rn-runtime/core/currency-constants", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/currency/currency.component.tsx", "target": "@wavemaker/app-rn-runtime/core/components/textinput.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/currency/currency.component.tsx", "target": "wavemaker-rn-runtime/src/components/input/currency/currency.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/currency/currency.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/currency/currency.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/currency/currency.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/currency/currency.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/currency/currency.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/currency/currency.component.tsx", "target": "WmCurrencyProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/currency/currency.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/currency/currency.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/currency/currency.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/currency/currency.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/input/currency/currency.props.ts", "target": "@wavemaker/app-rn-runtime/components/input/basenumber/basenumber.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/currency/currency.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/currency/currency.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/input/currency/currency.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/staticdata.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.styles.ts", "target": "color", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.styles.ts", "target": "victory-core", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "moment", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "victory-core", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "victory-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "@wavemaker/app-rn-runtime/components/chart/theme/chart.theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "wavemaker-rn-runtime/src/components/chart/basechart.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "wavemaker-rn-runtime/src/components/chart/basechart.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "wavemaker-rn-runtime/src/components/chart/staticdata", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/lottie/lottie.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "string", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "VictoryAxis", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "VictoryLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "VictoryLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "VictoryAxis", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "VictoryLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "VictoryLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx", "target": "WmLottie", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.props.ts", "target": "@wavemaker/app-rn-runtime/runtime/base-fragment.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/basechart.props.ts", "target": "string", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.styles.ts", "target": "wavemaker-rn-runtime/src/components/chart/basechart.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.props.ts", "target": "@wavemaker/app-rn-runtime/components/chart/basechart.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.component.tsx", "target": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.component.tsx", "target": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.component.tsx", "target": "victory-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.component.tsx", "target": "victory-core", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.component.tsx", "target": "react-native-svg", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.component.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.component.tsx", "target": "WmBubbleChartProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.component.tsx", "target": "Svg", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/legend/legend.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/legend/legend.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/legend/legend.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/legend/legend.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/legend/legend.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/legend/legend.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.component.tsx", "target": "react-native-svg", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.component.tsx", "target": "victory-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.component.tsx", "target": "victory-core", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.component.tsx", "target": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.component.tsx", "target": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.component.tsx", "target": "WmStackChartProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.component.tsx", "target": "VictoryBar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.component.tsx", "target": "VictoryPie", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.component.tsx", "target": "Svg", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.component.tsx", "target": "VictoryAxis", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.component.tsx", "target": "Svg", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.component.tsx", "target": "Svg", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.props.ts", "target": "@wavemaker/app-rn-runtime/components/chart/basechart.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.styles.ts", "target": "wavemaker-rn-runtime/src/components/chart/basechart.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "react-native-svg", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "victory-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "@wavemaker/app-rn-runtime/components/chart/donut-chart/donut-chart.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "wavemaker-rn-runtime/src/components/chart/legend/legend.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "WmPieChartProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "Legend", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "Legend", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx", "target": "Legend", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.props.ts", "target": "@wavemaker/app-rn-runtime/components/chart/basechart.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.props.ts", "target": "victory-pie", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.styles.ts", "target": "wavemaker-rn-runtime/src/components/chart/basechart.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.styles.ts", "target": "wavemaker-rn-runtime/src/components/chart/basechart.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.component.tsx", "target": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.component.tsx", "target": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.component.tsx", "target": "moment", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.component.tsx", "target": "WmBarChartProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.component.tsx", "target": "VictoryBar", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.component.tsx", "target": "VictoryChart", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.component.tsx", "target": "VictoryStack", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.component.tsx", "target": "VictoryGroup", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.props.ts", "target": "@wavemaker/app-rn-runtime/components/chart/basechart.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/column-chart/column-chart.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/column-chart/column-chart.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/column-chart/column-chart.styles.ts", "target": "wavemaker-rn-runtime/src/components/chart/basechart.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/column-chart/column-chart.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/column-chart/column-chart.props.ts", "target": "@wavemaker/app-rn-runtime/components/chart/bar-chart/bar-chart.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/column-chart/column-chart.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/column-chart/column-chart.component.tsx", "target": "wavemaker-rn-runtime/src/components/chart/column-chart/column-chart.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/theme/chart.theme.ts", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/theme/chart.theme.ts", "target": "victory-core", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/theme/chart.theme.ts", "target": "@wavemaker/app-rn-runtime/styles/theme.variables", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/theme/chart.theme.ts", "target": "string", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.props.ts", "target": "@wavemaker/app-rn-runtime/components/chart/basechart.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "color", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "react-native-svg", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "victory-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "victory-core", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme.variables", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "WmAreaChartProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "VictoryStack", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "VictoryGroup", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "Defs", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "LinearGradient", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "Stop", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx", "target": "Stop", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.styles.ts", "target": "wavemaker-rn-runtime/src/components/chart/basechart.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.component.tsx", "target": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.component.tsx", "target": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.component.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme.variables", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.component.tsx", "target": "victory-core", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.component.tsx", "target": "WmLineChartProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.component.tsx", "target": "VictoryGroup", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.component.tsx", "target": "VictoryLine", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.component.tsx", "target": "VictoryScatter", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.props.ts", "target": "@wavemaker/app-rn-runtime/components/chart/basechart.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.styles.ts", "target": "wavemaker-rn-runtime/src/components/chart/basechart.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/donut-chart/donut-chart.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/donut-chart/donut-chart.component.tsx", "target": "wavemaker-rn-runtime/src/components/chart/donut-chart/donut-chart.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/donut-chart/donut-chart.component.tsx", "target": "@wavemaker/app-rn-runtime/components/chart/pie-chart/pie-chart.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/donut-chart/donut-chart.props.ts", "target": "@wavemaker/app-rn-runtime/components/chart/pie-chart/pie-chart.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/donut-chart/donut-chart.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/donut-chart/donut-chart.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/donut-chart/donut-chart.styles.ts", "target": "wavemaker-rn-runtime/src/components/chart/basechart.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/chart/donut-chart/donut-chart.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/animatedview.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/animatedview.component.tsx", "target": "react-native-animatable", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/animatedview.component.tsx", "target": "react-native-animatable", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/animatedview.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/animatedview.component.tsx", "target": "AnimatedviewProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.styles.ts", "target": "color", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.component.tsx", "target": "react-native-circular-progress", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.component.tsx", "target": "@wavemaker/app-rn-runtime/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.component.tsx", "target": "WmProgressCircleProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.component.tsx", "target": "Tappable", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/video/video.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/video/video.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/video/video.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/video/video.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/video/video.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/video/video.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/picture/picture.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/video/video.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/video/video.styles.ts", "target": "WmVideoStyles", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/video/video.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/video/video.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/video/video.component.tsx", "target": "expo-video", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/video/video.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/video/video.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/video/video.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/video/video.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/video/video.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/video/video.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/video/video.component.tsx", "target": "WmVideoProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/video/video.component.tsx", "target": "TouchableWithoutFeedback", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/video/video.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/video/video.component.tsx", "target": "TouchableWithoutFeedback", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/video/video.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/tooltip/tooltip.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/tooltip/tooltip.props.ts", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/tooltip/tooltip.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/tooltip/tooltip.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/tooltip/tooltip.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/tooltip/tooltip.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/tooltip/tooltip.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/tooltip/tooltip.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/tooltip/tooltip.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/tooltip/tooltip.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/tooltip/tooltip.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/tooltip/tooltip.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/tooltip/tooltip.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/tooltip/tooltip.component.tsx", "target": "WmTooltipProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/tooltip/tooltip.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/buttongroup/buttongroup.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/buttongroup/buttongroup.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/buttongroup/buttongroup.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/buttongroup/buttongroup.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/button/button.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/buttongroup/buttongroup.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/buttongroup/buttongroup.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/buttongroup/buttongroup.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/buttongroup/buttongroup.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/buttongroup/buttongroup.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/buttongroup/buttongroup.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/buttongroup/buttongroup.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/buttongroup/buttongroup.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/buttongroup/buttongroup.component.tsx", "target": "WmButtongroupProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles.ts", "target": "WmSkeletonStyles", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.component.tsx", "target": "expo-linear-gradient", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.component.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.component.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.component.tsx", "target": "WmSkeletonProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.component.tsx", "target": "WmSkeleton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.component.tsx", "target": "react-native-paper", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.component.tsx", "target": "expo-linear-gradient", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.component.tsx", "target": "@wavemaker/app-rn-runtime/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.component.tsx", "target": "WmProgressBarProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.component.tsx", "target": "Tappable", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.styles.ts", "target": "color", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/picture/picture.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/picture/picture.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/picture/picture.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/picture/picture.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/picture/picture.component.tsx", "target": "expo-image", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/picture/picture.component.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/picture/picture.component.tsx", "target": "@wavemaker/app-rn-runtime/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/picture/picture.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/picture/picture.component.tsx", "target": "@wavemaker/app-rn-runtime/core/imageSizeEstimator", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/picture/picture.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/picture/picture.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/picture/picture.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/picture/picture.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/picture/picture.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/picture/picture.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/picture/picture.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/animatedview.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/picture/picture.component.tsx", "target": "WmPictureProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/picture/picture.component.tsx", "target": "WmPictureProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/picture/picture.component.tsx", "target": "SvgUri", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/picture/picture.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/picture/picture.component.tsx", "target": "Animatedview", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/picture/picture.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/picture/picture.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/picture/picture.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/picture/picture.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.component.tsx", "target": "@wavemaker/app-rn-runtime/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/label/label.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/label/label.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.component.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/animatedview.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.component.tsx", "target": "expo-linear-gradient", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.component.tsx", "target": "@react-native-masked-view/masked-view", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.component.tsx", "target": "WmLabelProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.component.tsx", "target": "NavigationServiceConsumer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.component.tsx", "target": "Tappable", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.component.tsx", "target": "LinearGradient", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.styles.ts", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/label/label.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/message/message.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/message/message.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/message/message.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/message/message.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/message/message.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/message/message.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/message/message.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/message/message.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/message/message.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/button/button.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/message/message.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/animatedview.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/message/message.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/message/message.component.tsx", "target": "WmMessageProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/message/message.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/message/message.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/message/message.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/message/message.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/message/message.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/message/message.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/message/message.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/message/message.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/message/message.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/spinner/spinner.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/spinner/spinner.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/spinner/spinner.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/picture/picture.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/spinner/spinner.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/spinner/spinner.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/spinner/spinner.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/spinner/spinner.component.tsx", "target": "color", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/spinner/spinner.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/spinner/spinner.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/spinner/spinner.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/spinner/spinner.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/spinner/spinner.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/spinner/spinner.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/spinner/spinner.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/picture/picture.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/spinner/spinner.component.tsx", "target": "lottie-react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/spinner/spinner.component.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme.variables", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/spinner/spinner.component.tsx", "target": "WmSpinnerProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/spinner/spinner.component.tsx", "target": "Lottie", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/spinner/spinner.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "react-native-gesture-handler", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/search/search.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/search/search.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "@wavemaker/app-rn-runtime/core/modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/search/local-data-provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/anchor/anchor.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/picture/picture.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "@wavemaker/app-rn-runtime/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "@wavemaker/app-rn-runtime/core/asset.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "WmSearchProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "typeof", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "void", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "TextInput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "WmButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "WmButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "Tappable", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "WmPicture", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "ModalConsumer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "ScrollView", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx", "target": "WmAnchor", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/local-data-provider.ts", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/local-data-provider.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/local-data-provider.ts", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.props.ts", "target": "@wavemaker/app-rn-runtime/components/input/basedataset/basedataset.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/search/search.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.styles.ts", "target": "wavemaker-rn-runtime/src/components/input/slider/slider.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.styles.ts", "target": "color", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.styles.ts", "target": "WmAudioStyles", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.component.tsx", "target": "@react-native-community/slider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.component.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.component.tsx", "target": "expo-av", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.component.tsx", "target": "expo-av/build/Audio", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/audio/audio.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/audio/audio.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.component.tsx", "target": "WmAudioProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/audio/audio.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/button/button.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/button/button.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/button/button.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/button/button.component.tsx", "target": "@wavemaker/app-rn-runtime/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/button/button.component.tsx", "target": "react-native-paper", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/button/button.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/button/button.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/button/button.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/button/button.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/button/button.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/button/button.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/animatedview.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/button/button.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/button/button.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/button/button.component.tsx", "target": "WmButtonProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/button/button.component.tsx", "target": "Badge", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/button/button.component.tsx", "target": "Animatedview", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/button/button.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/button/button.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/button/button.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/button/button.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/button/button.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/button/button.styles.ts", "target": "WmButtonStyles", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/lottie/lottie.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/lottie/lottie.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/lottie/lottie.styles.ts", "target": "WmLottieStyles", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/lottie/lottie.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/lottie/lottie.component.tsx", "target": "axios", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/lottie/lottie.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/lottie/lottie.component.tsx", "target": "lottie-react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/lottie/lottie.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/lottie/lottie.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/lottie/lottie.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/lottie/lottie.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/lottie/lottie.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/lottie/lottie.component.tsx", "target": "WmLottieProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/lottie/lottie.component.tsx", "target": "LottieView", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.component.tsx", "target": "react-native-paper", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.component.tsx", "target": "@wavemaker/app-rn-runtime/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/animatedview.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.component.tsx", "target": "WmAnchorProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.component.tsx", "target": "Badge", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.component.tsx", "target": "NavigationServiceConsumer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.component.tsx", "target": "Tappable", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.styles.ts", "target": "color", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/icon.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/icon.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/icon.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/icon.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/icon.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/icon.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/icon.component.tsx", "target": "@expo/vector-icons", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/icon.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/icon.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/icon.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/icon.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/icon/icon.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/icon.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/icon.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/icon/wavicon/wavicon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/icon.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/icon/streamline-light-icon/streamline-light-icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/icon.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/icon/streamline-regular-icon/streamline-regular-icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/icon.component.tsx", "target": "@wavemaker/app-rn-runtime/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/icon.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/animatedview.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/icon.component.tsx", "target": "WmIconProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/icon.component.tsx", "target": "Image", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/icon.component.tsx", "target": "FontAwesome", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/icon.component.tsx", "target": "WMCustomIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/icon.component.tsx", "target": "Animatedview", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/icon.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/wavicon/wavicon.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/icon/wavicon/wavicon.ttf", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/wavicon/wavicon.component.tsx", "target": "@expo/vector-icons/build/createIconSet", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/streamline-regular-icon/streamline-regular-icon.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/icon/streamline-regular-icon/streamline-regular-icon.ttf", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/streamline-regular-icon/streamline-regular-icon.component.tsx", "target": "@expo/vector-icons/build/createIconSet", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/streamline-light-icon/streamline-light-icon.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/icon/streamline-light-icon/streamline-light-icon.ttf", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/icon/streamline-light-icon/streamline-light-icon.component.tsx", "target": "@expo/vector-icons/build/createIconSet", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/modal/modal.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/modal/modal.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/modal/modal.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/modal/modal.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/modal/modal.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/modal/modal.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/modal/modal.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/modal/modal.component.tsx", "target": "WmModalProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/modal/modal.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/modal/modal.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/custom/custom.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/custom/custom.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/custom/custom.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/custom/custom.styles.ts", "target": "WmCustomStyles", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/basic/custom/custom.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/custom/custom.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/custom/custom.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/custom/custom.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/custom/custom.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/custom/custom.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/custom/custom.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/custom/custom.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/custom/custom.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/basic/custom/custom.component.tsx", "target": "WmCustomProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.component.tsx", "target": "@wavemaker/app-rn-runtime/components/navigation/navitem/navitem.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.component.tsx", "target": "@wavemaker/app-rn-runtime/components/navigation/basenav/basenav.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.component.tsx", "target": "@wavemaker/app-rn-runtime/components/navigation/basenav/basenav.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.component.tsx", "target": "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.component.tsx", "target": "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.component.tsx", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.component.tsx", "target": "WmNavbarProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.component.tsx", "target": "WmNavItem", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.props.ts", "target": "@wavemaker/app-rn-runtime/components/navigation/basenav/basenav.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.props.ts", "target": "@wavemaker/app-rn-runtime/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/basenav/basenav.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/basenav/basenav.component.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/basenav/basenav.component.ts", "target": "wavemaker-rn-runtime/src/components/navigation/basenav/basenav.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/basenav/basenav.component.ts", "target": "wavemaker-rn-runtime/src/components/navigation/basenav/basenav.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/basenav/basenav.component.ts", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/basenav/basenav.component.ts", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/basenav/basenav.component.ts", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/basenav/basenav.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/basenav/basenav.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/anchor/anchor.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.styles.ts", "target": "@wavemaker/app-rn-runtime/components/container/container.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.component.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.component.tsx", "target": "@wavemaker/app-rn-runtime/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.component.tsx", "target": "@wavemaker/app-rn-runtime/core/modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/anchor/anchor.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.component.tsx", "target": "wavemaker-rn-runtime/src/components/navigation/popover/popover.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.component.tsx", "target": "wavemaker-rn-runtime/src/components/navigation/popover/popover.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/container.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.component.tsx", "target": "react-native-gesture-handler", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.component.tsx", "target": "WmPopoverProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.component.tsx", "target": "ScrollView", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.component.tsx", "target": "ModalConsumer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.component.tsx", "target": "GestureHandlerRootView", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.props.ts", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/popover/popover.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/menu/menu.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/menu/menu.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/menu/menu.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/anchor/anchor.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/menu/menu.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/menu/menu.component.tsx", "target": "wavemaker-rn-runtime/src/components/navigation/basenav/basenav.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/menu/menu.component.tsx", "target": "wavemaker-rn-runtime/src/components/navigation/popover/popover.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/menu/menu.component.tsx", "target": "wavemaker-rn-runtime/src/components/navigation/menu/menu.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/menu/menu.component.tsx", "target": "wavemaker-rn-runtime/src/components/navigation/menu/menu.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/menu/menu.component.tsx", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/menu/menu.component.tsx", "target": "WmMenuProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/menu/menu.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/menu/menu.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/menu/menu.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/anchor/anchor.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/menu/menu.styles.ts", "target": "wavemaker-rn-runtime/src/components/navigation/popover/popover.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/menu/menu.styles.ts", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/menu/menu.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/menu/menu.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/menu/menu.props.ts", "target": "@wavemaker/app-rn-runtime/components/navigation/basenav/basenav.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "react-native-paper", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/picture/picture.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "@wavemaker/app-rn-runtime/core/sticky-container.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "react-native-safe-area-context", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "@wavemaker/app-rn-runtime/core/AppConfig", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "@wavemaker/app-rn-runtime/core/fixed-view.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "WmAppNavbarProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "AppConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "number", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "Badge", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.styles.ts", "target": "color", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.styles.ts", "target": "@wavemaker/app-rn-runtime/components/navigation/menu/menu.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/anchor/anchor.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.styles.ts", "target": "@wavemaker/app-rn-runtime/components/navigation/popover/popover.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/picture/picture.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.props.ts", "target": "@wavemaker/app-rn-runtime/components/navigation/basenav/basenav.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.props.ts", "target": "@wavemaker/app-rn-runtime/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/anchor/anchor.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.component.tsx", "target": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.component.tsx", "target": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.component.tsx", "target": "@wavemaker/app-rn-runtime/components/navigation/basenav/basenav.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.component.tsx", "target": "@wavemaker/app-rn-runtime/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.component.tsx", "target": "WmNavItemProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.component.tsx", "target": "WmAnchor", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/anchor/anchor.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/container.props.ts", "target": "wavemaker-rn-runtime/src/components/container/partial-host.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/container.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/container.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/container.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/container.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/container.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/container.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/container.component.tsx", "target": "@wavemaker/app-rn-runtime/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/container.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/animatedview.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/container.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/partial-host.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/container.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/container.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/container.component.tsx", "target": "react-native-gesture-handler", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/container.component.tsx", "target": "@wavemaker/app-rn-runtime/core/sticky-container.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/container.component.tsx", "target": "WmContainerProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/container.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/container.component.tsx", "target": "Tappable", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/container.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/container.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/container.component.tsx", "target": "Tappable", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/container.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/container.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/container.component.tsx", "target": "ScrollView", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/partial-host.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/partial-host.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/partial-host.component.tsx", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/partial-host.component.tsx", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/container.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/container.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabs.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabs.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabs.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabs.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabs.component.tsx", "target": "@wavemaker/app-rn-runtime/gestures/swipe.animation", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabs.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabs.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/tabs/tabs.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabs.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/tabs/tabs.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabs.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/tabs/tabpane/tabpane.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabs.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabs.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabs.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabs.component.tsx", "target": "WmTabsProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabs.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabs.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabs.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabs.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabs.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabs.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabs.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabs.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabs.styles.ts", "target": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabs.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabpane/tabpane.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabpane/tabpane.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabpane/tabpane.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabpane/tabpane.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabpane/tabpane.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabpane/tabpane.component.tsx", "target": "react-native-gesture-handler", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabpane/tabpane.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabpane/tabpane.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/tabs/tabpane/tabpane.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabpane/tabpane.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/tabs/tabpane/tabpane.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabpane/tabpane.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/tabs/tabs.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabpane/tabpane.component.tsx", "target": "WmTabpaneProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.component.tsx", "target": "@wavemaker/app-rn-runtime/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.component.tsx", "target": "@wavemaker/app-rn-runtime/styles/background.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.component.tsx", "target": "WmTabheaderProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.component.tsx", "target": "Tappable", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.component.tsx", "target": "Tappable", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/layoutgrid.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/layoutgrid.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/layoutgrid.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/label/label.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/layoutgrid.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/layoutgrid.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/layoutgrid.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/layoutgrid.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/layoutgrid.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/layoutgrid.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/layoutgrid/layoutgrid.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/layoutgrid.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/layoutgrid/layoutgrid.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/layoutgrid.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/layoutgrid.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/layoutgrid.component.tsx", "target": "WmLayoutgridProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/layoutgrid.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridcolumn/gridcolumn.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridcolumn/gridcolumn.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridcolumn/gridcolumn.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridcolumn/gridcolumn.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridcolumn/gridcolumn.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridcolumn/gridcolumn.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridcolumn/gridcolumn.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridcolumn/gridcolumn.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridcolumn/gridcolumn.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridcolumn/gridcolumn.component.tsx", "target": "WmGridcolumnProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridcolumn/gridcolumn.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridrow/gridrow.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridrow/gridrow.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridrow/gridrow.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridrow/gridrow.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridrow/gridrow.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridrow/gridrow.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridrow/gridrow.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridrow/gridrow.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridrow/gridrow.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridrow/gridrow.component.tsx", "target": "WmGridrowProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridrow/gridrow.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridrow/gridrow.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/layoutgrid/gridrow/gridrow.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/collapsible-pane.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/collapsible-pane.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/collapsible-pane.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "react-native-paper", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/panel/panel.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/panel/panel.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/panel/collapsible-pane.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/label/label.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "WmPanelProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "Badge", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "CollapsiblePane", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel-content/panel-content.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel-content/panel-content.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel-content/panel-content.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel-content/panel-content.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/panel/panel-content/panel-content.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel-content/panel-content.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/panel/panel-content/panel-content.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel-content/panel-content.component.tsx", "target": "WmPanelContentProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel-content/panel-content.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel-content/panel-content.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel-content/panel-content.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel-content/panel-content.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel-footer/panel-footer.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel-footer/panel-footer.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel-footer/panel-footer.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel-footer/panel-footer.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel-footer/panel-footer.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel-footer/panel-footer.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/panel/panel-footer/panel-footer.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel-footer/panel-footer.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/panel/panel-footer/panel-footer.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel-footer/panel-footer.component.tsx", "target": "WmPanelFooterProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel-footer/panel-footer.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/panel/panel-footer/panel-footer.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx", "target": "react-native-paper", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/accordion/accordion.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/accordion/accordion.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/accordion/accordionpane/accordionpane.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/label/label.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx", "target": "WmAccordionProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx", "target": "Badge", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx", "target": "TouchableOpacity", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.styles.ts", "target": "color", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordion.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordionpane/accordionpane.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordionpane/accordionpane.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/accordion/accordionpane/accordionpane.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordionpane/accordionpane.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/accordion/accordionpane/accordionpane.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordionpane/accordionpane.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/accordion/accordion.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordionpane/accordionpane.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordionpane/accordionpane.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordionpane/accordionpane.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/panel/collapsible-pane.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordionpane/accordionpane.component.tsx", "target": "WmAccordionpaneProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordionpane/accordionpane.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordionpane/accordionpane.component.tsx", "target": "CollapsiblePane", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordionpane/accordionpane.styles.ts", "target": "color", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordionpane/accordionpane.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordionpane/accordionpane.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/accordion/accordionpane/accordionpane.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/anchor/anchor.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/progress-circle/progress-circle.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.styles.ts", "target": "@wavemaker/app-rn-runtime/components/navigation/popover/popover.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/label/label.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/wizard/wizard.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/wizard/wizard.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/anchor/anchor.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/wizard/wizardstep/wizardstep.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/progress-circle/progress-circle.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "@wavemaker/app-rn-runtime/components/navigation/popover/popover.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/label/label.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "WmWizardProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "WmWizardProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "TouchableWithoutFeedback", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "WmProgressCircle", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "WmButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "WmButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "WmButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "WmButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx", "target": "WmAnchor", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizard.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizardstep/wizardstep.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizardstep/wizardstep.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizardstep/wizardstep.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizardstep/wizardstep.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizardstep/wizardstep.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizardstep/wizardstep.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizardstep/wizardstep.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/wizard/wizardstep/wizardstep.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizardstep/wizardstep.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/wizard/wizardstep/wizardstep.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizardstep/wizardstep.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/wizard/wizard.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizardstep/wizardstep.component.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/wizard/wizardstep/wizardstep.component.tsx", "target": "WmWizardstepProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/tile/tile.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tile/tile.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tile/tile.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tile/tile.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tile/tile.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tile/tile.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tile/tile.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tile/tile.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/tile/tile.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tile/tile.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/tile/tile.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tile/tile.component.tsx", "target": "@wavemaker/app-rn-runtime/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tile/tile.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/animatedview.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tile/tile.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tile/tile.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/tile/tile.component.tsx", "target": "WmTileProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/tile/tile.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/tile/tile.component.tsx", "target": "Animatedview", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayout.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayout.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayout.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayout.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayout.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayout.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayout.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayout.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayout.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayout.component.tsx", "target": "WmLinearlayoutProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayout.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayout.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayout.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayout.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayout.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayoutitem/linearlayoutitem.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayoutitem/linearlayoutitem.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayoutitem/linearlayoutitem.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayoutitem/linearlayoutitem.component.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayoutitem/linearlayoutitem.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayoutitem/linearlayoutitem.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayout.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayoutitem/linearlayoutitem.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayoutitem/linearlayoutitem.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayoutitem/linearlayoutitem.component.tsx", "target": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayoutitem/linearlayoutitem.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayoutitem/linearlayoutitem.component.tsx", "target": "WmLinearlayoutitemProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayoutitem/linearlayoutitem.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayoutitem/linearlayoutitem.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/prefab/prefab-container.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/prefab/prefab-container.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/prefab/prefab-container.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/prefab/prefab-container.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/prefab/prefab-container.props.ts", "target": "@wavemaker/app-rn-runtime/runtime/base-fragment.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/prefab/prefab-container.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/prefab/prefab-container.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/prefab/prefab-container.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/prefab/prefab-container.component.tsx", "target": "wavemaker-rn-runtime/src/components/prefab/prefab-container.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/prefab/prefab-container.component.tsx", "target": "wavemaker-rn-runtime/src/components/prefab/prefab-container.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/prefab/prefab-container.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/lottie/lottie.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/prefab/prefab-container.component.tsx", "target": "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/prefab/prefab-container.component.tsx", "target": "WmPrefabContainerProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/prefab/prefab-container.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/prefab/prefab-container.component.tsx", "target": "WmLottie", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/prefab/prefab-container.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialogactions/dialogactions.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialogactions/dialogactions.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialogactions/dialogactions.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialogactions/dialogactions.component.tsx", "target": "wavemaker-rn-runtime/src/components/dialogs/dialogactions/dialogactions.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialogactions/dialogactions.component.tsx", "target": "wavemaker-rn-runtime/src/components/dialogs/dialogactions/dialogactions.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialogactions/dialogactions.component.tsx", "target": "WmDialogactionsProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialogactions/dialogactions.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialogactions/dialogactions.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialogactions/dialogactions.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.styles.ts", "target": "WmDialogStyles", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.component.tsx", "target": "@wavemaker/app-rn-runtime/core/modal.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.component.tsx", "target": "@wavemaker/app-rn-runtime/core/asset.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.component.tsx", "target": "@wavemaker/app-rn-runtime/core/if.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.component.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.component.tsx", "target": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.component.tsx", "target": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.component.tsx", "target": "WmDialogProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.component.tsx", "target": "void", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.component.tsx", "target": "ModalConsumer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.component.tsx", "target": "AssetProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.component.tsx", "target": "ThemeProvider", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.component.tsx", "target": "WmButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.styles.ts", "target": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.styles.ts", "target": "wavemaker-rn-runtime/src/components/dialogs/dialogcontent/dialogcontent.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.styles.ts", "target": "wavemaker-rn-runtime/src/components/dialogs/dialogactions/dialogactions.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/label/label.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/label/label.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.component.tsx", "target": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.component.tsx", "target": "wavemaker-rn-runtime/src/components/dialogs/dialogcontent/dialogcontent.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.component.tsx", "target": "wavemaker-rn-runtime/src/components/dialogs/dialogactions/dialogactions.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.component.tsx", "target": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.component.tsx", "target": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.component.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.component.tsx", "target": "WmConfirmdialogProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.component.tsx", "target": "WmDialogcontent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.component.tsx", "target": "WmDialogactions", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialogcontent/dialogcontent.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialogcontent/dialogcontent.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialogcontent/dialogcontent.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialogcontent/dialogcontent.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialogcontent/dialogcontent.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialogcontent/dialogcontent.component.tsx", "target": "react-native-gesture-handler", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialogcontent/dialogcontent.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialogcontent/dialogcontent.component.tsx", "target": "wavemaker-rn-runtime/src/components/dialogs/dialogcontent/dialogcontent.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialogcontent/dialogcontent.component.tsx", "target": "wavemaker-rn-runtime/src/components/dialogs/dialogcontent/dialogcontent.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/dialogcontent/dialogcontent.component.tsx", "target": "WmDialogcontentProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.styles.ts", "target": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.styles.ts", "target": "wavemaker-rn-runtime/src/components/dialogs/dialogcontent/dialogcontent.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.styles.ts", "target": "wavemaker-rn-runtime/src/components/dialogs/dialogactions/dialogactions.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.styles.ts", "target": "wavemaker-rn-runtime/src/components/basic/label/label.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/label/label.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.component.tsx", "target": "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.component.tsx", "target": "wavemaker-rn-runtime/src/components/dialogs/dialogcontent/dialogcontent.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.component.tsx", "target": "wavemaker-rn-runtime/src/components/dialogs/dialogactions/dialogactions.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.component.tsx", "target": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.component.tsx", "target": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.component.tsx", "target": "WmAlertdialogProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.component.tsx", "target": "WmDialogcontent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.component.tsx", "target": "WmDialogactions", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/device/camera/camera.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/camera/camera.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/camera/camera.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/camera/camera.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/camera/camera.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/camera/camera.component.tsx", "target": "wavemaker-rn-runtime/src/components/device/camera/camera.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/camera/camera.component.tsx", "target": "wavemaker-rn-runtime/src/components/device/camera/camera.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/camera/camera.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/camera/camera.component.tsx", "target": "@wavemaker/app-rn-runtime/variables/device/camera/capture-image.operation", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/camera/camera.component.tsx", "target": "@wavemaker/app-rn-runtime/core/device/camera-service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/camera/camera.component.tsx", "target": "@wavemaker/app-rn-runtime/variables/device/camera/capture-video.operation", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/camera/camera.component.tsx", "target": "@wavemaker/app-rn-runtime/core/accessibility", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/camera/camera.component.tsx", "target": "WmCameraProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/device/camera/camera.component.tsx", "target": "CameraConsumer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/device/camera/camera.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/device/camera/camera.component.tsx", "target": "WmButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/device/camera/camera.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/camera/camera.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/camera/camera.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.component.tsx", "target": "@wavemaker/app-rn-runtime/variables/device/scan/scan.operation", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.component.tsx", "target": "@wavemaker/app-rn-runtime/core/device/scan-service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.component.tsx", "target": "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.component.tsx", "target": "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.component.tsx", "target": "WmBarcodescannerProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.component.tsx", "target": "ScanConsumer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.component.tsx", "target": "WmButton", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.props.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/label/label.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/message/message.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "@wavemaker/app-rn-runtime/core/toast.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/form/form.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/form/form.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "WmFormProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "WmFormField", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "WmFormAction", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "WmFormAction", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "WmFormField", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "WmFormAction", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "WmFormField", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "ToastConsumer", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.component.tsx", "target": "WmMessage", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/label/label.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme.variables", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-footer/form-footer.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-footer/form-footer.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-footer/form-footer.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-footer/form-footer.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/form/form-footer/form-footer.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-footer/form-footer.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/form/form-footer/form-footer.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-footer/form-footer.component.tsx", "target": "WmFormFooterProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-footer/form-footer.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-footer/form-footer.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-footer/form-footer.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-body/form-body.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-body/form-body.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-body/form-body.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-body/form-body.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/form/form-body/form-body.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-body/form-body.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/form/form-body/form-body.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-body/form-body.component.tsx", "target": "WmFormBodyProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-body/form-body.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-body/form-body.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-body/form-body.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-field/form-field.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-field/form-field.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-field/form-field.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-field/form-field.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-field/form-field.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-field/form-field.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/form/form-field/form-field.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-field/form-field.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/form/form-field/form-field.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-field/form-field.component.tsx", "target": "@wavemaker/app-rn-runtime/core/logger", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-field/form-field.component.tsx", "target": "WmFormFieldProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-field/form-field.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-field/form-field.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-field/form-field.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-field/form-field.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-field/form-field.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-action/form-action.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-action/form-action.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-action/form-action.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-action/form-action.component.tsx", "target": "@wavemaker/app-rn-runtime/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-action/form-action.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/form/form-action/form-action.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-action/form-action.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/form/form-action/form-action.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-action/form-action.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-action/form-action.component.tsx", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-action/form-action.component.tsx", "target": "WmFormActionProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-action/form-action.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-action/form-action.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-action/form-action.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-action/form-action.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/form/form-action/form-action.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/label/label.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.component.tsx", "target": "@wavemaker/app-rn-runtime/components/navigation/menu/menu.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.component.tsx", "target": "@wavemaker/app-rn-runtime/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/picture/picture.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/card/card.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/card/card.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.component.tsx", "target": "WmCardProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.component.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.component.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.component.tsx", "target": "Tappable", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/picture/picture.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/label/label.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card-footer/card-footer.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card-footer/card-footer.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card-footer/card-footer.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card-footer/card-footer.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/card/card-footer/card-footer.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card-footer/card-footer.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/card/card-footer/card-footer.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card-footer/card-footer.component.tsx", "target": "WmCardFooterProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card-footer/card-footer.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card-footer/card-footer.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card-footer/card-footer.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card-content/card-content.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card-content/card-content.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card-content/card-content.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card-content/card-content.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card-content/card-content.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/card/card-content/card-content.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card-content/card-content.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/card/card-content/card-content.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card-content/card-content.component.tsx", "target": "WmCardContentProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card-content/card-content.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card-content/card-content.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/card/card-content/card-content.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.styles.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/label/label.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "@wavemaker/app-rn-runtime/core/tappable.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "@wavemaker/app-rn-runtime/core/key.extractor", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/label/label.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/icon/icon.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "react-native-gesture-handler", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/list/list-action-template/list-action-template.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/list/list.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/list/list.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "@wavemaker/app-rn-runtime/styles/background.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "WmListProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "Text", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "WmIcon", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "ActivityIndicator", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.component.tsx", "target": "WmLabel", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.props.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.props.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.props.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.props.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list.props.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-template/list-template.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-template/list-template.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-template/list-template.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-template/list-template.styles.ts", "target": "WmListTemplateStyles", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-template/list-template.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-template/list-template.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-template/list-template.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-template/list-template.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-template/list-template.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/list/list-template/list-template.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-template/list-template.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/list/list-template/list-template.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-template/list-template.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/list/list.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-template/list-template.component.tsx", "target": "@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-template/list-template.component.tsx", "target": "WmListTemplateProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-template/list-template.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-template/list-template.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-action-template/list-action-template.component.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-action-template/list-action-template.component.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-action-template/list-action-template.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-action-template/list-action-template.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/list/list-action-template/list-action-template.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-action-template/list-action-template.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/list/list-action-template/list-action-template.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-action-template/list-action-template.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/list/list.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-action-template/list-action-template.component.tsx", "target": "WmListActionTemplateProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-action-template/list-action-template.component.tsx", "target": "View", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-action-template/list-action-template.props.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-action-template/list-action-template.styles.ts", "target": "@wavemaker/app-rn-runtime/styles/theme", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-action-template/list-action-template.styles.ts", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-action-template/list-action-template.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/button/button.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-action-template/list-action-template.styles.ts", "target": "@wavemaker/app-rn-runtime/components/basic/anchor/anchor.styles", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/list/list-action-template/list-action-template.styles.ts", "target": "WmListActionTemplateStyles", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/components/data/liveform/liveform.component.tsx", "target": "@wavemaker/app-rn-runtime/core/base.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/liveform/liveform.component.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/liveform/liveform.component.tsx", "target": "wavemaker-rn-runtime/src/components/data/form/form.props", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/liveform/liveform.component.tsx", "target": "@wavemaker/app-rn-runtime/components/data/form/form.component", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/components/data/liveform/liveform.component.tsx", "target": "WmFormProps", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/device-variable.ts", "target": "@wavemaker/app-rn-runtime/variables/base-variable", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device-variable.ts", "target": "DeviceVariableConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/device-variable.ts", "target": "DeviceVariable", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/model-variable.ts", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/model-variable.ts", "target": "wavemaker-rn-runtime/src/variables/base-variable", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/model-variable.ts", "target": "@wavemaker/variables/src/model/variable/model-variable", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/http.service.ts", "target": "axios", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/http.service.ts", "target": "@wavemaker/variables/src/types/http-client.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/http.service.ts", "target": "@wavemaker/app-rn-runtime/variables/utils/variable.constants", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/http.service.ts", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/http.service.ts", "target": "@wavemaker/app-rn-runtime/core/AppConfig", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/http.service.ts", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/http.service.ts", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/http.service.ts", "target": "AppConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/service-variable.ts", "target": "wavemaker-rn-runtime/src/variables/base-variable", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/service-variable.ts", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/service-variable.ts", "target": "@wavemaker/app-rn-runtime/core/AppConfig", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/service-variable.ts", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/service-variable.ts", "target": "@wavemaker/variables/src/model/variable/service-variable", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/service-variable.ts", "target": "@wavemaker/app-rn-runtime/variables/http.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/service-variable.ts", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/service-variable.ts", "target": "AppConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/base-variable.ts", "target": "wavemaker-rn-runtime/src/variables/utils/dataset-util", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/base-variable.ts", "target": "@wavemaker/app-rn-runtime/core/event-notifier", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/base-variable.ts", "target": "@wavemaker/app-rn-runtime/core/logger", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/base-variable.ts", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/base-variable.ts", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/base-variable.ts", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/base-variable.ts", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/base-variable.ts", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/live-variable.ts", "target": "wavemaker-rn-runtime/src/variables/base-variable", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/live-variable.ts", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/live-variable.ts", "target": "@wavemaker/app-rn-runtime/core/AppConfig", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/live-variable.ts", "target": "@wavemaker/variables/src/model/variable/live-variable", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/live-variable.ts", "target": "@wavemaker/app-rn-runtime/variables/http.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/live-variable.ts", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/live-variable.ts", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/live-variable.ts", "target": "@wavemaker/app-rn-runtime/core/formatters", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/live-variable.ts", "target": "AppConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/utils/dataset-util.ts", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/utils/inflight-queue.ts", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/utils/variable.utils.ts", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/operation.provider.ts", "target": "wavemaker-rn-runtime/src/variables/device-variable", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/operation.provider.ts", "target": "Output", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/device/calendar/delete-event.operation.tsx", "target": "wavemaker-rn-runtime/src/variables/device/operation.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/calendar/delete-event.operation.tsx", "target": "@wavemaker/app-rn-runtime/core/device/calendar-service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/calendar/delete-event.operation.tsx", "target": "DeleteEventOutput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/device/calendar/create-event.operation.tsx", "target": "wavemaker-rn-runtime/src/variables/device/operation.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/calendar/create-event.operation.tsx", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/calendar/create-event.operation.tsx", "target": "moment", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/calendar/create-event.operation.tsx", "target": "@wavemaker/app-rn-runtime/core/device/calendar-service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/calendar/create-event.operation.tsx", "target": "CreateEventOutput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/device/calendar/get-events.operation.tsx", "target": "wavemaker-rn-runtime/src/variables/device/operation.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/calendar/get-events.operation.tsx", "target": "@wavemaker/app-rn-runtime/core/device/calendar-service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/calendar/get-events.operation.tsx", "target": "CalendarEvent", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/device/file/upload-file.operation.tsx", "target": "axios", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/file/upload-file.operation.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/file/upload-file.operation.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/file/upload-file.operation.tsx", "target": "expo-document-picker", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/file/upload-file.operation.tsx", "target": "@wavemaker/app-rn-runtime/variables/device/operation.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/file/upload-file.operation.tsx", "target": "@wavemaker/app-rn-runtime/core/file-extension-types", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/file/upload-file.operation.tsx", "target": "UploadFileOutput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/device/camera/capture-image.operation.tsx", "target": "@wavemaker/app-rn-runtime/core/device/camera-service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/camera/capture-image.operation.tsx", "target": "wavemaker-rn-runtime/src/variables/device/operation.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/camera/capture-image.operation.tsx", "target": "CaptureImageOutput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/device/camera/capture-video.operation.tsx", "target": "@wavemaker/app-rn-runtime/core/device/camera-service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/camera/capture-video.operation.tsx", "target": "wavemaker-rn-runtime/src/variables/device/operation.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/camera/capture-video.operation.tsx", "target": "CaptureVideoOutput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/device/contacts/get-contacts.operation.ts", "target": "wavemaker-rn-runtime/src/variables/device/operation.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/contacts/get-contacts.operation.ts", "target": "@wavemaker/app-rn-runtime/core/device/contacts-service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/contacts/get-contacts.operation.ts", "target": "PhoneNumber", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/device/contacts/get-contacts.operation.ts", "target": "ContactsOutput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/device/scan/scan.operation.tsx", "target": "@wavemaker/app-rn-runtime/core/device/scan-service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/scan/scan.operation.tsx", "target": "wavemaker-rn-runtime/src/variables/device/operation.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/scan/scan.operation.tsx", "target": "ScanOutput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/device/device/current-geo-position.operation.ts", "target": "@wavemaker/app-rn-runtime/variables/device/operation.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/device/current-geo-position.operation.ts", "target": "@wavemaker/app-rn-runtime/core/device/location-service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/device/current-geo-position.operation.ts", "target": "GeoPositionOutput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/device/device/vibrate.operation.ts", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/device/vibrate.operation.ts", "target": "@wavemaker/app-rn-runtime/variables/device/operation.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/device/vibrate.operation.ts", "target": "Output", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/device/device/network-info.operation.ts", "target": "expo-network", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/device/network-info.operation.ts", "target": "@wavemaker/app-rn-runtime/variables/device/operation.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/device/network-info.operation.ts", "target": "@wavemaker/app-rn-runtime/core/network.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/device/network-info.operation.ts", "target": "wavemaker-rn-runtime/src/variables/device-variable", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/device/network-info.operation.ts", "target": "NetworkInfoOutput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/device/device/app-info.operation.ts", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/device/app-info.operation.ts", "target": "@wavemaker/app-rn-runtime/variables/device/operation.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/device/app-info.operation.ts", "target": "AppInfoOutput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/variables/device/device/device-info.operation.ts", "target": "expo-device", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/device/device-info.operation.ts", "target": "@wavemaker/app-rn-runtime/variables/device/operation.provider", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/variables/device/device/device-info.operation.ts", "target": "DeviceInfoOutput", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/gestures/swipe.animation.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/gestures/swipe.animation.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/gestures/swipe.animation.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/gestures/swipe.animation.tsx", "target": "react-native-gesture-handler", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/gestures/swipe.animation.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/gestures/swipe.animation.tsx", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/gestures/swipe.animation.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/gestures/swipe.animation.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/gestures/swipe.animation.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/gestures/swipe.animation.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/gestures/swipe.animation.tsx", "target": "GestureDetector", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/gestures/carousel-swipe.animation.tsx", "target": "lodash-es", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/gestures/carousel-swipe.animation.tsx", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/gestures/carousel-swipe.animation.tsx", "target": "react-native", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/gestures/carousel-swipe.animation.tsx", "target": "react-native-gesture-handler", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/gestures/carousel-swipe.animation.tsx", "target": "@wavemaker/app-rn-runtime/core/utils", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/gestures/carousel-swipe.animation.tsx", "target": "@wavemaker/app-rn-runtime/core/injector", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/gestures/carousel-swipe.animation.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/gestures/carousel-swipe.animation.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/gestures/carousel-swipe.animation.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/gestures/carousel-swipe.animation.tsx", "target": "any", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/gestures/carousel-swipe.animation.tsx", "target": "RNView", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/actions/timer-action.ts", "target": "wavemaker-rn-runtime/src/actions/base-action", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/actions/timer-action.ts", "target": "TimerActionConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/actions/login-action.ts", "target": "wavemaker-rn-runtime/src/actions/base-action", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/actions/login-action.ts", "target": "wavemaker-rn-runtime/src/variables/base-variable", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/actions/login-action.ts", "target": "@wavemaker/app-rn-runtime/core/security.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/actions/login-action.ts", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/actions/login-action.ts", "target": "LoginActionConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/actions/base-action.ts", "target": "@wavemaker/app-rn-runtime/variables/base-variable", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/actions/base-action.ts", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/actions/base-action.ts", "target": "T", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/actions/logout-action.ts", "target": "wavemaker-rn-runtime/src/actions/base-action", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/actions/logout-action.ts", "target": "@wavemaker/app-rn-runtime/core/security.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/actions/logout-action.ts", "target": "wavemaker-rn-runtime/src/variables/base-variable", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/actions/logout-action.ts", "target": "LogoutActionConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/actions/notification-action.ts", "target": "wavemaker-rn-runtime/src/actions/base-action", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/actions/notification-action.ts", "target": "@wavemaker/app-rn-runtime/core/toast.service", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/actions/notification-action.ts", "target": "react", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/actions/notification-action.ts", "target": "NotificationActionConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/actions/navigation-action.ts", "target": "@wavemaker/app-rn-runtime/core/AppConfig", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/actions/navigation-action.ts", "target": "@wavemaker/app-rn-runtime/variables/base-variable", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/actions/navigation-action.ts", "target": "wavemaker-rn-runtime/src/actions/base-action", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/actions/navigation-action.ts", "target": "lodash", "type": "imports"}, {"source": "wavemaker-rn-runtime/src/actions/navigation-action.ts", "target": "NavigationActionConfig", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/actions/navigation-action.ts", "target": "NavigationAction", "type": "uses_component"}, {"source": "wavemaker-rn-runtime/src/actions/navigation-action.ts", "target": "NavigationAction", "type": "uses_component"}], "file_contents": {"wavemaker-rn-runtime/babel.config.js": "module.exports = function (api) {\n  api.cache(true);\n  return {\n    presets: [\n      'module:metro-react-native-babel-preset', //default present of react-native projects\n      'babel-preset-expo', // for expo projects\n      '@babel/preset-typescript', // for typescript support\n    ],\n    plugins: ['@babel/plugin-transform-class-static-block'],\n  };\n};\n", "wavemaker-rn-runtime/test/jest.setup.js": "/*import 'react-native-gesture-handler/jestSetup';\n\nimport { configure } from 'enzyme';\nimport Adapter from 'enzyme-adapter-react-16';\n\n\nconfigure({ adapter: new Adapter() });*/\n\n/*jest.mock('react-native-reanimated', () => {\n  const Reanimated = require('react-native-reanimated/mock');\n\n  // The mock for `call` immediately calls the callback which is incorrect\n  // So we override it with a no-op\n  Reanimated.default.call = () => {};\n\n  return Reanimated;\n});*/ //\n\n// Silence the warning: Animated: `useNativeDriver` is not supported because the native animated module is missing\n/*jest.mock('react-native/Libraries/Animated/src/NativeAnimatedHelper');\n\njest.mock('react-native-gesture-handler', () => {});*/\n\n//import '@testing-library/react-native/extend-expect';\n//import 'react-native-gesture-handler/jestSetup';\n\nimport * as AccessibilityConfig from '../src/core/accessibility';\n\njest.mock('@react-native-async-storage/async-storage', () =>\n  require('@react-native-async-storage/async-storage/jest/async-storage-mock')\n);\n\njest.mock(\n  'react-native/Libraries/Components/AccessibilityInfo/AccessibilityInfo',\n  () => {\n    const originalModule = jest.requireActual(\n      'react-native/Libraries/Components/AccessibilityInfo/AccessibilityInfo'\n    );\n    return {\n      _esModule: true,\n      default: {\n        ...originalModule,\n        addEventListener: jest.fn().mockReturnValue({ remove: null }),\n        isScreenReaderEnabled: jest.fn(() => Promise.resolve(true)),\n      },\n    };\n  }\n);\n\njest.mock('@expo/vector-icons', () => {\n  const { View, Text } = require('react-native');\n  return {\n    FontAwesome: jest.fn().mockImplementation(({ name, ...props }) => {\n      return (\n        <View>\n          <Text {...props}>{name}</Text>\n        </View>\n      );\n    }),\n  };\n});\n\njest.mock('../src/components/basic/icon/wavicon/wavicon.component', () => {\n  const { View, Text } = require('react-native');\n  return jest.fn().mockImplementation(({ name, ...props }) => {\n    return (\n      <View>\n        <Text {...props}>{name}</Text>\n      </View>\n    );\n  });\n});\n\njest.mock(\n  '../src/components/basic/icon/streamline-regular-icon/streamline-regular-icon.component',\n  () => {\n    const { View, Text } = require('react-native');\n    return jest.fn().mockImplementation(({ name, ...props }) => {\n      return (\n        <View>\n          <Text {...props}>{name}</Text>\n        </View>\n      );\n    });\n  }\n);\n\njest.mock(\n  '../src/components/basic/icon/streamline-light-icon/streamline-light-icon.component',\n  () => {\n    const { View, Text } = require('react-native');\n    return jest.fn().mockImplementation(({ name, ...props }) => {\n      return (\n        <View>\n          <Text {...props}>{name}</Text>\n        </View>\n      );\n    });\n  }\n);\n\njest.mock('@wavemaker/app-rn-runtime/core/injector', () => {\n  const actualInjector = jest.requireActual(\n    '@wavemaker/app-rn-runtime/core/injector'\n  );\n  return {\n    ...actualInjector,\n    get: jest.fn().mockImplementation(() => {\n      return {\n        app: {\n          toastsOpened: 1,\n        },\n        refresh: () => {},\n      };\n    }),\n    FOCUSED_ELEMENT: {\n      get: jest.fn().mockImplementation(() => ({\n        blur: jest.fn(),\n      })),\n      set: jest.fn(),\n    },\n    I18nService: {\n      ...actualInjector.I18nService,\n      get: jest.fn().mockImplementation(() => ({\n        defaultSupportedLocale: 'en',\n        selectedLocale: 'en',\n        dateFormat: 'MMM d, y',\n        timeFormat: 'h:mm:ss a',\n        dateTimeFormat: 'MMM d, y h:mm:ss a',\n        currencyCode: 'USD',\n        timezone: '',\n        isRTLLocale: jest.fn().mockReturnValue(false),\n        getSelectedLocale: jest.fn().mockReturnValue('en'),\n      })),\n    },\n  };\n});\n\njest.spyOn(AccessibilityConfig, 'isScreenReaderEnabled').mockReturnValue(false);\n", "wavemaker-rn-runtime/test/index.test.tsx": "import React from 'react';\nimport renderer from 'react-test-renderer';\nimport WMButton from '@wavemaker/app-rn-runtime/components/basic/button.component';\n\n\ndescribe('Check Button', () => {\n  test('renders correctly', () => {\n    const tree = renderer.create(<WMButton name=\"test_button\"/>).toJSON();\n    expect(1).toBe(1);\n  });\n});", "wavemaker-rn-runtime/test/__mocks__/navigation.service.ts": "// navigationServiceMock.js\nimport NavigationService from '@wavemaker/app-rn-runtime/core/navigation.service';\n\nconst mockNavigationService = {\n  goToPage: jest.fn(() => Promise.resolve()),\n  goBack: jest.fn(() => Promise.resolve()),\n  openUrl: jest.fn(() => Promise.resolve()),\n};\n\nexport default mockNavigationService;\n", "wavemaker-rn-runtime/test/__mocks__/react-native-animatable.js": "import {\n  View as CoreView,\n  Image as CoreImage,\n  Text as CoreText,\n  Animated,\n} from 'react-native';\n\nimport React from 'react';\n\nexport const createAnimatableComponent = (WrappedComponent) => {\n  const Animatable = Animated.createAnimatedComponent(WrappedComponent);\n  return class AnimatableComponent extends React.Component {\n    handleRef = (ref) => {\n      this.ref = ref;\n    };\n    transition() {}\n    stopAnimation() {}\n    stopAnimations() {}\n    // mock any other function you using\n\n    render() {\n      return (\n        <Animatable\n          ref={this.handleRef}\n          {...this.props}\n          //testID=\"animatableView\"\n        />\n      );\n    }\n  };\n};\nexport const initializeRegistryWithDefinitions = () => {};\nexport const View = createAnimatableComponent(CoreView);\nexport const Text = createAnimatableComponent(CoreImage);\nexport const Image = createAnimatableComponent(CoreText);\n", "wavemaker-rn-runtime/test/core/utils.spec.ts": "import { deepCopy } from '@wavemaker/app-rn-runtime/core/utils';\n\ndescribe('test deepCopy', () => {\n    test('replace values in the simple source object with destination', () => {\n        const r = deepCopy({a: 1}, {a: 2});\n        expect(r.a).toEqual(2);\n    });\n    test('Keys present in source object but not in destination', () => {\n        const r = deepCopy({a: 1, b : { c: 3, d: 4}}, {a: 2, b: {c: 5}});\n        expect(r.b.c).toEqual(5);\n        expect(r.b.d).toEqual(4);\n    });\n});", "wavemaker-rn-runtime/test/core/base.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport { Text, TouchableOpacity } from 'react-native';\nimport { shallow } from 'enzyme';\nimport renderer from 'react-test-renderer';\nimport {\n  BaseComponent,\n  BaseComponentState,\n  BaseProps,\n} from '@wavemaker/app-rn-runtime/core/base.component';\n\ninterface SampleProps extends BaseProps {\n  caption: string;\n  onTap?: Function;\n}\nconst DEFAULT_CLASS = 'app-sample-component';\n\nconst DEFAULT_STYLES = {\n  label: {\n    color: 'black',\n    fontSize: 20,\n  },\n};\n\nclass SampleComponent extends BaseComponent<\n  SampleProps,\n  BaseComponentState<SampleProps>\n> {\n  insProperty = true;\n  constructor(props: SampleProps) {\n    super(props, DEFAULT_CLASS, DEFAULT_STYLES);\n  }\n\n  render(): ReactNode {\n    super.render();\n    const props = this.state.props;\n    return (\n      <TouchableOpacity\n        onPress={() => this.invokeEventCallback('onTap', ['test_data', this])}\n      >\n        <Text style={this.styles.label}>{props.caption}</Text>\n      </TouchableOpacity>\n    );\n  }\n}\n\ndescribe.skip('Test BaseComponent', () => {\n  test('Check validity of sample component', () => {\n    const tree = renderer\n      .create(<SampleComponent name=\"test_button\" caption=\"test_label\" />)\n      .toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('Check init callback', () => {\n    const onInitFn = jest.fn((i) => {});\n    renderer.create(\n      <SampleComponent\n        name=\"test_button\"\n        caption=\"test_label\"\n        onInit={onInitFn}\n      />\n    );\n    expect(onInitFn.mock.calls.length).toBe(1);\n    const componentInstance = onInitFn.mock.calls[0][0];\n    expect(componentInstance.caption).toEqual('test_label');\n    componentInstance.caption = 'test_label_modified';\n    expect(componentInstance.caption).toEqual('test_label_modified');\n  });\n\n  test('Check component properties', () => {\n    let componentInstance: any = null;\n    renderer.create(\n      <SampleComponent\n        name=\"test_button\"\n        caption=\"test_label\"\n        onInit={(i: any) => {\n          componentInstance = i;\n        }}\n      />\n    );\n    componentInstance.onPropertyChange = jest.fn((name, $new, $old) => {});\n    expect(componentInstance.caption).toEqual('test_label');\n    expect(componentInstance.onPropertyChange.mock.calls.length).toEqual(0);\n    componentInstance.caption = 'test_label_modified';\n    expect(componentInstance.caption).toEqual('test_label_modified');\n    expect(componentInstance.onPropertyChange.mock.calls.length).toEqual(1);\n    const mockCall = componentInstance.onPropertyChange.mock.calls[0];\n    expect(mockCall[0]).toEqual('caption');\n    expect(mockCall[1]).toEqual('test_label_modified');\n    expect(mockCall[2]).toEqual('test_label');\n    expect(componentInstance.insProperty).toEqual(true);\n    componentInstance.insProperty = false;\n    expect(componentInstance.insProperty).toEqual(false);\n  });\n\n  test('Check styles', () => {\n    let componentInstance: any = null;\n    const styles = {\n      label: {\n        color: 'white',\n      },\n    };\n    renderer.create(\n      <SampleComponent\n        name=\"test_button\"\n        caption=\"test_label\"\n        onInit={(i: any) => {\n          componentInstance = i;\n        }}\n      />\n    );\n    // check default styles\n    expect(componentInstance.styles.label.color).toEqual('black');\n    renderer.create(\n      <SampleComponent\n        name=\"test_button\"\n        caption=\"test_label\"\n        styles={styles}\n        onInit={(i: any) => {\n          componentInstance = i;\n        }}\n      />\n    );\n    expect(componentInstance.styles.label.color).toEqual('white');\n  });\n\n  test('Check component events', () => {\n    const eventListener = jest.fn((e, w) => {});\n    let wrapper = shallow(\n      <SampleComponent\n        name=\"test_button\"\n        caption=\"test_label\"\n        onTap={eventListener}\n      />\n    );\n    const tp = wrapper.find(TouchableOpacity);\n    expect(tp.length).toEqual(1);\n    expect(eventListener.mock.calls.length).toBe(0);\n    tp.get(0).props.onPress();\n    expect(eventListener.mock.calls.length).toBe(1);\n    expect(eventListener.mock.calls[0][1]).toStrictEqual(wrapper.instance());\n  });\n\n  test('Check destroy callback', () => {\n    const onDestroyFn = jest.fn(() => {});\n    const instance = renderer.create(\n      <SampleComponent\n        name=\"test_button\"\n        caption=\"test_label\"\n        onDestroy={onDestroyFn}\n      />\n    );\n    expect(onDestroyFn.mock.calls.length).toBe(0);\n    instance.unmount();\n    expect(onDestroyFn.mock.calls.length).toBe(1);\n  });\n});\n", "wavemaker-rn-runtime/test/core/props.provider.spec.ts": "import { waitFor } from '@testing-library/react-native';\nimport { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { PropsProvider } from '@wavemaker/app-rn-runtime/core/props.provider';\n\n// describe('Test PropsProvider', () => {\n//     interface TestProps extends BaseProps {\n//         flag : boolean\n//     }\n//     const initialProps = {\n//         name: 'test',\n//         flag: true\n//     };\n//     test('Instance needs to be created without any error', () => {\n//         const instance = new PropsProvider<TestProps>(initialProps, () => {});\n//         expect(instance).not.toBeNull();\n//     });\n\n//     test('Should return the initial property values', () => {\n//         const instance = new PropsProvider<TestProps>(initialProps, () => {});\n//         const props = instance.get();\n//         expect(props).not.toBeNull();\n//     });\n\n//     test('check properties', () => {\n//         const instance = new PropsProvider<TestProps>(initialProps, () => {});\n//         const props = instance.get();\n//         expect(props.flag).toBeTruthy();\n//         //@ts-ignore\n//         expect(props.unknown).toBeUndefined();\n//     });\n\n//     test('setting properties', () => {\n//         const instance = new PropsProvider<TestProps>(initialProps, () => {});\n//         const props = instance.get();\n//         expect(props.flag).toBeTruthy();\n//         props.flag = false;\n//         expect(initialProps.flag).toBeTruthy();\n//         expect(props.flag).toBeFalsy();\n//         //@ts-ignore\n//         props.unknown = 'unknown';\n//         //@ts-ignore\n//         expect(props.unknown).toBeUndefined();\n//     });\n    \n//     test('getting callback on change of properties', () => {\n//         const callback = jest.fn((name: string, $new: any, $old: any) => {});\n//         const instance = new PropsProvider<TestProps>(initialProps, callback);\n//         const props = instance.get();\n//         let callCount = 2; // initialization callback for each property with value\n//         expect(callback.mock.calls.length).toBe(callCount);\n//         props.flag = false;\n//         expect(callback.mock.calls.length).toBe(++callCount);\n//         props.flag = false;\n//         expect(callback.mock.calls.length).toBe(callCount);\n//         props.flag = true;\n//         expect(callback.mock.calls.length).toBe(++callCount);\n//         expect(callback.mock.calls[callCount - 1][0]).toBe('flag');\n//         expect(callback.mock.calls[callCount - 1][1]).toBeTruthy();\n//         expect(callback.mock.calls[callCount - 1][2]).toBeFalsy();\n//     });\n// });\n\n\nclass TestProps extends BaseProps {\n    name?: string;\n    age?: number;\n}\n\ndescribe('PropsProvider', () => {\n    let defaultProps: TestProps;\n    let initProps: TestProps;\n    let mockOnChange: jest.Mock;\n\n    function createPropsProviderInstance(){\n        const provider = new PropsProvider<TestProps>(defaultProps, initProps, mockOnChange);\n        provider.check()\n        return provider;\n    }\n\n    beforeEach(() => {\n        defaultProps = { name: 'John', age: 30 };\n        initProps = { name: 'Doe' };\n        mockOnChange = jest.fn();\n    });\n\n    it('should initialize with default and init props', () => {\n        const provider = createPropsProviderInstance()\n        \n        const propsProxy = provider.get();\n        \n        expect(propsProxy.name).toBe('Doe'); // from initProps\n        expect(propsProxy.age).toBe(30);     // from defaultProps\n    });\n\n    it('should override properties and call onChange when set', () => {\n        const provider = createPropsProviderInstance()\n\n        const propsProxy = provider.get();\n        \n        // Override a property\n        propsProxy.name = 'Jane';\n        expect(mockOnChange).toHaveBeenCalledWith('name', 'Jane', 'Doe');\n        expect(propsProxy.name).toBe('Jane');\n    });\n\n    it('should not call onChange if the value is the same', () => {\n        const provider = createPropsProviderInstance()\n\n        const propsProxy = provider.get();\n\n        // Set the same value\n        propsProxy.name = 'Doe';\n        expect(mockOnChange.mock.calls.length).toBeLessThanOrEqual(2);\n         // No change in value, onChange should not be called except during the initial setting of values\n    }); \n\n    it('should allow setting default properties', () => {\n        const provider = createPropsProviderInstance()\n\n        // Set a default property\n        provider.setDefault('name', 'DefaultName');\n        const propsProxy = provider.get();\n        \n        expect(propsProxy.name).toBe('Doe'); // InitProps still override default\n        provider.overrideProp('name', 'Jane');\n        expect(propsProxy.name).toBe('Jane'); // overriddenProps should take precedence\n    });\n\n    it('should allow overriding properties directly', () => {\n        const provider = createPropsProviderInstance()\n        \n        provider.overrideProp('age', 40);\n        const propsProxy = provider.get();\n\n        expect(propsProxy.age).toBe(40); // overriddenProps should return 40\n    });\n\n    it('should detect property changes when using check()', () => {\n        const provider = createPropsProviderInstance()\n        \n        const hasChanged = provider.check({ name: 'NewName', age: 40 });\n        \n        expect(hasChanged).toBe(true); // Props have changed\n        expect(mockOnChange).toHaveBeenCalledWith('name', 'NewName', 'Doe');\n        expect(mockOnChange).toHaveBeenCalledWith('age', 40, 30);\n    });\n\n    it('should not detect changes if there are none during check()', () => {\n        const provider = createPropsProviderInstance()\n        \n        const hasChanged = provider.check({ name: 'Doe', age: 30 });\n        \n        expect(hasChanged).toBe(false); // No changes detected\n        expect(mockOnChange.mock.calls.length).toBeLessThanOrEqual(2);\n    });\n\n    it('should set properties using set() and call onChange', () => {\n        const provider = createPropsProviderInstance()\n\n        provider.set('name', 'NewName');\n        const propsProxy = provider.get();\n\n        expect(propsProxy.name).toBe('NewName');\n        expect(mockOnChange).toHaveBeenCalledWith('name', 'NewName', 'Doe');\n    });\n\n    it('should return false for has() if the property is not in propertyNames', () => {\n        const provider = createPropsProviderInstance()\n\n        expect(provider.has('nonExistentProp')).toBe(false); // Property doesn't exist\n    });\n\n    it('should return true for has() if the property exists', () => {\n        const provider = createPropsProviderInstance()\n\n        expect(provider.has('name')).toBe(true); // Property exists\n    });\n\n    it('should handle multiple property changes in check()', () => {\n        const provider = createPropsProviderInstance()\n\n        const propsToCheck = { name: 'Alice', age: 35 };\n        const hasChanged = provider.check(propsToCheck);\n\n        expect(hasChanged).toBe(true); // Properties have changed\n        expect(mockOnChange).toHaveBeenCalledWith('name', 'Alice', 'Doe');\n        expect(mockOnChange).toHaveBeenCalledWith('age', 35, 30);\n    });\n\n    it('should handle undefined values correctly', () => {\n        const provider = createPropsProviderInstance()\n        const propsProxy = provider.get();\n        \n        // Set undefined value\n        propsProxy.name = undefined;\n        expect(mockOnChange).toHaveBeenCalledWith('name', undefined, 'Doe');\n        expect(propsProxy.name).toBeUndefined();\n    });\n\n    it('should handle null values correctly', () => {\n        const provider = createPropsProviderInstance()\n        const propsProxy = provider.get();\n        \n        // Set null value\n        propsProxy.name = null;\n        expect(mockOnChange).toHaveBeenCalledWith('name', null, 'Doe');\n        expect(propsProxy.name).toBeNull();\n    });\n\n    xit('should not fail when initProps is undefined', () => {\n        const provider = new PropsProvider<TestProps>(defaultProps, undefined, mockOnChange);\n        const propsProxy = provider.get();\n\n        expect(propsProxy.name).toBe('John'); // Should fallback to defaultProps\n        expect(propsProxy.age).toBe(30);     // defaultProp age\n    });\n\n    it('should not call onChange if no property has changed', () => {\n        const provider = createPropsProviderInstance()\n        provider.check({ name: 'Doe', age: 30 });\n\n        expect(mockOnChange.mock.calls.length).toBeLessThanOrEqual(2);// No changes should trigger onChange\n    });\n\n    it('should not allow setting non-existent properties', () => {\n        const provider = createPropsProviderInstance()\n        const propsProxy = provider.get();\n\n        propsProxy.nonExistentProp = 'someValue'; // Property does not exist\n        expect(propsProxy.nonExistentProp).toBeUndefined(); // Should remain undefined\n    });\n\n    it('should reset the dirty flag after a check', () => {\n        const provider = createPropsProviderInstance()\n\n        provider.overrideProp('name', 'Alice');\n        expect(provider.check()).toBe(true); // Changed -> dirty\n        expect(provider.check()).toBe(false); // Reset -> clean after first check\n    });\n\n    it('should properly handle deeply nested objects', () => {\n        const provider = createPropsProviderInstance()\n        const propsProxy = provider.get();\n\n        // propsProxy.nested.key = 'newKey';\n        provider.set('newObj',{lname:'bob'})\n        expect(mockOnChange).toHaveBeenCalledWith('newObj',{ lname: 'bob' },undefined);\n\n        provider.overrideProp('newObj', { lname: 'bob the builder' });\n        expect(provider.check()).toBe(true); // Changed -> dirty\n\n        // expect(mockOnChange).toHaveBeenCalledWith('newObj', { lname: 'bob the builder' }, { lname: 'bob' });\n    });\n\n    it('should handle multiple overrides and track isDirty correctly', () => {\n        const provider = createPropsProviderInstance()\n\n        provider.overrideProp('name', 'Alice');\n        provider.check({name:'Alice'})\n        provider.overrideProp('age', 35);\n\n        const hasChanged = provider.check({age:35});\n        expect(hasChanged).toBe(true); // Multiple changes\n        // expect(mockOnChange).toHaveBeenCalledWith('name', 'Alice', 'Doe');\n        // expect(mockOnChange).toHaveBeenCalledWith('age', 35, 30);\n    });\n\n    it('should allow checking props without triggering onChange when values are unchanged', () => {\n        const provider = createPropsProviderInstance()\n        provider.check({ name: 'Doe', age: 30 });\n\n        expect(provider.check({ name: 'Doe', age: 30 })).toBe(false); // No change\n        expect(mockOnChange.mock.calls.length).toBeLessThanOrEqual(2);\n\n    });\n\n});\n\n", "wavemaker-rn-runtime/test/core/components/floatinglabel.component.spec.tsx": "import React from 'react';\nimport { act, render, cleanup, waitFor } from '@testing-library/react-native';\nimport { FloatingLabel } from '@wavemaker/app-rn-runtime/core/components/floatinglabel.component';\nimport MockDate from 'mockdate';\n\nconst frameTime = 100;\nconst timeTravel = (time = frameTime) => {\n  const tickTravel = () => {\n    const now = Date.now();\n    MockDate.set(new Date(now + frameTime));\n    // Run the timers forward\n    act(() => {\n      jest.advanceTimersByTime(frameTime);\n    });\n  };\n  // Step through each of the frames\n  const frames = time / frameTime;\n  for (let i = 0; i < frames; i++) {\n    tickTravel();\n  }\n};\n\ndescribe('FloatingLabel Component', () => {\n  beforeEach(()=> {\n    MockDate.set(0);\n  })\n\n  afterEach(() => {\n    cleanup();\n    MockDate.reset();\n  });\n\n  test('should apply ellipsizeMode correctly', async () => {\n    const { getByText } = render(\n      <FloatingLabel label=\"Ellipsize Label\" moveUp={false} />\n    );\n    timeTravel(200);\n    const text = getByText('Ellipsize Label');\n\n    await waitFor(()=>{\n      expect(text.props.ellipsizeMode).toBe('tail');\n    })\n  });\n\n  test('should render the label with default props', () => {\n    const { getByText } = render(\n      <FloatingLabel label=\"Test Label\" moveUp={true} />\n    );\n\n    expect(getByText('Test Label')).toBeTruthy();\n  });\n\n  test('should apply additional styles from prop', () => {\n    const { getByText } = render(\n      <FloatingLabel\n        label=\"Styled Label\"\n        moveUp={false}\n        style={{ color: 'red', fontSize: 20 }}\n      />\n    );\n    const text = getByText('Styled Label');\n    expect(text.props.style).toMatchObject({ color: 'red' });\n    expect(text.props.style).toMatchObject({ fontSize: 20 });\n  });\n\n  test('should animate position and scale when moveUp is true', () => {\n    jest.useFakeTimers();\n    const { getByText, rerender } = render(\n      <FloatingLabel label=\"Animate Label\" moveUp={false} />\n    );\n    timeTravel(200);\n\n    const initialAnimatedView = getByText('Animate Label').parent?.parent;\n    const style = {};\n    initialAnimatedView?.props.style.transform.forEach((item) => {\n      if (!item) return;\n      Object.keys(item).forEach((key) => {\n        style[key] = item[key];\n      });\n    });\n\n    expect(style).toMatchObject({\n      translateY: 0,\n      translateX: 0,\n      scale: 1,\n    });\n\n    rerender(<FloatingLabel label=\"Animate Label\" moveUp={true} />);\n    timeTravel(200);\n\n    const animatedView = getByText('Animate Label').parent?.parent;\n    const transformStyle = {};\n    animatedView.props.style.transform.forEach((item) => {\n      if (!item) return;\n      Object.keys(item).forEach((key) => {\n        transformStyle[key] = item[key];\n      });\n    });\n\n    expect(transformStyle).toMatchObject({\n      translateY: -16,\n      translateX: -16,\n      scale: 0.8,\n    });\n\n    jest.useRealTimers();\n  });\n\n  test('should animate position and scale when moveUp becomes true to false', () => {\n    jest.useFakeTimers();\n\n    const { getByText, rerender } = render(\n      <FloatingLabel label=\"Animate Label\" moveUp={true} />\n    );\n    timeTravel(200);\n\n    const initialAnimatedView = getByText('Animate Label').parent?.parent;\n    const style = {};\n    initialAnimatedView?.props.style.transform.forEach((item) => {\n      if (!item) return;\n      Object.keys(item).forEach((key) => {\n        style[key] = item[key];\n      });\n    });\n\n    expect(style).toMatchObject({\n      translateY: -16,\n      translateX: -16,\n      scale: 0.8,\n    });\n\n    rerender(<FloatingLabel label=\"Animate Label\" moveUp={false} />);\n    timeTravel(200);\n\n    const animatedView = getByText('Animate Label').parent?.parent;\n    const transformStyle = {};\n    animatedView.props.style.transform.forEach((item) => {\n      if (!item) return;\n      Object.keys(item).forEach((key) => {\n        transformStyle[key] = item[key];\n      });\n    });\n\n    expect(transformStyle).toMatchObject({\n      translateY: 0,\n      translateX: 0,\n      scale: 1,\n    });\n    jest.useRealTimers();\n\n  });\n\n  test('should set correct transformation values based on style', () => {\n    jest.useFakeTimers();\n    const width = 85;\n    const fontSize = 20;\n\n    const { getByText } = render(\n      <FloatingLabel\n        label=\"Animate Label\"\n        moveUp={true}\n        style={{\n          fontSize: fontSize,\n          width: width,\n        }}\n      />\n    );\n    timeTravel(200);\n\n    const initialAnimatedView = getByText('Animate Label').parent?.parent;\n    const style = {};\n    initialAnimatedView?.props.style.transform.forEach((item) => {\n      if (!item) return;\n      Object.keys(item).forEach((key) => {\n        style[key] = item[key];\n      });\n    });\n\n    expect(style).toMatchObject({\n      translateX: -1 * width * 0.1,\n      translateY: -1 * fontSize,\n      scale: 0.8,\n    });\n    jest.useRealTimers();\n  });\n});\n", "wavemaker-rn-runtime/test/core/components/textinput.component.spec.tsx": "import React from 'react';\nimport { act, fireEvent, render, waitFor } from '@testing-library/react-native';\nimport { WMTextInput } from '@wavemaker/app-rn-runtime/core/components/textinput.component';\nimport { Platform, TextInput } from 'react-native';\n\ndescribe('TextInput Component', () => {\n  const defaultProps = {\n    allowContentSelection: false,\n    displayformat: '',\n    maskchar: '',\n    floatingLabelStyle: {},\n    activeFloatingLabelStyle: {},\n    onChangeText: jest.fn(),\n    onFocus: jest.fn(),\n    onBlur: jest.fn(),\n    placeholder: 'Enter text',\n    editable: true\n  };\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  test('should render correctly with default props', () => {\n    const tree = render(<WMTextInput {...defaultProps} />);\n    expect(tree).toMatchSnapshot();\n    expect(tree.UNSAFE_getByType(TextInput)).toBeTruthy();\n  });\n\n  test('should show floating label when focused', () => {\n    const tree = render(\n      <WMTextInput {...defaultProps} floatingLabel=\"Floating Label\" />\n    );\n\n    const input = tree.UNSAFE_getByType(TextInput);\n    act(() => {\n      fireEvent(input, 'focus', {\n        target: null,\n      });\n    });\n    expect(tree).toMatchSnapshot();\n    expect(tree.getByText('Floating Label')).toBeTruthy();\n  });\n\n  test('should call onChangeText with the correct value', () => {\n    const { getByPlaceholderText } = render(<WMTextInput {...defaultProps} />);\n    const input = getByPlaceholderText('Enter text');\n    act(() => {\n      fireEvent.changeText(input, 'test');\n    });\n    expect(defaultProps.onChangeText).toHaveBeenCalledWith('test');\n  });\n\n  test('should call onFocus and onBlur when input is focused and blurred', () => {\n    const { getByPlaceholderText } = render(<WMTextInput {...defaultProps} />);\n    const input = getByPlaceholderText('Enter text');\n    act(() => {\n      fireEvent(input, 'focus', {\n        event: {\n          target: null,\n        },\n      });\n    });\n    expect(defaultProps.onFocus).toHaveBeenCalled();\n\n    act(() => {\n      fireEvent(input, 'blur');\n    });\n    expect(defaultProps.onBlur).toHaveBeenCalled();\n  });\n\n  test('should mask characters if maskchar is provided', () => {\n    const { getByPlaceholderText, queryByText } = render(\n      <WMTextInput {...defaultProps} maskchar=\"*\" />\n    );\n    const input = getByPlaceholderText('Enter text');\n\n    act(() => {\n      fireEvent.changeText(input, '1234');\n    });\n\n    expect(queryByText('****')).toBeTruthy();\n  });\n\n  test('should format input based on displayformat', async () => {\n    const propsWithFormat = {\n      ...defaultProps,\n      displayformat: '99-999',\n    };\n\n    const tree = render(<WMTextInput {...propsWithFormat} />);\n\n    expect(tree).toMatchSnapshot();\n\n    const input = tree.UNSAFE_getByType(TextInput);\n\n    act(() => {\n      fireEvent.changeText(input, '12345');\n    });\n\n    expect(tree.queryByText('12-345')).toBeTruthy();\n  });\n\n  test('should not allow content selection if allowContentSelection is false when platform is android', async () => {\n    (Platform as any).OS = 'android';\n    const tree = render(<WMTextInput {...defaultProps} />);\n    const input = tree.getByPlaceholderText('Enter text');\n\n    act(() => {\n      fireEvent(input, 'selectionChange', {\n        nativeEvent: { selection: { start: 0, end: 4 } },\n      });\n    });\n\n    await waitFor(() => {\n      expect(tree).toMatchSnapshot();\n    });\n\n    expect(input.props).toHaveProperty('caretHidden', true);\n    expect(input.props).toHaveProperty('contextMenuHidden', true);\n  });\n\n  test('should handle floatingLabel prop correctly', () => {\n    const { queryByText } = render(\n      <WMTextInput {...defaultProps} floatingLabel=\"Custom Label\" />\n    );\n    expect(queryByText('Custom Label')).toBeTruthy();\n  });\n\n  test('should hide cursor when hideInput is true', () => {\n    const { UNSAFE_getByType } = render(\n      <WMTextInput {...defaultProps} displayformat=\"99-99\" />\n    );\n    const input = UNSAFE_getByType(TextInput);\n    expect(input.props).toHaveProperty('selectionColor', 'transparent');\n    expect(input.props).toHaveProperty('cursorColor', 'transparent');\n  });\n\n  test('updates correctly on prop change', () => {\n    const { getByPlaceholderText, rerender } = render(\n      <WMTextInput {...defaultProps} value=\"Initial\" />\n    );\n    const input = getByPlaceholderText('Enter text');\n\n    rerender(<WMTextInput {...defaultProps} value=\"Updated\" />);\n    expect(input.props.value).toBe('Updated');\n  });\n\n  test('should render custom cursor', () => {\n    const tree = render(\n      <WMTextInput {...defaultProps} displayCursor={true} maskchar=\"*\" />\n    );\n\n    fireEvent(tree.getByPlaceholderText('Enter text'), 'focus', {\n      target: null,\n    });\n\n    expect(tree).toMatchSnapshot();\n    expect(tree.getByTestId('wm-custom-cursor')).toBeTruthy();\n  });\n\n  test('should not render custom cursor when testinput is not focused', () => {\n    const tree = render(\n      <WMTextInput {...defaultProps} displayCursor={true} maskchar=\"*\" />\n    );\n\n    fireEvent(tree.getByPlaceholderText('Enter text'), 'blur');\n\n    expect(tree).toMatchSnapshot();\n    expect(tree.queryByTestId('wm-custom-cursor')).toBeNull();\n  });\n\n  test('should not render custom cursor when maskchar prop is falsy', () => {\n    const tree = render(\n      <WMTextInput {...defaultProps} displayCursor={true} maskchar=\"\" />\n    );\n\n    fireEvent(tree.getByPlaceholderText('Enter text'), 'focus', {\n      target: null,\n    });\n\n    expect(tree).toMatchSnapshot();\n    expect(tree.queryByTestId('wm-custom-cursor')).toBeNull();\n  });\n\n  test('should not render custom cursor when displayformat value is passed', () => {\n    const tree = render(\n      <WMTextInput\n        {...defaultProps}\n        displayCursor={true}\n        displayformat=\"99-99\"\n      />\n    );\n\n    fireEvent(tree.UNSAFE_getByType(TextInput), 'focus', {\n      target: null,\n    });\n\n    expect(tree).toMatchSnapshot();\n    expect(tree.queryByTestId('wm-custom-cursor')).toBeNull();\n  });\n\n  test('should render the customDisplayValue text when it is passed in props', async () => {\n    Platform.OS = 'ios';\n    const tree = render(\n      <WMTextInput {...defaultProps} customDisplayValue=\"500%\" />\n    );\n    const input = tree.UNSAFE_getByType(TextInput);\n\n    fireEvent.changeText(input, '200');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    expect(input.props.defaultValue).toBe('500%');\n  });\n\n  test('should apply autoCapitalize prop in InputText component', async () => {\n    Platform.OS = 'ios';\n    const tree = render(\n      <WMTextInput {...defaultProps} autoCapitalize=\"characters\" />\n    );\n    const input = tree.UNSAFE_getByType(TextInput);\n    expect(input.props.autoCapitalize).toBe('characters');\n  });\n\n  test('should change the text to capital weh autoCapitalize prop is set to characters', async () => {\n    const { UNSAFE_getByType, getByText } = render(\n      <WMTextInput {...defaultProps} autoCapitalize=\"characters\" />\n    );\n\n    const input = UNSAFE_getByType(TextInput);\n\n    fireEvent(input, 'changeText', 'hello');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    expect(input.props.autoCapitalize).toBe(\"characters\")\n    await waitFor(()=>{\n      expect(defaultProps.onChangeText).toHaveBeenCalledWith('HELLO');\n    })\n  });\n  test('should render Text instead of TextInput for Android device and editable prop is false', async () => {\n    Platform.OS = 'android';\n    const tree = render(\n      <WMTextInput {...defaultProps} editable={false} />\n    );\n\n    const input = tree.getByText('Enter text');\n\n    expect(input.type).toBe('Text')\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render TextInput for iOS device and editable prop is true', async () => {\n    Platform.OS = 'ios';\n    const tree = render(\n      <WMTextInput {...defaultProps} editable={false} />\n    );\n\n    const input = tree.getByPlaceholderText('Enter text');\n\n    expect(input.type).toBe('TextInput')\n    expect(tree).toMatchSnapshot();\n  });\n});\n", "wavemaker-rn-runtime/test/runtime/watcher.spec.ts": "import {\n  Watcher,\n  useWatcher,\n} from '@wavemaker/app-rn-runtime/runtime/watcher';\nimport { WIDGET_LOGGER } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { useState } from 'react';\nimport { Text,View } from 'react-native';\n\n// import { renderHook } from '@testing-library/react-hooks';\n\n\nconst WATCH_LOGGER = WIDGET_LOGGER.extend('watch');\n\ndescribe('Watcher System', () => {\n  let watcher: Watcher;\n  let mockLogger: any;\n\n  beforeEach(() => {\n    watcher = Watcher.ROOT.create(); // Create a fresh child watcher for each test\n    // mockLogger = WATCH_LOGGER;\n  });\n\n  afterEach(() => {\n    watcher.destroy(); // Cleanup watcher after each test\n  });\n\n  it('should add a watch expression and detect changes in primitive values', () => {\n    let value = 1;\n    const onChange = jest.fn();\n\n    watcher.watch(() => value, onChange);\n\n    watcher.check();\n    expect(onChange).not.toHaveBeenCalled();\n\n    // Trigger a change\n    value = 2;\n    watcher.check();\n\n    expect(onChange).toHaveBeenCalledWith(1, 2);\n  });\n\n  it('should not trigger onChange if the value has not changed', () => {\n    let value = 1;\n    const onChange = jest.fn();\n\n    watcher.watch(() => value, onChange);\n\n    watcher.check(); \n    expect(onChange).not.toHaveBeenCalled();\n\n    value = 1; // No change in value\n    watcher.check();\n    expect(onChange).not.toHaveBeenCalled();\n  });\n\n  it('should handle array changes correctly', () => {\n    let arr = [1, 2, 3];\n    const onChange = jest.fn();\n\n    watcher.watch(() => arr, onChange);\n\n    expect(onChange).not.toHaveBeenCalled();\n\n    // Modify the array\n    arr = [1, 2, 3, 4];\n    watcher.check();\n\n    expect(onChange).toHaveBeenCalledWith([1, 2, 3], [1, 2, 3, 4]);\n  });\n\n  it('should detect changes in array', () => {\n    let arr = [1, 2, 3];\n    const onChange = jest.fn();\n\n    const expression = watcher.watch(() => arr, onChange);\n\n    arr = [1, 2, 3, 4];\n    watcher.check();\n\n    // Check if `last` was cloned properly (after the change)\n    expect(expression.value).toEqual([1, 2, 3, 4]);\n\n    // Modify the new array and check if it's a separate instance\n    arr.push(5);\n    watcher.check();\n    expect(expression.value).toEqual([1, 2, 3, 4, 5]); // The last value should remain unchanged\n  });\n\n  it('should handle multiple watch expressions', () => {\n    let value1 = 1;\n    let value2 = 10;\n    const onChange1 = jest.fn();\n    const onChange2 = jest.fn();\n\n    watcher.watch(() => value1, onChange1);\n    watcher.watch(() => value2, onChange2);\n\n    // Trigger a change in the first expression\n    value1 = 2;\n    watcher.check();\n\n    expect(onChange1).toHaveBeenCalledWith(1, 2);\n    expect(onChange2).not.toHaveBeenCalled();\n\n    // Now change the second value\n    value2 = 20;\n    watcher.check();\n\n    expect(onChange2).toHaveBeenCalledWith(10, 20);\n  });\n\n  it('should remove child watcher and clean up', () => {\n    const childWatcher = watcher.create();\n\n    expect(watcher.children.length).toBe(1);\n\n    childWatcher.destroy();\n\n    expect(watcher.children.length).toBe(0);\n  });\n\n  it('should count the total number of watchers and expressions', () => {\n    let value1 = 1;\n    let value2 = 10;\n\n    watcher.watch(() => value1, jest.fn());\n    watcher.watch(() => value2, jest.fn());\n\n    const childWatcher = watcher.create();\n    childWatcher.watch(() => value2, jest.fn());\n\n    expect(watcher.count()).toBe(3); // 2 in root watcher, 1 in child watcher\n  });\n\n  it('should handle null and undefined values', () => {\n    let value: any = null;\n    const onChange = jest.fn();\n\n    watcher.watch(() => value, onChange);\n    expect(onChange).not.toHaveBeenCalled();\n\n    // Change from null to undefined\n    value = undefined;\n    watcher.check();\n    expect(onChange).toHaveBeenCalledWith(null, undefined);\n  });\n\n  it('should detect changes when function throws an error', () => {\n    let value = 1;\n    const onChange = jest.fn();\n\n    watcher.watch(() => {\n      if (value === 2) throw new Error('Error');\n      return value;\n    }, onChange);\n\n    // Trigger change to 2 which throws an error\n    value = 2;\n    watcher.check();\n\n    // Error in execution should return null and cause change detection\n    expect(onChange).toHaveBeenCalledWith(1, null);\n  });\n\n  it('should handle changes in empty arrays correctly', () => {\n    let arr: number[] = [];\n    const onChange = jest.fn();\n\n    watcher.watch(() => arr, onChange);\n\n    expect(onChange).not.toHaveBeenCalled();\n\n    // Change from empty array to array with elements\n    arr = [1, 2, 3];\n    watcher.check();\n\n    expect(onChange).toHaveBeenCalledWith([], [1, 2, 3]);\n  });\n\n  it('should not trigger onChange if array contents remain the same after mutation', () => {\n    let arr = [1, 2, 3];\n    const onChange = jest.fn();\n\n    watcher.watch(() => arr, onChange);\n\n    // Mutate array but keep the contents the same\n    arr = [1, 2, 3];\n    watcher.check();\n\n    expect(onChange).not.toHaveBeenCalled(); // No change in array content\n  });\n\n  it('should handle object equality check', () => {\n    let obj1 = { a: 1, b: { c: 2 } };\n    let obj2 = { d: 3, e: 4 };\n    const onChange = jest.fn();\n\n    watcher.watch(() => obj1, onChange);\n    obj1 = { ...obj1, ...obj2 };\n\n    watcher.check();\n\n    expect(onChange).toHaveBeenCalledWith(\n      { a: 1, b: { c: 2 } },\n      { a: 1, b: { c: 2 }, d: 3, e: 4 }\n    );\n  });\n\n  //we are not handling deep manipulation of objects , i.e onchange is not called when reference of both objects remain same\n  // it('should handle deep object equality check', () => {\n  //     let obj = { a: 1, b: { c: 2 } };\n  //     const onChange = jest.fn();\n\n  //     watcher.watch(() => obj, onChange);\n\n  //     // Mutate inner object\n  //     obj.b.c = 3;\n  //     watcher.check();\n\n  //     expect(onChange).toHaveBeenCalledWith({ a: 1, b: { c: 2 } }, { a: 1, b: { c: 3 } });\n  // });\n\n  it('should trigger onChange even if objects remain deeply equal', () => {\n    let obj = { a: 1, b: { c: 2 } };\n    const onChange = jest.fn();\n\n    watcher.watch(() => obj, onChange);\n\n    // Reassign object but contents remain the same\n    obj = { a: 1, b: { c: 2 } };\n    watcher.check();\n\n    expect(onChange).toHaveBeenCalled();\n    expect(onChange).toHaveBeenCalledWith(\n      { a: 1, b: { c: 2 } },\n      { a: 1, b: { c: 2 } }\n    );\n  });\n\n  it('should not log a debug message if no change is detected', () => {\n    let prop = 10;\n    const onChange = jest.fn();\n    const debugSpy = jest.spyOn(WATCH_LOGGER, 'debug');\n    watcher.watch(() => prop, onChange);\n    watcher.check();\n\n    expect(debugSpy).not.toHaveBeenCalled();\n  });\n\n  it('should log a debug message when a change is detected', () => {\n    let prop = 10;\n    let debugMsg = \"\";\n    const onChange = jest.fn();\n    const debugSpy = jest.spyOn(WATCH_LOGGER, 'debug').mockImplementation((fn:any ) => {\n      debugMsg = fn();\n    });\n    watcher.watch(() => prop, onChange);\n\n    prop = 20;\n    watcher.check();\n\n    expect(debugSpy).toHaveBeenCalled();\n    expect(debugSpy).toHaveBeenCalledWith(expect.any(Function));\n\n    expect(debugMsg).toBe('Watcher: <prop> Changed from 10 to 20 ');\n  });\n\n});\n\ndescribe('Parent and Child Watcher tests ', () => {\n  let parentWatcher: Watcher;\n  let childWatcher: Watcher;\n\n  beforeEach(() => {\n    // Create a parent watcher\n    parentWatcher = Watcher.ROOT.create();\n\n    // Create a child watcher from the parent\n    childWatcher = parentWatcher.create();\n  });\n\n  afterEach(() => {\n    // Cleanup watchers after each test\n    parentWatcher.destroy();\n  });\n\n  // it('should trigger both parent and child watchers when child prop changes', () => {\n  it('should trigger both parent and child watchers independently on respective changes', () => {\n    // Track variables to monitor changes\n    let parentProp = 5;\n    let childProp = 10;\n    let parentWatcherTriggered = false;\n    let childWatcherTriggered = false;\n\n    // Watch a property using the parent watcher\n    parentWatcher.watch(\n      () => parentProp,\n      (prev, now) => {\n        parentWatcherTriggered = true;\n      }\n    );\n\n    // Watch a property using the child watcher\n    childWatcher.watch(\n      () => childProp,\n      (prev, now) => {\n        childWatcherTriggered = true;\n      }\n    );\n\n    // Initially, no changes should have triggered the watchers\n    expect(parentWatcherTriggered).toBe(false);\n    expect(childWatcherTriggered).toBe(false);\n\n    // Change the child prop and force the parent watcher to check for changes\n    childProp = 20;\n    parentWatcher.check();\n\n    // Verify that both the parent and child watchers were triggered\n    expect(parentWatcherTriggered).toBe(false); // Parent should not trigger, as its watched prop didn't change\n    expect(childWatcherTriggered).toBe(true); // Child should trigger because its prop changed\n\n    // Reset the flags and change the parent prop\n    parentWatcherTriggered = false;\n    childWatcherTriggered = false;\n    parentProp = 15;\n    parentWatcher.check();\n\n    // Verify that the parent watcher is triggered\n    expect(parentWatcherTriggered).toBe(true); // Parent should now trigger\n    expect(childWatcherTriggered).toBe(false); // Child should not be triggered for parent prop change\n  });\n\n  it('should clean up child watcher when removed from parent', () => {\n    // Ensure the parent has the child watcher\n    expect(parentWatcher.children.length).toBe(1);\n\n    // Remove the child watcher from the parent\n    parentWatcher.remove(childWatcher);\n\n    // Check that the child watcher has been removed\n    expect(parentWatcher.children.length).toBe(0);\n  });\n\n  it('should handle multiple props and correctly trigger on specific changes', () => {\n    let parentProp1 = 1;\n    let parentProp2 = 2;\n    let childProp1 = 10;\n    let childProp2 = 20;\n\n    let parentTriggeredCount = 0;\n    let childTriggeredCount = 0;\n\n    // Parent watcher watching multiple props\n    parentWatcher.watch(\n      () => parentProp1,\n      () => parentTriggeredCount++\n    );\n    parentWatcher.watch(\n      () => parentProp2,\n      () => parentTriggeredCount++\n    );\n\n    // Child watcher watching multiple props\n    childWatcher.watch(\n      () => childProp1,\n      () => childTriggeredCount++\n    );\n    childWatcher.watch(\n      () => childProp2,\n      () => childTriggeredCount++\n    );\n\n    // No changes should have been detected yet\n    expect(parentTriggeredCount).toBe(0);\n    expect(childTriggeredCount).toBe(0);\n\n    // Change a child prop\n    childProp1 = 30;\n    parentWatcher.check();\n\n    // Verify that only the child watcher was triggered\n    expect(parentTriggeredCount).toBe(0); // Parent watcher should not be triggered\n    expect(childTriggeredCount).toBe(1); // Child watcher should be triggered once\n\n    // Change a parent prop\n    parentProp1 = 5;\n    parentWatcher.check();\n\n    // Verify that only the parent watcher was triggered\n    expect(parentTriggeredCount).toBe(1); // Parent watcher should be triggered once\n    expect(childTriggeredCount).toBe(1); // Child watcher should remain unchanged\n  });\n});\n\n// import React from 'react';\n// import { TouchableOpacity } from 'react-native';\n// import { render, fireEvent, act } from '@testing-library/react-native';\n\n// // Helper Component to test the useWatcher hook\n// const TestWatcherComponent = ({ initialValue }) => {\n//     const parentWatcher = Watcher.ROOT;\n//     const { watch } = useWatcher(parentWatcher);\n\n//     const [value, setValue] = React.useState(initialValue);\n\n//     const watchedValue = watch(() => value);\n\n//     return (\n//         <View>\n//             <Text testID=\"watched-value\">{watchedValue}</Text>\n//             <TouchableOpacity testID=\"change-value\" onPress={() => setValue(value + 1)}>\n//                 <Text>Change Value</Text>\n//             </TouchableOpacity>\n//         </View>\n//     );\n// };\n\n// describe('useWatcher hook', () => {\n//     let parentWatcher: Watcher;\n\n//     beforeEach(() => {\n//         parentWatcher = Watcher.ROOT.create();  // Create fresh parent watcher\n//     });\n\n//     afterEach(() => {\n//         parentWatcher.destroy();  // Cleanup parent watcher after each test\n//     });\n\n//     it('should create a watcher and track changes in a React Native component', () => {\n//         const initialValue = 1;\n//         const { getByTestId } = render(<TestWatcherComponent initialValue={initialValue} />);\n\n//         // Ensure that the watcher is created\n//         expect(parentWatcher.children.length).toBe(1);\n\n//         // Initial value rendered in the component\n//         const watchedValueText = getByTestId('watched-value');\n//         expect(watchedValueText.props.children).toBe(1);  // Value should be 1 initially\n\n//         // Simulate value change by pressing the button\n//         const changeValueButton = getByTestId('change-value');\n//         act(() => {\n//             fireEvent.press(changeValueButton);  // Press the button to increment value\n//         });\n\n//         // Check if the parentWatcher detects the change\n//         act(() => {\n//             parentWatcher.check();\n//         });\n\n//         // The new watched value should be updated\n//         expect(watchedValueText.props.children).toBe(2);\n//     });\n\n//     it('should clean up watcher on component unmount', () => {\n//         const { unmount } = render(<TestWatcherComponent initialValue={1} />);\n\n//         // Ensure that the watcher is created\n//         expect(parentWatcher.children.length).toBe(1);\n\n//         // Unmount the component\n//         unmount();\n\n//         // The watcher should be removed after the component unmounts\n//         expect(parentWatcher.children.length).toBe(0);\n//     });\n// });\n\n// describe('useWatcher hook', () => {\n//     let parentWatcher: Watcher;\n\n//     beforeEach(() => {\n//         parentWatcher = Watcher.ROOT.create();  // Create fresh parent watcher\n//     });\n\n//     afterEach(() => {\n//         parentWatcher.destroy();  // Cleanup parent watcher after each test\n//     });\n\n//     it('should create a watcher and track changes in a React component', () => {\n//         let value = 1;\n\n//         const { result } = renderHook(() => useWatcher(parentWatcher));\n\n//         expect(parentWatcher.children.length).toBe(1);  // New watcher created\n\n//         // Watch a value\n//         const watchedValue = result.current.watch(() => value);\n//         expect(watchedValue).toBe(1);  // Initial value is 1\n\n//         // Change value and check if watcher updates\n//         value = 2;\n//         parentWatcher.check();  // Force the parent watcher to check for changes\n\n//         const updatedValue = result.current.watch(() => value);\n//         expect(updatedValue).toBe(2);  // Updated value after the check\n//     });\n\n//     it('should clean up watcher on component unmount', () => {\n//         const { unmount } = renderHook(() => useWatcher(parentWatcher));\n\n//         expect(parentWatcher.children.length).toBe(1);  // New watcher created\n\n//         unmount();  // Simulate component unmount\n\n//         expect(parentWatcher.children.length).toBe(0);  // Watcher should be cleaned up\n//     });\n// });\n\n// // Helper Component to test the useWatcher hook\n// const TestWatcherComponent = ({ initialValue }: { initialValue: number }) => {\n//     const parentWatcher = Watcher.ROOT;\n//     const { watch } = useWatcher(parentWatcher);\n\n//     const [value, setValue] = useState(initialValue);\n\n//     const watchedValue = watch(() => value);\n\n//     return (\n//         <View>\n//             <Text testID=\"watched-value\">{watchedValue}</Text>\n//             <Text testID=\"change-value\" onPress={() => setValue(value + 1)}>Change Value</Text>\n//         </View>\n//     );\n// };\n\n// describe('useWatcher hook without @testing-library/react-hooks', () => {\n//     let parentWatcher: Watcher;\n\n//     beforeEach(() => {\n//         parentWatcher = Watcher.ROOT.create();  // Create fresh parent watcher\n//     });\n\n//     afterEach(() => {\n//         parentWatcher.destroy();  // Cleanup parent watcher after each test\n//     });\n\n//     it('should create a watcher and track changes in a React component', () => {\n//         const initialValue = 1;\n//         const { getByTestId } = render(<TestWatcherComponent initialValue={initialValue} />);\n\n//         // Ensure that the watcher is created\n//         expect(parentWatcher.children.length).toBe(1);\n\n//         // Initial value rendered in the component\n//         const watchedValueText = getByTestId('watched-value');\n//         expect(watchedValueText.props.children).toBe(1);  // Value should be 1 initially\n\n//         // Simulate value change by pressing the button\n//         const changeValueButton = getByTestId('change-value');\n//         fireEvent.press(changeValueButton);  // Press the button to increment value\n\n//         // Check if the parentWatcher detects the change\n//         parentWatcher.check();\n\n//         // The new watched value should be updated\n//         expect(watchedValueText.props.children).toBe(2);\n//     });\n\n//     it('should clean up watcher on component unmount', () => {\n//         const { unmount } = render(<TestWatcherComponent initialValue={1} />);\n\n//         // Ensure that the watcher is created\n//         expect(parentWatcher.children.length).toBe(1);\n\n//         // Unmount the component\n//         unmount();\n\n//         // The watcher should be removed after the component unmounts\n//         expect(parentWatcher.children.length).toBe(0);\n//     });\n// });\n", "wavemaker-rn-runtime/test/styles/background.component.spec.tsx": "import React from 'react';\nimport { Image } from 'react-native';\nimport { cleanup, render, waitFor } from '@testing-library/react-native';\nimport { BackgroundComponent } from '@wavemaker/app-rn-runtime/styles/background.component';\nimport { AssetProvider } from '@wavemaker/app-rn-runtime/core/asset.provider';\nimport { isFullPathUrl } from '@wavemaker/app-rn-runtime/core/utils';\n\nconst timer = (time = 200) =>\n  new Promise((resolve: any, reject) => {\n    setTimeout(() => resolve(), time);\n  });\n\nconst hexToArgbValue = (hex: string) => {\n  let hexCode = hex.substring(1);\n  if (hexCode.length === 3) {\n    hexCode = '' + hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n  }\n  hexCode = '0xff' + hexCode;\n\n  return parseInt(hexCode, 16);\n};\n\nconst formateDecimalValue = (valueInStr: string) => {\n  return parseFloat(valueInStr) / 100;\n}\n\nconst renderComponent = (props = {}) => {\n  const defaultProps = {\n    size: '100% 100%',\n  };\n\n  return render(\n    <AssetProvider value={(path) => path}>\n      <BackgroundComponent {...defaultProps} {...props} />\n    </AssetProvider>\n  );\n};\n\n// jest.mock('@wavemaker/app-rn-runtime/core/utils', () => {\n//   return {\n//     isFullPathUrl: jest.fn(),\n//   };\n// });\n\njest.mock('@wavemaker/app-rn-runtime/core/imageSizeEstimator', () => ({\n  getSize: jest.fn((uri, callback) => {\n    callback(100, 200); // mock image dimensions\n  }),\n}));\n\ndescribe('Background Component', () => {\n  afterEach(() => {\n    jest.clearAllMocks();\n    cleanup();\n  });\n\n  test('should render gradient when image prop contains linear-gradient', () => {\n    const tree = renderComponent({\n      image: 'linear-gradient(45deg, #4c669f, #3b5998)',\n    });\n\n    expect(tree.getByTestId('wm-expo-linear-gradient').props.colors).toEqual([\n      hexToArgbValue('#4c669f'),\n      hexToArgbValue('#3b5998'),\n    ]);\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render gradient when image prop contains linear-gradient with decimal values in gradient color', () => {\n    const tree = renderComponent({\n      image: 'linear-gradient(68.44deg, #EEEEEE 10%, #A61527 41.98%, #C32033 73.75%, #B41227 100%)',\n    });\n\n    expect(tree.getByTestId('wm-expo-linear-gradient').props.colors).toEqual([\n      hexToArgbValue('#EEEEEE'),\n      hexToArgbValue('#A61527'),\n      hexToArgbValue('#C32033'),\n      hexToArgbValue('#B41227'),\n    ]);\n    expect(tree.getByTestId('wm-expo-linear-gradient').props.locations).toEqual([\n      formateDecimalValue('10%'),\n      formateDecimalValue('41.98%'),\n      formateDecimalValue('73.75%'),\n      formateDecimalValue('100%')\n    ])\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('source should not have \"url\" prefix of the image string', async () => {\n    const props = {\n      image: 'url(http://example.com/image.jpg)',\n    };\n\n    const tree = renderComponent(props);\n    await timer();\n\n    await waitFor(() => {\n      expect(tree.toJSON()).not.toBeNull();\n      expect(tree).toMatchSnapshot();\n      expect(tree.UNSAFE_getByType(Image).props).toMatchObject({\n        resizeMode: 'repeat',\n        source: { uri: 'http://example.com/image.jpg' },\n      });\n    });\n  });\n\n  test('should apply image natural width and height when size is falsy', async () => {\n    const props = {\n      image: 'url(http://example.com/image.jpg)',\n      size: null,\n    };\n\n    const tree = renderComponent(props);\n    await timer();\n\n    await waitFor(() => {\n      expect(tree.toJSON()).not.toBeNull();\n      expect(tree).toMatchSnapshot();\n      expect(tree.UNSAFE_getByType(Image).props).toMatchObject({\n        resizeMode: 'repeat',\n        source: { uri: 'http://example.com/image.jpg' },\n      });\n\n      // value is mocked at the top\n      expect(tree.UNSAFE_getByType(Image).props.style).toEqual(\n        expect.arrayContaining([\n          {\n            minHeight: 200,\n            minWidth: 100,\n          },\n        ])\n      );\n    });\n  });\n\n  test('should apply resizeMode correctly', async () => {\n    const props = {\n      image: 'url(http://example.com/image.jpg)',\n      resizeMode: 'center',\n    };\n\n    const tree = renderComponent(props);\n    await timer();\n\n    await waitFor(() => {\n      expect(tree.toJSON()).not.toBeNull();\n      expect(tree).toMatchSnapshot();\n      expect(tree.UNSAFE_getByType(Image).props).toMatchObject({\n        resizeMode: 'center',\n        source: { uri: 'http://example.com/image.jpg' },\n      });\n    });\n  });\n\n  xit('should apply position center correctly', async () => {\n    const props = {\n      image: 'url(http://example.com/image.jpg)',\n      position: 'center',\n    };\n\n    const tree = renderComponent(props);\n\n    await waitFor(() => {\n      expect(tree.toJSON()).not.toBeNull();\n      expect(tree.UNSAFE_getByType(Image).props).toMatchObject({\n        resizeMode: 'center',\n        source: { uri: 'http://example.com/image.jpg' },\n      });\n      expect(tree.UNSAFE_getByType(Image).parent?.props.style).toEqual(\n        expect.arrayContaining([\n          {\n            alignItems: 'center',\n            justifyContent: 'center',\n          },\n        ])\n      );\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should apply resizeMode as repeat', async () => {\n    const props = {\n      image: 'url(http://example.com/image.jpg)',\n    };\n\n    const tree = renderComponent(props);\n\n    await waitFor(() => {\n      expect(tree.toJSON()).not.toBeNull();\n      expect(tree.UNSAFE_getByType(Image).props).toMatchObject({\n        resizeMode: 'repeat',\n        source: { uri: 'http://example.com/image.jpg' },\n      });\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should render with image file present in project directory', async () => {\n    const props = {\n      image: 'resources/images/american-impressionism.png',\n    };\n\n    const tree = renderComponent(props);\n    await timer();\n\n    await waitFor(() => {\n      expect(tree.toJSON()).not.toBeNull();\n      expect(tree).toMatchSnapshot();\n      expect(tree.UNSAFE_getByType(Image).props).toMatchObject({\n        resizeMode: 'repeat',\n        source: 'resources/images/american-impressionism.png',\n      });\n    });\n  });\n\n  test('should update image source if props change', async () => {\n    const tree = renderComponent({\n      image: 'example.com/image.jpg',\n      size: '80% 50%',\n    });\n\n    await waitFor(() => {\n      expect(tree.toJSON()).not.toBeNull();\n      expect(tree.UNSAFE_getByType(Image).props).toMatchObject({\n        resizeMode: 'repeat',\n        source: 'example.com/image.jpg',\n      });\n      expect(tree.UNSAFE_getByType(Image).parent?.props.style).toEqual(\n        expect.arrayContaining([\n          {\n            height: '50%',\n            width: '80%',\n          },\n        ])\n      );\n      expect(tree).toMatchSnapshot();\n    });\n\n    tree.rerender(\n      <AssetProvider value={(path) => path}>\n        <BackgroundComponent\n          image=\"example.com/new-image.jpg\"\n          size=\"20% 100%\"\n        />\n      </AssetProvider>\n    );\n\n    await waitFor(() => {\n      expect(tree.toJSON()).not.toBeNull();\n      expect(tree.UNSAFE_getByType(Image).props).toMatchObject({\n        resizeMode: 'repeat',\n        source: 'example.com/new-image.jpg',\n      });\n      expect(tree.UNSAFE_getByType(Image).parent?.props.style).toEqual(\n        expect.arrayContaining([\n          {\n            height: '100%',\n            width: '20%',\n          },\n        ])\n      );\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should render image when valid image full path is provided', async () => {\n    const tree = renderComponent({\n      image: 'http://example.com/image.jpg',\n    });\n\n    await waitFor(() => {\n      expect(tree.toJSON()).not.toBeNull();\n      expect(tree.UNSAFE_getByType(Image).props.source).toMatchObject({\n        uri: 'http://example.com/image.jpg',\n      });\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should set resizeMode based on size prop as \"contain\"', async () => {\n    const tree = renderComponent({\n      image: 'http://example.com/image.jpg',\n      size: 'contain',\n    });\n\n    await waitFor(() => {\n      expect(tree.toJSON()).not.toBeNull();\n      expect(tree.UNSAFE_getByType(Image).props).toMatchObject({\n        source: { uri: 'http://example.com/image.jpg' },\n        resizeMode: 'contain',\n      });\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  xit('should render when position has two values', async () => {\n    const tree = renderComponent({\n      image: 'http://example.com/image.jpg',\n      position: '(top, left)',\n    });\n\n    await waitFor(() => {\n      expect(tree.toJSON()).not.toBeNull();\n      expect(tree.UNSAFE_getByType(Image).props).toMatchObject({\n        source: { uri: 'http://example.com/image.jpg' },\n      });\n      expect(tree.UNSAFE_getByType(Image).parent?.props.style).toEqual(\n        expect.arrayContaining([\n          {\n            left: 0,\n            top: 0,\n          },\n        ])\n      );\n      expect(tree).toMatchSnapshot();\n    });\n\n    tree.rerender(\n      <AssetProvider value={(path) => path}>\n        <BackgroundComponent\n          image=\"http://example.com/image.jpg\"\n          position=\"(top, right)\"\n        />\n      </AssetProvider>\n    );\n\n    await waitFor(() => {\n      expect(tree.toJSON()).not.toBeNull();\n      expect(tree.UNSAFE_getByType(Image).props).toMatchObject({\n        source: { uri: 'http://example.com/image.jpg' },\n      });\n      expect(tree.UNSAFE_getByType(Image).parent?.props.style).toEqual(\n        expect.arrayContaining([\n          {\n            right: 0,\n            top: 0,\n          },\n        ])\n      );\n      expect(tree).toMatchSnapshot();\n    });\n\n    tree.rerender(\n      <AssetProvider value={(path) => path}>\n        <BackgroundComponent\n          image=\"http://example.com/image.jpg\"\n          position={'(bottom, right)'}\n        />\n      </AssetProvider>\n    );\n\n    await waitFor(() => {\n      expect(tree.toJSON()).not.toBeNull();\n      expect(tree.UNSAFE_getByType(Image).props).toMatchObject({\n        source: { uri: 'http://example.com/image.jpg' },\n      });\n      expect(tree.UNSAFE_getByType(Image).parent?.props.style).toEqual(\n        expect.arrayContaining([\n          {\n            right: 0,\n            bottom: 0,\n          },\n        ])\n      );\n      expect(tree).toMatchSnapshot();\n    });\n\n    tree.rerender(\n      <AssetProvider value={(path) => path}>\n        <BackgroundComponent\n          image=\"http://example.com/image.jpg\"\n          position={'(bottom, left)'}\n        />\n      </AssetProvider>\n    );\n\n    await waitFor(() => {\n      expect(tree.toJSON()).not.toBeNull();\n      expect(tree.UNSAFE_getByType(Image).props).toMatchObject({\n        source: { uri: 'http://example.com/image.jpg' },\n      });\n      expect(tree.UNSAFE_getByType(Image).parent?.props.style).toEqual(\n        expect.arrayContaining([\n          {\n            left: 0,\n            bottom: 0,\n          },\n        ])\n      );\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should render with different repeat props', async () => {\n    const tree = renderComponent({\n      image: 'http://example.com/image.jpg',\n      repeat: 'no-repeat',\n      size: null,\n    });\n\n    await waitFor(() => {\n      expect(tree.toJSON()).not.toBeNull();\n      expect(tree.UNSAFE_getByType(Image).props).toMatchObject({\n        source: { uri: 'http://example.com/image.jpg' },\n      });\n      expect(tree.UNSAFE_getByType(Image).parent?.props.style).toEqual(\n        expect.arrayContaining([\n          {\n            height: 200,\n            width: 100,\n          },\n        ])\n      );\n      expect(tree).toMatchSnapshot();\n    });\n\n    tree.rerender(\n      <AssetProvider value={(path) => path}>\n        <BackgroundComponent\n          image=\"http://example.com/image.jpg\"\n          repeat=\"repeat-x\"\n          size={null}\n        />\n      </AssetProvider>\n    );\n\n    await waitFor(() => {\n      expect(tree.toJSON()).not.toBeNull();\n      expect(tree.UNSAFE_getByType(Image).props).toMatchObject({\n        source: { uri: 'http://example.com/image.jpg' },\n        resizeMode: 'repeat',\n      });\n      expect(tree.UNSAFE_getByType(Image).parent?.props.style).toEqual(\n        expect.arrayContaining([\n          {\n            height: 200,\n            width: '100%',\n          },\n        ])\n      );\n      expect(tree).toMatchSnapshot();\n    });\n\n    tree.rerender(\n      <AssetProvider value={(path) => path}>\n        <BackgroundComponent\n          image=\"http://example.com/image.jpg\"\n          repeat=\"repeat-y\"\n          size={null}\n        />\n      </AssetProvider>\n    );\n\n    await waitFor(() => {\n      expect(tree.toJSON()).not.toBeNull();\n      expect(tree.UNSAFE_getByType(Image).props).toMatchObject({\n        source: { uri: 'http://example.com/image.jpg' },\n      });\n      expect(tree.UNSAFE_getByType(Image).parent?.props.style).toEqual(\n        expect.arrayContaining([\n          {\n            width: 100,\n            height: '100%',\n          },\n        ])\n      );\n      expect(tree).toMatchSnapshot();\n    });\n  });\n});\n", "wavemaker-rn-runtime/test/styles/theme.spec.ts": "import { BaseStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport BaseTheme, { AllStyle, Theme } from '@wavemaker/app-rn-runtime/styles/theme';\n\ndescribe('Test theme functionality', () => {\n    test('Check Base Theme', () => {\n        expect(BaseTheme instanceof Theme).toBeTruthy();\n    });\n    test('Check Theme creation by extending', () => {\n        const theme = BaseTheme.$new('test', {});\n        expect(theme instanceof Theme).toBeTruthy();\n    });\n    test('Check adding styles to a theme', () => {\n        const child = BaseTheme.$new('test');\n        child.addStyle('style1', '', { color: 'black'} as any);\n        expect(child.getStyle('style1').color).toEqual('black');\n    });\n    test('Check adding new styles by extending old styles', () => {\n        const child = BaseTheme.$new('test');\n        child.addStyle('style1', '', { color: 'black', paddingTop: 5} as any);\n        child.addStyle('style2', 'style1', { color: 'white'} as any);\n        expect(child.getStyle('style2').color).toEqual('white');\n        expect(child.getStyle('style2').paddingTop).toEqual(5);\n    });\n    test('Check child can access styles in parent but not vice versa', () => {\n        const parent = BaseTheme.$new('test1');\n        const child = parent.$new('test2');\n        parent.addStyle('style1', '', { color: 'black', paddingTop: 5} as any);\n        child.addStyle('style2', 'style1', { color: 'white'} as any);\n        expect(parent.getStyle('style1').color).toEqual('black');\n        expect(child.getStyle('style1').paddingTop).toEqual(5);\n        expect(child.getStyle('style2').color).toEqual('white');\n        expect(child.getStyle('style2').paddingTop).toEqual(5);\n    });\n});\n\ndescribe.skip('check trace', () => {\n    test('check trace', () => {\n        const style = BaseTheme.$new('testTheme', {\n            testStyle: {\n                root: {\n                    color: 'black'\n                }\n            } as BaseStyles\n        }).getStyle('testStyle');\n        expect(style.root.__trace[0].name).toEqual('@testTheme:testStyle.root');\n    });\n    test('check hierarchy trace', () => {\n        const parent = BaseTheme.$new('parent', {\n            test: {\n                root: {\n                    color: 'black', \n                    paddingTop: 5\n                }\n            } as BaseStyles\n        });\n        const child = parent.$new('child', {\n            test: {\n                root: {\n                    color: 'black', \n                    paddingBottom: 5\n                }\n            }\n        });\n        const heirarchyStyle = child.getStyle('test');\n        expect(heirarchyStyle.root.__trace[0].name).toEqual('@child:test.root');\n        expect(heirarchyStyle.root.__trace[1].name).toEqual('@parent:test.root');\n    });\n    test('check merge trace', () => {\n        const parent = BaseTheme.$new('parent', {\n            test: {\n                root: {\n                    color: 'black', \n                    paddingTop: 5\n                }\n            } as BaseStyles\n        });\n        const child = parent.$new('child', {\n            test: {\n                root: {\n                    color: 'black', \n                    paddingBottom: 5\n                },\n                icon: {\n                    text: {\n                        fontSize: 12\n                    }\n                }\n            } as any,\n            test1: {\n                root: {\n                    color: 'red', \n                    paddingLeft: 5\n                },\n                icon: {\n                    root: {\n                        width: 100\n                    },\n                    text: {\n                        fontSize: 20\n                    }\n                }\n            } as any\n        });\n        const mergeStyle = child.getStyle('test test1');\n        expect(mergeStyle.root.__trace[0].name).toEqual('@child:test1.root');\n        expect(mergeStyle.root.__trace[1].name).toEqual('@child:test.root');\n        expect(mergeStyle.root.__trace[2].name).toEqual('@parent:test.root');\n        expect(mergeStyle.icon.root.__trace[0].name).toEqual('@child:test1.icon.root');\n        expect(mergeStyle.icon.text.__trace[0].name).toEqual('@child:test1.icon.text');\n        expect(mergeStyle.icon.text.__trace[1].name).toEqual('@child:test.icon.text');\n    });\n});", "wavemaker-rn-runtime/test/components/page.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport { View, Text, TouchableOpacity } from 'react-native';\nimport { BackgroundComponent } from '@wavemaker/app-rn-runtime/styles/background.component';\nimport WmPage from '@wavemaker/app-rn-runtime/components//page/page.component';\nimport {\n  render,\n  screen,\n  fireEvent,\n  waitFor,\n} from '@testing-library/react-native';\n\nconst renderComponent = (props = {}) => {\n  return render(<WmPage name=\"test_Page\" {...props} />);\n};\n\ndescribe('Test Page component', () => {\n  it('should render page component', () => {\n    const tree = renderComponent();\n    expect(tree).toMatchSnapshot();\n    expect(tree).not.toBeNull();\n    expect(tree).toBeDefined();\n  });\n\n  it('should render page component with root styles', () => {\n    const tree = renderComponent();\n    const rootEle = tree.root;\n    expect(rootEle.props.style.flexDirection).toBe('column');\n    expect(rootEle.props.style.top).toBe(0);\n    expect(rootEle.props.style.left).toBe(0);\n    expect(rootEle.props.style.right).toBe(0);\n    expect(rootEle.props.style.bottom).toBe(0);\n    expect(rootEle.props.style.position).toBe('absolute');\n\n    const styles = {\n      root: {\n        flexDirection: 'column',\n        top: 10,\n        left: 20,\n        right: 30,\n        bottom: 40,\n        position: 'absolute',\n      },\n    };\n    //rerender\n    tree.rerender(<WmPage name=\"test_Page\" styles={styles} />);\n    expect(rootEle.props.style.flexDirection).toBe('column');\n    expect(rootEle.props.style.top).toBe(10);\n    expect(rootEle.props.style.left).toBe(20);\n    expect(rootEle.props.style.right).toBe(30);\n    expect(rootEle.props.style.bottom).toBe(40);\n    expect(rootEle.props.style.position).toBe('absolute');\n  });\n\n  //background Component\n  it('should render background Component', () => {\n    const tree = renderComponent();\n    const viewEle = tree.UNSAFE_queryByType(BackgroundComponent);\n    expect(viewEle).not.toBeNull();\n    expect(viewEle).toBeDefined();\n  });\n\n  //children\n  it('should render children', () => {\n    const tree = renderComponent({\n      children: (\n        <View>\n          <Text>children</Text>\n        </View>\n      ),\n    });\n    expect(tree.getByText('children')).toBeTruthy();\n  });\n});\n", "wavemaker-rn-runtime/test/components/container.component.spec.tsx": "import React, { Children, ReactNode } from 'react';\nimport { Text, TouchableOpacity } from 'react-native';\nimport { shallow } from 'enzyme';\nimport renderer from 'react-test-renderer';\nimport WmContainer from '@wavemaker/app-rn-runtime/components//container/container.component';\nimport WmContainerProps from '@wavemaker/app-rn-runtime/components/container/container.props';\nimport {\n  fireEvent,\n  render,\n  waitFor,\n  screen,\n} from '@testing-library/react-native';\nimport { ScrollView } from 'react-native-gesture-handler';\n\nconst renderComponent = (props = {}) => {\n  return render(<WmContainer name=\"test_Container\" {...props} />);\n};\n\ndescribe('Test Container component', () => {\n  const defaultProps: WmContainerProps = {\n    onLoad: jest.fn(),\n  };\n\n  test('Check validity of sample component', () => {\n    const tree = render(\n      <WmContainer name=\"test_Container\" {...defaultProps} />\n    );\n    expect(screen).toMatchSnapshot();\n  });\n\n  test('Check children are being rendered', () => {\n    const tree = render(\n      <WmContainer\n        name=\"test_Container\"\n        {...{ children: <Text>children are rendered</Text> }}\n        {...defaultProps}\n      />\n    );\n    expect(tree.getByText('children are rendered')).toBeTruthy();\n  });\n\n  test('Check onTap is being called', async () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmContainer.prototype,\n      'invokeEventCallback'\n    );\n    const onTapMock = jest.fn();\n    const tree = render(\n      <WmContainer\n        name=\"test_Container\"\n        {...{ children: <Text>children</Text>, onTap: onTapMock }}\n        {...defaultProps}\n      />\n    );\n    fireEvent.press(tree.getByText('children'));\n    await waitFor(() => {\n      expect(onTapMock).toHaveBeenCalled();\n      expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n        'onTap',\n        expect.anything()\n      );\n    });\n  });\n\n  test('Check DoubleTap is being called', async () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmContainer.prototype,\n      'invokeEventCallback'\n    );\n    const onDoubletapMock = jest.fn();\n    const tree = render(\n      <WmContainer\n        name=\"test_Container\"\n        {...{ children: <Text>children</Text>, onDoubletap: onDoubletapMock }}\n        {...defaultProps}\n      />\n    );\n    fireEvent.press(tree.getByText('children'));\n    fireEvent.press(tree.getByText('children'));\n    await waitFor(() => {\n      expect(onDoubletapMock).toHaveBeenCalled();\n      expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n        'onDoubletap',\n        expect.anything()\n      );\n    });\n  });\n\n  test('Check LongTap is being called', async () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmContainer.prototype,\n      'invokeEventCallback'\n    );\n    const onLongTapMock = jest.fn();\n    const tree = render(\n      <WmContainer\n        name=\"test_Container\"\n        {...{ children: <Text>children</Text>, onLongtap: onLongTapMock }}\n        {...defaultProps}\n      />\n    );\n    fireEvent(tree.getByText('children'), 'longPress');\n    await waitFor(() => {\n      expect(onLongTapMock).toHaveBeenCalled();\n      expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n        'onLongtap',\n        expect.anything()\n      );\n    });\n  });\n\n  xit('Check onTouchstart is being called', async () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmContainer.prototype,\n      'invokeEventCallback'\n    );\n    const onTouchStartMock = jest.fn();\n    const tree = render(\n      <WmContainer\n        name=\"test_Container\"\n        {...{ children: <Text>children</Text>, onTouchstart: onTouchStartMock }}\n        {...defaultProps}\n      />\n    );\n    fireEvent(tree.getByText('children'), 'press');\n    await waitFor(() => {\n      expect(onTouchStartMock).toHaveBeenCalled();\n      expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n        'onTouchstart',\n        expect.anything()\n      );\n    });\n  });\n\n  xit('Check onTouchend is being called', async () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmContainer.prototype,\n      'invokeEventCallback'\n    );\n    const onTouchEndMock = jest.fn();\n    const tree = render(\n      <WmContainer\n        name=\"test_Container\"\n        {...{ children: <Text>children</Text>, onTouchend: onTouchEndMock }}\n        {...defaultProps}\n      />\n    );\n    fireEvent(tree.getByText('children'), 'pressOut');\n    await waitFor(() => {\n      expect(onTouchEndMock).toHaveBeenCalled();\n      expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n        'onTouchend',\n        expect.anything()\n      );\n    });\n  });\n\n  test('Check if width height styles are being applied', () => {\n    const tree = render(\n      <WmContainer\n        name=\"test_Container\"\n        {...{ styles: { root: { width: '100%', height: '100%' } } }}\n        {...defaultProps}\n      />\n    );\n    expect(screen.root.props.style.width).toBe('100%');\n    expect(screen.root.props.style.height).toBe('100%');\n  });\n\n  test('render skeleton if showskeleton is true and showskeletonchildren is true', async () => {\n    const renderSkeletonMock = jest.spyOn(\n      WmContainer.prototype,\n      'renderSkeleton'\n    );\n\n    const tree = render(\n      <WmContainer\n        name=\"test_Container\"\n        {...{\n          children: <Text>hii</Text>,\n          showskeleton: true,\n          showskeletonchildren: true,\n        }}\n        {...defaultProps}\n      />\n    );\n    expect(screen).toMatchSnapshot();\n\n    expect(renderSkeletonMock).toHaveBeenCalled();\n    const viewElement = tree.getByTestId('non_animatableView');\n    expect(viewElement.props.style.backgroundColor).toBe('transparent');\n    expect(viewElement.props.style.borderColor).toBe('transparent');\n    expect(viewElement.props.style.shadowColor).toBe('transparent');\n    renderSkeletonMock.mockRestore();\n  });\n\n  test('render skeleton if showskeleton is true and showskeletonchildren is false', async () => {\n    const renderSkeletonMock = jest.spyOn(\n      WmContainer.prototype,\n      'renderSkeleton'\n    );\n\n    const tree = render(\n      <WmContainer\n        name=\"test_Container\"\n        {...{\n          children: <Text>hii</Text>,\n          showskeleton: true,\n          showskeletonchildren: false,\n        }}\n        {...defaultProps}\n      />\n    );\n    expect(screen).toMatchSnapshot();\n    expect(renderSkeletonMock).toHaveBeenCalled();\n    expect(screen.root.children[0].props.style[1].opacity).toBe(0);\n    renderSkeletonMock.mockRestore();\n  });\n\n  test('should render partial content', async () => {\n    const onLoadMock = jest.fn();\n\n    const tree = render(\n      <WmContainer\n        name=\"test_Container\"\n        onLoad={onLoadMock()}\n        {...{\n          renderPartial: (props: any, onLoad: any) => {\n            onLoad();\n            return <Text>container partial content</Text>;\n          },\n        }}\n        {...defaultProps}\n      />\n    );\n    expect(screen.getByText('container partial content')).toBeTruthy();\n    await waitFor(() => {\n      expect(onLoadMock).toHaveBeenCalled();\n    });\n  });\n\n  it('should render scrollView when scrollable prop is true', () => {\n    renderComponent({ scrollable: true });\n    const viewEle = screen.UNSAFE_queryByType(ScrollView);\n    expect(viewEle).not.toBeNull();\n    expect(viewEle).toBeDefined();\n  });\n\n  it('should not render scrollView when scrollable prop is false', () => {\n    renderComponent({ scrollable: false });\n    const viewEle = screen.UNSAFE_queryByType(ScrollView);\n    expect(viewEle).toBeNull();\n  });\n});\n", "wavemaker-rn-runtime/test/components/advanced/login.component.spec.tsx": "import React, { ReactNode, createRef, useRef } from 'react';\nimport { Text, TouchableOpacity } from 'react-native';\nimport WmLogin from '@wavemaker/app-rn-runtime/components/advanced/login/login.component';\n\nimport { render, fireEvent, act, waitFor } from '@testing-library/react-native';\nimport WmLoginProps from '@wavemaker/app-rn-runtime/components/advanced/login/login.props';\nimport { ThemeProvider } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { AxiosError, AxiosResponse } from 'axios';\nimport ThemeVariables from '../../../src/styles/theme.variables';\n\n// Mock Theme\nconst mockTheme = {\n  getStyle: (styleName: string) => ({}), // Adjust based on required styles\n  mergeStyle: (style1, style2) => ({ ...style1, ...style2 }),\n};\n\nconst renderWithTheme = (component: React.ReactElement) => {\n  return render(<ThemeProvider value={mockTheme}>{component}</ThemeProvider>);\n};\n\ndescribe('WmLogin', () => {\n  it('renders correctly with default props', () => {\n    const props: WmLoginProps = { children: <></>, onLogin: jest.fn() };\n\n    const tree = render(<WmLogin {...props} />);\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('calls onLogin function when doLogin is executed', () => {\n    const onLoginMock = jest.fn();\n    const ref = createRef();\n    const formData = { username: 'test', password: 'test' };\n    const props: WmLoginProps = { children: <></>, onLogin: onLoginMock };\n\n    const tree = render(<WmLogin {...props} ref={ref} />);\n    act(() => {\n      ref.current.doLogin(formData);\n    });\n\n    expect(onLoginMock).toHaveBeenCalledWith(\n      formData,\n      expect.any(Function),\n      expect.any(Function)\n    );\n  });\n\n  it('renders children components', () => {\n    const props: WmLoginProps = {\n      children: <Text testID=\"child\">Login Form</Text>,\n      onLogin: jest.fn(),\n    };\n\n    const { getByTestId } = render(<WmLogin {...props} />);\n    const childComponent = getByTestId('child');\n\n    expect(childComponent).toBeTruthy();\n    expect(childComponent.props.children).toBe('Login Form');\n  });\n\n  it('triggers onLoginSuccess callback correctly', () => {\n    const response = { data: 'success' } as AxiosResponse;\n    const ref = createRef();\n    const onLoginMock = jest.fn((formData, onSuccess) => {\n      onSuccess(response);\n    });\n\n    const props: WmLoginProps = { children: <></>, onLogin: onLoginMock };\n    const onLoginSuccess = jest.spyOn(WmLogin.prototype, 'onLoginSuccess');\n    const { getByTestId } = render(<WmLogin {...props} ref={ref} />);\n\n    act(() => {\n      ref.current.doLogin({});\n    });\n\n    expect(onLoginMock).toHaveBeenCalled();\n    expect(onLoginSuccess).toHaveBeenCalled();\n  });\n\n  it('triggers onLoginError callback correctly and shows error', async () => {\n    const error = { message: 'Error occurred' } as AxiosError;\n    const ref = createRef();\n    const onLoginMock = jest.fn((formData, onSuccess, onError) => {\n      onError(error);\n    });\n\n    const props: WmLoginProps = { children: <></>, onLogin: onLoginMock };\n    const onLoginError = jest.spyOn(WmLogin.prototype, 'onLoginError');\n    const { getByText } = render(<WmLogin {...props} ref={ref} />);\n\n    act(() => {\n      ref.current.doLogin({});\n    });\n    const themeVariables = new ThemeVariables();\n    expect(onLoginMock).toHaveBeenCalled();\n    await waitFor(() => {\n      const errorText = getByText(error.message);\n      expect(errorText).toBeTruthy();\n      expect(errorText.props.style.backgroundColor).toBe(\n        themeVariables.loginErrorMsgBgColor\n      );\n      expect(errorText.props.style.borderColor).toBe(\n        themeVariables.loginErrorMsgBorderColor\n      );\n    });\n    expect(onLoginError).toHaveBeenCalled();\n  });\n\n  it('should have width and height to be 0 when show is false', () => {\n    const props = {\n      children: <></>,\n      onLogin: jest.fn(),\n      show: false,\n    };\n\n    const tree = render(<WmLogin {...props} />);\n    const rootElement = tree.root;\n    expect(rootElement.props.style.width).toBe(0);\n    expect(rootElement.props.style.height).toBe(0);\n  });\n\n  it('should render width and height', () => {\n    const width = 50;\n    const height = 70;\n    const props = {\n      children: <></>,\n      onLogin: jest.fn(),\n      styles: {\n        root: {\n          width: width,\n          height: height,\n        },\n      },\n    };\n    const tree = render(<WmLogin {...props} />);\n    const rootElement = tree.root;\n\n    expect(rootElement.props.style.width).toBe(width);\n    expect(rootElement.props.style.height).toBe(height);\n  });\n});\n", "wavemaker-rn-runtime/test/components/advanced/webview.component.spec.tsx": "import React, { createRef } from 'react';\nimport { AccessibilityInfo, Platform, View } from 'react-native';\nimport { act, fireEvent, render, waitFor } from '@testing-library/react-native';\nimport WmWebview from '@wavemaker/app-rn-runtime/components/advanced/webview/webview.component';\nimport * as accessibilityUtils from '@wavemaker/app-rn-runtime/core/accessibility';\nimport {\n  BackHandler as RNBackHandler,\n  BackHandlerStatic as RNBackHandlerStatic,\n} from 'react-native';\n\njest.mock('react-native/Libraries/Utilities/BackHandler', () =>\n  require('react-native/Libraries/Utilities/__mocks__/BackHandler')\n);\ninterface BackHandlerStatic extends RNBackHandlerStatic {\n  mockPressBack(): void;\n}\n\nconst BackHandler = RNBackHandler as BackHandlerStatic;\n\ndescribe('Test Webview component', () => {\n  const baseProps = {\n    id: 'wm',\n    name: 'webview-component',\n    src: 'https://example.com',\n    incognito: false,\n    onLoad: jest.fn(),\n  };\n\n  const invokeEventCallbackMock = jest.spyOn(\n    WmWebview.prototype,\n    'invokeEventCallback'\n  );\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  test('should render WmWebview component with given src', async () => {\n    const tree = render(<WmWebview {...baseProps} />);\n    const webview = tree.getByTestId('wm_web_view');\n\n    // await waitFor(()=>{\n    //   expect(webview.props.source).toBeDefined();\n    // })\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render component with accessibility props', async () => {\n    const props = {\n      ...baseProps,\n      accessibilitylabel: 'wm-web-view',\n      hint: 'this is a web view',\n      accessibilityrole: 'web-view-wm',\n    };\n    const tree = render(<WmWebview {...props} />);\n\n    expect(tree.getByTestId('wm_web_view')).toBeDefined();\n    expect(tree.getByLabelText('wm-web-view')).toBeDefined();\n    expect(tree.getByAccessibilityHint('this is a web view')).toBeDefined();\n    expect(tree.getByTestId('wm_web_view').props.accessibilityRole).toBe(\n      'web-view-wm'\n    );\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should handle onLoad callback when content is loaded', async () => {\n    const tree = render(<WmWebview {...baseProps} />);\n    const webview = tree.getByTestId('wm_web_view');\n\n    const event = {\n      nativeEvent: {\n        title: 'Example Page',\n        url: 'https://example.com',\n      },\n    };\n\n    fireEvent(webview, 'onLoadEnd', event);\n\n    await waitFor(() => {\n      expect(baseProps.onLoad).toHaveBeenCalledWith(\n        event,\n        expect.any(WmWebview)\n      );\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should inject JavaScript and handle result', async () => {\n    const customRef = createRef<WmWebview>();\n    render(<WmWebview {...baseProps} ref={customRef} />);\n\n    const invokeScriptFn = jest.spyOn(\n      customRef.current.webview,\n      'injectJavaScript'\n    );\n\n    customRef.current.executeScript(`function(){console.log(\"hello world\")}`);\n    expect(invokeScriptFn).toHaveBeenCalled();\n    expect(invokeScriptFn).toHaveBeenCalledWith(\n      expect.stringContaining(`function(){console.log(\"hello world\")}`)\n    );\n  });\n\n  test('should handle BackHandler for Android', () => {\n    Platform.OS = 'android';\n    const customRef = createRef<WmWebview>();\n\n    // const backHandlerSpy = jest.spyOn(\n    //   WmWebview.prototype,\n    //   'handleBackButtonPress'\n    // );\n    render(<WmWebview {...baseProps} ref={customRef} />);\n\n    // hardwareBackPress;\n\n    BackHandler.mockPressBack();\n\n    // expect(backHandlerSpy).toHaveBeenCalled();\n  });\n\n  test('should use incognito mode if incognito prop is true', () => {\n    const props = {\n      ...baseProps,\n      incognito: true,\n    };\n\n    const { getByTestId } = render(<WmWebview {...props} />);\n    const webview = getByTestId('wm_web_view');\n\n    expect(webview.props.incognito).toBe(true);\n  });\n\n  test('should handle onMessage callback when a message is received', () => {\n    const parseResultMock = jest.spyOn(WmWebview.prototype, 'parseResult');\n    const customRef = createRef<WmWebview>();\n    const { getByTestId } = render(\n      <WmWebview {...baseProps} ref={customRef} />\n    );\n    const webview = getByTestId('wm_web_view');\n\n    const event = {\n      nativeEvent: {\n        data: 'test message',\n      },\n    };\n\n    fireEvent(webview, 'onMessage', event);\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith('onMessage', [\n      event,\n      expect.anything(),\n    ]);\n\n    act(() => {\n      customRef.current.invokeJSCallbacks = {\n        1: (arg) => arg,\n      };\n    });\n\n    event.nativeEvent = {\n      data: 'afterInjectJavaScript:1:function()',\n    };\n\n    fireEvent(webview, 'onMessage', event);\n    expect(parseResultMock).toHaveBeenCalled();\n  });\n\n  test('should parse the result correctly from executeScript', () => {\n    const parseResultMock = jest.spyOn(WmWebview.prototype, 'parseResult');\n    const customRef = createRef<WmWebview>();\n    const { getByTestId } = render(\n      <WmWebview {...baseProps} ref={customRef} />\n    );\n    const webview = getByTestId('wm_web_view');\n\n    act(() => {\n      customRef.current.invokeJSCallbacks = {\n        1: (arg) => arg,\n      };\n    });\n\n    const event = {\n      nativeEvent: {\n        data: 'afterInjectJavaScript:1:{value: \"wm-web-view\"}',\n      },\n    };\n\n    fireEvent(webview, 'onMessage', event);\n    expect(parseResultMock).toHaveBeenCalled();\n    expect(parseResultMock).toHaveBeenCalledWith('{value: \"wm-web-view\"}');\n  });\n\n  test('should handle insertCSS correctly', async () => {\n    const executeScriptMock = jest.spyOn(WmWebview.prototype, 'executeScript');\n    const customRef = createRef();\n    render(<WmWebview {...baseProps} ref={customRef} />);\n    let result;\n\n    act(() => {\n      result = customRef.current.insertCSS('body { background-color: red; }');\n    });\n\n    expect(executeScriptMock).toHaveBeenCalled();\n    await waitFor(() => {\n      expect(result).toMatchObject({});\n    });\n  });\n\n  // test('should render iframe when Platform is web', () => {\n  //   jest.mock(iframe, ()=><View/>)\n  //   Platform.OS = 'web';\n  //   const tree = render(<WmWebview {...baseProps}/>);\n\n  //   expect(tree.UNSAFE_getByType(<iframe/>)).toBeDefined();\n  // })\n});\n", "wavemaker-rn-runtime/test/components/advanced/carousel.component.spec.tsx": "import React, { createRef } from 'react';\nimport {\n  act,\n  fireEvent,\n  render,\n  screen,\n  waitFor,\n} from '@testing-library/react-native';\nimport WmCarousel from '@wavemaker/app-rn-runtime/components/advanced/carousel/carousel.component';\nimport { View, Text } from 'react-native';\n\nimport TimingAnimation from 'react-native/Libraries/Animated/animations/TimingAnimation';\n\njest.mock('react-native/Libraries/Animated/Easing', () => {\n  const originalModule = jest.requireActual(\n    'react-native/Libraries/Animated/Easing'\n  );\n  return {\n    _esModule: true,\n    default: {\n      ...originalModule,\n      linear: jest.fn(() => 'linear-mock'),\n      ease: jest.fn(() => 'ease-mock'),\n      bounce: jest.fn(() => 'bounce-mock'),\n      in: jest.fn(() => 'in-mock'),\n      out: jest.fn(() => 'out-mock'),\n      inOut: jest.fn(() => 'inOut-mock'),\n      bezier: jest.fn(),\n      // Add other methods you use if needed\n    },\n  };\n});\n\njest.mock('react-native/Libraries/Animated/animations/TimingAnimation', () => {\n  const originalModule = jest.requireActual(\n    'react-native/Libraries/Animated/animations/TimingAnimation'\n  );\n\n  // Create a mock class that extends the original\n  class MockTimingAnimation extends originalModule.default {\n    constructor(config) {\n      super(config);\n      this._easing = jest.fn(originalModule.default.prototype._easing);\n    }\n\n    // You can add or override more methods here if needed\n    start = jest.fn(originalModule.default.prototype.start);\n    // start(fromValue, onUpdate, onEnd) {\n    //   onUpdate(this._toValue);\n    //   onEnd({ finished: true });\n    // }\n    onUpdate = jest.fn(originalModule.default.prototype.onUpdate);\n    stop = jest.fn(originalModule.default.prototype.stop);\n  }\n\n  return {\n    __esModule: true,\n    default: MockTimingAnimation,\n  };\n});\n\nimport { Easing } from 'react-native';\n\njest.mock('react-native/Libraries/Animated/nodes/AnimatedInterpolation', () => {\n  return {\n    __esModule: true,\n    default: jest.fn((parent, config) => ({\n      _parent: parent,\n      _config: {\n        inputRange: [0, 1],\n        outputRange: [0, 1],\n        easing: jest.fn(),\n        extrapolate: 'extend',\n        extrapolateLeft: 'extend',\n        extrapolateRight: 'extend',\n        ...config,\n      },\n      interpolate: jest.fn(),\n      __getValue: jest.fn(),\n      __attach: jest.fn(),\n      __detach: jest.fn(),\n      __getNativeConfig: jest.fn(),\n    })),\n  };\n});\n\nconst renderComponent = (props = {}) => {\n  return render(<WmCarousel {...props} name=\"test_carousel\" />);\n};\n\nconst timer = (time = 100) =>\n  new Promise((resolve: any, reject) => {\n    setTimeout(() => resolve(), time);\n  });\n\ndescribe('WmCarousel Component', () => {\n  it('should render without crashing', () => {\n    const { toJSON } = renderComponent();\n    expect(toJSON()).toMatchSnapshot();\n  });\n\n  it('should render children components correctly', () => {\n    const tree = renderComponent({\n      children: [\n        <View key=\"slide1\">\n          <Text>Slide 1</Text>\n        </View>,\n        <View key=\"slide2\">\n          <Text>Slide 2</Text>\n        </View>,\n      ],\n    });\n    const childElementWithLayout = tree.toJSON()[1].children[0];\n\n    fireEvent(childElementWithLayout, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 100,\n          height: 100,\n        },\n      },\n    });\n    expect(tree.getByText('Slide 1')).toBeTruthy();\n    expect(tree.getByText('Slide 2')).toBeTruthy();\n  });\n\n  it('should render pagination dots when indicators are enabled', () => {\n    renderComponent({\n      controls: 'indicators',\n      children: [\n        <View key=\"slide1\">\n          <Text>Slide 1</Text>\n        </View>,\n        <View key=\"slide2\">\n          <Text>Slide 2</Text>\n        </View>,\n      ],\n    });\n\n    expect(screen.getByTestId('test_carousel_indicator0')).toBeTruthy();\n    expect(screen.getByTestId('test_carousel_indicator1')).toBeTruthy();\n  });\n\n  it('should render pagination dots based on the dataset length', () => {\n    const dataset = [\n      <View key=\"slide1\">\n        <Text>Slide 1</Text>\n      </View>,\n      <View key=\"slide2\">\n        <Text>Slide 2</Text>\n      </View>,\n      <View key=\"slide3\">\n        <Text>Slide 3</Text>\n      </View>,\n      <View key=\"slide4\">\n        <Text>Slide 4</Text>\n      </View>,\n      <View key=\"slide5\">\n        <Text>Slide 5</Text>\n      </View>,\n      <View key=\"slide6\">\n        <Text>Slide 6</Text>\n      </View>,\n    ];\n  \n    renderComponent({\n      controls: 'indicators',\n      children: dataset,\n    });\n  \n    const expectedDots = dataset.length > 5 ? 5 : dataset.length;\n    for (let i = 0; i < expectedDots; i++) {\n      expect(screen.getByTestId(`test_carousel_indicator${i}`)).toBeTruthy();\n    }\n  });\n  \n  it('should render pagination dots based on the dataset length for dynamic carousel', () => {\n    const dataset = [\n      {\n        \"imagesrc\": \"https://picsum.photos/200/300\"\n      },\n      {\n        \"imagesrc\": \"https://picsum.photos/200/300\"\n      },\n      {\n        \"imagesrc\": \"https://picsum.photos/200/300\"\n      }\n    ];\n  \n    renderComponent({\n      controls: 'indicators',\n      dataset: dataset,\n      type: \"dynamic\",\n      renderSlide: (item: any, index: any, that: any) => {\n        return (\n          <View key={`${index}`} testID={`carousel_${index}`}>\n            <Text>Slide {index}</Text>\n          </View>\n        )\n      }\n    });\n  \n    const expectedDots = dataset.length > 5 ? 5 : dataset.length;\n    for (let i = 0; i < expectedDots; i++) {\n      expect(screen.getByTestId(`carousel_${i}`)).toBeTruthy();\n    }\n  });\n  \n  xit('should navigate to the next slide on press of any item inside carousel content', async () => {\n    const ref = createRef();\n    const onChangeMock = jest.fn();\n    const { getByLabelText } = renderComponent({\n      ref,\n      animation: 'none',\n      controls: 'navs',\n      onChange: onChangeMock,\n      children: [\n        <View key=\"slide1\">\n          <Text>Slide 1</Text>\n        </View>,\n        <View key=\"slide2\">\n          <Text>Slide 2</Text>\n        </View>,\n      ],\n    });\n\n    const slide1Content = screen.getByText('Slide 1');\n\n    await timer(1000); // timer added because of the settimeout present in autoPlay() else condition\n\n    await act(async () => {\n      fireEvent.press(slide1Content);\n      await timer(300);\n    });\n    expect(screen.getByText('Slide 2')).toBeTruthy();\n\n    expect(ref.current.state.activeIndex).toBe(2);\n    expect(onChangeMock).toHaveBeenCalledWith(ref.current.proxy, 2, 1);\n  });\n\n  it('should enable controls (both nav and indicators) when controls are set to \"both\"', () => {\n    renderComponent({\n      controls: 'both',\n      children: [\n        <View key=\"slide1\">\n          <Text>Slide 1</Text>\n        </View>,\n        <View key=\"slide2\">\n          <Text>Slide 2</Text>\n        </View>,\n      ],\n    });\n\n    expect(screen.getByLabelText('next')).toBeTruthy();\n    expect(screen.getByLabelText('back')).toBeTruthy();\n    expect(screen.getByTestId('test_carousel_indicator0')).toBeTruthy();\n    expect(screen.getByTestId('test_carousel_indicator1')).toBeTruthy();\n  });\n\n  it('should navigate to the next slide on next button click', async () => {\n    const ref = createRef();\n    const onChangeMock = jest.fn();\n    const { getByLabelText } = renderComponent({\n      ref,\n      animation: 'none',\n      controls: 'navs',\n      onChange: onChangeMock,\n      children: [\n        <View key=\"slide1\">\n          <Text>Slide 1</Text>\n        </View>,\n        <View key=\"slide2\">\n          <Text>Slide 2</Text>\n        </View>,\n      ],\n    });\n    const carouselItem0 = screen.getByTestId('carousel_item_0');\n    const carouselItem1 = screen.getByTestId('carousel_item_1');\n\n    act(() => {\n      fireEvent(carouselItem0, 'layout', {\n        nativeEvent: {\n          layout: {\n            x: 100,\n            y: 100,\n            width: 200,\n            height: 200,\n          },\n        },\n      });\n    });\n\n    await timer(1000);\n    const nextButton = getByLabelText('next');\n    await act(async () => {\n      fireEvent.press(nextButton);\n      await timer(500);\n    });\n    expect(screen.getByText('Slide 2')).toBeTruthy();\n\n    expect(onChangeMock).toHaveBeenCalledWith(ref.current.proxy, 2, 1);\n    expect(ref.current.state.activeIndex).toBe(2);\n\n    await act(async () => {\n      fireEvent.press(nextButton); //should go back to first slide\n      await timer(500);\n    });\n\n    expect(onChangeMock).toHaveBeenCalledWith(ref.current.proxy, 1, 2);\n    expect(ref.current.state.activeIndex).toBe(1);\n  });\n\n  it('should navigate to the previous slide on previous button click', async () => {\n    const ref = createRef();\n    const onChangeMock = jest.fn();\n    const { getByLabelText } = renderComponent({\n      ref,\n      animation: 'none',\n      controls: 'navs',\n      onChange: onChangeMock,\n      children: [\n        <View key=\"slide1\">\n          <Text>Slide 1</Text>\n        </View>,\n        <View key=\"slide2\">\n          <Text>Slide 2</Text>\n        </View>,\n      ],\n    });\n\n    const carouselItem0 = screen.getByTestId('carousel_item_0');\n    const carouselItem1 = screen.getByTestId('carousel_item_1');\n\n    act(() => {\n      fireEvent(carouselItem0, 'layout', {\n        nativeEvent: {\n          layout: {\n            x: 100,\n            y: 100,\n            width: 200,\n            height: 200,\n          },\n        },\n      });\n    });\n\n    await timer(1000);\n\n    const nextButton = getByLabelText('next');\n    await act(async () => {\n      fireEvent.press(nextButton); // Go to slide 2 first\n      await timer(500);\n    });\n\n    expect(onChangeMock).toHaveBeenCalledWith(ref.current.proxy, 2, 1);\n    expect(ref.current.state.activeIndex).toBe(2);\n\n    const prevButton = getByLabelText('back');\n    await act(async () => {\n      fireEvent.press(prevButton); // Go back to slide 1\n      await timer(500);\n    });\n\n    expect(screen.getByText('Slide 1')).toBeTruthy();\n    expect(onChangeMock).toHaveBeenCalledWith(ref.current.proxy, 1, 2);\n    expect(ref.current.state.activeIndex).toBe(1);\n  });\n\n  it('should auto-play when animation is \"auto\" and animationInterval is set', async () => {\n    const ref = createRef();\n    const onChangeMock = jest.fn();\n    renderComponent({\n      ref,\n      onChange: onChangeMock,\n      animation: 'auto',\n      animationinterval: 0.5,\n      children: [\n        <View key=\"slide1\">\n          <Text>Slide 1</Text>\n        </View>,\n        <View key=\"slide2\">\n          <Text>Slide 2</Text>\n        </View>,\n        <View key=\"slide3\">\n          <Text>Slide 3</Text>\n        </View>,\n      ],\n    });\n\n    expect(screen.getByText('Slide 1')).toBeTruthy();\n    expect(screen.getByText('Slide 2')).toBeTruthy();\n    const carouselItem0 = screen.getByTestId('carousel_item_0');\n    const carouselItem1 = screen.getByTestId('carousel_item_1');\n    const carouselItem2 = screen.getByTestId('carousel_item_2');\n\n    act(() => {\n      fireEvent(carouselItem0, 'layout', {\n        nativeEvent: {\n          layout: {\n            x: 100,\n            y: 100,\n            width: 200,\n            height: 200,\n          },\n        },\n      });\n    });\n\n    await act(async () => {\n      await timer(1600);\n    });\n    expect(onChangeMock).toHaveBeenCalledWith(ref.current.proxy, 2, 1);\n    expect(ref.current.state.activeIndex).toBe(2);\n\n    act(() => {\n      fireEvent(carouselItem1, 'layout', {\n        nativeEvent: {\n          layout: {\n            x: 100,\n            y: 100,\n            width: 200,\n            height: 200,\n          },\n        },\n      });\n    });\n\n    await act(async () => {\n      await timer(700);\n    });\n    expect(onChangeMock).toHaveBeenCalledWith(ref.current.proxy, 3, 2);\n\n    act(() => {\n      fireEvent(carouselItem2, 'layout', {\n        nativeEvent: {\n          layout: {\n            x: 100,\n            y: 100,\n            width: 200,\n            height: 200,\n          },\n        },\n      });\n    });\n\n    await act(async () => {\n      await timer(600);\n    });\n    expect(onChangeMock).toHaveBeenCalledWith(ref.current.proxy, 1, 3);\n    expect(ref.current.state.activeIndex).toBe(1);\n  }, 10000);\n\n  // it('should change active slide when swipe gestures are triggered', () => {\n  //   const { getByTestId } = renderComponent({\n  //     children: [\n  //       <View key=\"slide1\" testID=\"slide1\">\n  //         <Text>Slide 1</Text>\n  //       </View>,\n  //       <View key=\"slide2\" testID=\"slide2\">\n  //         <Text>Slide 2</Text>\n  //       </View>,\n  //     ],\n  //   });\n  //   expect(screen).toMatchSnapshot();\n  //   const animatedView = getByTestId('slide1');\n  //   fireEvent(animatedView, 'swipeLeft');\n  //   fireEvent(animatedView, 'swipeRight');\n\n  //   expect(screen.getByText('Slide 1')).toBeTruthy();\n  //   expect(screen.getByText('Slide 2')).toBeTruthy();\n  // });\n\n  it('should clear interval when stopAnimation is called', () => {\n    jest.useFakeTimers();\n    const clearIntervalMock = jest.spyOn(global, 'clearInterval');\n\n    renderComponent({\n      animation: 'auto',\n      animationinterval: 1,\n      children: [\n        <View key=\"slide1\">\n          <Text>Slide 1</Text>\n        </View>,\n        <View key=\"slide2\">\n          <Text>Slide 2</Text>\n        </View>,\n      ],\n    });\n\n    // Start autoPlay\n    const instance = screen.UNSAFE_getByType(WmCarousel).instance;\n    instance.autoPlay();\n\n    // Stop autoPlay\n    instance.stopAnimation();\n\n    // Verify that the interval has been cleared\n    expect(clearIntervalMock).toHaveBeenCalled();\n    clearIntervalMock.mockRestore();\n  });\n\n  it('should apply the correct styles to the root element', () => {\n    const tree = renderComponent({\n      styles: {\n        root: {\n          rippleColor: '#893334',\n        },\n      },\n    });\n    const rootEle = tree.toJSON()[1];\n\n    expect(rootEle).toHaveStyle({\n      position: 'relative',\n      rippleColor: '#893334',\n    });\n  });\n});\n", "wavemaker-rn-runtime/test/components/advanced/network-info-toaster.component.spec.tsx": "import React, { createRef } from 'react';\nimport { View } from 'react-native';\nimport { act, cleanup, render, waitFor } from '@testing-library/react-native';\nimport WmNetworkInfoToaster from '@wavemaker/app-rn-runtime/components/advanced/network-info-toaster/network-info-toaster.component';\nimport NetworkService from '@wavemaker/app-rn-runtime/core/network.service';\nimport {\n  ToastProvider,\n  ToastOptions,\n} from '@wavemaker/app-rn-runtime/core/toast.service';\n\nconst renderComponent = (props = {}) => {\n  const defaultProps = {\n    id: 'testToaster',\n    appLocale: {\n      messages: {\n        MESSAGE_SERVICE_CONNECTED: 'Service Connected',\n        MESSAGE_SERVICE_CONNECTING: 'Service Connecting',\n        MESSAGE_SERVICE_AVAILABLE: 'Service Available',\n        MESSAGE_NETWORK_NOT_AVAILABLE: 'Network Not Available',\n        MESSAGE_SERVICE_NOT_AVAILABLE: 'Service Not Available',\n        LABEL_HIDE_NETWORK_INFO: 'Hide Network Info',\n        LABEL_CONNECT_TO_SERVICE: 'Connect to Service',\n      },\n    },\n  };\n\n  return render(\n    <ToastProvider\n      value={{\n        showToast: (arg: ToastOptions) => <View>{arg.content}</View>,\n        hideToast: (arg: any) => null,\n      }}\n    >\n      <WmNetworkInfoToaster {...defaultProps} {...props} />\n    </ToastProvider>\n  );\n};\n\n// Mock NetworkService\njest.mock('@wavemaker/app-rn-runtime/core/network.service', () => ({\n  getState: jest.fn(),\n  isConnected: jest.fn(),\n  notifier: {\n    subscribe: jest.fn((event, callback) => {\n      if (event === 'onNetworkStateChange') {\n        callback({\n          isConnected: false,\n          isConnecting: false,\n          isServiceAvailable: false,\n          isNetworkAvailable: false,\n        });\n      }\n      return jest.fn();\n    }),\n  },\n}));\n\ndescribe('WmNetworkInfoToaster Component', () => {\n  beforeEach(() => {\n    jest.useFakeTimers();\n  });\n\n  afterEach(() => {\n    cleanup();\n    jest.useRealTimers();\n    jest.clearAllMocks();\n  })\n\n  test('should return null when network network status is same as previous', () => {\n    const tree = renderComponent();\n    expect(tree.toJSON().children).toBeNull();\n  });\n\n  test('should return null when showToast is false', async () => {\n    const customRef = createRef();\n    const tree = renderComponent({ ref: customRef });\n\n    act(() => {\n      customRef.current.setState({\n        showToast: false,\n      });\n    });\n\n    await waitFor(() => {\n      expect(customRef.current.state.showToast).toBe(false);\n      expect(tree.toJSON().children).toBeNull();\n    });\n  });\n\n  test('should return null even if showToast is true', async () => {\n    const customRef = createRef();\n    const tree = renderComponent({ ref: customRef });\n\n    act(() => {\n      customRef.current.setState({\n        showToast: true,\n      });\n    });\n\n    await waitFor(() => {\n      expect(customRef.current.state.showToast).toBe(true);\n      expect(tree.toJSON().children).toBeNull();\n    });\n  });\n\n  test('option content should have the render component', () => {\n    const customRef = createRef();\n    renderComponent({ ref: customRef });\n    const content = customRef.current.options.content;\n    const firstChildren = content.props.children[1];\n    const secondChildren = content.props.children[2].props.children;\n\n    expect(content.type.displayName).toBe('View');\n    expect(content.children).not.toBeNull();\n    expect(firstChildren.props.children).toBe('Network Not Available');\n    expect(secondChildren.props.children).toBe('Hide Network Info');\n  });\n\n  test('shows correct message for service connected', async () => {\n    (NetworkService.getState as jest.Mock).mockReturnValueOnce({\n      isConnected: true,\n      isConnecting: false,\n      isServiceAvailable: true,\n      isNetworkAvailable: true,\n    });\n    \n    const customRef = createRef();\n    const updateStateMock = jest.spyOn(\n      WmNetworkInfoToaster.prototype,\n      'updateState'\n    );\n    renderComponent({ ref: customRef });\n\n    await waitFor(() => {\n      expect(updateStateMock).toHaveBeenCalled();\n      expect(updateStateMock).toHaveBeenCalledWith({\n        newtworkState: {\n          isConnected: false,\n          isConnecting: false,\n          isServiceAvailable: false,\n          isNetworkAvailable: false,\n        },\n        showToast: true,\n      });\n    });\n  });\n\n  test('shows correct message when service available is true', async () => {\n    (NetworkService.getState as jest.Mock).mockReturnValue({\n      isConnected: false,\n      isConnecting: false,\n      isServiceAvailable: true,\n      isNetworkAvailable: false,\n    });\n\n    (NetworkService.notifier.subscribe as jest.Mock).mockImplementation(\n      () => {}\n    );\n\n    const customRef = createRef();\n    renderComponent({ ref: customRef });\n    const content = customRef.current.options.content;\n    const firstChildren = content.props.children[1];\n    const secondChildren = content.props.children[2].props.children;\n    const thirdChildren = content.props.children[4].props.children;\n\n    expect(content.type.displayName).toBe('View');\n    expect(content.children).not.toBeNull();\n    expect(firstChildren.props.children).toBe('Service Available');\n    expect(secondChildren.props.children).toBe('Hide Network Info');\n    expect(thirdChildren.props.children).toBe('Connect to Service');\n  });\n\n  test('shows correct message when network available is false', async () => {\n    (NetworkService.getState as jest.Mock).mockReturnValue({\n      isConnected: false,\n      isConnecting: false,\n      isServiceAvailable: false,\n      isNetworkAvailable: false,\n    });\n\n    (NetworkService.notifier.subscribe as jest.Mock).mockImplementation(\n      () => {}\n    );\n\n    const customRef = createRef();\n    renderComponent({ ref: customRef });\n    const content = customRef.current.options.content;\n    const firstChildren = content.props.children[1];\n    const secondChildren = content.props.children[2].props.children;\n\n    expect(content.type.displayName).toBe('View');\n    expect(content.children).not.toBeNull();\n    expect(firstChildren.props.children).toBe('Network Not Available');\n    expect(secondChildren.props.children).toBe('Hide Network Info');\n  });\n\n  test('shows correct message when network is connected', () => {\n    (NetworkService.getState as jest.Mock).mockReturnValue({\n      isConnected: true,\n      isConnecting: false,\n      isServiceAvailable: false,\n      isNetworkAvailable: false,\n    });\n\n    (NetworkService.notifier.subscribe as jest.Mock).mockImplementation(\n      () => {}\n    );\n\n    const customRef = createRef();\n    renderComponent({ ref: customRef });\n    const content = customRef.current.options.content;\n    const firstChildren = content.props.children[1];\n    const secondChildren = content.props.children[2].props.children;\n\n    expect(content.type.displayName).toBe('View');\n    expect(content.children).not.toBeNull();\n    expect(firstChildren.props.children).toBe('Service Connected');\n    expect(secondChildren.props.children).toBe('Hide Network Info');\n  });\n\n  test('shows correct message when network is connecting', () => {\n    (NetworkService.getState as jest.Mock).mockReturnValue({\n      isConnected: false,\n      isConnecting: true,\n      isServiceAvailable: false,\n      isNetworkAvailable: false,\n    });\n\n    (NetworkService.notifier.subscribe as jest.Mock).mockImplementation(\n      () => {}\n    );\n\n    const customRef = createRef();\n    renderComponent({ ref: customRef });\n    const content = customRef.current.options.content;\n    const firstChildren = content.props.children[1];\n\n    expect(content.type.displayName).toBe('View');\n    expect(content.children).not.toBeNull();\n    expect(firstChildren.props.children).toBe('Service Connecting');\n  });\n\n  test('shows correct message when network available is true but isConnected, isConnecting and isServiceAvailable is false', () => {\n    (NetworkService.getState as jest.Mock).mockReturnValue({\n      isConnected: false,\n      isConnecting: false,\n      isServiceAvailable: false,\n      isNetworkAvailable: true,\n    });\n\n    (NetworkService.notifier.subscribe as jest.Mock).mockImplementation(\n      () => {}\n    );\n\n    const customRef = createRef();\n    renderComponent({ ref: customRef });\n    const content = customRef.current.options.content;\n    const firstChildren = content.props.children[1];\n    const secondChildren = content.props.children[2].props.children;\n\n    expect(content.type.displayName).toBe('View');\n    expect(content.children).not.toBeNull();\n    expect(firstChildren.props.children).toBe('Service Not Available');\n    expect(secondChildren.props.children).toBe('Hide Network Info');\n  });\n  \n  test('should hide toaster when onClose is called', async () => {\n    (NetworkService.getState as jest.Mock).mockReturnValueOnce({\n      isConnected: true,\n      isConnecting: false,\n      isServiceAvailable: true,\n      isNetworkAvailable: true,\n    });\n\n    const updateStateMock = jest.spyOn(\n      WmNetworkInfoToaster.prototype,\n      'updateState'\n    );\n\n    const customRef = createRef();\n    renderComponent({ ref: customRef });\n\n    act(() => {\n      customRef.current.options.onClose();\n    });\n\n    await waitFor(() => {\n      expect(updateStateMock).toHaveBeenCalled();\n      expect(updateStateMock).toHaveBeenCalledWith({\n        showToast: false,\n      });\n    });\n  });\n});\n", "wavemaker-rn-runtime/test/components/advanced/carousel/carousel-template.component.spec.tsx": "import React from 'react';\nimport { render, screen } from '@testing-library/react-native';\nimport WmCarouselTemplate from '@wavemaker/app-rn-runtime/components/advanced/carousel/carousel-template/carousel-template.component';\nimport { View, Text } from 'react-native';\nimport { BackgroundComponent } from '@wavemaker/app-rn-runtime/styles/background.component';\n\n// Helper function to render the component\nconst renderComponent = (props = {}) => {\n  return render(<WmCarouselTemplate {...props} />);\n};\n\ndescribe('WmCarouselTemplate Component', () => {\n  it('should render the component without crashing', () => {\n    const tree = renderComponent().toJSON();\n    expect(tree).toMatchSnapshot(); // Ensure it matches the snapshot\n    expect(tree).not.toBeNull(); // The component should not be null\n    expect(tree).toBeDefined(); // The component should be defined\n  });\n\n  it('should render the root element with default styles when height is provided', () => {\n    const mockStyles = {\n      root: {\n        height: '50%', // Simulating height being passed in the styles\n        flexDirection: 'column',\n        justifyContent: 'center',\n        alignItems: 'center',\n        width: '100%',\n      },\n    };\n\n    const tree = renderComponent({ styles: mockStyles });\n\n    // Access the root View element\n    const viewEle = tree.UNSAFE_getByType(View); // Get the root View component\n    expect(viewEle).toBeDefined();\n    expect(viewEle).toHaveStyle({\n      height: '50%',\n      flexDirection: 'column',\n      justifyContent: 'center',\n      alignItems: 'center',\n      width: '100%',\n    });\n  });\n\n  it('should render children components correctly', () => {\n    const tree = renderComponent({\n      children: (\n        <View>\n          <Text>Carousel Item</Text>\n        </View>\n      ),\n    });\n\n    const rootView = tree.root.props.style;\n    // Check if child text is rendered\n    expect(tree.getByText('Carousel Item')).toBeTruthy();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('should render the background component if it exists', () => {\n    const tree = renderComponent();\n    const backgroundEle = tree.UNSAFE_getByType(BackgroundComponent); // Check for the background component\n    expect(backgroundEle).toBeDefined(); // It should be defined if present\n  });\n});\n", "wavemaker-rn-runtime/test/components/advanced/carousel/carousel-content.component.spec.tsx": "import React from 'react';\nimport { render, screen } from '@testing-library/react-native';\nimport WmCarouselContent from '@wavemaker/app-rn-runtime/components/advanced/carousel/carousel-content/carousel-content.component';\nimport { View, Text } from 'react-native';\nimport { BackgroundComponent } from '@wavemaker/app-rn-runtime/styles/background.component';\n\n// Helper function to render the component\nconst renderComponent = (props = {}) => {\n  return render(<WmCarouselContent {...props} />);\n};\n\ndescribe('WmCarouselContent Component', () => {\n  \n  it('should render the component without crashing', () => {\n    const tree = renderComponent().toJSON();\n    expect(tree).toMatchSnapshot();  // Ensure it matches the snapshot\n    expect(tree).not.toBeNull();     // The component should not be null\n    expect(tree).toBeDefined();      // The component should be defined\n  });\n\n  it('should render the root element with default styles', () => {\n    const tree = renderComponent();\n\n    // Access the root View element\n    const viewEle = tree.UNSAFE_getByType(View);  // Get the root View component\n    expect(viewEle).toBeDefined();\n    expect(viewEle).toHaveStyle({\n      flexDirection: 'column',\n      justifyContent: 'center',\n      alignItems: 'center',\n      width: '100%',\n      height: '100%',\n    });\n  });\n\n  it('should render children components correctly', () => {\n    const tree = renderComponent({\n      children: (\n        <View>\n          <Text>Carousel Item</Text>\n        </View>\n      ),\n    });\n    // Check if child text is rendered\n    expect(tree.getByText('Carousel Item')).toBeTruthy();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('should render the background component if it exists', () => {\n    const tree = renderComponent();\n    const backgroundEle = tree.UNSAFE_getByType(BackgroundComponent);  // Check for the background component\n    expect(backgroundEle).toBeDefined();  // It should be defined if present\n  });\n});", "wavemaker-rn-runtime/test/components/page/content.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport { View, Text, TouchableOpacity } from 'react-native';\nimport WmContent from '@wavemaker/app-rn-runtime/components/page/content/content.component';\nimport { render, screen } from '@testing-library/react-native';\nimport { BackgroundComponent } from '@wavemaker/app-rn-runtime/styles/background.component';\n\nconst renderComponent = (props = {}) => {\n  return render(<WmContent name=\"test_Navbar\" {...props} />);\n};\n\ndescribe('Test Content component', () => {\n  it('should render the content component', () => {\n    const tree = renderComponent().toJSON();\n    expect(tree).toMatchSnapshot();\n    expect(tree).not.toBeNull();\n    expect(tree).toBeDefined();\n  });\n\n  it('should render the root element with styles', () => {\n    const styles = {\n      root: {\n        flex: 3,\n      },\n      text: {},\n    };\n    const tree = renderComponent();\n    const viewEle = screen.root;\n    expect(viewEle).toBeDefined();\n    expect(viewEle.props.style.flex).toBe(1); //default styles\n    tree.rerender(<WmContent name=\"test_Navbar\" styles={styles} />);\n    expect(viewEle.props.style.flex).toBe(3); //custom styles\n  });\n\n  it('should render the background Component', () => {\n    const tree = renderComponent();\n    const viewEle = tree.UNSAFE_getByType(BackgroundComponent);\n    expect(viewEle).toBeDefined();\n  });\n\n  it('should render the component with children', () => {\n    const tree = renderComponent({\n      children: (\n        <View>\n          <Text>content Component</Text>\n        </View>\n      ),\n    });\n    expect(tree.getByText('content Component')).toBeTruthy();\n  });\n});\n", "wavemaker-rn-runtime/test/components/page/page-content.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport { View, Text, TouchableOpacity } from 'react-native';\nimport WmPageContent from '@wavemaker/app-rn-runtime/components/page/page-content/page-content.component';\nimport { fireEvent, render, screen } from '@testing-library/react-native';\nimport { ScrollView } from 'react-native-gesture-handler';\nimport { BackgroundComponent } from '@wavemaker/app-rn-runtime/styles/background.component';\n\nimport WmContent from '@wavemaker/app-rn-runtime/components/page/content/content.component';\nimport WmLabel from '@wavemaker/app-rn-runtime/components/basic/label/label.component';\n\nclass PC_SkeletonTester_Without_Content_Skeleton extends React.Component {\n  render() {\n     return (<WmContent\n      name=\"content1\"\n      >\n         <WmPageContent showskeleton={true} name=\"pagecontent1\">\n            <WmLabel name=\"test_skeleton\"/>\n         </WmPageContent>\n      </WmContent>\n     )\n  }\n}\n\nclass PC_SkeletonTester_With_Content_Skeleton extends React.Component {\n  render() {\n     return (<WmContent\n      name=\"content1\"\n      showskeleton={false}\n      >\n         <WmPageContent showskeleton={true}  name=\"pagecontent1\">\n            <WmLabel name=\"test_skeleton\"/>\n         </WmPageContent>\n      </WmContent>\n     )\n  }\n}\n\n\ndescribe('base component test skeleton when page content inside content', () => {\n  test('should not show the skeleton', () => {\n    render(<PC_SkeletonTester_Without_Content_Skeleton/>)\n    expect(() => screen.getByTestId('test_skeleton_caption')).toThrow();\n  })\n\n  test('should not show the skeleton', () => {\n    render(<PC_SkeletonTester_With_Content_Skeleton/>)\n   expect(screen.getByTestId('test_skeleton_caption')).toBeTruthy()\n})\n})\n\n\n\nconst renderComponent = (props = {}) => {\n  return render(<WmPageContent name=\"test_Navbar\" {...props} />);\n};\n\ndescribe('Test PageContent component', () => {\n  it('should render pageContent component', () => {\n    const tree = renderComponent().toJSON();\n    expect(tree).toMatchSnapshot();\n    expect(tree).not.toBeNull();\n    expect(tree).toBeDefined();\n  });\n\n  it('should render root element with backgroundcolor when scrollable prop is true', () => {\n    renderComponent();\n    const rootEle = screen.root;\n    expect(rootEle.props.style.backgroundColor).toBe('#eeeeee');\n  });\n\n  it('should render scrollView when scrollable prop is true', () => {\n    renderComponent();\n    const viewEle = screen.UNSAFE_queryByType(ScrollView);\n    expect(viewEle).not.toBeNull();\n    expect(viewEle).toBeDefined();\n  });\n\n  it('should not render scrollView when scrollable prop is false', () => {\n    renderComponent({ scrollable: false });\n    const viewEle = screen.UNSAFE_queryByType(ScrollView);\n    expect(viewEle).toBeNull();\n  });\n\n  it('should render background Component', () => {\n    const tree = renderComponent();\n    const viewEle = tree.UNSAFE_queryByType(BackgroundComponent);\n    expect(viewEle).not.toBeNull();\n    expect(viewEle).toBeDefined();\n  });\n\n  it('when ever user tries to scroll, then onscroll event should render and calls the notify method', () => {\n    const notifyMock = jest.spyOn(WmPageContent.prototype, 'notify');\n    renderComponent({\n      children: (\n        <View>\n          <Text>children</Text>\n        </View>\n      ),\n    });\n    const scrollViewEle = screen.root.children[1];\n    fireEvent(scrollViewEle, 'scroll');\n    expect(screen.getByText('children')).toBeTruthy();\n    expect(notifyMock).toHaveBeenCalled();\n  });\n\n  //styles\n  xit('should render root element with styles when scrollable prop is false', () => {\n    const tree = renderComponent({ scrollable: false });\n    const rootEle = screen.root;\n    expect(rootEle.props.style.backgroundColor).toBe('#eeeeee');\n    expect(rootEle.props.style.minHeight).toBe('100%');\n    expect(rootEle.props.style.paddingLeft).toBe(8);\n    expect(rootEle.props.style.paddingRight).toBe(8);\n    expect(rootEle.props.style.paddingTop).toBe(8);\n    expect(rootEle.props.style.paddingBottom).toBe(8);\n\n    const styles = {\n      root: {\n        paddingLeft: 10,\n        paddingRight: 20,\n        paddingTop: 10,\n        paddingBottom: 20,\n        backgroundColor: 'red',\n        minHeight: '100%',\n      },\n    };\n    //rerender\n    tree.rerender(<WmPageContent name=\"test_Navbar\" styles={styles} />);\n    expect(rootEle.props.style.backgroundColor).toBe('red');\n    expect(rootEle.props.style.minHeight).toBe('100%');\n    expect(rootEle.props.style.paddingLeft).toBe(10);\n    expect(rootEle.props.style.paddingRight).toBe(20);\n    expect(rootEle.props.style.paddingTop).toBe(10);\n    expect(rootEle.props.style.paddingBottom).toBe(20);\n  });\n\n  it('should render children when scrollable prop is false', () => {\n    const tree = renderComponent({\n      scrollable: false,\n      children: (\n        <View>\n          <Text>children</Text>\n        </View>\n      ),\n    });\n    expect(tree.getByText('children')).toBeTruthy();\n  });\n\n\n  it('should trigger onSwipedown event when user scrolls down', () => {\n    const onSwipedownMock = jest.fn();\n    const { getByTestId } = renderComponent({ onSwipedown: onSwipedownMock });\n  \n    const scrollViewEle = getByTestId('test_Navbar_page_content_scrollview');\n    \n    fireEvent.scroll(scrollViewEle, {\n      nativeEvent: { contentOffset: { y: 0 }, layoutMeasurement: {}, contentSize: {} },\n    });\n  \n    fireEvent.scroll(scrollViewEle, {\n      nativeEvent: { contentOffset: { y: -20 }, layoutMeasurement: {}, contentSize: {} },\n    });\n  \n    expect(onSwipedownMock).toHaveBeenCalled();\n  });\n  \n  it('should trigger onSwipeup event when user scrolls up', () => {\n    const onSwipeupMock = jest.fn();\n    const { getByTestId } = renderComponent({ onSwipeup: onSwipeupMock });\n  \n    const scrollViewEle = getByTestId('test_Navbar_page_content_scrollview');\n  \n    fireEvent.scroll(scrollViewEle, {\n      nativeEvent: { contentOffset: { y: 0 }, layoutMeasurement: {}, contentSize: {} },\n    });\n  \n    fireEvent.scroll(scrollViewEle, {\n      nativeEvent: { contentOffset: { y: 20 }, layoutMeasurement: {}, contentSize: {} },\n    });\n  \n    expect(onSwipeupMock).toHaveBeenCalled();\n  });\n  \n});\n", "wavemaker-rn-runtime/test/components/page/left-panel.component.spec.tsx": "import React, { createRef, ReactNode } from 'react';\nimport { View, Text, TouchableOpacity } from 'react-native';\nimport WmLeftPanel from '@wavemaker/app-rn-runtime/components/page/left-panel/left-panel.component';\nimport {\n  fireEvent,\n  render,\n  waitFor,\n  screen,\n} from '@testing-library/react-native';\nimport { BackgroundComponent } from '@wavemaker/app-rn-runtime/styles/background.component';\n\nconst renderComponent = (props = {}) => {\n  return render(<WmLeftPanel name=\"test_LeftPanel\" {...props} />);\n};\n\ndescribe('Test LeftPanel component', () => {\n  it('should render the left-panel component', () => {\n    const tree = renderComponent().toJSON();\n    expect(tree).not.toBeNull();\n    expect(tree).toBeDefined();\n    expect(tree).toMatchSnapshot();\n  });\n\n  //styles\n  it('should render scrollView with default and custom rootStyles', () => {\n    const tree = renderComponent();\n    const rootElement = screen.root.props;\n\n    expect(rootElement.contentContainerStyle[0].minHeight).toBe('100%');\n    expect(rootElement.contentContainerStyle[0].backgroundColor).toBe(\n      '#ffffff'\n    );\n    expect(rootElement.contentContainerStyle[0].elevation).toBe(1);\n    expect(rootElement.contentContainerStyle[0].borderTopRightRadius).toBe(16);\n    expect(rootElement.contentContainerStyle[0].borderBottomRightRadius).toBe(\n      16\n    );\n    expect(rootElement.contentContainerStyle[1].maxWidth).toBe('100%');\n\n    const styles = {\n      root: {\n        minHeight: '100%',\n        backgroundColor: 'red',\n        elevation: 2,\n        borderTopRightRadius: 20,\n        borderBottomRightRadius: 25,\n        maxWidth: 380,\n      },\n    };\n\n    //rerender\n    tree.rerender(<WmLeftPanel name=\"test_LeftPanel\" styles={styles} />);\n\n    expect(screen.root.props.contentContainerStyle[0].minHeight).toBe('100%');\n    expect(screen.root.props.contentContainerStyle[0].backgroundColor).toBe(\n      'red'\n    );\n    expect(screen.root.props.contentContainerStyle[0].elevation).toBe(2);\n    expect(\n      screen.root.props.contentContainerStyle[0].borderTopRightRadius\n    ).toBe(20);\n    expect(\n      screen.root.props.contentContainerStyle[0].borderBottomRightRadius\n    ).toBe(25);\n    expect(screen.root.props.contentContainerStyle[0].maxWidth).toBe(380);\n  });\n\n  //onscroll event\n  it('when ever user tries to scroll, then onscroll event should render and calls the notify method', () => {\n    const notifyMock = jest.spyOn(WmLeftPanel.prototype, 'notify');\n\n    //render\n    renderComponent();\n\n    fireEvent(screen.root, 'scroll');\n    expect(notifyMock).toHaveBeenCalled();\n  });\n\n  //background Component\n  it('should render background Component', () => {\n    const tree = renderComponent();\n\n    const viewEle = tree.UNSAFE_queryByType(BackgroundComponent);\n    expect(viewEle).not.toBeNull();\n    expect(viewEle).toBeDefined();\n  });\n\n  //if the children, having text means...this case should pass\n  it('should return (children with text) when renderPartial prop is not given', () => {\n    const ref = createRef();\n    const tree = renderComponent({\n      children: (\n        <View>\n          <Text>children</Text>\n        </View>\n      ),\n      ref,\n    });\n    expect(tree.getByText('children')).toBeTruthy();\n    expect(ref.current.state.isPartialLoaded).toBeFalsy();\n  });\n\n  //if that children, doesnot have text means.. this case should pass\n  it('should return children when renderPartial prop is not given', () => {\n    const renderContentMock = jest.spyOn(\n      WmLeftPanel.prototype,\n      'renderContent'\n    );\n    renderComponent({\n      children: (\n        <View>\n          <View></View>\n        </View>\n      ),\n    });\n    expect(renderContentMock).toHaveReturnedWith(\n      <View>\n        <View></View>\n      </View>\n    );\n  });\n\n  it('should return renderPartial function when renderPartial prop is provided', async () => {\n    const onPartialLoadMock = jest.spyOn(\n      WmLeftPanel.prototype,\n      'onPartialLoad'\n    );\n\n    const onLoadMock = jest.fn();\n    const invokeEventCallbackMock = jest.spyOn(\n      WmLeftPanel.prototype,\n      'invokeEventCallback'\n    );\n    const renderPartial = (props: any, onPartialLoad: Function) => {\n      onPartialLoad();\n      return (\n        <View>\n          <Text>This is partial text</Text>\n        </View>\n      );\n    };\n\n    //render\n    renderComponent({\n      renderPartial: renderPartial,\n      onLoad: onLoadMock,\n    });\n\n    await waitFor(() => {\n      expect(invokeEventCallbackMock).toHaveBeenCalled();\n      expect(onPartialLoadMock).toHaveBeenCalled();\n      expect(onLoadMock).toHaveBeenCalled();\n      expect(screen.getByText('This is partial text')).toBeTruthy();\n    });\n  });\n\n  it('should update the state of isPartialLoaded to true', async () => {\n    const ref = createRef<WmLeftPanel>();\n    const updateStateMock = jest.spyOn(WmLeftPanel.prototype, 'updateState');\n    const renderPartial = (props: any, onPartialLoad: Function) => {\n      onPartialLoad();\n    };\n\n    //render\n    const tree = renderComponent({\n      renderPartial: renderPartial,\n      ref: ref,\n    });\n    await waitFor(() => {\n      expect(updateStateMock).toHaveBeenCalled();\n      expect(ref.current.state.isPartialLoaded).toBe(true);\n    });\n  });\n});\n", "wavemaker-rn-runtime/test/components/page/tabbar.component.spec.tsx": "import React, { createRef } from 'react';\nimport {\n  render,\n  fireEvent,\n  cleanup,\n  screen,\n} from '@testing-library/react-native';\nimport AppModalService from '@wavemaker/app-rn-runtime/runtime/services/app-modal.service';\nimport { ModalProvider } from '@wavemaker/app-rn-runtime/core/modal.service';\nimport WmTabbar from '@wavemaker/app-rn-runtime/components/page/tabbar/tabbar.component';\nimport WmTabbarProps from '@wavemaker/app-rn-runtime/components/page/tabbar/tabbar.props';\nimport { NavigationServiceProvider } from '../../../src/core/navigation.service';\nimport mockNavigationService from '../../__mocks__/navigation.service';\nimport { View } from 'react-native';\n\nconst renderComponent = (props: WmTabbarProps = {}) => {\n  AppModalService.modalsOpened = [];\n  return render(\n    <NavigationServiceProvider value={mockNavigationService}>\n      <ModalProvider value={AppModalService}>\n        <WmTabbar name=\"test_Popover\" {...props} />\n      </ModalProvider>\n    </NavigationServiceProvider>\n  );\n};\n\nconst timer = (time = 100) =>\n  new Promise((resolve: any, reject) => {\n    setTimeout(() => resolve(), time);\n  });\n\nconst moreItems = [\n  {\n    label: 'Home',\n    icon: 'wm-sl-r sl-home',\n    link: 'www.wavemaker.com/home',\n  },\n  {\n    label: 'Analytics',\n    icon: 'wm-sl-r sl-graph-ascend',\n    link: 'www.wavemaker.com/analytics',\n  },\n  {\n    label: 'Alerts',\n    icon: 'wm-sl-r sl-alarm-bell',\n    link: 'www.wavemaker.com/alerts',\n  },\n  {\n    label: 'Favorites',\n    icon: 'wm-sl-r sl-settings',\n    link: 'www.wavemaker.com/favorites',\n  },\n  {\n    label: 'Profile',\n    icon: 'wm-sl-r sl-settings',\n    link: 'www.wavemaker.com/profile',\n  },\n  {\n    label: 'Settings',\n    icon: 'wm-sl-r sl-settings',\n    link: 'www.wavemaker.com/settings',\n  },\n];\n\ndescribe('Test Tabbar component', () => {\n  afterEach(() => {\n    cleanup();\n    jest.clearAllMocks();\n  });\n\n  it('should render the Tabbar component', () => {\n    const tree = renderComponent();\n    expect(tree).toBeDefined();\n    expect(tree).not.toBeNull();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('should handle layout change event', () => {\n    const ref = createRef();\n    const tree = render(\n      <ModalProvider value={AppModalService}>\n        <WmTabbar name=\"test_Popover\" ref={ref} />\n      </ModalProvider>\n    );\n\n    const viewEle = tree.UNSAFE_getAllByType(View)[2];\n    fireEvent(viewEle, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 100,\n          height: 100,\n        },\n      },\n    });\n\n    expect(ref.current.proxy.tabbarHeight).toBe(100);\n  });\n\n  it('should render the Clipped Tabbar component', () => {\n    const dataset = [\n      {\n        label: 'Home',\n        icon: 'wm-sl-r sl-home',\n      },\n      {\n        label: 'Analytics',\n        icon: 'wm-sl-r sl-graph-ascend',\n      },\n      {\n        label: 'Alerts',\n        icon: 'wm-sl-r sl-alarm-bell',\n      },\n    ];\n    const tree = renderComponent({\n      classname: 'clipped-tabbar',\n      dataset: dataset,\n    });\n    expect(tree).toBeDefined();\n    expect(tree).not.toBeNull();\n  });\n\n  it('should have 4 tab items by default', () => {\n    const tree = renderComponent();\n    const itemLabels = ['Home', 'Analytics', 'Alerts', 'Settings'].map((s) =>\n      tree.getByText(s)\n    );\n    expect(itemLabels.length).toBe(4);\n  });\n\n  it('should have called isActive function for each tab item', () => {\n    const labelsToCheck = ['Home', 'Analytics', 'Alerts', 'Settings'];\n    const isActiveFnMock = jest.fn((item) => {\n      expect(item.label).toBeDefined();\n      expect(item.icon).toBeDefined();\n      expect(labelsToCheck.includes(item.label)).toBeTruthy();\n      return false;\n    });\n    renderComponent({\n      isActive: isActiveFnMock,\n    });\n    expect(isActiveFnMock).toHaveBeenCalledTimes(4);\n  });\n\n  it('should have Home as active tab item', () => {\n    const isActiveFnMock = jest.fn((item) => {\n      return item.label === 'Home';\n    });\n    const tree = renderComponent({\n      isActive: isActiveFnMock,\n    });\n    expect(tree.getByText('Home')).toHaveStyle({ color: '#4263eb' });\n    expect(tree.getByText('Analytics')).toHaveStyle({ color: '#d8d8d8' });\n    expect(tree.getByText('Settings')).toHaveStyle({ color: '#d8d8d8' });\n    expect(tree.getByText('Alerts')).toHaveStyle({ color: '#d8d8d8' });\n  });\n\n  it('should have called onSelect function', async () => {\n    const onSelect = jest.fn();\n    const tree = renderComponent({\n      dataset: moreItems,\n      onSelect: onSelect,\n    });\n    const analyticsItem = tree.getByText('Analytics');\n    expect(onSelect).toHaveBeenCalledTimes(0);\n    fireEvent(analyticsItem, 'press');\n    await timer(200);\n    expect(onSelect).toHaveBeenCalledTimes(1);\n    expect(mockNavigationService.openUrl).toHaveBeenCalledWith(\n      'www.wavemaker.com/analytics'\n    );\n  });\n\n  it('should not have a more button if there are less or equal to 5 tab items', async () => {\n    const tree = renderComponent();\n    expect(tree.queryByText('more')).toBeNull();\n  });\n\n  it('should have a more button if there are more than 5 tab items', async () => {\n    const tree = renderComponent({ dataset: moreItems });\n    expect(tree.queryByText('more')).not.toBeNull();\n  });\n\n  it('should show extra menu only when menu is pressed', async () => {\n    const tree = renderComponent({ dataset: moreItems });\n    const moreItem = tree.getByText('more');\n    expect(tree.queryByText('Profile')).toBeNull();\n    expect(tree.queryByText('Settings')).toBeNull();\n    fireEvent(moreItem, 'press');\n    await timer(200);\n    const renderOptions = AppModalService.modalsOpened[0];\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const contentTree = render(<Content />);\n\n    expect(contentTree.queryByText('Profile')).not.toBeNull();\n    expect(contentTree.queryByText('Settings')).not.toBeNull();\n  });\n\n  it('should use TestMore as label of more button', async () => {\n    const tree = renderComponent({\n      dataset: moreItems,\n      morebuttonlabel: 'TestMore',\n    });\n    expect(tree.queryByText('more')).toBeNull();\n    expect(tree.queryByText('TestMore')).toBeDefined();\n  });\n\n  it('should have called onSelect function when an item in the extra menu is pressed', async () => {\n    const onSelect = jest.fn();\n    const tree = renderComponent({\n      dataset: moreItems,\n      onSelect: onSelect,\n    });\n    const moreItem = tree.getByText('more');\n    expect(tree.queryByText('Profile')).toBeNull();\n    fireEvent(moreItem, 'press');\n    await timer(300);\n    const renderOptions = AppModalService.modalsOpened[0];\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const contentTree = render(<Content />);\n    expect(contentTree.queryByText('Profile')).not.toBeNull();\n    const profileIns = contentTree.getByText('Profile');\n    expect(onSelect).toHaveBeenCalledTimes(0);\n    fireEvent(profileIns, 'press');\n    await timer(300);\n    expect(onSelect).toHaveBeenCalledTimes(1);\n    expect(mockNavigationService.openUrl).toHaveBeenCalledWith(\n      'www.wavemaker.com/profile'\n    );\n  });\n\n  it('handles show property correctly', async () => {\n    const ref = createRef();\n    const tree = render(\n      <ModalProvider value={AppModalService}>\n        <WmTabbar name=\"test_Popover\" show={true} ref={ref} />\n      </ModalProvider>\n    );\n\n    expect(tree.toJSON()[1].props.style.width).not.toBe(0);\n    expect(tree.toJSON()[1].props.style.height).not.toBe(0);\n\n    ref.current.proxy.show = false;\n\n    await timer(300);\n    expect(tree.toJSON()[1].props.style.width).toBe(0);\n    expect(tree.toJSON()[1].props.style.height).toBe(0);\n  });\n\n  xit('should hide the modal when an item in the extra menu is selected', async () => {\n    const onSelect = jest.fn();\n    const tree = renderComponent({\n      dataset: moreItems,\n      onSelect: onSelect,\n    });\n    const moreItem = tree.getByText('more');\n    expect(tree.queryByText('Profile')).toBeNull();\n    fireEvent(moreItem, 'press');\n    await timer(300);\n    const renderOptions = AppModalService.modalsOpened[0];\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const contentTree = render(<Content />);\n\n    expect(contentTree.queryByText('Profile')).not.toBeNull();\n    const profileIns = contentTree.getByText('Profile');\n    expect(onSelect).toHaveBeenCalledTimes(0);\n    fireEvent(profileIns, 'press');\n    await timer(300);\n    expect(onSelect).toHaveBeenCalledTimes(1);\n\n    expect(screen.queryByText('Profile')).toBeNull();\n  });\n});\n", "wavemaker-rn-runtime/test/components/page/partial-container.component.spec.tsx": "import React from 'react';\nimport { render, screen } from '@testing-library/react-native';\nimport WmPartialContainer from '@wavemaker/app-rn-runtime/components/page/partial-container/partial-container.component'; // Adjust the import path\nimport { View, Text } from 'react-native';\nimport { BackgroundComponent } from '@wavemaker/app-rn-runtime/styles/background.component';\nimport PartialService, {\n  PartialConsumer,\n} from '@wavemaker/app-rn-runtime/core/partial.service';\n\n// Mock PartialService\nconst mockPartialService = {\n  get: jest.fn(),\n};\n\n// Mock PartialConsumer to use the mocked PartialService\njest.mock('@wavemaker/app-rn-runtime/core/partial.service', () => ({\n  PartialConsumer: ({ children }) => children(mockPartialService),\n}));\n\n// Helper function to render the component\nconst renderComponent = (props = {}) => {\n  return render(<WmPartialContainer {...props} />);\n};\n\ndescribe('Test WmPartialContainer component', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('should render WmPartialContainer component', () => {\n    const tree = renderComponent().toJSON();\n    expect(tree).toMatchSnapshot();\n    expect(tree).not.toBeNull();\n    expect(tree).toBeDefined();\n  });\n\n  it('should render root element with default styles', () => {\n    renderComponent();\n    const rootEle = screen.root;\n    expect(rootEle.props.style.width).toBe('100%');\n    expect(rootEle.props.style.backgroundColor).toBe('#eeeeee'); // Assuming default bg color\n  });\n\n  it('should render the background component', () => {\n    const tree = renderComponent();\n    const backgroundEle = tree.UNSAFE_queryByType(BackgroundComponent);\n    expect(backgroundEle).not.toBeNull();\n    expect(backgroundEle).toBeDefined();\n  });\n\n  it('should render partial content when provided', () => {\n    // Mock the return value of the get method in PartialService\n    mockPartialService.get.mockReturnValue(() => (\n      <View>\n        <Text>Partial Content</Text>\n      </View>\n    ));\n\n    renderComponent({ content: 'somePartial' });\n\n    expect(mockPartialService.get).toHaveBeenCalledWith('somePartial');\n    expect(screen.getByText('Partial Content')).toBeTruthy();\n  });\n\n  it('should not render partial if content is not provided', () => {\n    // Mock the return value of the get method in PartialService\n    mockPartialService.get.mockReturnValue(null);\n\n    renderComponent({ content: 'unknownPartial' });\n\n    expect(mockPartialService.get).toHaveBeenCalledWith('unknownPartial');\n    expect(screen.queryByText('Partial Content')).toBeNull();\n  });\n\n  xit('should call onLoad prop when component is loaded', () => {\n    const onLoadMock = jest.fn();\n    renderComponent({ onLoad: onLoadMock });\n    expect(onLoadMock).toHaveBeenCalled();\n  });\n});\n", "wavemaker-rn-runtime/test/components/page/partial.component.spec.tsx": "import React from 'react';\nimport { View, Text } from 'react-native';\nimport WmPartial from '@wavemaker/app-rn-runtime/components/page/partial/partial.component';\nimport { render } from '@testing-library/react-native';\nimport { BackgroundComponent } from '@wavemaker/app-rn-runtime/styles/background.component';\n\nconst renderComponent = (props = {}) => {\n  return render(<WmPartial name=\"test_Page\" {...props} />);\n};\n\ndescribe('Test Partial component', () => {\n  it('should render partial component', () => {\n    const tree = renderComponent();\n    expect(tree).toMatchSnapshot();\n    expect(tree).not.toBeNull();\n    expect(tree).toBeDefined();\n  });\n\n  it('should render partial component with root styles', () => {\n    const tree = renderComponent();\n    const rootEle = tree.root;\n    expect(rootEle.props.style.width).toBe('100%');\n\n    const styles = {\n      root: {\n        width: '50%',\n      },\n    };\n    //rerender\n    tree.rerender(<WmPartial name=\"test_Page\" styles={styles} />);\n    expect(rootEle.props.style.width).toBe('50%');\n  });\n\n  //background Component\n  it('should render background Component', () => {\n    const tree = renderComponent();\n    const viewEle = tree.UNSAFE_queryByType(BackgroundComponent);\n    expect(viewEle).not.toBeNull();\n    expect(viewEle).toBeDefined();\n  });\n\n  //children\n  it('should render children', () => {\n    const tree = renderComponent({\n      children: (\n        <View>\n          <Text>children</Text>\n        </View>\n      ),\n    });\n    expect(tree.getByText('children')).toBeTruthy();\n  });\n});\n", "wavemaker-rn-runtime/test/components/input/toggle.component.spec.tsx": "import React, { createRef } from 'react';\nimport { Platform, View } from 'react-native';\nimport {\n  render,\n  fireEvent,\n  waitFor,\n  cleanup,\n  act,\n} from '@testing-library/react-native';\nimport MockDate from 'mockdate';\nimport WmToggle from '@wavemaker/app-rn-runtime/components/input/toggle/toggle.component';\nimport * as accessibilityUtils from '@wavemaker/app-rn-runtime/core/accessibility';\nimport { defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\n\n// const frameTime = 100;\n// const timeTravel = (time = frameTime) => {\n//   const tickTravel = () => {\n//     const now = Date.now();\n//     MockDate.set(new Date(now + frameTime));\n//     // Run the timers forward\n//     act(() => {\n//       jest.advanceTimersByTime(frameTime);\n//     });\n//   };\n//   // Step through each of the frames\n//   const frames = time / frameTime;\n//   for (let i = 0; i < frames; i++) {\n//     tickTravel();\n//   }\n// };\n\nconst hexToArgbValue = (hex) => {\n  let hexCode = hex.substr(1);\n  if (hexCode === 3) {\n    hexCode = '' + hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n  }\n  hexCode = '0xff' + hexCode;\n\n  return parseInt(hexCode, 16);\n};\n\nconst invokeEventCallbackMock = jest.spyOn(\n  WmToggle.prototype,\n  'invokeEventCallback'\n);\n\ndescribe('Test Toggle component', () => {\n  beforeAll(() => {\n    jest\n      .spyOn(accessibilityUtils, 'isScreenReaderEnabled')\n      .mockReturnValue(false);\n\n    const DEFAULT_CLASS = 'app-toggle';\n    BASE_THEME.registerStyle((themeVariables, addStyle) => {\n      const defaultStyles = defineStyles({\n        root: {\n          width: 52,\n          height: 32,\n          flexDirection: 'row',\n          alignItems: 'center',\n          borderRadius: 18,\n        },\n        text: {},\n        handle: {\n          width: 16,\n          height: 16,\n          borderRadius: 18,\n          marginLeft: 8,\n          marginRight: 0,\n          backgroundSize: '100% 100%',\n          backgroundPosition: 'center',\n          backgroundImage: 'linear-gradient(45deg, #4c669f, #3b5998)',\n        },\n      });\n      addStyle(DEFAULT_CLASS, '', defaultStyles);\n      addStyle(DEFAULT_CLASS + '-on', '', {\n        root: {\n          backgroundColor: '#000000',\n        },\n        handle: {\n          backgroundColor: '#367BA7',\n        },\n      });\n      addStyle(DEFAULT_CLASS + '-off', '', {\n        root: {\n          backgroundColor: '#ffffff',\n          borderColor: '#000000',\n          borderWidth: 2,\n        },\n        handle: {\n          backgroundColor: '#E9EDEF',\n        },\n      });\n      addStyle(DEFAULT_CLASS + '-rtl', '', {});\n      addStyle(DEFAULT_CLASS + '-disabled', '', {\n        root: {},\n      });\n    });\n  });\n\n  beforeEach(() => {\n    MockDate.set(0);\n  });\n\n  afterEach(() => {\n    (Platform as any).OS = 'ios';\n    cleanup();\n    MockDate.reset();\n  });\n\n  const baseProps = {\n    id: 'wm-toggle',\n    name: 'toggle-switch',\n    checkedvalue: true,\n    uncheckedvalue: false,\n    datavalue: false,\n    readonly: false,\n    onFieldChange: jest.fn(),\n    accessibilitylabel: 'wm-toggle-switch',\n    hint: 'Toggle switch hint',\n    accessibilityrole: 'togglebutton',\n  };\n\n  test('should render WmToggle component', async () => {\n    const tree = render(<WmToggle {...baseProps} />);\n\n    await waitFor(() => {\n      expect(tree.getByTestId('wm-toggle_a')).toBeDefined();\n      expect(tree.getByTestId('wm-expo-linear-gradient')).toBeDefined();\n      expect(tree.getByTestId('wm-expo-linear-gradient').props.colors).toEqual([\n        hexToArgbValue('#4c669f'),\n        hexToArgbValue('#3b5998'),\n      ]);\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should toggle the switch', async () => {\n    const { getByTestId } = render(<WmToggle {...baseProps} />);\n    const toggleComponent = getByTestId('wm-toggle_a');\n\n    expect(toggleComponent.props.accessibilityState.selected).toBe(false);\n\n    fireEvent.press(toggleComponent);\n\n    await waitFor(() => {\n      expect(toggleComponent.props.accessibilityState.selected).toBe(true);\n    });\n  });\n\n  test('should not toggle if disabled in native platform', async () => {\n    const props = {\n      ...baseProps,\n      disabled: true,\n    };\n    const tree = render(<WmToggle {...props} />);\n    const toggleComponent = tree.getByTestId('wm-toggle_a');\n\n    expect(toggleComponent.props.accessibilityState.selected).toBe(false);\n\n    fireEvent(toggleComponent, 'press');\n\n    await waitFor(() => {\n      expect(toggleComponent.props.accessibilityState.selected).not.toBe(true);\n      expect(toggleComponent.props.accessibilityState.selected).toBe(false);\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should not toggle if disabled in web platform', async () => {\n    (Platform as any).OS = 'web';\n    const props = {\n      ...baseProps,\n      disabled: true,\n    };\n    const toggleSwitchMock = jest.spyOn(WmToggle.prototype, 'onToggleSwitch');\n    const tree = render(<WmToggle {...props} />);\n    const toggleComponent = tree.getByTestId('wm-toggle_a');\n\n    fireEvent(toggleComponent, 'press');\n\n    await waitFor(() => {\n      expect(toggleSwitchMock).not.toHaveBeenCalled();\n    });\n  });\n\n  xit('should call invoke event callback on press toggle when readonly', async () => {\n    const props = {\n      ...baseProps,\n      readonly: true,\n    };\n    const customRef = createRef();\n    const tree = render(<WmToggle {...props} ref={customRef} />);\n    const toggleComponent = tree.getByTestId('wm-toggle_a');\n\n    expect(toggleComponent.props.accessibilityState.selected).toBe(false);\n\n    act(() => {\n      fireEvent(toggleComponent, 'press');\n    });\n\n    await waitFor(() => {\n      expect(toggleComponent.props.accessibilityState.selected).toBe(true);\n      expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n        'onTap',\n        expect.arrayContaining([null])\n      );\n    });\n  });\n\n  test('should call invoke event callback with onChange on press toggle when onFieldChange prop is falsy', async () => {\n    const props = {\n      ...baseProps,\n      onFieldChange: null,\n    };\n    const customRef = createRef();\n    const tree = render(<WmToggle {...props} ref={customRef} />);\n    const toggleComponent = tree.getByTestId('wm-toggle_a');\n\n    expect(toggleComponent.props.accessibilityState.selected).toBe(false);\n\n    act(() => {\n      fireEvent(toggleComponent, 'press');\n    });\n\n    await waitFor(() => {\n      expect(toggleComponent.props.accessibilityState.selected).toBe(true);\n      expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n        'onChange',\n        expect.arrayContaining([null, true, false])\n      );\n    });\n  });\n\n  test('should call onFieldChange when toggled', async () => {\n    const { getByTestId } = render(<WmToggle {...baseProps} />);\n    const toggleComponent = getByTestId('wm-toggle_a');\n    fireEvent.press(toggleComponent);\n\n    await waitFor(() => {\n      expect(baseProps.onFieldChange).toHaveBeenCalledWith(\n        'datavalue',\n        true,\n        false\n      );\n    });\n  });\n\n  test('should validate on property change', async () => {\n    const { getByTestId, rerender } = render(<WmToggle {...baseProps} />);\n    const toggleComponent = getByTestId('wm-toggle_a');\n\n    rerender(<WmToggle {...baseProps} datavalue={true} />);\n\n    await waitFor(() => {\n      expect(toggleComponent.props.accessibilityState.selected).toBe(true);\n    });\n\n    rerender(<WmToggle {...baseProps} datavalue={false} />);\n\n    await waitFor(() => {\n      expect(toggleComponent.props.accessibilityState.selected).toBe(false);\n    });\n  });\n\n  test('should render with different styles based on state', async () => {\n    const tree = render(<WmToggle {...baseProps} />);\n    const { getByTestId, rerender } = tree;\n    let toggleComponent = getByTestId('wm-toggle_a');\n    let animatedViewStyleArr = (toggleComponent.children[0] as any).props.style;\n    let animatedViewStyle = {};\n    animatedViewStyleArr.forEach((item) => {\n      if (!item) return;\n\n      Object.keys(item).forEach((key) => {\n        animatedViewStyle[key] = item[key];\n      });\n    });\n\n    await waitFor(() => {\n      expect(toggleComponent.props.style).toMatchObject({\n        backgroundColor: '#ffffff',\n        borderColor: '#000000',\n        borderWidth: 2,\n      });\n      expect(animatedViewStyle).toMatchObject({\n        backgroundColor: '#E9EDEF',\n      });\n    });\n\n    fireEvent.press(toggleComponent);\n\n    await waitFor(() => {\n      expect(toggleComponent.props.accessibilityState.selected).toBe(true);\n    });\n\n    toggleComponent = getByTestId('wm-toggle_a');\n    animatedViewStyleArr = (toggleComponent.children[0] as any).props.style;\n    animatedViewStyle = {};\n\n    animatedViewStyleArr.forEach((item) => {\n      if (!item) return;\n\n      Object.keys(item).forEach((key) => {\n        animatedViewStyle[key] = item[key];\n      });\n    });\n\n    await waitFor(() => {\n      expect(toggleComponent.props.style).toMatchObject({\n        backgroundColor: '#000000',\n      });\n      expect(animatedViewStyle).toMatchObject({\n        backgroundColor: '#367BA7',\n      });\n    });\n  });\n\n  test('should set the value of width based on layout change', () => {\n    const setStateMock = jest.spyOn(WmToggle.prototype, 'setState');\n    const tree = render(<WmToggle {...baseProps} />);\n\n    const comp = tree.UNSAFE_getAllByType(View)?.[1]\n    fireEvent(comp, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 50,\n        },\n      },\n    });\n\n    expect(setStateMock).toHaveBeenCalledWith({ viewWidth: 50 });\n  });\n\n   //skeleton loader\n  test('should render skeleton with respect to provided styles when show skeleton is true', () => {\n    const tree = render(<WmToggle {...baseProps} showskeleton={true}  />)\n    const root = tree.toJSON()?.[1];\n    expect(root.props.style.width).toBe(52);\n    expect(root.props.style.height).toBe(32);\n    expect(root.props.style.borderRadius).toBe(18);\n  })\n  \n  // test('should apply animations correctly', async () => {\n  //   jest.useFakeTimers();\n\n  //   const viewWidth = 30;\n  //   const tree = render(<WmToggle {...baseProps} viewWidth={viewWidth}/>);\n  //   const { getByTestId, rerender } = tree;\n\n  //   timeTravel(600);\n  //   await waitFor(()=>{\n  //     expect(getByTestId('wm-toggle_a').props.accessibilityState.selected).toBe(false);\n  //   })\n\n  //   let toggleComponent = getByTestId('wm-toggle_a');\n\n  //   console.log('style: ', toggleComponent.children[1].props.style[1].transform);\n\n  //   let animatedViewStyleArr = (toggleComponent.children[1] as any).props.style;\n  //   let animatedViewStyle = {};\n  //   animatedViewStyleArr.forEach(item => {\n  //     if(!item) return;\n\n  //     Object.keys(item).forEach(key => {\n  //       animatedViewStyle[key] = item[key];\n  //     })\n  //   });\n\n  //   let style = {};\n  //   animatedViewStyle.transform.forEach(item => {\n  //     if(!item) return;\n  //     Object.keys(item).forEach(key => {\n  //       style[key] = item[key];\n  //     })\n  //   })\n\n  //   await waitFor(()=>{\n  //     expect(style).toMatchObject({\n  //       translateX: 0, scale: 1,\n  //     })\n  //   })\n\n  //   fireEvent.press(toggleComponent);\n\n  //   await waitFor(()=>{\n  //     expect(toggleComponent.props.accessibilityState.selected).toBe(true);\n  //   });\n\n  //   toggleComponent = getByTestId('wm-toggle_a');\n  //   animatedViewStyleArr = (toggleComponent.children[1] as any).props.style;\n  //   animatedViewStyle = {};\n  //   animatedViewStyleArr.forEach(item => {\n  //     if(!item) return;\n\n  //     Object.keys(item).forEach(key => {\n  //       animatedViewStyle[key] = item[key];\n  //     })\n  //   })\n\n  //   await waitFor(()=>{\n  //     expect(animatedViewStyle).toMatchObject({\n  //       transform: [\n  //         {translateX: viewWidth - ( 16 + 18)}, // 16 is styles.handle.width defined in beforeAll\n  //         {scale: 1.5}\n  //       ],\n  //     })\n  //   })\n\n  //   jest.useRealTimers();\n  // })\n});\n", "wavemaker-rn-runtime/test/components/input/switch.component.spec.tsx": "import React, { ReactNode, createRef } from 'react';\nimport WmSwitch from '@wavemaker/app-rn-runtime/components/input/switch/switch.component';\n\nimport {\n  render,\n  screen,\n  fireEvent,\n  act,\n  waitFor,\n} from '@testing-library/react-native';\nimport '@testing-library/jest-native/extend-expect';\nimport WmSwitchProps from '@wavemaker/app-rn-runtime/components/input/switch/switch.props';\nimport { Tappable } from '../../../src/core/tappable.component';\nimport { View } from 'react-native';\n\n// Mock React Native components and WmIcon\n// jest.mock('react-native', () => ({\n//   Text: 'Text',\n//   View: 'View',\n// }));\n// jest.mock('@wavemaker/app-rn-runtime/components/basic/icon/icon.component', () => 'WmIcon');\n// jest.mock('@wavemaker/app-rn-runtime/core/tappable.component', () => ({\n//   Tappable: ({ children, onTap }) => (<div onClick={onTap} data-testid=\"tappable-item\">{children}</div>),\n// }));\n\ndescribe('WmSwitch', () => {\n  const mockDataset = [\n    {\n      key: '1',\n      displayfield: 'Yes',\n      datafield: 'yes',\n      iconclass: 'fa fa-check',\n    },\n    { key: '2', displayfield: 'No', datafield: 'no', iconclass: 'fa fa-edit' },\n    {\n      key: '3',\n      displayfield: 'Maybe',\n      datafield: 'maybe',\n      iconclass: 'fa fa-anchor',\n    },\n  ];\n\n  let defaultProps: WmSwitchProps;\n\n  beforeEach(() => {\n    defaultProps = new WmSwitchProps();\n    defaultProps.dataset = mockDataset;\n    defaultProps.datavalue = 'yes';\n    defaultProps.datafield = 'datafield';\n    defaultProps.displayfield = 'displayfield';\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  // Check Rendering with Default Props\n  it('renders correctly with default props', () => {\n    render(<WmSwitch />);\n    expect(screen).toMatchSnapshot();\n    expect(screen.getByText('yes')).toBeTruthy();\n    expect(screen.getByText('no')).toBeTruthy();\n    expect(screen.getByText('maybe')).toBeTruthy();\n  });\n\n  // Dataset Handling\n  it('handles dataset properly and renders items based on it', async () => {\n    render(<WmSwitch {...defaultProps} />);\n    const items = screen.UNSAFE_queryAllByType(Tappable);\n    expect(items.length).toBe(3);\n    items.forEach((item, index) => {\n      expect(screen.getByText(mockDataset[index].displayfield)).toBeTruthy();\n    });\n    // await waitFor(() => {\n    //   expect(screen.getByText('Yes')).toBeTruthy();\n    //   expect(screen.getByText('No')).toBeTruthy();\n    //   expect(screen.getByText('Maybe')).toBeTruthy();\n    // });\n  });\n\n  // Data Value Change\n  it('responds to changes in datavalue prop and sets selected item correctly', () => {\n    const ref = createRef();\n    const { rerender } = render(<WmSwitch {...defaultProps} ref={ref} />);\n\n    rerender(<WmSwitch {...defaultProps} datavalue=\"no\" ref={ref} />);\n    // const items = screen.UNSAFE_getAllByType(Tappable);\n    const items = screen.root.children;\n    expect(items[1].props.styles).toContainEqual(\n      expect.objectContaining({\n        backgroundColor: ref.current.styles.selectedButton.backgroundColor,\n      })\n    );\n  });\n\n  // Accessibility Props\n  it('applies accessibility props correctly', () => {\n    render(<WmSwitch {...defaultProps} hint=\"wm-switch\" />);\n    const items = screen.getAllByA11yHint('wm-switch');\n\n    // expect(screen.getAllByA11yHint('wm-switch')).toBeTruthy();\n    expect(items[0].props.accessibilityState.selected).toBe(true);\n    expect(items[1].props.accessibilityState.selected).toBe(false);\n    expect(items[2].props.accessibilityState.selected).toBe(false);\n  });\n\n  // Interaction Handling (onTap and onChange)\n  it('handles onTap and onChange correctly', async () => {\n    const ref = createRef();\n    render(<WmSwitch {...defaultProps} ref={ref} />);\n    const textItem = screen.getByText('No');\n    const invokeEventCallbackMock = jest.spyOn(\n      WmSwitch.prototype,\n      'invokeEventCallback'\n    );\n    const onChangeMock = jest.spyOn(WmSwitch.prototype, 'onChange');\n    const items = screen.root.children;\n    fireEvent(textItem, 'press');\n\n    await waitFor(() => {\n      expect(onChangeMock).toHaveBeenCalledWith('no');\n      expect(invokeEventCallbackMock).toHaveBeenCalledTimes(2);\n    });\n    expect(items[1].props.styles).toContainEqual(\n      expect.objectContaining({\n        backgroundColor: ref.current.styles.selectedButton.backgroundColor,\n      })\n    );\n  });\n\n  // Handle icon rendering for an item\n  it('renders icon if iconclass prop is provided', () => {\n    const propsWithIconClass = { ...defaultProps, iconclass: 'iconclass' };\n    render(<WmSwitch {...propsWithIconClass} />);\n    expect(screen.getByText('check')).toBeTruthy();\n    expect(screen.getByText('edit')).toBeTruthy();\n    expect(screen.getByText('anchor')).toBeTruthy();\n  });\n\n  // Disabled State\n  it('does not handle taps when disabled', async () => {\n    const ref = createRef();\n    render(<WmSwitch {...defaultProps} disabled={true} ref={ref} />);\n    const textItem = screen.getByText('No');\n    const items = screen.root.children;\n    const invokeEventCallbackMock = jest.spyOn(\n      WmSwitch.prototype,\n      'invokeEventCallback'\n    );\n    const onChangeMock = jest.spyOn(WmSwitch.prototype, 'onChange');\n    fireEvent(textItem, 'press');\n\n    await waitFor(() => {\n      expect(onChangeMock).not.toHaveBeenCalledWith('no');\n      expect(invokeEventCallbackMock).not.toHaveBeenCalled();\n    });\n    expect(items[1].props.styles).not.toContainEqual(\n      expect.objectContaining({\n        backgroundColor: ref.current.styles.selectedButton.backgroundColor,\n      })\n    );\n  });\n\n  // Dynamic Dataset Update\n  it('processes updates to the dataset prop correctly', async () => {\n    const { rerender } = render(<WmSwitch {...defaultProps} />);\n    const newDataset = [\n      { key: '1', displayfield: 'One', datafield: 'one' },\n      { key: '2', displayfield: 'Two', datafield: 'two' },\n    ];\n    rerender(<WmSwitch {...defaultProps} dataset={newDataset} />);\n    let items;\n    await waitFor(() => {\n      items = screen.UNSAFE_queryAllByType(Tappable);\n      expect(items.length).toBe(2);\n    });\n    items.forEach((item, index) => {\n      expect(screen.getByText(newDataset[index].displayfield)).toBeTruthy();\n    });\n  });\n\n  it('renders correctly when datafield = \"All Fields\"', async () => {\n    const ref = createRef();\n    render(<WmSwitch {...defaultProps} datafield=\"All Fields\" ref={ref} />);\n    const textItem = screen.getByText('No');\n    const invokeEventCallbackMock = jest.spyOn(\n      WmSwitch.prototype,\n      'invokeEventCallback'\n    );\n    const onChangeMock = jest.spyOn(WmSwitch.prototype, 'onChange');\n    const items = screen.root.children;\n    fireEvent(textItem, 'press');\n\n    await waitFor(() => {\n      expect(onChangeMock).toHaveBeenCalledWith('null_item1');\n      expect(invokeEventCallbackMock).toHaveBeenCalledTimes(2);\n    });\n    expect(items[1].props.styles).toContainEqual(\n      expect.objectContaining({\n        backgroundColor: ref.current.styles.selectedButton.backgroundColor,\n      })\n    );\n  });\n\n  it('should not change anything when same item is clicked', async () => {\n    const ref = createRef();\n    render(<WmSwitch {...defaultProps} ref={ref} />);\n    const textItem = screen.getByText('Yes');\n    const invokeEventCallbackMock = jest.spyOn(\n      WmSwitch.prototype,\n      'invokeEventCallback'\n    );\n    const onChangeMock = jest.spyOn(WmSwitch.prototype, 'onChange');\n    const items = screen.root.children;\n    // pressing 1st time\n\n    fireEvent(textItem, 'press');\n\n    await waitFor(() => {\n      expect(onChangeMock).toHaveBeenCalledWith('yes');\n      expect(invokeEventCallbackMock).toHaveBeenCalledTimes(1);\n    });\n    expect(items[0].props.styles).toContainEqual(\n      expect.objectContaining({\n        backgroundColor: ref.current.styles.selectedButton.backgroundColor,\n      })\n    );\n    // pressing 2nd time\n    fireEvent(textItem, 'press');\n\n    await waitFor(() => {\n      expect(onChangeMock).toHaveBeenCalledWith('yes');\n      expect(invokeEventCallbackMock).toHaveBeenCalledTimes(1);\n    });\n    expect(items[0].props.styles).toContainEqual(\n      expect.objectContaining({\n        backgroundColor: ref.current.styles.selectedButton.backgroundColor,\n      })\n    );\n  });\n\n  it('should render skeleton with default styles when showskeleton is true',  () => {\n    const tree = render(<WmSwitch {...defaultProps} showskeleton={true}/>);\n    const viewEles = tree.UNSAFE_getAllByType(View);\n    expect(viewEles[3].props.style.width).toBe(30);\n    expect(viewEles[3].props.style.height).toBe(10);\n    expect(viewEles[6].props.style.width).toBe(30);\n    expect(viewEles[6].props.style.height).toBe(10);\n    expect(viewEles[9].props.style.width).toBe(30);\n    expect(viewEles[9].props.style.height).toBe(10);\n })\n});\n", "wavemaker-rn-runtime/test/components/input/textarea.component.spec.tsx": "import React, { createRef } from 'react';\nimport {\n  act,\n  cleanup,\n  fireEvent,\n  render,\n  waitFor,\n} from '@testing-library/react-native';\nimport WmTextarea from '@wavemaker/app-rn-runtime/components/input/textarea/textarea.component';\nimport { Platform, TextInput } from 'react-native';\n\nconst defaultProps = {\n  id: 'wmTextarea',\n  name: 'wmTextarea',\n  placeholder: 'Place your text',\n  disabled: false,\n  show: true,\n  styles: null,\n  classname: null,\n  listener: null,\n  showindevice: null,\n  showskeleton: false,\n  deferload: false,\n};\n\ndescribe('Test Textarea component', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    jest.useFakeTimers();\n  });\n\n  afterEach(() => {\n    // jest.runOnlyPendingTimers();\n    jest.useRealTimers();\n    cleanup();\n  });\n\n  test('should render correctly with default props', () => {\n    const tree = render(<WmTextarea {...defaultProps} />);\n    expect(tree.getByPlaceholderText('Place your text')).toBeTruthy();\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should show floating label when focused', () => {\n    const tree = render(\n      <WmTextarea {...defaultProps} floatinglabel=\"sample label\" />\n    );\n    const { queryByText, UNSAFE_getByType } = tree;\n    const input = UNSAFE_getByType(TextInput);\n\n    fireEvent(input, 'focus', {\n      target: null,\n    });\n\n    expect(queryByText('sample label')).toBeTruthy();\n  });\n\n  test('should call onChangeText with correct value', () => {\n    const onChangeTextMock = jest.spyOn(WmTextarea.prototype, 'onChangeText');\n    const { getByPlaceholderText } = render(<WmTextarea {...defaultProps} />);\n    const input = getByPlaceholderText('Place your text');\n    const text = 'new text';\n\n    fireEvent.changeText(input, text);\n\n    expect(onChangeTextMock).toHaveBeenCalledWith(text);\n  });\n\n  test('should handle disabled prop correctly', () => {\n    const { getByPlaceholderText } = render(\n      <WmTextarea {...defaultProps} disabled={true} />\n    );\n    const input = getByPlaceholderText('Place your text');\n\n    expect(input.props.editable).toBe(false);\n  });\n\n  test('should handle readonly prop correctly', () => {\n    const { getByPlaceholderText } = render(\n      <WmTextarea {...defaultProps} readonly={true} />\n    );\n    const input = getByPlaceholderText('Place your text');\n\n    expect(input.props.editable).toBe(false);\n  });\n\n  test('should handle maxchars prop correctly', () => {\n    const maxchars = 100;\n    const { getByPlaceholderText } = render(\n      <WmTextarea {...defaultProps} maxchars={maxchars} />\n    );\n    const input = getByPlaceholderText('Place your text');\n\n    expect(input.props.maxLength).toBe(maxchars);\n  });\n\n  test('should have default value for native platform', () => {\n    const tree = render(\n      <WmTextarea {...defaultProps} datavalue=\"sample text\" />\n    );\n    expect(tree.UNSAFE_getByType(TextInput).props.defaultValue).toBe(\n      'sample text'\n    );\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should have default value for web platform', () => {\n    (Platform as any).OS = 'web';\n\n    const tree = render(\n      <WmTextarea {...defaultProps} datavalue=\"sample text\" />\n    );\n    expect(tree.UNSAFE_getByType(TextInput).props.value).toBe('sample text');\n    expect(tree).toMatchSnapshot();\n  });\n\n  xit('should render field in invalid state when isValid is false', async () => {\n    const invalidStyle = { borderColor: 'red' };\n    const { getByPlaceholderText } = render(\n      <WmTextarea {...defaultProps} styles={{ invalid: invalidStyle }} />\n    );\n    const input = getByPlaceholderText('Place your text');\n    fireEvent.changeText(input, 'text exceeding validation');\n\n    await waitFor(() => {\n      const styleArr = input.props.style[0];\n      const style = {};\n      styleArr.forEach((item) => {\n        if (!item) return;\n        Object.keys(item).forEach((key) => {\n          style[key] = item[key];\n        });\n      });\n\n      expect(style).toMatchObject(invalidStyle);\n    });\n  });\n\n  test('should render floating label with labelformat', () => {\n    const { getByText, UNSAFE_getByType } = render(\n      <WmTextarea {...defaultProps} floatinglabel=\"Test Label\" />\n    );\n    const input = UNSAFE_getByType(TextInput);\n    expect(getByText('Test Label')).toBeTruthy();\n  });\n\n  test('should hide skeleton when showSkeleton is false', () => {\n    const { queryByTestId } = render(\n      <WmTextarea {...defaultProps} showskeleton={false} />\n    );\n    const skeleton = queryByTestId('skeleton');\n    expect(skeleton).toBeNull();\n  });\n\n  xit('renders with accessibility properties', async () => {\n    const { getByLabelText } = render(\n      <WmTextarea {...defaultProps} accessibilitylabel=\"Textarea input\" />\n    );\n\n    await waitFor(() => {\n      const input = getByLabelText('Textarea input');\n      expect(input.props.accessibilityLabel).toBe('Textarea input');\n    });\n  });\n\n  test('should auto complete username if autocomplete prop is provided', () => {\n    const { getByPlaceholderText } = render(\n      <WmTextarea {...defaultProps} autocomplete={true} />\n    );\n    const input = getByPlaceholderText('Place your text');\n    expect(input.props.autoComplete).toBe('username');\n  });\n\n  test('should auto complete off if autocomplete prop is not provided or falsy', () => {\n    const { getByPlaceholderText } = render(\n      <WmTextarea {...defaultProps} autocomplete={false} />\n    );\n    const input = getByPlaceholderText('Place your text');\n    expect(input.props.autoComplete).toBe('off');\n  });\n\n  test('should have keyboardType as numeric for type as number', () => {\n    const { getByPlaceholderText } = render(\n      <WmTextarea {...defaultProps} type=\"number\" />\n    );\n\n    const input = getByPlaceholderText('Place your text');\n    expect(input.props.keyboardType).toBe('numeric');\n  });\n\n  test('should have keyboardType as phone-pad for type as tel', () => {\n    const { getByPlaceholderText } = render(\n      <WmTextarea {...defaultProps} type=\"tel\" />\n    );\n\n    const input = getByPlaceholderText('Place your text');\n    expect(input.props.keyboardType).toBe('phone-pad');\n  });\n\n  test('should have keyboardType as email-address for type as email', () => {\n    const { getByPlaceholderText } = render(\n      <WmTextarea {...defaultProps} type=\"email\" />\n    );\n\n    const input = getByPlaceholderText('Place your text');\n    expect(input.props.keyboardType).toBe('email-address');\n  });\n\n  test('should not show component when show prop is false', () => {\n    const tree = render(<WmTextarea {...defaultProps} show={false} />);\n\n    const styleArr =\n      tree.getByPlaceholderText('Place your text').props.style[0];\n    const style = {};\n    styleArr.forEach((item) => {\n      if (!item) return;\n      Object.keys(item).forEach((key) => {\n        style[key] = item[key];\n      });\n    });\n\n    expect(style).toMatchObject({\n      height: 0,\n      width: 0,\n    });\n  });\n\n  test('should render with default placeholder when placeholder passed as props is falsy', () => {\n    const tree = render(<WmTextarea {...defaultProps} placeholder=\"\" />);\n\n    expect(tree.getByPlaceholderText('Place your text')).toBeTruthy();\n  });\n\n  test('should render Text instead of TextInput for Android device and disabled prop is true', async () => {\n    Platform.OS = 'android';\n    const tree = render(\n      <WmTextarea \n        {...defaultProps} \n        disabled={true}\n      />\n    );\n\n    const input = tree.getByText('Place your text');\n\n    expect(input.type).toBe('Text')\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render Text instead of TextInput for Android device and readOnly prop is true', async () => {\n    Platform.OS = 'android';\n    const tree = render(\n      <WmTextarea \n        {...defaultProps} \n        readonly={true}\n      />\n    );\n\n    const input = tree.getByText('Place your text');\n\n    expect(input.type).toBe('Text')\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render TextInput for iOS device and disabled prop is true', async () => {\n    Platform.OS = 'ios';\n    const tree = render(\n      <WmTextarea \n        {...defaultProps} \n        disabled={true}\n      />\n    );\n\n    const input = tree.getByPlaceholderText('Place your text');\n\n    expect(input.type).toBe('TextInput')\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render TextInput for iOS device and readOnly prop is true', async () => {\n    Platform.OS = 'ios';\n    const tree = render(\n      <WmTextarea \n        {...defaultProps} \n        readonly={true}\n      />\n    );\n\n    const input = tree.getByPlaceholderText('Place your text');\n\n    expect(input.type).toBe('TextInput')\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render limitdisplaytext when maxchars and limitdisplaytext are provided', () => {\n    const { getByText } = render(\n      <WmTextarea\n        {...defaultProps}\n        maxchars={100}\n        limitdisplaytext=\"50/100 characters used\"\n      />\n    );\n  \n    expect(getByText('50/100 characters used')).toBeTruthy();\n  });\n});\n", "wavemaker-rn-runtime/test/components/input/calendar.component.spec.tsx": "import React, { createRef, ReactNode } from 'react';\nimport { View, Text, TouchableOpacity } from 'react-native';\nimport WmCalendar from '@wavemaker/app-rn-runtime/components/input/calendar/calendar.component';\nimport WmCalendarProps from '@wavemaker/app-rn-runtime/components/input/calendar/calendar.props';\nimport {\n  render,\n  fireEvent,\n  screen,\n  waitFor,\n} from '@testing-library/react-native';\nimport moment, { Moment } from 'moment';\nimport { exitProcess } from 'yargs';\n\nconst DEFAULT_DATE_FORMAT = 'DD-MM-YYYY';\n\nconst timer = (time = 100) =>\n  new Promise((resolve: any, reject) => {\n    setTimeout(() => resolve(), time);\n  });\n\ndescribe('WmCalendar Component', () => {\n  let props: WmCalendarProps;\n  const month = new Date().getMonth() + 1;\n  const year = new Date().getFullYear();\n\n  const date1 = '15-' + month + '-' + year;\n  const date2 = '18-' + month + '-' + year;\n  const date3 = '20-' + month + '-' + year;\n\n  beforeEach(() => {\n    props = new WmCalendarProps();\n    props.name = 'test_calendar';\n    props.eventstart = 'date';\n    props.dataset = [\n      { date: date1, event: 'Event A' },\n      { date: date2, event: 'Event B' },\n      { date: date3, event: 'Event C' },\n      { date: date3, event: 'Event D' },\n    ];\n    props.eventtitle = 'event';\n  });\n\n  it('should render without crashing', () => {\n    const { getByText } = render(<WmCalendar {...props} />);\n    expect(getByText('chevron-right')).toBeTruthy();\n    expect(getByText('chevron-left')).toBeTruthy();\n    expect(getByText(new Date().getUTCFullYear().toString())).toBeTruthy();\n    expect(getByText(new Date().toDateString().substring(4, 7))).toBeTruthy();\n    expect(screen).toMatchSnapshot();\n  });\n\n  it('should initialize with the current date', () => {\n    const component = new WmCalendar(props);\n    const today = moment();\n    expect(component.state.selectedDate.format('DD-MM-YYYY')).toEqual(\n      today.format('DD-MM-YYYY')\n    );\n  });\n\n  it('should prepare dataset correctly', () => {\n    const component = new WmCalendar(props);\n    component.prepareDataset(props.dataset);\n    expect(component.state.calendar.get(date1)).toBeDefined();\n    expect(component.state.calendar.get(date2).events.length).toBe(1);\n  });\n\n  it('should handle date change and invoke onSelect callback', async () => {\n    const onSelectMock = jest.fn();\n    const ref = createRef();\n    const { getByText } = render(\n      <WmCalendar {...props} onSelect={onSelectMock} ref={ref} />\n    );\n\n    // Choosing a new date (assuming the date exists for simplicity)\n    const dateButton = getByText('15');\n    fireEvent.press(dateButton);\n\n    expect(onSelectMock).toHaveBeenCalled();\n    await waitFor(() => {\n      expect(ref.current.state.props.datavalue).toBe(date1);\n    });\n    expect(dateButton.props.style[4].backgroundColor).toBe(\n      ref.current.styles.selectedDay.backgroundColor\n    );\n  });\n\n  xit('should render event icon on days with events', async () => {\n    const ref = createRef();\n    const { getByTestId, getAllByText } = render(\n      <WmCalendar {...props} ref={ref} />\n    );\n\n    ref.current.proxy.dataset = [\n      { date: date1, event: 'Event A' },\n      { date: date2, event: 'Event B' },\n      { date: date3, event: 'Event C' },\n      { date: date3, event: 'Event D' },\n    ];\n    await timer(300);\n\n    const eventIcon1 = getAllByText('circle');\n    expect(eventIcon1.length).toBe(4);\n  });\n\n  it('should update styles for selected date correctly', async () => {\n    const ref = createRef();\n    const { getByText, rerender } = render(<WmCalendar {...props} ref={ref} />);\n\n    // Update prop to change the date\n    ref.current.state.props.datavalue = date2;\n    await timer();\n\n    const selectedDate = getByText(moment(date2, 'DD-MM-YYYY').format('DD'));\n    expect(selectedDate.props.style[4].backgroundColor).toBe(\n      ref.current.styles.selectedDay.backgroundColor\n    );\n  });\n\n  it('should navigate to previous and next month correctly', async () => {\n    const { getByTestId, getByText } = render(<WmCalendar {...props} />);\n\n    // Test previous month button\n    const prevMonthBtn = getByTestId('test_calendar_prevmonthicon_icon');\n    fireEvent.press(prevMonthBtn);\n    await timer();\n    const prevMonth = moment()\n      .month(month - 2)\n      .format('MMM');\n    expect(getByText(prevMonth.toString())).toBeTruthy();\n\n    // Test next month button\n    const nextMonthBtn = getByTestId('test_calendar_nextmonthicon_icon');\n    fireEvent.press(nextMonthBtn);\n    await timer();\n    expect(\n      getByText(\n        moment()\n          .month(month - 1)\n          .format('MMM')\n          .toString()\n      )\n    ).toBeTruthy();\n  });\n\n  it('should invoke onBeforerender and onViewrender event callbacks', async () => {\n    const onBeforerenderMock = jest.fn();\n    const ref = createRef();\n    const onViewrenderMock = jest.fn();\n    props.onBeforerender = onBeforerenderMock;\n    props.onViewrender = onViewrenderMock;\n\n    render(<WmCalendar {...props} ref={ref} />);\n\n    await timer(300);\n    expect(onBeforerenderMock).toHaveBeenCalled();\n    ref.current.proxy.name = 'test_calendar';\n    await timer(300);\n\n    expect(onViewrenderMock).toHaveBeenCalled();\n    // });\n  });\n\n  xit('should apply custom styles correctly', () => {\n    props.styles = {\n      root: { backgroundColor: 'blue' },\n      day: { color: 'red' },\n    };\n    const { getByText } = render(<WmCalendar {...props} />);\n    const dayLabel = getByText('15'); // Sample day with event\n    expect(dayLabel.props.style).toEqual(\n      expect.arrayContaining([{ color: 'red' }])\n    );\n  });\n\n  it('should render multiple events correctly on a single date', () => {\n    const component = new WmCalendar(props);\n    component.prepareDataset(props.dataset);\n    const dateWindow = component.state.calendar.get(date3);\n    expect(dateWindow.events.length).toBe(2); // Two events on the same day\n  });\n\n  it('should handle invalid dates/events gracefully', () => {\n    props.dataset.push({ date: 'invalid-date', event: 'Invalid Event' });\n    const component = new WmCalendar(props);\n    expect(() => component.prepareDataset(props.dataset)).not.toThrow();\n  });\n\n  it('should restore state correctly on re-render with new props', () => {\n    const { getByText, rerender } = render(<WmCalendar {...props} />);\n    const currMonth = moment()\n      .month(month - 1)\n      .format('MMM');\n    const currYear = moment().format('YYYY');\n\n    expect(getByText(currMonth)).toBeTruthy();\n    expect(getByText(currYear)).toBeTruthy();\n\n    rerender(<WmCalendar {...props} dataset={[]} />); // Change props\n\n    expect(getByText(currMonth)).toBeTruthy();\n    expect(getByText(currYear)).toBeTruthy();\n  });\n\n  // show property\n  it('handles show property correctly', async () => {\n    const ref = createRef();\n    const tree = render(<WmCalendar {...props} show={true} ref={ref} />);\n\n    await timer(100);\n    expect(tree.root.props.style.width).not.toBe(0);\n    expect(tree.root.props.style.height).not.toBe(0);\n\n    ref.current.proxy.show = false;\n    await timer(100);\n\n    expect(tree.root.props.style.width).toBe(0);\n    expect(tree.root.props.style.height).toBe(0);\n  });\n\n  //skeleton loader\n  it('should render skeleton with respect to root styles when show skeleton is true', () => {\n    const tree = render(<WmCalendar {...props} name=\"date1\" showskeleton={true}/>);\n    const viewEles = tree.UNSAFE_getAllByType(View);\n    expect(viewEles[2].props.style.width).toBe('10%');\n    expect(viewEles[2].props.style.height).toBe(28);\n    expect(viewEles[3].props.style.width).toBe('68%');\n    expect(viewEles[3].props.style.height).toBe(16);\n    expect(viewEles[4].props.style.width).toBe('10%');\n    expect(viewEles[4].props.style.height).toBe(28);\n  })\n});\n", "wavemaker-rn-runtime/test/components/input/chips.component.spec.tsx": "import React, { ReactNode, createRef } from 'react';\nimport { Text, TouchableOpacity, View } from 'react-native';\nimport {\n  render,\n  screen,\n  fireEvent,\n  waitFor,\n} from '@testing-library/react-native';\nimport WmChips from '@wavemaker/app-rn-runtime/components/input/chips/chips.component';\nimport WmChipsProps from '@wavemaker/app-rn-runtime/components/input/chips/chips.props';\n\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport WmSearch from '@wavemaker/app-rn-runtime/components/basic/search/search.component';\nimport WmPicture from '@wavemaker/app-rn-runtime/components/basic/picture/picture.component';\n\nimport { ModalProvider } from '@wavemaker/app-rn-runtime/core/modal.service';\nimport { AssetProvider } from '@wavemaker/app-rn-runtime/core/asset.provider';\nimport AppModalService from '@wavemaker/app-rn-runtime/runtime/services/app-modal.service';\n\nconst timer = (time = 100) =>\n  new Promise((resolve: any, reject) => {\n    setTimeout(() => resolve(), time);\n  });\n\nconst loadAsset = (path: any) => path;\n\nAppModalService.modalsOpened = [];\n\ndescribe('WmChips', () => {\n  let defaultProps: WmChipsProps;\n  let datasetProps: React.JSX.IntrinsicAttributes &\n    React.JSX.IntrinsicClassAttributes<WmChips> &\n    Readonly<WmChipsProps>;\n\n  beforeEach(() => {\n    defaultProps = new WmChipsProps();\n    defaultProps.dataset = [\n      {\n        name: 'name0',\n        dataValue: 'dataValue0',\n      },\n      {\n        name: 'name1',\n        dataValue: 'dataValue1',\n      },\n      {\n        name: 'name2',\n        dataValue: 'dataValue2',\n      },\n    ];\n    defaultProps.searchable = true;\n    defaultProps.placeholder = 'Search chips...';\n    defaultProps.searchkey = 'name';\n\n    datasetProps = {\n      datafield: 'name',\n      displayfield: 'name',\n    };\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  function renderComponentWithWrappers(props = {}) {\n    const ref = createRef();\n    return render(\n      <ModalProvider value={AppModalService}>\n        <AssetProvider value={loadAsset}>\n          <WmChips {...defaultProps} {...datasetProps} {...props} />\n        </AssetProvider>\n      </ModalProvider>\n    );\n  }\n\n  const invokeEventCallbackMock = jest.spyOn(\n    WmChips.prototype,\n    'invokeEventCallback'\n  );\n\n  // Check Rendering with Default Props\n  it('renders correctly with default props and type as search', () => {\n    render(<WmChips {...defaultProps} {...datasetProps} />);\n    expect(screen.getByPlaceholderText('Search chips...')).toBeTruthy();\n    let searchInput = screen.UNSAFE_getByType(WmSearch);\n    expect(searchInput.props.type).toBe('search');\n    expect(screen).toMatchSnapshot();\n  });\n\n  it('renders correctly with default props and type as autocomplete', async () => {\n    render(<WmChips {...defaultProps} {...datasetProps} minchars={0} />);\n    expect(screen.getByPlaceholderText('Search chips...')).toBeTruthy();\n    let searchInput = screen.UNSAFE_getByType(WmSearch);\n    expect(searchInput.props.type).toBe('autocomplete');\n  });\n\n  // Dataset Handling\n  it('handles dataset properly and renders chips based on it', () => {\n    render(\n      <WmChips\n        {...defaultProps}\n        {...datasetProps}\n        searchable={false}\n        datavalue=\"name1\"\n      />\n    );\n\n    const selectedChip = screen.getByText('name1');\n    expect(screen.getByText('name0')).toBeTruthy();\n    expect(screen.getByText('name2')).toBeTruthy();\n    expect(selectedChip).toBeTruthy();\n    expect(selectedChip.parent?.parent?.props.accessibilityState.selected).toBe(\n      true\n    );\n  });\n\n  // Prop Update Handling\n  it('responds to prop updates correctly', async () => {\n    const { rerender } = render(\n      <WmChips {...defaultProps} {...datasetProps} />\n    );\n    const newDataset = [{ name: 'Chip 3', dataValue: 'chip3' }];\n    rerender(\n      <WmChips\n        {...defaultProps}\n        dataset={newDataset}\n        {...datasetProps}\n        searchable={false}\n      />\n    );\n    await waitFor(() => {\n      expect(screen.getByText('Chip 3')).toBeTruthy();\n    });\n  });\n\n  // Item Addition\n  it('adds chips correctly', async () => {\n    // AppModalService.modalsOpened = [];\n\n    const tree = renderComponentWithWrappers();\n    const searchInput = tree.getByPlaceholderText('Search chips...');\n    const search = tree.UNSAFE_getByType(WmSearch);\n    search.instance.view = {\n      measure: (callback: Function) => {\n        callback(0, 0, 100, 50, 10, 20);\n      },\n    } as any;\n    fireEvent(searchInput, 'onFocus');\n    fireEvent.changeText(searchInput, 'name2');\n\n    await timer(500);\n\n    const renderOptions = AppModalService.modalOptions; //[0];\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const subTree = render(<Content />);\n\n    const selectItem = subTree.getByText('name2');\n    expect(selectItem).toBeTruthy();\n\n    fireEvent.press(selectItem);\n    await waitFor(() => {\n      expect(tree.getByText('name2')).toBeTruthy();\n    });\n    // should not add same chip if selected again.\n    fireEvent.press(selectItem);\n    const resetSearchModelMock = jest.spyOn(\n      WmChips.prototype,\n      'resetSearchModel'\n    );\n    await waitFor(() => {\n      expect(resetSearchModelMock).toHaveBeenCalled();\n    });\n  });\n\n  // Item Removal\n  it('removes chips correctly', async () => {\n    render(<WmChips {...defaultProps} {...datasetProps} datavalue=\"name2\" />);\n    fireEvent.press(screen.getByText('clear'));\n    const removeItemMock = jest.spyOn(WmChips.prototype, 'removeItem');\n    await waitFor(() => {\n      expect(removeItemMock).toHaveBeenCalled();\n    });\n    expect(screen.queryByText('name2')).toBeNull();\n  });\n\n  // Max Size Handling\n  it('does not add more chips when max size is reached', async () => {\n    // AppModalService.modalsOpened = [];\n    const tree = renderComponentWithWrappers({\n      maxsize: 1,\n      datavalue: 'name2',\n    });\n    expect(tree.getByPlaceholderText('Max size reached')).toBeTruthy();\n\n    fireEvent.press(tree.getByText('clear'));\n    await timer(300);\n\n    const searchInput = tree.getByPlaceholderText('Search chips...');\n    const search = tree.UNSAFE_getByType(WmSearch);\n    search.instance.view = {\n      measure: (callback: Function) => {\n        callback(0, 0, 100, 50, 10, 20);\n      },\n    } as any;\n    fireEvent(searchInput, 'onFocus');\n    fireEvent.changeText(searchInput, 'name');\n\n    await timer(500);\n\n    const renderOptions = AppModalService.modalOptions; //[0];\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const subTree = render(<Content />);\n    fireEvent.press(subTree.getByText('name1'));\n    await timer(300);\n    await waitFor(() => {\n      expect(tree.getByText('name1')).toBeTruthy();\n      expect(tree.queryByText('name2')).toBeNull();\n      expect(tree.getByPlaceholderText('Max size reached')).toBeTruthy();\n    });\n  });\n\n  // Accessibility Props\n  xit('applies accessibility props correctly', async () => {\n    const ref = createRef();\n    render(\n      <WmChips\n        {...defaultProps}\n        {...datasetProps}\n        searchable={true}\n        ref={ref}\n        accessibilitylabel=\"Chips Component\"\n        hint=\"chips\"\n      />\n    );\n\n    await waitFor(() => {\n      // expect(screen).toMatchSnapshot();\n      expect(screen.getByLabelText('Chips Component')).toBeTruthy();\n      expect(screen.getByAccessibilityHint('chips')).toBeTruthy();\n    });\n  });\n\n  it('should be able to select chip when searchable is false', () => {\n    const ref = createRef();\n    render(\n      <WmChips\n        {...defaultProps}\n        {...datasetProps}\n        searchable={false}\n        ref={ref}\n      />\n    );\n    const selectChipMock = jest.spyOn(WmChips.prototype, 'selectChip');\n    const setDatavalueMock = jest.spyOn(WmChips.prototype, 'setDatavalue');\n    const chipItem = screen.getByText('name1');\n    fireEvent.press(chipItem);\n    expect(selectChipMock).toHaveBeenCalled();\n    expect(setDatavalueMock).toHaveBeenCalled();\n    expect(invokeEventCallbackMock).toHaveBeenCalled();\n    expect(ref.current.state.dataItems[1].selected).toBe(true);\n  });\n\n  it('should handle readonly properly', async () => {\n    render(\n      <WmChips\n        {...defaultProps}\n        {...datasetProps}\n        datavalue=\"name1\"\n        readonly={true}\n      />\n    );\n    expect(screen.queryByText('clear')).toBeNull();\n\n    await timer(300);\n    await waitFor(() => {\n      expect(screen.getByText('name1')).toBeTruthy();\n    });\n\n    render(\n      <WmChips\n        {...defaultProps}\n        {...datasetProps}\n        datavalue=\"name1\"\n        readonly={true}\n        searchable={false}\n      />\n    );\n    const defaultChip = screen.getByText('name1');\n    fireEvent.press(defaultChip);\n    await timer(300);\n    expect(defaultChip.parent?.parent?.props.accessibilityState.selected).toBe(\n      true\n    );\n  });\n\n  it('should handle disabled properly', async () => {\n    render(\n      <WmChips\n        {...defaultProps}\n        {...datasetProps}\n        datavalue=\"name1\"\n        disabled={true}\n      />\n    );\n    expect(screen.queryByText('clear')).toBeNull();\n    fireEvent.press(screen.getByText('name1'));\n\n    await waitFor(() => {\n      expect(screen.getByText('name1')).toBeTruthy();\n    });\n  });\n\n  it('should not allow to select chips more than maxsize', async () => {\n    render(\n      <WmChips\n        {...defaultProps}\n        {...datasetProps}\n        searchable={false}\n        datavalue=\"name1\"\n        maxsize={1}\n      />\n    );\n    const defaultChip = screen.getByText('name1');\n    const selectedChip = screen.getByText('name2');\n    fireEvent.press(selectedChip);\n    expect(selectedChip.parent?.parent?.props.accessibilityState.selected).toBe(\n      false\n    );\n    expect(defaultChip.parent?.parent?.props.accessibilityState.selected).toBe(\n      true\n    );\n\n    fireEvent.press(defaultChip);\n    await timer();\n    fireEvent.press(selectedChip);\n\n    await waitFor(() => {\n      expect(\n        selectedChip.parent?.parent?.props.accessibilityState.selected\n      ).toBe(true);\n    });\n  });\n  //skeleton loader\n  it('should render skeleton when show skeleton is true', () => {\n    const { getByTestId } = render(\n      <WmChips {...defaultProps} {...datasetProps} showskeleton={true} />\n    );\n    expect(getByTestId('null_chip0').children[0].props.styles.root.width).toBe(\n      50\n    );\n    expect(getByTestId('null_chip1').children[0].props.styles.root.width).toBe(\n      50\n    );\n    expect(getByTestId('null_chip2').children[0].props.styles.root.width).toBe(\n      50\n    );\n  });\n});\n", "wavemaker-rn-runtime/test/components/input/checkbox.component.spec.tsx": "import React, { ReactNode, createRef } from 'react';\nimport {\n  render,\n  screen,\n  fireEvent,\n  waitFor,\n} from '@testing-library/react-native';\nimport WmCheckbox from '@wavemaker/app-rn-runtime/components/input/checkbox/checkbox.component';\nimport WmCheckboxProps from '@wavemaker/app-rn-runtime/components/input/checkbox/checkbox.props';\nimport { View } from 'react-native';\n\n// jest.mock(\n//   '@wavemaker/app-rn-runtime/components/basic/icon/icon.component',\n//   () => 'WmIcon'\n// );\n\ndescribe('WmCheckbox Unit tests', () => {\n  let defaultProps: WmCheckboxProps;\n\n  beforeEach(() => {\n    defaultProps = new WmCheckboxProps();\n    defaultProps.caption = 'Test Checkbox';\n    // defaultProps.datavalue = false;\n    defaultProps.checkedvalue = 'yes';\n    defaultProps.uncheckedvalue = 'no';\n    // defaultProps.readonly = false;\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  // Check Rendering with Default Props\n  it('renders correctly with default props', () => {\n    render(<WmCheckbox {...defaultProps} />);\n    expect(screen).toMatchSnapshot();\n    expect(screen.getByText('Test Checkbox')).toBeTruthy();\n  });\n\n  // Checked and Unchecked Value Handling\n  it('handles checked and unchecked values correctly', async () => {\n    const { rerender } = render(\n      <WmCheckbox {...defaultProps} datavalue=\"yes\" />\n    );\n    const checkbox = screen.getByRole('checkbox');\n    expect(checkbox.props.accessibilityState.checked).toBe(true);\n\n    rerender(<WmCheckbox {...defaultProps} datavalue=\"no\" />);\n    await waitFor(() => {\n      expect(checkbox.props.accessibilityState.checked).toBe(false);\n    });\n  });\n\n  // Disabled and Readonly Handling\n  xit('does not respond to press events when disabled', async () => {\n    render(<WmCheckbox {...defaultProps} disabled={true} />);\n    const checkbox = screen.getByRole('checkbox');\n    const invokeEventCallbackMock = jest.spyOn(\n      WmCheckbox.prototype,\n      'invokeEventCallback'\n    );\n    fireEvent.press(checkbox);\n    await waitFor(() => {\n      expect(checkbox.props.accessibilityState.checked).not.toBe(true);\n      expect(invokeEventCallbackMock).not.toHaveBeenCalled();\n      expect(checkbox.props.accessibilityState.disabled).toBe(true);\n    });\n  });\n\n  it('does not respond to press events when readonly', async () => {\n    render(<WmCheckbox {...defaultProps} readonly={true} datavalue=\"yes\" />);\n    const invokeEventCallback = jest.spyOn(\n      WmCheckbox.prototype,\n      'invokeEventCallback'\n    );\n\n    const checkbox = screen.getByRole('checkbox');\n    fireEvent.press(checkbox);\n    await waitFor(() => {});\n    expect(checkbox.props.accessibilityState.checked).toBe(true);\n    expect(invokeEventCallback).not.toHaveBeenCalledWith('onFocus', [\n      null,\n      expect.anything(),\n    ]);\n  });\n\n  // Accessibility Props\n  xit('applies accessibility props correctly', () => {\n    render(\n      <WmCheckbox\n        {...defaultProps}\n        disabled={false}\n        datavalue=\"yes\"\n        hint=\"wm-checkbox\"\n      />\n    );\n    const checkbox = screen.getByRole('checkbox');\n    expect(screen.getByLabelText('Checkbox for Test Checkbox')).toBeTruthy();\n    expect(checkbox).toBeTruthy();\n    expect(screen.getByA11yHint('wm-checkbox')).toBeTruthy();\n    expect(checkbox.props.accessibilityState.checked).toBe(true);\n    expect(checkbox.props.accessibilityState.disabled).toBe(false);\n  });\n\n  // Validation\n  it('validates correctly using validateField utility', async () => {\n    const validateMock = jest.spyOn(WmCheckbox.prototype, 'validate');\n    const updateStateMock = jest.spyOn(WmCheckbox.prototype, 'updateState');\n    render(<WmCheckbox {...defaultProps} required={true} datavalue=\"no\" />);\n    fireEvent.press(screen.getByRole('checkbox'));\n    await waitFor(() => {\n      expect(validateMock).toHaveBeenCalled();\n      expect(updateStateMock).toHaveBeenCalledWith({\n        isValid: true,\n        errorType: undefined,\n      });\n    });\n  });\n\n  // User Interaction (onPress)\n  it('handles onPress event correctly', async () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmCheckbox.prototype,\n      'invokeEventCallback'\n    );\n    const updateStateMock = jest.spyOn(WmCheckbox.prototype, 'updateState');\n    const props = {\n      ...defaultProps,\n      datavalue: 'no',\n    };\n    render(<WmCheckbox {...props} />);\n    const checkbox = screen.getByRole('checkbox');\n    fireEvent.press(checkbox);\n\n    await waitFor(() => {\n      expect(invokeEventCallbackMock).toHaveBeenCalledWith('onBlur', [\n        null,\n        expect.anything(),\n      ]);\n      expect(updateStateMock).toHaveBeenCalledWith({ isChecked: true });\n    });\n\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith('onChange', [\n      null,\n      expect.anything(),\n      'yes',\n      'no',\n    ]);\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith('onTap', [\n      null,\n      expect.anything(),\n    ]);\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith('onFocus', [\n      null,\n      expect.anything(),\n    ]);\n  });\n\n  // Icon and Text Rendering\n  it('renders icon and text correctly', () => {\n    render(<WmCheckbox {...defaultProps} />);\n\n    expect(screen.getByText('Test Checkbox')).toBeTruthy();\n    expect(screen.getByText('check')).toBeTruthy();\n  });\n\n  // Disabled State Styles\n  it('applies correct styles when disabled', () => {\n    render(<WmCheckbox {...defaultProps} disabled={true} />);\n    const checkbox = screen.getByRole('checkbox');\n    // Check if disabled styles are applied correctly\n    expect(checkbox.props.style).toMatchObject({ opacity: 0.8 });\n  });\n\n  // Initialization and State\n  it('sets initial state correctly based on datavalue', () => {\n    const ref = createRef();\n    const { getByRole } = render(\n      <WmCheckbox {...defaultProps} datavalue=\"yes\" ref={ref} />\n    );\n    const checkbox = getByRole('checkbox');\n    expect(ref.current.state.isChecked).toBe(true);\n  });\n\n  // Internal Methods\n  it('calls internal methods correctly', async () => {\n    const ref = createRef();\n    const onFieldChange = jest.fn();\n    render(\n      <WmCheckbox\n        {...defaultProps}\n        ref={ref}\n        onFieldChange={onFieldChange}\n        datavalue=\"no\"\n      />\n    );\n    const setCheckedMock = jest.spyOn(WmCheckbox.prototype, 'setChecked');\n    const updateStateMock = jest.spyOn(WmCheckbox.prototype, 'updateState');\n\n    fireEvent.press(screen.getByRole('checkbox'));\n\n    await waitFor(() => {\n      expect(setCheckedMock).toHaveBeenCalled();\n      expect(onFieldChange).toHaveBeenCalledWith('datavalue', 'yes', 'no');\n    });\n    expect(ref.current.state.isChecked).toBe(true);\n\n    fireEvent.press(screen.getByRole('checkbox'));\n\n    await waitFor(() => {\n      expect(setCheckedMock).toHaveBeenCalled();\n      expect(ref.current.state.isChecked).toBe(false);\n    });\n\n    ref.current.updateDatavalue(true);\n    expect(updateStateMock).toHaveBeenCalledWith({\n      props: { datavalue: true },\n    });\n  });\n\n  //skeleton loader\n  it('should render skeleton with default styles when show skeleton is true', () => {\n    const {UNSAFE_getAllByType} = render(<WmCheckbox {...defaultProps} showskeleton={true} />)\n    const skeletonText = UNSAFE_getAllByType(View);\n    expect(skeletonText[1].props.style.width).toBe(20);\n    expect(skeletonText[1].props.style.height).toBe(20);\n    expect(skeletonText[2].props.style.width).toBe(200);\n    expect(skeletonText[2].props.style.height).toBe(16);\n  })\n});\n", "wavemaker-rn-runtime/test/components/input/select.component.spec.tsx": "import React, { ReactNode, createRef } from 'react';\nimport { View, Text, TouchableOpacity } from 'react-native';\nimport WmSelect from '@wavemaker/app-rn-runtime/components/input/select/select.component';\nimport WmSelectProps from '@wavemaker/app-rn-runtime/components/input/select/select.props';\nimport {\n  render,\n  screen,\n  fireEvent,\n  waitFor,\n  cleanup,\n} from '@testing-library/react-native';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\n\nimport * as AccessibilityConfig from '../../../src/core/accessibility';\n\nimport AppModalService from '@wavemaker/app-rn-runtime/runtime/services/app-modal.service';\nimport { AssetProvider } from '@wavemaker/app-rn-runtime/core/asset.provider';\nimport { ModalProvider } from '@wavemaker/app-rn-runtime/core/modal.service';\nimport { create } from 'lodash-es';\n\nconst dataItems = [\n  {\n    name: 'name0',\n    dataValue: 'dataValue0',\n  },\n  {\n    name: 'name1',\n    dataValue: 'dataValue1',\n  },\n  {\n    name: 'name2',\n    dataValue: 'dataValue2',\n  },\n];\n\nconst timer = (time = 100) =>\n  new Promise((resolve: any, reject) => {\n    setTimeout(() => resolve(), time);\n  });\n\nconst loadAsset = (path: any) => path;\n\nconst defaultProps = {\n  placeholder: 'Select an option',\n  dataset: [\n    {\n      name: 'name0',\n      dataValue: 'dataValue0',\n    },\n    {\n      name: 'name1',\n      dataValue: 'dataValue1',\n    },\n    {\n      name: 'name2',\n      dataValue: 'dataValue2',\n    },\n  ],\n  datafield: 'name',\n  displayfield: 'name',\n};\n\nAppModalService.modalsOpened = [];\n\nfunction renderComponentWithWrappers(props = {}) {\n  AppModalService.modalsOpened = [];\n\n  return render(\n    <ModalProvider value={AppModalService}>\n      <AssetProvider value={loadAsset}>\n        <WmSelect\n          {...defaultProps}\n          dataset={dataItems}\n          datafield=\"name\"\n          displaylabel=\"name\"\n          {...props}\n        />\n      </AssetProvider>\n    </ModalProvider>\n  );\n}\n\ndescribe('WmSelect', () => {\n  beforeEach(() => {\n    jest\n      .spyOn(AccessibilityConfig, 'isScreenReaderEnabled')\n      .mockReturnValue(false);\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n    cleanup();\n  });\n\n  // Check Rendering with Default Props\n  it('renders correctly with default props', () => {\n    render(<WmSelect {...defaultProps} name=\"select1\" />);\n    expect(screen.getByText('Select an option')).toBeTruthy();\n    expect(screen).toMatchSnapshot();\n  });\n\n  // Disabled State\n  it('does not allow selection when disabled', async () => {\n    const tree = renderComponentWithWrappers({\n      disabled: true,\n      accessibilityrole: 'select',\n    });\n    const select = tree.getByText('Select an option');\n    const selectParent = tree.getByRole('select');\n    expect(selectParent.props.accessibilityState.disabled).toBe(true);\n    fireEvent.press(select);\n\n    await timer(200);\n\n    const renderOptions = AppModalService.modalOptions;\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const subTree = render(<Content />);\n    expect(subTree.queryByText('name0')).toBe(null);\n  });\n\n  // Event Handling\n  it('handles onFocus and onBlur events', async () => {\n    const onFocusMock = jest.fn();\n    const onBlurMock = jest.fn();\n    const ref = createRef();\n    const tree = renderComponentWithWrappers({\n      onFocus: onFocusMock,\n      onBlur: onBlurMock,\n      ref,\n    });\n    const select = tree.getByText('Select an option');\n\n    fireEvent.press(select);\n\n    expect(onFocusMock).toHaveBeenCalled();\n\n    await timer(200);\n\n    const renderOptions = AppModalService.modalOptions;\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const subTree = render(<Content />);\n\n    const cancel = subTree.getByText('name0');\n    fireEvent.press(cancel);\n    await timer(500);\n\n    expect(onBlurMock).toHaveBeenCalled();\n  });\n\n  // Dataset Handling\n  it('handles dataset properly and renders options based on it', async () => {\n    const tree = renderComponentWithWrappers({ name: 'select1' });\n    const select = tree.getByText('Select an option');\n    fireEvent.press(select);\n\n    await timer(200);\n\n    const renderOptions = AppModalService.modalOptions;\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const subTree = render(<Content />);\n    expect(subTree.getByText('name0')).toBeTruthy();\n    expect(subTree.getByText('name1')).toBeTruthy();\n    expect(subTree.getByText('name2')).toBeTruthy();\n  });\n\n  // Accessibility Props\n  it('applies accessibility props correctly', () => {\n    render(\n      <WmSelect\n        {...defaultProps}\n        accessibilitylabel=\"Select an option\"\n        hint=\"wm-select\"\n        accessibilityrole=\"select\"\n      />\n    );\n\n    expect(screen.getByLabelText('Select an option')).toBeTruthy();\n    expect(screen.getByRole('select')).toBeTruthy();\n    expect(screen.getAllByA11yHint('wm-select')).toBeTruthy();\n  });\n\n  //default value\n  it('renders default value correctly', async () => {\n    const tree = renderComponentWithWrappers({\n      accessibilityrole: 'select',\n      datavalue: 'name1',\n    });\n\n    const select = tree.getByText('name1');\n    fireEvent.press(select);\n\n    await timer(200);\n\n    const renderOptions = AppModalService.modalOptions;\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const subTree = render(<Content />);\n    expect(\n      subTree.UNSAFE_getAllByType(WmIcon)[2].props.styles.root.opacity\n    ).toBe(1);\n  });\n\n  // Item Selection\n  it('selects item correctly and updates value', async () => {\n    const ref = createRef();\n    const onChangeEventMock = jest.fn();\n    const tree = renderComponentWithWrappers({\n      accessibilityrole: 'select',\n      ref,\n      onChange: onChangeEventMock,\n    });\n    const onChangefnMock = jest.spyOn(WmSelect.prototype, 'onChange');\n    const select = tree.getByText('Select an option');\n    const selectParent = tree.getByRole('select');\n\n    fireEvent.press(select);\n\n    await timer(200);\n\n    const renderOptions = AppModalService.modalOptions; //[0];\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const subTree = render(<Content />);\n\n    AppModalService.animatedRefs = [\n      {\n        triggerExit: () => {},\n      },\n    ];\n    const option = subTree.getByText('name0');\n\n    fireEvent.press(option);\n\n    await timer(1000);\n\n    expect(onChangeEventMock).toHaveBeenCalled();\n    expect(onChangefnMock).toHaveBeenCalled();\n    await waitFor(() => {\n      expect(screen.getByText('name0')).toBeTruthy();\n    });\n  });\n\n  // Error Handling\n  it('handles validation and error states correctly', async () => {\n    const triggerValidationMock = jest.fn();\n    const ref = createRef();\n    const validateMock = jest.spyOn(WmSelect.prototype, 'validate');\n    // const validateMock = jest.spyOn(, 'validateField');\n    const tree = renderComponentWithWrappers({\n      triggerValidation: triggerValidationMock,\n      datavalue: '',\n      ref,\n      required: true,\n    });\n    const select = screen.getByText('Select an option');\n    fireEvent.press(select);\n\n    await timer(200);\n\n    const renderOptions = AppModalService.modalOptions; //[0];\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const subTree = render(<Content />);\n    renderOptions.onClose();\n    await timer(200);\n\n    expect(triggerValidationMock).toHaveBeenCalled();\n    expect(validateMock).toHaveBeenCalled();\n  });\n\n  // show property\n  it('handles show property correctly', async () => {\n    const ref = createRef();\n    const tree = render(\n      <WmSelect\n        {...defaultProps}\n        accessibilitylabel=\"Select an option\"\n        show={true}\n        ref={ref}\n      />\n    );\n\n    await timer(100);\n    expect(tree.root.props.children[1].props.style[0].width).not.toBe(0);\n    expect(tree.root.props.children[1].props.style[0].height).not.toBe(0);\n\n    ref.current.proxy.show = false;\n    await timer(100);\n\n    expect(tree.root.props.children[1].props.style[0].width).toBe(0);\n    expect(tree.root.props.children[1].props.style[0].height).toBe(0);\n  });\n\n//skeleton loader\n  it('should render skeleton with respect to root styles when show skeleton is true',  () => {\n    const tree = render(<WmSelect {...defaultProps} showskeleton={true} />);\n    expect(tree).toMatchSnapshot();\n    const viewEles = tree.UNSAFE_getAllByType(View);\n    expect(viewEles[2].props.style.width).toBe(100);\n    expect(viewEles[2].props.style.height).toBe(16);\n    expect(viewEles[3].props.style.width).toBe(24);\n    expect(viewEles[3].props.style.height).toBe(24);\n  })\n});\n", "wavemaker-rn-runtime/test/components/input/text.component.spec.tsx": "import React, { createRef } from 'react';\nimport { act, fireEvent, render, waitFor } from '@testing-library/react-native';\nimport WmText from '@wavemaker/app-rn-runtime/components/input/text/text.component';\nimport { Platform, TextInput } from 'react-native';\nimport injector from '@wavemaker/app-rn-runtime/core/injector';\n\nconst defaultProps = {\n  id: 'wmText',\n  name: 'wmText',\n  // floatinglabel: 'Enter text',\n  placeholder: 'Enter text',\n  disabled: false,\n  show: true,\n  styles: null,\n  classname: null,\n  listener: null,\n  showindevice: null,\n  showskeleton: false,\n  deferload: false,\n  // onChangeText: jest.fn(),\n};\n\ndescribe('Text component', () => {\n  test('should render correctly with default props', () => {\n    const tree = render(<WmText {...defaultProps} />);\n    expect(tree.getByPlaceholderText('Enter text')).toBeTruthy();\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should show floating label when focused', async () => {\n    const tree = render(\n      <WmText {...defaultProps} floatinglabel=\"Floating Label\" />\n    );\n    const { UNSAFE_getByType, queryByText, getByText } = tree;\n    const input = UNSAFE_getByType(TextInput);\n\n    fireEvent(input, 'focus', {\n      target: null,\n    });\n\n    await waitFor(() => {\n      expect(getByText('Floating Label')).toBeTruthy();\n    });\n  });\n\n  test('should call onChangeText with correct value', () => {\n    const onChangeTextMock = jest.spyOn(WmText.prototype, 'onChangeText');\n\n    const { getByPlaceholderText } = render(<WmText {...defaultProps} />);\n    const input = getByPlaceholderText('Enter text');\n    const text = 'test';\n\n    fireEvent.changeText(input, text);\n\n    expect(onChangeTextMock).toHaveBeenCalledWith(text);\n  });\n\n  test('should handle disabled prop correctly', () => {\n    const { getByPlaceholderText } = render(\n      <WmText {...defaultProps} disabled={true} />\n    );\n    const input = getByPlaceholderText('Enter text');\n    expect(input.props.editable).toBe(false);\n  });\n\n  test('should handle readonly prop correctly', () => {\n    const { getByPlaceholderText } = render(\n      <WmText {...defaultProps} readonly={true} />\n    );\n    const input = getByPlaceholderText('Enter text');\n    expect(input.props.editable).toBe(false);\n  });\n\n  test('should handle maxchars prop correctly', () => {\n    const maxchars = 10;\n    const { getByPlaceholderText } = render(\n      <WmText {...defaultProps} maxchars={maxchars} />\n    );\n    const input = getByPlaceholderText('Enter text');\n    expect(input.props.maxLength).toBe(maxchars);\n  });\n\n  test('should handle secureTextEntry prop correctly for password type', () => {\n    const { getByPlaceholderText } = render(\n      <WmText {...defaultProps} type=\"password\" />\n    );\n    const input = getByPlaceholderText('Enter text');\n    expect(input.props.secureTextEntry).toBe(true);\n  });\n\n  test('should render floating label', () => {\n    const { getByText } = render(\n      <WmText {...defaultProps} floatinglabel=\"Test Label\" />\n    );\n    expect(getByText('Test Label')).toBeTruthy();\n  });\n\n  test.skip('should render field in invalid state when isValid is false', async () => {\n    const invalidStyle = { borderColor: 'red' };\n    const { getByPlaceholderText } = render(\n      <WmText {...defaultProps} styles={{ invalid: invalidStyle }} />\n    );\n\n    const input = getByPlaceholderText('Enter text');\n    const inputStyleArr = input.props.style[0];\n    const inputStyle = {};\n    inputStyleArr.forEach((item) => {\n      if (!item) return;\n      Object.keys(item).forEach((key) => {\n        inputStyle[key] = item[key];\n      });\n    });\n\n    fireEvent.changeText(input, 'text exceeding validation');\n\n    await waitFor(() => {\n      expect(inputStyle).toMatchObject(invalidStyle);\n    });\n  });\n\n  test('should secureTextEntry true for password inputs when maskchar is falsy', () => {\n    const { getByPlaceholderText } = render(\n      <WmText {...defaultProps} type=\"password\" maskchar={null} />\n    );\n    const input = getByPlaceholderText('Enter text');\n    expect(input.props.secureTextEntry).toBe(true);\n  });\n\n  test('should impose displayformat accurately', () => {\n    const customRef = createRef();\n    const displayformat = '999-999-9999';\n    const tree = render(\n      <WmText {...defaultProps} displayformat={displayformat} ref={customRef} />\n    );\n    const { getByText, UNSAFE_getByType } = tree;\n    const input = UNSAFE_getByType(TextInput);\n\n    fireEvent.changeText(input, '1231231234');\n    expect(getByText('123-123-1234')).toBeTruthy();\n  });\n\n  test('should mask characters accurately when maskchar is provided', async () => {\n    const maskchar = '*';\n    const { getByPlaceholderText, getByText } = render(\n      <WmText {...defaultProps} maskchar={maskchar} updateon='default'/>\n    );\n    const input = getByPlaceholderText('Enter text');\n    act(() => {\n      fireEvent.changeText(input, '123456');\n    });\n\n    await waitFor(()=>{\n      expect(getByText('******')).toBeTruthy();\n    })\n  });\n\n  test('should hide skeleton when showSkeleton is false', () => {\n    const { queryByTestId } = render(\n      <WmText {...defaultProps} showskeleton={false} />\n    );\n    const skeleton = queryByTestId('skeleton');\n    expect(skeleton).toBeNull();\n  });\n\n  test('renders with accessibility properties', () => {\n    const { getByLabelText } = render(\n      <WmText {...defaultProps} accessibilitylabel=\"Text input\" />\n    );\n    const input = getByLabelText('Text input');\n    expect(input.props.accessibilityLabel).toBe('Text input');\n  });\n\n  test('should auto complete username if autocomplete prop is provided', () => {\n    const { getByPlaceholderText } = render(\n      <WmText {...defaultProps} autocomplete={\"true\"} />\n    );\n    const input = getByPlaceholderText('Enter text');\n    expect(input.props.autoComplete).toBe('username');\n  });\n\n  test('should auto complete off if autocomplete prop is false', () => {\n    const { getByPlaceholderText } = render(\n      <WmText {...defaultProps} autocomplete={\"false\"} />\n    );\n    const input = getByPlaceholderText('Enter text');\n    expect(input.props.autoComplete).toBe('off');\n  });\n\n  test('should have default value for native platform', () => {\n    const tree = render(<WmText {...defaultProps} datavalue=\"sample text\" />);\n    expect(tree.UNSAFE_getByType(TextInput).props.defaultValue).toBe(\n      'sample text'\n    );\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should have default value for web platform', () => {\n    (Platform as any).OS = 'web';\n\n    const tree = render(<WmText {...defaultProps} datavalue=\"sample text\" />);\n    expect(tree.UNSAFE_getByType(TextInput).props.value).toBe('sample text');\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should not show component when show prop is false', () => {\n    const tree = render(<WmText {...defaultProps} show={false} />);\n\n    const styleArr = tree.getByPlaceholderText('Enter text').props.style[0];\n    const style = {};\n    styleArr.forEach((item) => {\n      if (!item) return;\n      Object.keys(item).forEach((key) => {\n        style[key] = item[key];\n      });\n    });\n\n    expect(style).toMatchObject({\n      height: 0,\n      width: 0,\n    });\n  });\n\n  test('should have keyboardType as numeric for type as number', () => {\n    const { getByPlaceholderText } = render(\n      <WmText {...defaultProps} type=\"number\" />\n    );\n\n    const input = getByPlaceholderText('Enter text');\n    expect(input.props.keyboardType).toBe('numeric');\n  });\n\n  test('should have keyboardType as phone-pad for type as tel', () => {\n    const { getByPlaceholderText } = render(\n      <WmText {...defaultProps} type=\"tel\" />\n    );\n\n    const input = getByPlaceholderText('Enter text');\n    expect(input.props.keyboardType).toBe('phone-pad');\n  });\n\n  test('should have keyboardType as email-address for type as email', () => {\n    const { getByPlaceholderText } = render(\n      <WmText {...defaultProps} type=\"email\" />\n    );\n\n    const input = getByPlaceholderText('Enter text');\n    expect(input.props.keyboardType).toBe('email-address');\n  });\n\n  test('should assign autoCapitalize prop in textinput component', () => {\n    Platform.OS = 'ios';\n    const { getByPlaceholderText } = render(\n      <WmText \n        {...defaultProps} \n        autocapitalize='characters' \n      />\n    );\n\n    const input = getByPlaceholderText(\"Enter text\");\n    expect(input.props.autoCapitalize).toBe(\"characters\")\n  });\n\n  test('should change the text to capital when autoCapitalize prop is set to characters', async () => {\n    const { getByPlaceholderText } = render(\n      <WmText \n        {...defaultProps} \n        autocapitalize='characters' \n        updateon='default'\n      />\n    );\n\n    const input = getByPlaceholderText(\"Enter text\");\n\n    fireEvent(input, 'changeText', 'hello');\n\n    expect(input.props.autoCapitalize).toBe(\"characters\")\n\n    await waitFor(()=>{\n      expect(input.props.defaultValue).toBe(\"HELLO\")\n    })\n  });\n\n  test('should update the state when hastwowaybinding is enabled', async () => {\n    injector.FOCUSED_ELEMENT.remove = jest.fn();\n    const tree = render(\n      <WmText \n        {...defaultProps} \n        updateon='blur'\n        hastwowaybinding={true}\n        datavalue={\"hello\"}\n      />\n    );\n\n    const input = tree.getByPlaceholderText(\"Enter text\");\n\n    await waitFor(()=>{\n      expect(input.props.defaultValue).toBe(\"hello\")\n    })\n\n    fireEvent(input, 'changeText', 'hello world');\n    await new Promise((resolve: any, reject) => setTimeout(()=>{resolve()}, 800));\n    fireEvent(input, 'blur')\n    await new Promise((resolve: any, reject) => setTimeout(()=>{resolve()}, 800));\n\n    expect(input.props.defaultValue).toBe(\"hello world\")\n  });\n\n  test('should update the text after some time when updateon prop is lazy', async () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmText.prototype,\n      'invokeEventCallback'\n    );\n\n    const { getByPlaceholderText } = render(\n      <WmText \n        {...defaultProps} \n        updateon='lazy'\n      />\n    );\n\n    const input = getByPlaceholderText('Enter text');\n\n    fireEvent(input, 'changeText', 'hello');\n    expect(invokeEventCallbackMock).not.toHaveBeenCalled();\n\n    await new Promise((resolve: any, reject) => setTimeout(()=>{resolve()}, 200));\n\n    await waitFor(()=>{\n      expect(invokeEventCallbackMock).toHaveBeenCalledWith('onChange', expect.arrayContaining(['hello']));\n    })\n  });\n\n  test('should render Text instead of TextInput for Android device and disabled prop is true', async () => {\n    Platform.OS = 'android';\n    const tree = render(\n      <WmText \n        {...defaultProps} \n        disabled={true}\n      />\n    );\n\n    const input = tree.getByText('Enter text');\n\n    expect(input.type).toBe('Text')\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render Text instead of TextInput for Android device and readOnly prop is true', async () => {\n    Platform.OS = 'android';\n    const tree = render(\n      <WmText \n        {...defaultProps} \n        readonly={true}\n      />\n    );\n\n    const input = tree.getByText('Enter text');\n\n    expect(input.type).toBe('Text')\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render TextInput for iOS device and disabled prop is true', async () => {\n    Platform.OS = 'ios';\n    const tree = render(\n      <WmText \n        {...defaultProps} \n        disabled={true}\n      />\n    );\n\n    const input = tree.getByPlaceholderText('Enter text');\n\n    expect(input.type).toBe('TextInput')\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render TextInput for iOS device and readOnly prop is true', async () => {\n    Platform.OS = 'ios';\n    const tree = render(\n      <WmText \n        {...defaultProps} \n        readonly={true}\n      />\n    );\n\n    const input = tree.getByPlaceholderText('Enter text');\n\n    expect(input.type).toBe('TextInput')\n    expect(tree).toMatchSnapshot();\n  });\n});\n", "wavemaker-rn-runtime/test/components/input/fileupload.component.spec.tsx": "import React, { ReactNode, createRef } from 'react';\nimport WmFileupload from '@wavemaker/app-rn-runtime/components/input/fileupload/fileupload.component';\nimport WmFileuploadProps from '@wavemaker/app-rn-runtime/components/input/fileupload/fileupload.props';\nimport {\n  render,\n  screen,\n  fireEvent,\n  waitFor,\n} from '@testing-library/react-native';\nimport * as DocumentPicker from 'expo-document-picker';\nimport { Platform } from 'react-native';\n\njest.mock('expo-document-picker');\n\nconst timer = (time = 100) =>\n  new Promise((resolve: any, reject) => {\n    setTimeout(() => resolve(), time);\n  });\n\ndescribe('WmFileupload', () => {\n  let defaultProps: WmFileuploadProps;\n  const mockDocumentPickerResult = {\n    uri: 'file://document-uri',\n    name: 'document.txt',\n    size: 12345,\n    type: 'success',\n    mimeType: 'text/plain',\n  };\n\n  const mockDocumentPickerResponse = {\n    assets: [{ mockDocumentPickerResult }],\n    canceled: false,\n    output: {},\n  };\n  const mockDocumentPickerResponseWeb = {\n    assets: [{ file: mockDocumentPickerResult }],\n    canceled: false,\n    output: {},\n  };\n\n  beforeEach(() => {\n    defaultProps = new WmFileuploadProps();\n    defaultProps.caption = 'Upload';\n    defaultProps.iconclass = 'wm-sl-l sl-cloud-upload';\n    defaultProps.iconsize = 16;\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  // Check Rendering with Default Props\n  it('renders correctly with default props', () => {\n    render(<WmFileupload {...defaultProps} />);\n    expect(screen.getByText('Upload')).toBeTruthy();\n  });\n\n  // File Selection Handling\n  it('handles file selection correctly', async () => {\n    DocumentPicker.getDocumentAsync.mockResolvedValue(\n      mockDocumentPickerResponse\n    );\n\n    render(<WmFileupload {...defaultProps} />);\n    const button = screen.getByText('Upload');\n    fireEvent.press(button);\n\n    await waitFor(() => {\n      expect(DocumentPicker.getDocumentAsync).toHaveBeenCalled();\n      expect(screen.queryByText('Upload')).toBeTruthy();\n    });\n  });\n\n  // Accessibility Props\n  it('applies accessibility props correctly', () => {\n    render(<WmFileupload {...defaultProps} accessibilitylabel=\"Upload File\" />);\n    expect(screen.getByLabelText('Upload File')).toBeTruthy();\n  });\n\n  // Invoke onBeforeselect and onSelect Callbacks\n  it('invokes onBeforeselect and onSelect callbacks correctly', async () => {\n    const onBeforeselect = jest.fn();\n    const onSelect = jest.fn();\n    const props = { ...defaultProps, onBeforeselect, onSelect };\n\n    DocumentPicker.getDocumentAsync.mockResolvedValue(\n      mockDocumentPickerResponse\n    );\n\n    render(<WmFileupload {...props} />);\n    const button = screen.getByText('Upload');\n    fireEvent.press(button);\n\n    await waitFor(() => {\n      expect(onBeforeselect).toHaveBeenCalled();\n      expect(onSelect).toHaveBeenCalled();\n    });\n  });\n\n  // Disabled State\n  xit('does not allow file selection when disabled', async () => {\n    const props = { ...defaultProps, disabled: true };\n    render(<WmFileupload {...props} />);\n    const button = screen.getByText('Upload');\n    fireEvent.press(button);\n\n    await timer(300);\n\n    expect(DocumentPicker.getDocumentAsync).not.toHaveBeenCalled();\n  });\n\n  // some bug with expo-document-picker due to which the below case is not passing\n  // it('handles document selection cancelled by user gracefully', async () => {\n  //   const onSelect = jest.fn();\n  //   const onBeforeselect = jest.fn();\n\n  //   DocumentPicker.getDocumentAsync.mockResolvedValue({ type: 'cancel' });\n\n  //   render(\n  //     <WmFileupload\n  //       {...defaultProps}\n  //       onSelect={onSelect}\n  //       onBeforeselect={onBeforeselect}\n  //     />\n  //   );\n  //   const button = screen.getByText('Upload');\n  //   fireEvent.press(button);\n  //   await timer(300);\n  //   await waitFor(() => {\n  //     expect(DocumentPicker.getDocumentAsync).toHaveBeenCalled();\n  //     expect(onSelect).not.toHaveBeenCalled();\n  //     expect(onBeforeselect).not.toHaveBeenCalled();\n  //   });\n  // });\n\n  // Error Handling\n  xit('handles errors during file selection', async () => {\n    const error = new Error('File selection error');\n    DocumentPicker.getDocumentAsync.mockRejectedValue(error);\n\n    render(<WmFileupload {...defaultProps} />);\n    const button = screen.getByText('Upload');\n    fireEvent.press(button);\n\n    await waitFor(() => {\n      expect(DocumentPicker.getDocumentAsync).toHaveBeenCalled();\n      expect(screen.queryByText('Upload')).toBeTruthy();\n    });\n  });\n\n  // Platform-specific Behavior\n  it('handles platform-specific behavior for file selection', async () => {\n    const originalPlatform = Platform.OS;\n    Platform.OS = 'web';\n    const onSelect = jest.fn();\n    const onBeforeselect = jest.fn();\n    DocumentPicker.getDocumentAsync.mockResolvedValue(\n      mockDocumentPickerResponseWeb\n    );\n\n    render(\n      <WmFileupload\n        {...defaultProps}\n        onSelect={onSelect}\n        onBeforeselect={onBeforeselect}\n      />\n    );\n    const button = screen.getByText('Upload');\n    fireEvent.press(button);\n\n    await waitFor(() => {\n      expect(DocumentPicker.getDocumentAsync).toHaveBeenCalled();\n      expect(screen.queryByText('Upload')).toBeTruthy();\n      expect(onBeforeselect).toHaveBeenCalled();\n      expect(onSelect).toHaveBeenCalled();\n    });\n\n    Platform.OS = originalPlatform;\n  });\n});\n", "wavemaker-rn-runtime/test/components/input/rating.component.spec.tsx": "import React, { ReactNode, createRef } from 'react';\nimport renderer from 'react-test-renderer';\nimport WmRating from '@wavemaker/app-rn-runtime/components/input/rating/rating.component';\nimport WmRatingProps from '@wavemaker/app-rn-runtime/components/input/rating/rating.props';\nimport {\n  render,\n  screen,\n  fireEvent,\n  waitFor,\n} from '@testing-library/react-native';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport { View } from 'react-native';\n\n// Mock Icon Component\n// jest.mock(\n//   '@wavemaker/app-rn-runtime/components/basic/icon/icon.component',\n//   () => 'WmIcon'\n// );\n\ndescribe('WmRating', () => {\n  let defaultProps;\n\n  const dataInput = [\n    {\n      name: 'name0',\n      dataValue: 'dataValue0',\n    },\n    {\n      name: 'name1',\n      dataValue: 'dataValue1',\n    },\n    {\n      name: 'name2',\n      dataValue: 'dataValue2',\n    },\n    {\n      name: 'name3',\n      dataValue: 'dataValue3',\n    },\n    {\n      name: 'name4',\n      dataValue: 'dataValue4',\n    },\n  ];\n\n  beforeEach(() => {\n    defaultProps = {\n      dataset: dataInput,\n      datafield: 'dataValue',\n      displayfield: 'name',\n      // getDisplayExpression: null,\n      // datavalue: null,\n      maxvalue: 5,\n      // readonly: false,\n      // iconcolor: null,\n      iconsize: 32,\n      showcaptions: true,\n      // onFieldChange: jest.fn(),\n    };\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  // Check Rendering with Default Props\n  it('renders correctly with default props', () => {\n    render(<WmRating {...defaultProps} />);\n    expect(screen).toMatchSnapshot();\n    expect(screen.getAllByText('star-border')).toHaveLength(\n      defaultProps.maxvalue\n    );\n  });\n\n  // Prop Update Handling\n  it('responds to prop updates correctly', async () => {\n    const { rerender } = render(\n      <WmRating {...defaultProps} iconcolor=\"red\" datavalue=\"dataValue2\" />\n    );\n\n    expect(\n      screen.UNSAFE_getAllByType(WmIcon)[2].props.styles.text\n    ).toMatchObject({\n      color: 'red',\n    });\n\n    rerender(<WmRating {...defaultProps} datavalue=\"dataValue3\" />);\n    await waitFor(() => {\n      expect(\n        screen.UNSAFE_getAllByType(WmIcon)[3].props.styles.text\n      ).toMatchObject({\n        color: 'red',\n      });\n    });\n  });\n\n  // Readonly Handling\n  it('should not be able to change value when readonly', async () => {\n    const invokeEventCallback = jest.spyOn(\n      WmRating.prototype,\n      'invokeEventCallback'\n    );\n    const updateState = jest.spyOn(WmRating.prototype, 'updateState');\n    const ref = createRef();\n    render(<WmRating {...defaultProps} readonly={true} />);\n    const starItem = screen.getAllByText('star-border')[2];\n    fireEvent.press(starItem);\n    await waitFor(() => {\n      expect(invokeEventCallback).not.toHaveBeenCalled();\n      expect(updateState).not.toHaveBeenCalledWith({\n        props: {\n          datavalue: 'dataValue2',\n        },\n      });\n    });\n  });\n\n  // Icon Color and Size\n  it('applies correct icon color and size', async () => {\n    render(\n      <WmRating\n        {...defaultProps}\n        iconcolor=\"blue\"\n        iconsize={40}\n        datavalue=\"dataValue0\"\n      />\n    );\n    const firstStar = screen.UNSAFE_getAllByType(WmIcon)[0];\n    expect(firstStar.props.iconsize).toEqual(40);\n    await waitFor(() => {\n      expect(firstStar.props.styles.text).toEqual(\n        expect.objectContaining({ color: 'blue' })\n      );\n    });\n  });\n\n  // Caption Display\n  it('displays caption correctly when showcaptions is true', async () => {\n    render(<WmRating {...defaultProps} datavalue=\"dataValue3\" />);\n    expect(screen.getByText('name3')).toBeTruthy();\n\n    const thirdItem = screen.getAllByText('star')[2];\n    fireEvent.press(thirdItem);\n    await waitFor(() => {\n      expect(screen.getByText(dataInput[2].name)).toBeTruthy();\n    });\n  });\n\n  // Handle invalid values for props\n  it('handles invalid maxvalue gracefully', () => {\n    render(<WmRating {...defaultProps} maxvalue={null} />);\n    const stars = screen.getAllByText('star-border');\n    expect(stars).toHaveLength(5); // Default maxvalue\n  });\n\n  // Event Callbacks\n  it('invokes onFieldChange properly', async () => {\n    const onFieldChangeMock = jest.fn();\n    const props = {\n      ...defaultProps,\n      onFieldChange: onFieldChangeMock,\n    };\n\n    render(<WmRating {...props} datavalue=\"dataValue1\" />);\n    const starItem = screen.getAllByText('star-border')[0];\n    fireEvent.press(starItem);\n    await waitFor(() => {\n      expect(onFieldChangeMock).toHaveBeenCalled();\n      expect(onFieldChangeMock).toHaveBeenCalledWith(\n        'datavalue',\n        'dataValue2',\n        'dataValue1',\n        undefined\n      );\n    });\n  });\n\n  it('invokes onChange properly when pressed on any star', async () => {\n    const invokeEventCallback = jest.spyOn(\n      WmRating.prototype,\n      'invokeEventCallback'\n    );\n    render(<WmRating {...defaultProps} datavalue=\"dataValue1\" />);\n    const starItem = screen.getAllByText('star-border')[2];\n    fireEvent.press(starItem);\n    await waitFor(() => {\n      expect(invokeEventCallback).toHaveBeenCalledWith('onChange', [\n        undefined,\n        expect.anything(),\n        'dataValue4',\n        'dataValue1',\n      ]);\n    });\n  });\n\n  // Internal Methods\n  it('calls prepareItems and changeValue correctly', async () => {\n    const ref = createRef();\n\n    render(<WmRating {...defaultProps} ref={ref} />);\n\n    // Validate prepareItems method\n    ref.current.prepareItems(defaultProps);\n    expect(ref.current.state.items).toBeDefined();\n    expect(ref.current.state.selectedIndex).toBe(-1);\n\n    // Validate changeValue method\n    ref.current.changeValue(2);\n    await waitFor(() => {\n      expect(ref.current.state.props.datavalue).toBe(\n        defaultProps.dataset[2].dataValue\n      );\n    });\n  });\n\n  // Edge Cases\n  it('handles empty caption and invalid datafield gracefully', () => {\n    render(\n      <WmRating\n        {...defaultProps}\n        showcaptions={true}\n        datafield=\"\"\n        displayfield=\"\"\n      />\n    );\n    expect(screen.getAllByText('star-border').length).toBe(\n      defaultProps.maxvalue\n    );\n\n    render(\n      <WmRating\n        {...defaultProps}\n        showcaptions={true}\n        datafield=\"\"\n        datavalue=\"dataValue3\"\n        displayfield=\"\"\n      />\n    );\n    expect(screen.getByText('')).toBeTruthy();\n  });\n\n  it('handles invalid datavalue gracefully ', () => {\n    render(<WmRating {...defaultProps} datavalue={1} />);\n    expect(screen.getAllByText('star').length).toBe(2);\n  });\n\n  // Empty Dataset Handling\n  it('handles empty dataset gracefully', () => {\n    render(<WmRating {...defaultProps} dataset={null} />);\n    const items = screen.getAllByText('star-border');\n    expect(items).toHaveLength(defaultProps.maxvalue);\n  });\n\n  it('handles string dataset ', () => {\n    render(<WmRating {...defaultProps} dataset=\"a,b,c,d,e,f\" />);\n    const items = screen.getAllByText('star-border');\n    expect(items).toHaveLength(defaultProps.maxvalue);\n  });\n\n  it('invokes display expression function when provided ', () => {\n    const getDisplayExpressionMock = jest.fn();\n    render(\n      <WmRating\n        {...defaultProps}\n        getDisplayExpression={getDisplayExpressionMock}\n        datavalue=\"dataValue2\"\n      />\n    );\n    expect(getDisplayExpressionMock).toBeCalledWith(dataInput[2]);\n  });\n\n  //skeleton Loader\n  it('should render skeletonLoader with default styles when showSkeleton is true', () =>{ \n    const {UNSAFE_getAllByType} = render(<WmRating {...defaultProps} showskeleton={true}/>);\n    const skeletonEles = UNSAFE_getAllByType(View);\n    expect(skeletonEles[1].props.style.width).toBe(32);\n    expect(skeletonEles[1].props.style.height).toBe(32);\n    expect(skeletonEles[2].props.style.width).toBe(32);\n    expect(skeletonEles[2].props.style.height).toBe(32);\n    expect(skeletonEles[3].props.style.width).toBe(32);\n    expect(skeletonEles[3].props.style.height).toBe(32);\n  })\n});\n", "wavemaker-rn-runtime/test/components/input/radioset.component.spec.tsx": "import React, { ReactNode, createRef } from 'react';\nimport { Text, TouchableOpacity } from 'react-native';\nimport WmRadioset from '@wavemaker/app-rn-runtime/components/input/radioset/radioset.component';\nimport WmRadiosetProps from '@wavemaker/app-rn-runtime/components/input/radioset/radioset.props';\n\nimport {\n  render,\n  screen,\n  fireEvent,\n  waitFor,\n} from '@testing-library/react-native';\n\nconst timer = (time = 100) =>\n  new Promise((resolve: any, reject) => {\n    setTimeout(() => resolve(), time);\n  });\n\ndescribe('WmRadioset', () => {\n  let defaultProps;\n\n  beforeEach(() => {\n    defaultProps = {\n      dataset: [\n        {\n          name: 'name0',\n          dataValue: 'dataValue0',\n          group: 'g1',\n        },\n        {\n          name: 'name2',\n          dataValue: 'dataValue2',\n          group: 'g1',\n        },\n        {\n          name: 'name1',\n          dataValue: 'dataValue1',\n          group: 'g2',\n        },\n      ],\n      displayfield: 'name',\n      datafield: 'name',\n    };\n    // defaultProps.itemsperrow = { xs: 1 };\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  const invokeEventCallbackMock = jest.spyOn(\n    WmRadioset.prototype,\n    'invokeEventCallback'\n  );\n\n  // Check Rendering with Default Props\n  it('renders correctly with default props', () => {\n    render(<WmRadioset {...defaultProps} groupby=\"group\" datavalue=\"name1\" />);\n    expect(screen).toMatchSnapshot();\n    expect(screen.getByText('name0')).toBeTruthy();\n    expect(screen.getByText('name1')).toBeTruthy();\n    expect(screen.getByText('name2')).toBeTruthy();\n  });\n\n  // Item Selection\n  it('selects items correctly', async () => {\n    const ref = createRef();\n    render(<WmRadioset {...defaultProps} ref={ref} />);\n    const option1 = screen.getByText('name1');\n    const option2 = screen.getByText('name2');\n    fireEvent.press(option1);\n    expect(ref.current.state.dataItems[2].selected).toBe(true);\n    fireEvent.press(option2);\n    expect(ref.current.state.dataItems[1].selected).toBe(true);\n  });\n\n  // Group By Functionality\n  it('renders grouped data correctly', () => {\n    render(<WmRadioset {...defaultProps} groupby=\"group\" />);\n    expect(screen.getByText('g1')).toBeTruthy();\n    expect(screen.getByText('g2')).toBeTruthy();\n    expect(screen.getByText('name0')).toBeTruthy();\n    expect(screen.getByText('name1')).toBeTruthy();\n    expect(screen.getByText('name2')).toBeTruthy();\n  });\n\n  it('renders orderby correctly', () => {\n    render(<WmRadioset {...defaultProps} orderby=\"name:desc\" />);\n    const items = screen.UNSAFE_getAllByType(Text);\n    expect(items[1].props.children).toBe('name2');\n    expect(items[3].props.children).toBe('name1');\n    expect(items[5].props.children).toBe('name0');\n  });\n\n  // Accessibility Props\n  xit('applies accessibility props correctly', () => {\n    render(<WmRadioset {...defaultProps} />);\n    expect(screen.getByLabelText('Radio button for name0')).toBeTruthy();\n    expect(screen.getByLabelText('Radio button for name1')).toBeTruthy();\n    expect(screen.getByLabelText('Radio button for name2')).toBeTruthy();\n  });\n\n  // Validation and Event Handling\n  it('handles onTap and onChange event correctly', async () => {\n    render(<WmRadioset {...defaultProps} datavalue=\"name0\" />);\n    const option1 = screen.getByText('name1');\n    fireEvent.press(option1);\n\n    await waitFor(() => {\n      expect(invokeEventCallbackMock).toHaveBeenCalledTimes(2);\n    });\n    expect(invokeEventCallbackMock.mock.calls[0][0]).toBe('onTap');\n    expect(invokeEventCallbackMock.mock.calls[1][0]).toBe('onChange');\n    expect(invokeEventCallbackMock.mock.calls[1][1][2].toString()).toBe(\n      'name1'\n    );\n    expect(invokeEventCallbackMock.mock.calls[1][1][3]).toBe('name0');\n    expect(invokeEventCallbackMock.mock.calls[1][1][1]).toBeInstanceOf(\n      WmRadioset\n    );\n  });\n\n  // Edge Cases: Empty Dataset\n  it('handles empty dataset gracefully', () => {\n    const props = { ...defaultProps, dataset: [] };\n    render(<WmRadioset {...props} />);\n    expect(screen.queryByText('name1')).toBeNull();\n    expect(screen.queryByText('name0')).toBeNull();\n  });\n\n  // Custom Render Item Partial\n  it('renders custom item partial correctly', async () => {\n    const ref = createRef();\n    const renderItemPartial = jest\n      .fn()\n      .mockReturnValue(<Text>Custom Partial</Text>);\n    const props = {\n      ...defaultProps,\n      renderitempartial: renderItemPartial,\n      ref,\n    };\n    render(<WmRadioset {...props} />);\n    ref.current.setTemplate(<Text>Custom Partial</Text>);\n\n    await timer();\n    expect(renderItemPartial).toHaveBeenCalled();\n    expect(screen.getAllByText('Custom Partial')).toBeTruthy();\n  });\n\n  // Handling multiple columns\n  it('handles multiple columns correctly', () => {\n    const props = { ...defaultProps, itemsperrow: { xs: 2 } };\n    render(<WmRadioset {...props} />);\n\n    const option1 = screen.UNSAFE_getAllByType(TouchableOpacity)[0];\n    expect(option1).toHaveProperty('props.style[2].width', '50%'); // Each column should take up 50% width if itemsperrow is 2\n  });\n\n  // Ensure setTemplate method works correctly\n  it('handles setTemplate correctly', () => {\n    const instance = new WmRadioset(defaultProps);\n    instance.setTemplate('custom-template');\n    expect(instance.state.template).toBe('custom-template');\n  });\n\n  it('check the radiosetscroll prop works correctly', () => {\n    const props = { ...defaultProps, radiosetscroll: false };\n    render(<WmRadioset {...props} />);\n    expect(screen).toMatchSnapshot();\n  });\n\n  // Error State Handling\n  xit('handles validation errors correctly', () => {\n    const ref = createRef();\n    const validateSpy = jest.spyOn(WmRadioset.prototype, 'validate');\n    const props = { ...defaultProps, required: true };\n    render(<WmRadioset {...props} ref={ref} />);\n    const option1 = screen.getByLabelText('Radio button for name1');\n\n    fireEvent.press(option1); // Add selection\n    expect(validateSpy).toHaveBeenCalledWith('name1');\n    expect(ref.current.state.isValid).toBe(true);\n  });\n\n  // Check for unique data items\n  it('handles unique data items correctly', () => {\n    const dataset = 'Option 1, Option 2, Option 1';\n    const props = { ...defaultProps, dataset: dataset };\n    render(<WmRadioset {...props} />);\n    expect(screen.getAllByText('Option 1').length).toBe(1);\n  });\n\n  // Readonly and Disabled States\n  it('handles readonly and disabled states correctly', async () => {\n    const ref = createRef();\n    const props = { ...defaultProps, disabled: true, ref };\n    render(<WmRadioset {...props} />);\n    const option1Radiobutton = screen.getByText('name1');\n    fireEvent.press(option1Radiobutton);\n    expect(ref.current.state.dataItems[2].selected).toBe(false);\n    expect(invokeEventCallbackMock).toBeCalledTimes(0);\n\n    const propsReadonly = {\n      ...defaultProps,\n      readonly: true,\n    };\n    render(<WmRadioset {...propsReadonly} />);\n    const option2Radiobutton = screen.getByText('name2');\n    fireEvent.press(option2Radiobutton);\n    expect(ref.current.state.dataItems[1].selected).toBe(false);\n    expect(invokeEventCallbackMock).toBeCalledTimes(0);\n  });\n\n  // Handling different dataset formats\n  it('handles different dataset formats correctly', () => {\n    const stringDataset = 'Option 1, Option 2, Option 3';\n    const arrayDataset = ['Option 1', 'Option 2', 'Option 3'];\n\n    const propsStringDataset = { ...defaultProps, dataset: stringDataset };\n    render(<WmRadioset {...propsStringDataset} />);\n    expect(screen.getByText('Option 3')).toBeTruthy();\n\n    const propsArrayDataset = { ...defaultProps, dataset: arrayDataset };\n    render(<WmRadioset {...propsArrayDataset} />);\n    expect(screen.getByText('Option 3')).toBeTruthy();\n  });\n});\n", "wavemaker-rn-runtime/test/components/input/currency.component.spec.tsx": "import React, { createRef } from 'react';\nimport {\n  act,\n  cleanup,\n  fireEvent,\n  render,\n  waitFor,\n} from '@testing-library/react-native';\nimport WmCurrency from '@wavemaker/app-rn-runtime/components/input/currency/currency.component';\nimport { CURRENCY_INFO } from '@wavemaker/app-rn-runtime/core/currency-constants';\nimport { Platform, TextInput, View } from 'react-native';\n\nconst defaultProps = {\n  currency: 'USD',\n  placeholder: 'Enter amount',\n  datavalue: null,\n  minvalue: null,\n  maxvalue: null,\n  step: 1,\n  required: false,\n  readonly: false,\n  disabled: false,\n  decimalPlaces: 2,\n};\n\ndescribe('Test Currency component', () => {\n  beforeEach(() => {\n    jest.useFakeTimers();\n  });\n\n  afterEach(() => {\n    jest.useRealTimers();\n    jest.clearAllMocks();\n    cleanup();\n  });\n\n  test('should render correctly with default props', () => {\n    const tree = render(\n      <WmCurrency {...defaultProps} floatinglabel=\"Amount\" />\n    );\n    const { getByText, UNSAFE_getByType } = tree;\n\n    expect(getByText(CURRENCY_INFO[defaultProps.currency].symbol)).toBeTruthy();\n    expect(UNSAFE_getByType(TextInput)).toBeTruthy();\n    expect(getByText('Amount')).toBeTruthy();\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should set the currency symbol on props.currency change', async () => {\n    const { getByText, rerender } = render(<WmCurrency {...defaultProps} />);\n    expect(getByText(CURRENCY_INFO[defaultProps.currency].symbol)).toBeTruthy();\n\n    rerender(<WmCurrency {...defaultProps} currency=\"EUR\" />);\n    // Ensure the new currency symbol is present\n    await waitFor(() => {\n      expect(getByText(CURRENCY_INFO['EUR'].symbol)).toBeTruthy();\n    });\n  });\n\n  test('should handle input change correctly', () => {\n    const onChangeTextMock = jest.spyOn(WmCurrency.prototype, 'onChangeText');\n    const { getByPlaceholderText } = render(<WmCurrency {...defaultProps} />);\n    const input = getByPlaceholderText(defaultProps.placeholder);\n\n    fireEvent.changeText(input, '123.45');\n    expect(onChangeTextMock).toHaveBeenCalledWith('123.45', 'currency');\n  });\n\n  test('should validate number correctly', () => {\n    const onChangeTextMock = jest.spyOn(WmCurrency.prototype, 'onChangeText');\n    const { getByPlaceholderText } = render(<WmCurrency {...defaultProps} />);\n    const input = getByPlaceholderText(defaultProps.placeholder);\n\n    fireEvent.changeText(input, '123.45');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    // Check if the value is set correctly\n    expect(onChangeTextMock).toHaveBeenCalledWith('123.45', 'currency');\n\n    // Check invalid values\n    fireEvent.changeText(input, '12.34563');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    // Should remain unchanged if invalid\n    expect(onChangeTextMock).toHaveBeenCalledWith('123.45', 'currency');\n  });\n\n  xit('should not accept negative number', async () => {\n    const updateStateMock = jest.spyOn(WmCurrency.prototype, 'updateState');\n    const onChangeTextMock = jest.spyOn(WmCurrency.prototype, 'onChangeText');\n    const customRef = createRef<WmCurrency>();\n    const { getByPlaceholderText } = render(\n      <WmCurrency {...defaultProps} ref={customRef} />\n    );\n    const input = getByPlaceholderText(defaultProps.placeholder);\n\n    fireEvent.changeText(input, '-123.45');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    // Check if the value is set correctly\n    expect(onChangeTextMock).toHaveBeenCalledWith('-123.45', 'currency');\n    await waitFor(() => {\n      expect(customRef.current.state.textValue).toBe(null);\n    });\n  });\n\n  test('should validate number correctly, only supports \"e\" as a character', () => {\n    const onChangeTextMock = jest.spyOn(WmCurrency.prototype, 'onChangeText');\n    const { getByPlaceholderText } = render(<WmCurrency {...defaultProps} />);\n    const input = getByPlaceholderText(defaultProps.placeholder);\n\n    fireEvent.changeText(input, '123.45');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    expect(onChangeTextMock).toHaveBeenCalledWith('123.45', 'currency');\n\n    fireEvent.changeText(input, '10e');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    expect(onChangeTextMock).toHaveBeenCalledWith('10e', 'currency');\n\n    fireEvent.changeText(input, '10a');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    expect(onChangeTextMock).toHaveBeenCalledWith('10e', 'currency');\n\n    fireEvent.changeText(input, '$$');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    expect(onChangeTextMock).toHaveBeenCalledWith('10e', 'currency');\n  });\n\n  test('should enable input if disabled and readonly props are falsy', () => {\n    const { getByPlaceholderText, rerender } = render(\n      <WmCurrency {...defaultProps} readonly={true} disabled={true} />\n    );\n    const input = getByPlaceholderText(defaultProps.placeholder);\n    expect(input.props.editable).toBe(false);\n\n    rerender(\n      <WmCurrency {...defaultProps} readonly={false} disabled={false} />\n    );\n    expect(input.props.editable).toBe(true);\n  });\n\n  test('should disable input if disabled is true', () => {\n    const { getByPlaceholderText, rerender } = render(\n      <WmCurrency {...defaultProps} />\n    );\n    const input = getByPlaceholderText(defaultProps.placeholder);\n\n    rerender(<WmCurrency {...defaultProps} disabled={true} />);\n    expect(input.props.editable).toBe(false);\n  });\n\n  test('should disable input if readonly props is true', () => {\n    const { getByPlaceholderText, rerender } = render(\n      <WmCurrency {...defaultProps} />\n    );\n    const input = getByPlaceholderText(defaultProps.placeholder);\n\n    rerender(<WmCurrency {...defaultProps} readonly={true} />);\n    expect(input.props.editable).toBe(false);\n  });\n\n  xit('should validate against required prop correctly', () => {\n    const customRef = createRef();\n    const { getByPlaceholderText } = render(\n      <WmCurrency {...defaultProps} ref={customRef} updateon=\"default\" />\n    );\n    const input = getByPlaceholderText(defaultProps.placeholder);\n\n    fireEvent.changeText(input, '');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    // Check if input indicates invalid state\n    expect(customRef.current.state.isValid).toBe(false);\n  });\n\n  test('should have default value for native platform', () => {\n    const tree = render(\n      <WmCurrency {...defaultProps} datavalue=\"sample text\" />\n    );\n    expect(tree.UNSAFE_getByType(TextInput).props.defaultValue).toBe(\n      'sample text'\n    );\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should have default value for \"platform=web\"', () => {\n    (Platform as any).OS = 'web';\n\n    const tree = render(\n      <WmCurrency {...defaultProps} datavalue=\"sample text\" />\n    );\n    expect(tree.UNSAFE_getByType(TextInput).props.value).toBe('sample text');\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should not show component when show prop is false', () => {\n    const tree = render(<WmCurrency {...defaultProps} show={false} />);\n\n    expect(tree.toJSON().props.style).toMatchObject({\n      height: 0,\n      width: 0,\n    });\n  });\n\n  xit('should isValid false when input number is below minvalue', async () => {\n    const onChangeTextMock = jest.spyOn(WmCurrency.prototype, 'onChangeText');\n    const customRef = createRef();\n    const tree = render(\n      <WmCurrency\n        {...defaultProps}\n        minvalue={100}\n        // maxvalue={1000}\n        ref={customRef}\n        updateon=\"default\"\n      />\n    );\n    const input = tree.getByPlaceholderText('Enter amount');\n\n    fireEvent.changeText(input, '500');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    await waitFor(() => {\n      expect(onChangeTextMock).toHaveBeenCalledWith('500', 'currency');\n      expect(customRef.current.state.isValid).toBe(true);\n    });\n\n    fireEvent.changeText(input, '10');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    await waitFor(() => {\n      expect(onChangeTextMock).toHaveBeenCalledWith('10', 'currency');\n      expect(customRef.current.state.isValid).toBe(false);\n    });\n  });\n\n  test('should isValid false when input number is above maxvalue', async () => {\n    const updateStateMock = jest.spyOn(WmCurrency.prototype, 'updateState');\n    const customRef = createRef();\n    const tree = render(\n      <WmCurrency\n        {...defaultProps}\n        maxvalue={1000}\n        ref={customRef}\n        updateon=\"default\"\n      />\n    );\n    const input = tree.getByPlaceholderText('Enter amount');\n\n    fireEvent.changeText(input, '500');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    await waitFor(() => {\n      expect(updateStateMock).toHaveBeenCalledWith({ isValid: true });\n      expect(customRef.current.state.isValid).toBe(true);\n    });\n\n    fireEvent.changeText(input, '50011');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    await waitFor(() => {\n      expect(updateStateMock).toHaveBeenCalledWith({ isValid: false });\n      expect(customRef.current.state.isValid).toBe(false);\n    });\n  });\n\n  //skeletonLoader\n  test('should render skeleton with respect to default styles when show skeleton is true', () => {\n    const tree = render(<WmCurrency {...defaultProps} showskeleton={true}  />)\n    const viewEles = tree.UNSAFE_getAllByType(View);\n    expect(viewEles[1].props.style.minHeight).toBe(42);\n    expect(viewEles[1].props.style.width).toBe('100%');\n  })\n});\n", "wavemaker-rn-runtime/test/components/input/slider.component.spec.tsx": "import React, { createRef, ReactNode } from 'react';\nimport { Text, TouchableOpacity } from 'react-native';\nimport WmTooltip from '@wavemaker/app-rn-runtime/components/basic/tooltip/tooltip.component';\nimport WmSlider from '@wavemaker/app-rn-runtime/components/input/slider/slider.component';\nimport { BackgroundComponent } from '@wavemaker/app-rn-runtime/styles/background.component';\nimport {\n  fireEvent,\n  render,\n  screen,\n  waitFor,\n} from '@testing-library/react-native';\n\nimport { GestureHandlerRootView } from 'react-native-gesture-handler';\nimport WmSliderProps from '@wavemaker/app-rn-runtime/components/input/slider/slider.props';\n// import { gestureHandlerRootHOC } from 'react-native-gesture-handler/jest-utils';\n\n// jest.mock('react-native-gesture-handler', () => {\n//   const actual = jest.requireActual('react-native-gesture-handler');\n//   return {\n//     ...actual,\n//     Gesture: {\n//       Pan: jest.fn(() => ({\n//         onUpdate: jest.fn().mockReturnThis(),\n//         onChange: jest.fn().mockReturnThis(),\n//         onEnd: jest.fn().mockReturnThis(),\n//         maxPointers: jest.fn().mockReturnThis(),\n//         minDistance: jest.fn().mockReturnThis(),\n//       })),\n//     },\n//   };\n// });\n\nconst dataset = [\n  {\n    x: 10,\n    y: 101,\n  },\n  {\n    x: 20,\n    y: 201,\n  },\n  {\n    x: 30,\n    y: 301,\n  },\n];\nconst defProps = new WmSliderProps();\n\nconst timer = (time = 100) =>\n  new Promise((resolve: any, reject) => {\n    setTimeout(() => resolve(), time);\n  });\n\n//rendering the component\nconst renderComponent = (props = {}) => {\n  return render(\n    <WmSlider\n      {...defProps}\n      datatype=\"dataset\"\n      name=\"test_Slider\"\n      dataset={dataset}\n      displayfield=\"x\"\n      datafield=\"y\"\n      {...props}\n    />\n  );\n};\n\nconst fireEventLayoutFun = (tree: any) => {\n  return fireEvent(tree.getByTestId('test_Slider'), 'layout', {\n    nativeEvent: {\n      layout: {\n        x: 100,\n        y: 100,\n        top: 100,\n        left: 100,\n        width: 200,\n        height: 200,\n      },\n    },\n  });\n};\n\nconst renderSlider = (props = {}) => {\n  return render(\n    <GestureHandlerRootView>\n      <WmSlider {...props} />\n    </GestureHandlerRootView>\n  );\n};\ndescribe('Test Slider component', () => {\n  // it('should update position on track gesture', () => {\n  //   const onChangeMock = jest.fn();\n  //   const { getByTestId } = renderSlider({\n  //     onChange: onChangeMock,\n  //     dataset: [],\n  //     datatype: 'dataset',\n  //     name: 'test',\n  //   });\n  //   expect(screen).toMatchSnapshot();\n  //   const track = getByTestId('test_sliderTouchable');\n\n  //   // Simulate a pan gesture on the track\n  //   fireEvent(track, 'onGestureEvent', {\n  //     nativeEvent: { x: 50 },\n  //   });\n\n  //   // Add assertions to check if the position has been updated\n  //   expect(onChangeMock).toHaveBeenCalled();\n  //   // You might need to adjust this based on how your component updates and reports changes\n  // });\n\n  it('should render the slider component ', () => {\n    const tree = renderComponent();\n    expect(tree).toMatchSnapshot();\n    expect(tree).toBeDefined();\n    expect(tree).not.toBeNull();\n  });\n\n  it('should render max and min value out of displayfield values as range markers when showmarkers and showtips is false', () => {\n    const renderOldMarkerStyleMock = jest.spyOn(\n      WmSlider.prototype,\n      'renderOldMarkerStyle'\n    );\n    const getScaledDataValueEle = jest.spyOn(\n      WmSlider.prototype,\n      'getScaledDataValue'\n    );\n    renderComponent();\n    expect(renderOldMarkerStyleMock).toHaveBeenCalled();\n    expect(getScaledDataValueEle).toHaveBeenCalled();\n    expect(screen.getByText(`${dataset[0].x}`)).toBeTruthy();\n    expect(screen.getByText(`${dataset[2].x}`)).toBeTruthy();\n  });\n\n  it('should render styles applied thru \"track\" class properly', () => {\n    const renderTracksMock = jest.spyOn(WmSlider.prototype, 'renderTracks');\n\n    renderComponent({\n      styles: {\n        track: {\n          position: 'relative',\n          height: 14,\n          flexDirection: 'row',\n          width: '100%',\n          minWidth: 180,\n          marginVertical: 12,\n          overflow: 'hidden',\n          borderRadius: 10,\n        },\n      },\n    });\n    const touchableEle = screen.getByTestId('test_Slider');\n    expect(renderTracksMock).toHaveBeenCalledTimes(1);\n    expect(touchableEle).toBeTruthy();\n    expect(touchableEle.props.style.borderRadius).toBe(10);\n    expect(touchableEle.props.style.overflow).toBe('hidden');\n    expect(touchableEle.props.style.marginVertical).toBe(12);\n    expect(touchableEle.props.style.minWidth).toBe(180);\n    expect(touchableEle.props.style.width).toBe('100%');\n    expect(touchableEle.props.style.height).toBe(14);\n    expect(touchableEle.props.style.flexDirection).toBe('row');\n  });\n\n  it('should render styles applied thru \"minimumTrack\" class properly', () => {\n    renderComponent({\n      styles: {\n        minimumTrack: {\n          position: 'absolute',\n          height: '100%',\n          backgroundColor: 'red',\n          width: 300,\n          borderTopLeftRadius: 10,\n          borderBottomLeftRadius: 20,\n        },\n      },\n    });\n    const animatedViewEle = screen.getByTestId('test_Slider').children;\n    expect(animatedViewEle.length).toBe(3);\n    expect(animatedViewEle[0].props.style[0].position).toBe('absolute');\n    expect(animatedViewEle[0].props.style[0].height).toBe('100%');\n    expect(animatedViewEle[0].props.style[0].width).toBe(300);\n    expect(animatedViewEle[0].props.style[0].backgroundColor).toBe('red');\n    expect(animatedViewEle[0].props.style[0].borderTopLeftRadius).toBe(10);\n    expect(animatedViewEle[0].props.style[0].borderBottomLeftRadius).toBe(20);\n  });\n\n  it('should render markers when \"showmarkers\" is true', async () => {\n    const tree = renderComponent({\n      showmarkers: true,\n    });\n\n    fireEventLayoutFun(tree);\n\n    await waitFor(() => {\n      expect(tree.getByText('10'));\n      expect(tree.getByText('20'));\n      expect(tree.getByText('30'));\n    });\n  });\n\n  it('should render tooltips when \"showtooltip\" is true', () => {\n    const renderToolTipsMock = jest.spyOn(WmSlider.prototype, 'renderToolTips');\n\n    const tree = renderComponent({\n      showtooltip: true,\n    });\n\n    expect(renderToolTipsMock).toHaveBeenCalled();\n    expect(tree.getByText('10')).toBeTruthy();\n\n    const viewEle = tree.UNSAFE_getByType(WmTooltip);\n    expect(viewEle).toBeDefined();\n    expect(viewEle.props.showTooltip).toBe(true);\n    expect(viewEle.props.text).toBe(dataset[0].x);\n    expect(viewEle.props.direction).toBe('up');\n  });\n\n  xit('should handle sliderValue change properly', async () => {\n    const ref = createRef();\n    const onChangeMock = jest.fn();\n    const onFieldChangeMock = jest.fn();\n    const dataVal = 101;\n\n    const tree = renderComponent({\n      ref,\n      datavalue: dataVal,\n      onChange: onChangeMock,\n      onFieldChange: onFieldChangeMock,\n    });\n\n    ref.current.proxy.onSliderChange(201, 'track');\n\n    await timer(300);\n    expect(onFieldChangeMock).toHaveBeenCalled();\n    // expect(onFieldChangeMock).toHaveBeenCalledWith('datavalue', 250, 200);\n    expect(onChangeMock).toHaveBeenCalled();\n    expect(ref.current.state.props.datavalue).toBe(201);\n  });\n\n  xit('should handle sliderValue change properly when range is true', async () => {\n    const ref = createRef();\n    const onChangeMock = jest.fn();\n    const onFieldChangeMock = jest.fn();\n\n    const tree = renderComponent({\n      ref,\n      range: true,\n      datavalue: [201, 301],\n      onChange: onChangeMock,\n      onFieldChange: onFieldChangeMock,\n    });\n\n    ref.current.proxy.onSliderChange(101, 'lowThumb');\n    await timer(500);\n    expect(onFieldChangeMock).toHaveBeenCalled();\n    // expect(onFieldChangeMock).toHaveBeenCalledWith('datavalue', 250, 200);\n    expect(onChangeMock).toHaveBeenCalled();\n\n    ref.current.proxy.onSliderChange(201, 'highThumb');\n    await timer(300);\n    expect(onFieldChangeMock).toHaveBeenCalled();\n    // expect(onFieldChangeMock).toHaveBeenCalledWith('datavalue', 250, 200);\n    expect(onChangeMock).toHaveBeenCalled();\n  });\n\n  //show\n  it('should handle show property properly', async () => {\n    const ref = createRef();\n    const tree = renderComponent({ show: true, ref });\n    const rootElement = tree.root;\n    expect(rootElement.props.style.width).not.toBe(0);\n    expect(rootElement.props.style.height).not.toBe(0);\n\n    ref.current.proxy.show = false;\n    await timer();\n\n    expect(rootElement.props.style.width).toBe(0);\n    expect(rootElement.props.style.height).toBe(0);\n  });\n\n  // datatype = number cases\n\n  xit('should render component when datatype is number', async () => {\n    const ref = createRef<WmSlider>();\n    const tree = render(\n      <WmSlider\n        {...defProps}\n        name=\"test_Slider\"\n        datatype=\"number\"\n        dataset={[]}\n        // datavalue={10}\n        ref={ref}\n      />\n    );\n\n    // ref.current.state.props.dataset = [];\n    fireEventLayoutFun(tree);\n\n    await timer(300);\n\n    // ref.current.proxy.renderOldMarkerStyle(defProps);\n    // expect(tree).toMatchSnapshot();\n\n    await waitFor(() => {\n      // expect(tree.queryByTestId('renderMarkerschild')).not.toBeNull()\n      // console.log(ref.current.state);\n      expect(tree.getByText('0')).toBeTruthy();\n    });\n  });\n});\n", "wavemaker-rn-runtime/test/components/input/number.component.spec.tsx": "import React, { createRef } from 'react';\nimport { Platform, TextInput } from 'react-native';\nimport {\n  cleanup,\n  fireEvent,\n  render,\n  waitFor,\n} from '@testing-library/react-native';\nimport WmNumber from '@wavemaker/app-rn-runtime/components/input/number/number.component';\n\nconst defaultProps = {\n  placeholder: 'Enter amount',\n  datavalue: null,\n  minvalue: null,\n  maxvalue: null,\n  step: 1,\n  required: false,\n  readonly: false,\n  disabled: false,\n  decimalPlaces: 2,\n  name: 'wm-text-input',\n};\n\ndescribe('Number component', () => {\n  beforeEach(() => {\n    jest.useFakeTimers();\n  });\n\n  afterEach(() => {\n    jest.useRealTimers();\n    jest.clearAllMocks();\n    cleanup();\n  });\n\n  test('should render correctly with default props', () => {\n    const tree = render(<WmNumber {...defaultProps} floatinglabel=\"Amount\" />);\n    const { getByText, UNSAFE_getByType } = tree;\n\n    expect(UNSAFE_getByType(TextInput)).toBeTruthy();\n    expect(getByText('Amount')).toBeTruthy();\n    expect(tree).toMatchSnapshot();\n  });\n\n  xit('should handle input change correctly', () => {\n    const onChangeTextMock = jest.spyOn(WmNumber.prototype, 'onChangeText');\n    const { getByPlaceholderText } = render(<WmNumber {...defaultProps} />);\n    const input = getByPlaceholderText(defaultProps.placeholder);\n\n    fireEvent.changeText(input, '123.45');\n    expect(onChangeTextMock).toHaveBeenCalledWith('123.45', 'number');\n  });\n\n  test('should validate number correctly', () => {\n    const onChangeTextMock = jest.spyOn(WmNumber.prototype, 'onChangeText');\n    const { getByPlaceholderText } = render(<WmNumber {...defaultProps} />);\n    const input = getByPlaceholderText(defaultProps.placeholder);\n\n    fireEvent.changeText(input, '123.45');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    // Check if the value is set correctly\n    expect(onChangeTextMock).toHaveBeenCalledWith('123.45', 'number', false);\n\n    // Check invalid values\n    fireEvent.changeText(input, '12.34563');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    // Should remain unchanged if invalid\n    expect(onChangeTextMock).toHaveBeenCalledWith('123.45', 'number', false);\n  });\n\n  it('should validate number correctly, only supports \"e\" as a character', () => {\n    const onChangeTextMock = jest.spyOn(WmNumber.prototype, 'onChangeText');\n    const { getByPlaceholderText } = render(<WmNumber {...defaultProps} />);\n    const input = getByPlaceholderText(defaultProps.placeholder);\n\n    fireEvent.changeText(input, '123.45');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    expect(onChangeTextMock).toHaveBeenCalledWith('123.45', 'number', false);\n\n    fireEvent.changeText(input, '10e');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    expect(onChangeTextMock).toHaveBeenCalledWith('10e', 'number', false);\n\n    fireEvent.changeText(input, '10a');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    expect(onChangeTextMock).toHaveBeenCalledWith('10e', 'number', false);\n\n    fireEvent.changeText(input, '$$');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    expect(onChangeTextMock).toHaveBeenCalledWith('10e', 'number', false);\n  });\n\n  test('should enable input if disabled and readonly props are falsy', () => {\n    const { getByPlaceholderText, rerender } = render(\n      <WmNumber {...defaultProps} readonly={true} disabled={true} />\n    );\n    const input = getByPlaceholderText(defaultProps.placeholder);\n    expect(input.props.editable).toBe(false);\n\n    rerender(<WmNumber {...defaultProps} readonly={false} disabled={false} />);\n    expect(input.props.editable).toBe(true);\n  });\n\n  test('should disable input if disabled is true', () => {\n    const { getByPlaceholderText, rerender } = render(\n      <WmNumber {...defaultProps} />\n    );\n    const input = getByPlaceholderText(defaultProps.placeholder);\n\n    rerender(<WmNumber {...defaultProps} disabled={true} />);\n    expect(input.props.editable).toBe(false);\n  });\n\n  test('should disable input if readonly props is true', () => {\n    const { getByPlaceholderText, rerender } = render(\n      <WmNumber {...defaultProps} />\n    );\n    const input = getByPlaceholderText(defaultProps.placeholder);\n\n    rerender(<WmNumber {...defaultProps} readonly={true} />);\n    expect(input.props.editable).toBe(false);\n  });\n\n  xit('should validate against required prop correctly', async () => {\n    const customRef = createRef();\n    const { getByPlaceholderText } = render(\n      <WmNumber {...defaultProps} ref={customRef} updateon=\"blur\" />\n    );\n    const input = getByPlaceholderText(defaultProps.placeholder);\n\n    fireEvent.changeText(input, 'a');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    // Check if input indicates invalid state\n    expect(customRef.current.state.isValid).toBe(false);\n  });\n\n  test('should have default value for native platform', () => {\n    const tree = render(<WmNumber {...defaultProps} datavalue=\"sample text\" />);\n    expect(tree.UNSAFE_getByType(TextInput).props.defaultValue).toBe(\n      'sample text'\n    );\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should have default value for web platform', () => {\n    (Platform as any).OS = 'web';\n\n    const tree = render(<WmNumber {...defaultProps} datavalue=\"sample text\" />);\n    expect(tree.UNSAFE_getByType(TextInput).props.value).toBe('sample text');\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should not show component when show prop is false', () => {\n    const tree = render(<WmNumber {...defaultProps} show={false} />);\n    const styleArr = tree.toJSON().props.style[0];\n    const style = {};\n\n    styleArr.forEach((item) => {\n      if (!item) return;\n      Object.keys(item).forEach((key) => {\n        style[key] = item[key];\n      });\n    });\n\n    expect(style).toMatchObject({\n      height: 0,\n      width: 0,\n    });\n  });\n\n  test('should isValid false when input number is below minvalue', async () => {\n    const onChangeTextMock = jest.spyOn(WmNumber.prototype, 'onChangeText');\n    const customRef = createRef();\n    const tree = render(\n      <WmNumber\n        {...defaultProps}\n        minvalue={100}\n        // maxvalue={1000}\n        ref={customRef}\n        updateon=\"default\"\n      />\n    );\n    const input = tree.getByPlaceholderText('Enter amount');\n\n    fireEvent.changeText(input, '500');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    await waitFor(() => {\n      expect(onChangeTextMock).toHaveBeenCalledWith('500', 'number', false);\n      expect(customRef.current.state.isValid).toBe(true);\n    });\n\n    fireEvent.changeText(input, '10');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    await waitFor(() => {\n      expect(onChangeTextMock).toHaveBeenCalledWith('10', 'number', false);\n      expect(customRef.current.state.isValid).toBe(false);\n    });\n  });\n\n  test('should isValid false when input number is above maxvalue', async () => {\n    const updateStateMock = jest.spyOn(WmNumber.prototype, 'updateState');\n    const customRef = createRef();\n    const tree = render(\n      <WmNumber\n        {...defaultProps}\n        maxvalue={1000}\n        ref={customRef}\n        updateon=\"default\"\n      />\n    );\n    const input = tree.getByPlaceholderText('Enter amount');\n\n    fireEvent.changeText(input, '500');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    await waitFor(() => {\n      expect(updateStateMock).toHaveBeenCalledWith({ isValid: true });\n      expect(customRef.current.state.isValid).toBe(true);\n    });\n\n    fireEvent.changeText(input, '50011');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    await waitFor(() => {\n      expect(updateStateMock).toHaveBeenCalledWith({ isValid: false });\n      expect(customRef.current.state.isValid).toBe(false);\n    });\n  });\n\n  test('should render the displayValue text when it is passed in props', async () => {\n    Platform.OS = 'ios';\n    const tree = render(\n      <WmNumber\n        {...defaultProps}\n        maxvalue={1000}\n        updateon=\"default\"\n        displayValue=\"500%\"\n      />\n    );\n    const input = tree.getByPlaceholderText('Enter amount');\n\n    fireEvent.changeText(input, '200');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    });\n\n    expect(input.props.defaultValue).toBe('500%');\n  });\n\n  test('should update the state when hastwowaybinding is enabled', async () => {\n    const tree = render(\n      <WmNumber \n        {...defaultProps} \n        updateon='blur'\n        hastwowaybinding={true}\n        datavalue={\"1000\"}\n      />\n    );\n\n    const input = tree.getByPlaceholderText(\"Enter amount\");\n\n    await waitFor(()=>{\n      expect(input.props.defaultValue).toBe(\"1000\")\n    })\n\n    fireEvent(input, 'changeText', '10003');\n    fireEvent(input, 'blur', {\n      target: {\n        value: null,\n      },\n    })\n    \n    expect(input.props.defaultValue).toBe(\"1000\");\n    await waitFor(()=>{\n      expect(input.props.defaultValue).toBe(\"10003\")\n    })\n  });\n\n  //skeletonLoader\n  test('should render skeleton with respect to default styles when show skeleton is true', () => {\n    const tree = render(<WmNumber {...defaultProps} showskeleton={true}  />)\n    const root = tree.root;\n    expect(root.props.style.borderRadius).toBe(6);\n    expect(root.props.style.width).toBe('100%');\n    expect(root.props.style.height).toBe(40);\n  })\n  \n});\n", "wavemaker-rn-runtime/test/components/input/composite.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport { Text, TouchableOpacity } from 'react-native';\nimport { shallow } from 'enzyme';\nimport renderer from 'react-test-renderer';\nimport WmComposite from '@wavemaker/app-rn-runtime/components/input/composite/composite.component';\n\ndescribe('Test Composite component', () => {\n    test('Check validity of sample component', () => {\n      const tree = renderer.create(<WmComposite name=\"test_Composite\"/>).toJSON();\n      expect(tree).toMatchSnapshot();\n    });\n});", "wavemaker-rn-runtime/test/components/input/checkboxset.component.spec.tsx": "import React, { ReactNode, createRef } from 'react';\nimport { Text, TouchableOpacity } from 'react-native';\nimport WmCheckboxset from '@wavemaker/app-rn-runtime/components/input/checkboxset/checkboxset.component';\nimport WmCheckboxsetProps from '@wavemaker/app-rn-runtime/components/input/checkboxset/checkboxset.props';\nimport {\n  render,\n  screen,\n  fireEvent,\n  waitFor,\n} from '@testing-library/react-native';\n\ndescribe('WmCheckboxset', () => {\n  let defaultProps;\n\n  beforeEach(() => {\n    defaultProps = {\n      dataset: [\n        {\n          name: 'name0',\n          dataValue: 'dataValue0',\n          group: 'g1',\n        },\n        {\n          name: 'name2',\n          dataValue: 'dataValue2',\n          group: 'g1',\n        },\n        {\n          name: 'name1',\n          dataValue: 'dataValue1',\n          group: 'g2',\n        },\n      ],\n      displayfield: 'name',\n      datafield: 'name',\n    };\n    // defaultProps.itemsperrow = { xs: 1 };\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  const invokeEventCallbackMock = jest.spyOn(\n    WmCheckboxset.prototype,\n    'invokeEventCallback'\n  );\n\n  // Check Rendering with Default Props\n  it('renders correctly with default props', () => {\n    render(<WmCheckboxset {...defaultProps} groupby=\"group\" />);\n    expect(screen.getByText('name0')).toBeTruthy();\n    expect(screen.getByText('name1')).toBeTruthy();\n    expect(screen.getByText('name2')).toBeTruthy();\n  });\n\n  // Item Selection\n  it('selects and deselects items correctly', async () => {\n    render(<WmCheckboxset {...defaultProps} />);\n    const option1 = screen.getByText('name1');\n    fireEvent.press(option1);\n    const option1Checkbox = screen.getByLabelText('Checkbox for name1');\n    expect(option1Checkbox).toHaveProperty(\n      'props.accessibilityState.checked',\n      true\n    );\n    fireEvent.press(option1);\n    await waitFor(() => {\n      expect(option1Checkbox).toHaveProperty(\n        'props.accessibilityState.checked',\n        false\n      );\n    });\n  });\n\n  // Group By Functionality\n  it('renders grouped data correctly', () => {\n    render(<WmCheckboxset {...defaultProps} groupby=\"group\" />);\n    expect(screen.getByText('g1')).toBeTruthy();\n    expect(screen.getByText('g2')).toBeTruthy();\n    expect(screen.getByText('name0')).toBeTruthy();\n    expect(screen.getByText('name1')).toBeTruthy();\n    expect(screen.getByText('name2')).toBeTruthy();\n  });\n\n  it('renders orderby correctly', () => {\n    render(<WmCheckboxset {...defaultProps} orderby=\"name:desc\" />);\n    const items = screen.UNSAFE_getAllByType(Text);\n    expect(items[1].props.children).toBe('name2');\n    expect(items[3].props.children).toBe('name1');\n    expect(items[5].props.children).toBe('name0');\n  });\n\n  // Accessibility Props\n  it('applies accessibility props correctly', () => {\n    render(<WmCheckboxset {...defaultProps} hint=\"wm-checkboxset\" />);\n    expect(screen.getByLabelText('Checkbox for name0')).toBeTruthy();\n    expect(screen.getByLabelText('Checkbox for name1')).toBeTruthy();\n    expect(screen.getByLabelText('Checkbox for name2')).toBeTruthy();\n    expect(screen.getAllByA11yHint('wm-checkboxset')).toBeTruthy();\n  });\n\n  // Validation and Event Handling\n  it('handles onTap and onChange event correctly', async () => {\n    render(<WmCheckboxset {...defaultProps} datavalue=\"name0\" />);\n    const option1 = screen.getByText('name1');\n    fireEvent.press(option1);\n    const onPressMock = jest.spyOn(WmCheckboxset.prototype, 'onPress');\n\n    const option1Checkbox = screen.getByLabelText('Checkbox for name1');\n    expect(option1Checkbox).toHaveProperty(\n      'props.accessibilityState.checked',\n      true\n    );\n    await waitFor(() => {\n      expect(invokeEventCallbackMock).toHaveBeenCalledTimes(2);\n    });\n    expect(invokeEventCallbackMock.mock.calls[0][0]).toBe('onTap');\n    expect(invokeEventCallbackMock.mock.calls[1][0]).toBe('onChange');\n    expect(invokeEventCallbackMock.mock.calls[1][1][2].toString()).toBe(\n      ['name0', 'name1'].toString()\n    );\n    expect(invokeEventCallbackMock.mock.calls[1][1][3]).toBe('name0');\n    expect(invokeEventCallbackMock.mock.calls[1][1][1]).toBeInstanceOf(\n      WmCheckboxset\n    );\n  });\n\n  // Edge Cases: Empty Dataset\n  it('handles empty dataset gracefully', () => {\n    const props = { ...defaultProps, dataset: [] };\n    render(<WmCheckboxset {...props} />);\n    expect(screen.queryByText('name1')).toBeNull();\n    expect(screen.queryByText('name0')).toBeNull();\n  });\n\n  // Custom Render Item Partial\n  xit('renders custom item partial correctly', async () => {\n    const renderItemPartial = jest\n      .fn()\n      .mockReturnValue(<Text>Custom Partial</Text>);\n    const props = {\n      ...defaultProps,\n      renderitempartial: renderItemPartial,\n      template: 'custom-template',\n    };\n    render(<WmCheckboxset {...props} />);\n    await waitFor(() => {\n      expect(screen.getByText('Custom Partial')).toBeTruthy();\n    });\n  });\n\n  // Handling multiple columns\n  it('handles multiple columns correctly', () => {\n    const props = { ...defaultProps, itemsperrow: { xs: 2 } };\n    render(<WmCheckboxset {...props} />);\n    expect(screen).toMatchSnapshot();\n\n    const option1 = screen.getByLabelText('Checkbox for name1');\n    expect(option1).toHaveProperty('props.style.width', '50%'); // Each column should take up 50% width if itemsperrow is 2\n  });\n\n  // Ensure setTemplate method works correctly\n  it('handles setTemplate correctly', () => {\n    const instance = new WmCheckboxset(defaultProps);\n    instance.setTemplate('custom-template');\n    expect(instance.state.template).toBe('custom-template');\n  });\n\n  // Ensure datavalue updates correctly\n  // it('updates datavalue correctly', async () => {\n  //   const instance = new WmCheckboxset(defaultProps);\n  //   // const ref = createRef();\n  //   // render(<WmCheckboxset {...defaultProps} ref={ref} />);\n  //   // ref.current.updateDatavalue(['1', '2']);\n\n  //   instance.updateDatavalue(['1', '2']);\n  //   await waitFor(() => {\n  //     expect(instance.state.props.datavalue).toEqual(['1', '2']);\n  //   });\n  // });\n\n  // Error State Handling\n  it('handles validation errors correctly', () => {\n    const ref = createRef();\n    const validateSpy = jest.spyOn(WmCheckboxset.prototype, 'validate');\n    const props = { ...defaultProps, required: true };\n    render(<WmCheckboxset {...props} ref={ref} />);\n    const option1 = screen.getByLabelText('Checkbox for name1');\n\n    fireEvent.press(option1); // Add selection\n    expect(validateSpy).toHaveBeenCalledWith(['name1']);\n    expect(ref.current.state.isValid).toBe(true);\n  });\n\n  // Check for unique data items\n  it('handles unique data items correctly', () => {\n    const dataset = 'Option 1, Option 2, Option 1';\n    const props = { ...defaultProps, dataset: dataset };\n    render(<WmCheckboxset {...props} />);\n    expect(screen.getAllByText('Option 1').length).toBe(1);\n  });\n\n  // Readonly and Disabled States\n  it('handles readonly and disabled states correctly', async () => {\n    const props = { ...defaultProps, disabled: true, datavalue: 'name1' };\n    render(<WmCheckboxset {...props} />);\n    const option1Checkbox = screen.getByLabelText('Checkbox for name1');\n    fireEvent.press(option1Checkbox);\n    await waitFor(() => {\n      expect(option1Checkbox).toHaveProperty(\n        'props.accessibilityState.checked',\n        true\n      );\n      expect(invokeEventCallbackMock).toHaveBeenCalledTimes(0);\n    });\n\n    const propsReadonly = {\n      ...defaultProps,\n      readonly: true,\n      datavalue: 'name2',\n    };\n    render(<WmCheckboxset {...propsReadonly} />);\n    const option2Checkbox = screen.getByLabelText('Checkbox for name2');\n    fireEvent.press(option2Checkbox);\n    await waitFor(() => {\n      expect(option2Checkbox).toHaveProperty(\n        'props.accessibilityState.checked',\n        true\n      );\n      expect(invokeEventCallbackMock).toHaveBeenCalledTimes(0);\n    });\n  });\n\n  // Handling different dataset formats\n  it('handles different dataset formats correctly', () => {\n    const stringDataset = 'Option 1, Option 2, Option 3';\n    const arrayDataset = ['Option 1', 'Option 2', 'Option 3'];\n\n    const propsStringDataset = { ...defaultProps, dataset: stringDataset };\n    render(<WmCheckboxset {...propsStringDataset} />);\n    expect(screen.getByText('Option 3')).toBeTruthy();\n\n    const propsArrayDataset = { ...defaultProps, dataset: arrayDataset };\n    render(<WmCheckboxset {...propsArrayDataset} />);\n    expect(screen.getByText('Option 3')).toBeTruthy();\n  });\n});\n", "wavemaker-rn-runtime/test/components/input/epoch/date.component.spec.tsx": "import React, { ReactNode, createRef } from 'react';\nimport { Modal, Platform, Text, TouchableOpacity, View } from 'react-native';\nimport WmDate from '@wavemaker/app-rn-runtime/components/input/epoch/date/date.component';\nimport WmWheelScrollPicker from '@wavemaker/app-rn-runtime/components/input/epoch/wheelpicker/wheelpicker.component';\nimport WmDateProps from '@wavemaker/app-rn-runtime/components/input/epoch/date/date.props';\nimport { ScrollView } from 'react-native-gesture-handler';\nimport AppModalService from '@wavemaker/app-rn-runtime/runtime/services/app-modal.service';\nimport { AssetProvider } from '@wavemaker/app-rn-runtime/core/asset.provider';\nimport { ModalProvider } from '@wavemaker/app-rn-runtime/core/modal.service';\n\nimport { SafeAreaProvider } from 'react-native-safe-area-context';\n\nimport {\n  render,\n  fireEvent,\n  screen,\n  waitFor,\n  act,\n} from '@testing-library/react-native';\n\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\n\njest.mock('react-native-safe-area-context', () => {\n  return {\n    useSafeAreaInsets: jest.fn().mockReturnValue({\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n    }),\n    SafeAreaProvider: ({ children }) => children,\n  };\n});\n\njest.mock('expo-asset');\njest.mock('expo-font');\n\nconst timer = (time = 100) =>\n  new Promise((resolve: any, reject) => {\n    setTimeout(() => resolve(), time);\n  });\n\nconst loadAsset = (path) => path;\n\nAppModalService.modalsOpened = [];\n\nfunction renderComponentWithWrappers(props = {}) {\n  AppModalService.modalsOpened = [];\n\n  return render(\n    <SafeAreaProvider>\n      <ModalProvider value={AppModalService}>\n        {/* <AssetProvider value={loadAsset}> */}\n        <WmDate {...props} />\n        {/* </AssetProvider> */}\n      </ModalProvider>\n    </SafeAreaProvider>\n  );\n}\n\ndescribe('WmDate Component', () => {\n  let props;\n\n  const currDate = new Date()\n    .toLocaleDateString('en-GB', {\n      year: 'numeric',\n      month: '2-digit',\n      day: '2-digit',\n    })\n    .split('/')\n    .reverse()\n    .join('-');\n\n  beforeEach(() => {\n    props = new WmDateProps();\n  });\n\n  it('should render with default properties correctly', async () => {\n    const ref = createRef();\n    render(<WmDate {...props} name=\"date1\" ref={ref} />);\n    const dateInput = screen.getAllByTestId('date1_a')[0];\n    fireEvent.press(dateInput);\n\n    await timer(200);\n\n    expect(screen.getByText(props.placeholder)).toBeTruthy();\n    expect(ref.current.state.showDatePicker).toBe(true);\n    expect(ref.current.state.showDatePickerModal).toBe(true);\n    expect(screen).toMatchSnapshot();\n  });\n\n  it('should apply the correct style class name when floatinglabel is present', () => {\n    props.floatinglabel = 'Test Label';\n    const ref = createRef();\n    render(<WmDate {...props} name=\"date1\" ref={ref} />);\n    const className = ref.current.getStyleClassName();\n    expect(className).toContain('app-date-with-label');\n  });\n\n  it('should show date picker modal on focus', async () => {\n    const ref = createRef();\n    const onTapMock = jest.fn();\n    render(<WmDate {...props} name=\"date1\" ref={ref} onTap={onTapMock} />);\n\n    const dateInput = screen.getAllByTestId('date1_a')[0];\n\n    fireEvent.press(dateInput);\n    await timer(300);\n    const selectDateText = screen.getByText('Select Date');\n    expect(selectDateText).toBeTruthy();\n    expect(screen.getByText('Select')).toBeTruthy();\n    expect(screen.getByText('Cancel')).toBeTruthy();\n    expect(onTapMock).toHaveBeenCalled();\n  });\n\n  it('should handle date change correctly', async () => {\n    const ref = createRef();\n    const onChangeMock = jest.fn();\n    const onBlurMock = jest.fn();\n\n    render(\n      <WmDate\n        {...props}\n        name=\"date1\"\n        ref={ref}\n        onChange={onChangeMock}\n        onBlur={onBlurMock}\n        datepattern=\"yyyy-MM-dd\"\n      />\n    );\n\n    const dateInput = screen.getAllByTestId('date1_a')[0];\n    fireEvent.press(dateInput);\n\n    await timer(300);\n\n    const scrollViewDate = screen.UNSAFE_getAllByType(ScrollView)[0];\n    const scrollViewMonth = screen.UNSAFE_getAllByType(ScrollView)[1];\n    const scrollViewYear = screen.UNSAFE_getAllByType(ScrollView)[2];\n    //selecting date\n    fireEvent(scrollViewDate, 'scroll', {\n      nativeEvent: {\n        contentOffset: {\n          x: 100,\n          y: 200,\n        },\n      },\n    });\n    fireEvent(scrollViewDate, 'momentumScrollEnd');\n\n    //selecting month\n    fireEvent(scrollViewMonth, 'scroll', {\n      nativeEvent: {\n        contentOffset: {\n          x: 100,\n          y: 200,\n        },\n      },\n    });\n    fireEvent(scrollViewMonth, 'momentumScrollEnd');\n\n    //selecting year\n    fireEvent(scrollViewYear, 'scroll', {\n      nativeEvent: {\n        contentOffset: {\n          x: 100,\n          y: 2000,\n        },\n      },\n    });\n    fireEvent(scrollViewYear, 'momentumScrollEnd');\n\n    await timer();\n\n    fireEvent.press(screen.getByText('Select'));\n\n    await timer(300);\n\n    expect(ref.current.state.props.datavalue).toBe('1990-05-05');\n    expect(ref.current.state.dateValue.toISOString()).toBe(\n      '1990-05-04T18:30:00.000Z'\n    );\n    expect(ref.current.state.displayValue).toBe('1990-05-05');\n    expect(onChangeMock).toHaveBeenCalled();\n    expect(onBlurMock).toHaveBeenCalled();\n    expect(screen.getByText('1990-05-05')).toBeTruthy();\n  });\n\n  it('should handle invalid date input correctly', async () => {\n    const ref = createRef();\n    const onChangeMock = jest.fn();\n    const onBlurMock = jest.fn();\n\n    render(\n      <WmDate\n        {...props}\n        name=\"date1\"\n        ref={ref}\n        onChange={onChangeMock}\n        onBlur={onBlurMock}\n        datepattern=\"yyyy-MM-dd\"\n        mindate=\"2024-08-01\"\n        maxdate=\"2024-08-31\"\n      />\n    );\n\n    const dateInput = screen.getAllByTestId('date1_a')[0];\n    fireEvent.press(dateInput);\n\n    await timer(300);\n\n    const scrollViewDate = screen.UNSAFE_getAllByType(ScrollView)[0];\n    const scrollViewMonth = screen.UNSAFE_getAllByType(ScrollView)[1];\n    const scrollViewYear = screen.UNSAFE_getAllByType(ScrollView)[2];\n    //selecting date\n    fireEvent(scrollViewDate, 'scroll', {\n      nativeEvent: {\n        contentOffset: {\n          x: 100,\n          y: 200,\n        },\n      },\n    });\n    fireEvent(scrollViewDate, 'momentumScrollEnd');\n\n    //selecting month\n    fireEvent(scrollViewMonth, 'scroll', {\n      nativeEvent: {\n        contentOffset: {\n          x: 100,\n          y: 200,\n        },\n      },\n    });\n    fireEvent(scrollViewMonth, 'momentumScrollEnd');\n\n    //selecting year\n    fireEvent(scrollViewYear, 'scroll', {\n      nativeEvent: {\n        contentOffset: {\n          x: 100,\n          y: 2000,\n        },\n      },\n    });\n    fireEvent(scrollViewYear, 'momentumScrollEnd');\n\n    await timer();\n\n    fireEvent.press(screen.getByText('Select'));\n\n    await timer(300);\n\n    expect(ref.current.state.props.datavalue).toBe('Invalid date');\n  });\n\n  it('should call onFocus and onBlur correctly', async () => {\n    const onFocusMock = jest.fn();\n    const onBlurMock = jest.fn();\n\n    render(\n      <WmDate\n        {...props}\n        name=\"date1\"\n        onFocus={onFocusMock}\n        onBlur={onBlurMock}\n      />\n    );\n    const dateInput = screen.getAllByTestId('date1_a')[0];\n\n    fireEvent.press(dateInput);\n    await timer(300);\n\n    expect(onFocusMock).toHaveBeenCalled();\n\n    fireEvent.press(screen.getByText('Cancel'));\n    await timer(300);\n\n    expect(onBlurMock).toHaveBeenCalled();\n  });\n\n  it('should display current date if datavalue is CURRENT_DATE', async () => {\n    props.datavalue = 'CURRENT_DATE';\n    props.datepattern = 'yyyy-MM-dd';\n    const ref = createRef();\n\n    render(<WmDate {...props} name=\"date1\" ref={ref} />);\n\n    await timer(300);\n\n    expect(ref.current.state.dateValue).toBeTruthy();\n    expect(ref.current.state.displayValue).toBe(currDate);\n    expect(screen.getByText(currDate)).toBeTruthy();\n  });\n\n  it('should handle minimum date property correctly', () => {\n    const minDate = new Date(2022, 7, 10).toISOString();\n    const ref = createRef();\n    const currDate = new Date().toISOString().split('T')[0];\n\n    render(<WmDate {...props} name=\"date1\" mindate={minDate} ref={ref} />);\n\n    expect(ref.current.state.props.mindate.toISOString()).toEqual(minDate);\n\n    render(<WmDate {...props} name=\"date1\" mindate=\"CURRENT_DATE\" ref={ref} />);\n\n    expect(ref.current.state.props.mindate.toISOString().split('T')[0]).toEqual(\n      currDate\n    );\n  });\n\n  it('should handle maximum date property correctly', () => {\n    const maxDate = new Date(2024, 7, 10).toISOString();\n    const ref = createRef();\n    const currDate = new Date().toISOString().split('T')[0];\n\n    render(<WmDate {...props} name=\"date1\" maxdate={maxDate} ref={ref} />);\n\n    expect(ref.current.state.props.maxdate.toISOString()).toEqual(maxDate);\n\n    render(<WmDate {...props} name=\"date1\" maxdate=\"CURRENT_DATE\" ref={ref} />);\n\n    expect(ref.current.state.props.maxdate.toISOString().split('T')[0]).toEqual(\n      currDate\n    );\n  });\n\n  it('should render FloatingLabel if the floatinglabel prop is set', () => {\n    props.floatinglabel = 'Test Label';\n\n    const { getByText } = render(<WmDate {...props} />);\n    expect(getByText('Test Label')).toBeTruthy();\n  });\n\n  it('should clear value on pressing clear button and check validation', async () => {\n    const validateFnMock = jest.spyOn(WmDate.prototype, 'validate');\n    const ref = createRef();\n\n    render(\n      <WmDate\n        {...props}\n        name=\"date1\"\n        datavalue=\"CURRENT_DATE\"\n        required={true}\n        ref={ref}\n        datepattern=\"yyyy-MM-dd\"\n      />\n    );\n\n    await timer();\n\n    expect(screen.getByText(currDate)).toBeTruthy();\n    expect(screen.getByText('clear')).toBeTruthy();\n\n    const clearButton = screen.getByText('clear');\n\n    fireEvent.press(clearButton);\n    await timer(300);\n\n    expect(ref.current.state.props.datavalue).toBe(null);\n    expect(screen.queryByText('clear')).toBeNull();\n\n    expect(validateFnMock).toHaveBeenCalled();\n  });\n\n  it('should handle readonly correctly', async () => {\n    const ref = createRef();\n    const onTapMock = jest.fn();\n    const onFocusMock = jest.fn();\n\n    render(\n      <WmDate\n        {...props}\n        name=\"date1\"\n        datavalue=\"CURRENT_DATE\"\n        readonly={true}\n        ref={ref}\n        datepattern=\"yyyy-MM-dd\"\n        onTap={onTapMock}\n        onFocus={onFocusMock}\n      />\n    );\n\n    await timer();\n\n    expect(screen.getByText(currDate)).toBeTruthy();\n    expect(screen.queryByText('clear')).toBeNull();\n\n    const dateInput = screen.getAllByTestId('date1_a')[0];\n    fireEvent(dateInput, 'press');\n\n    await timer(300);\n\n    expect(onFocusMock).not.toHaveBeenCalled();\n    expect(onTapMock).toHaveBeenCalled();\n  });\n\n  xit('should handle accessibility props', async () => {\n    render(\n      <WmDate\n        {...props}\n        name=\"date1\"\n        datavalue=\"CURRENT_DATE\"\n        datepattern=\"yyyy-MM-dd\"\n        hint=\"date1_Allyhint\"\n        accessibilityrole=\"date1_Allyrole\"\n        accessibilitylabel=\"date1_Allylabel\"\n      />\n    );\n\n    await timer(300);\n\n    await waitFor(() => {\n      expect(screen.getByRole('date1_Allyrole')).toBeTruthy();\n      expect(screen.getByLabelText('date1_Allylabel')).toBeTruthy();\n      expect(screen.getByA11yHint('date1_Allyhint')).toBeTruthy();\n    });\n  });\n\n  it('should handle layout change', async () => {\n    render(\n      <WmDate\n        {...props}\n        name=\"date1\"\n        datavalue=\"2024-08-14\"\n        datepattern=\"yyyy-MM-dd\"\n      />\n    );\n\n    const initialScrollToMock = jest.spyOn(\n      WmWheelScrollPicker.prototype,\n      'initialScrollTo'\n    );\n\n    const dateInput = screen.getAllByTestId('date1_a')[0];\n    fireEvent.press(dateInput);\n\n    await timer(300);\n\n    const scrollViewDate = screen.UNSAFE_getAllByType(ScrollView)[0];\n\n    fireEvent(scrollViewDate, 'layout');\n\n    expect(initialScrollToMock).toHaveBeenCalled();\n  });\n\n  it('should set showDatePickerModal to false when modal is dismissed', async () => {\n    const ref = createRef();\n    render(<WmDate {...props} name=\"date1\" ref={ref} />);\n    const dateInput = screen.getAllByTestId('date1_a')[0];\n    fireEvent.press(dateInput);\n\n    await timer(200);\n    expect(ref.current.state.showDatePickerModal).toBe(true);\n\n    const modalEle = screen.UNSAFE_getByType(Modal);\n    fireEvent(modalEle, 'dismiss');\n    await timer(200);\n\n    expect(ref.current.state.showDatePickerModal).toBe(false);\n  });\n\n  //iswheelpicker = false cases (prop not available in studio currently)\n\n  it('should render date widget when wheel picker is false and platform is android', async () => {\n    Platform.OS = 'android';\n\n    render(\n      <WmDate\n        {...props}\n        name=\"date1\"\n        iswheelpicker={false}\n        datavalue=\"2024-08-14\"\n        datepattern=\"yyyy-MM-dd\"\n      />\n    );\n    const dateInput = screen.getAllByTestId('date1_a')[0];\n\n    fireEvent.press(dateInput);\n    await timer(300);\n\n    expect(screen).toMatchSnapshot();\n  });\n\n  it('should render date widget when wheel picker is false and platform is ios', async () => {\n    Platform.OS = 'ios';\n\n    render(\n      <ModalProvider value={AppModalService}>\n        <AssetProvider value={loadAsset}>\n          <WmDate\n            {...props}\n            name=\"date1\"\n            iswheelpicker={false}\n            datavalue=\"2024-08-14\"\n            datepattern=\"yyyy-MM-dd\"\n          />\n        </AssetProvider>\n      </ModalProvider>\n    );\n\n    const dateInput = screen.getAllByTestId('date1_a')[0];\n\n    fireEvent.press(dateInput);\n    await timer(300);\n\n    expect(screen).toMatchSnapshot();\n\n    const renderOptions = AppModalService.modalOptions;\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const subTree = render(<Content />);\n\n    expect(subTree).toMatchSnapshot();\n  });\n\n  //// web cases\n\n  it('should render datepicker when Platform.OS = \"web\"', async () => {\n    Platform.OS = 'web';\n\n    let userAgent =\n      'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1';\n\n    window['navigator'] = { userAgent: userAgent };\n\n    const ref = createRef();\n\n    const tree = renderComponentWithWrappers({\n      ...props,\n      ref,\n      name: 'date1',\n      datepattern: 'yyyy-MM-dd',\n      locale: 'en',\n    });\n    await timer(200);\n\n    const dateInput = screen.getAllByTestId('date1_a')[0];\n    fireEvent.press(dateInput);\n\n    await timer();\n\n    const renderOptions = AppModalService.modalOptions;\n\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n\n    let subTree = render(<Content />);\n\n    AppModalService.animatedRefs = [\n      {\n        triggerExit: () => {},\n      },\n    ];\n\n    const saveButton = subTree.getByText('save');\n    fireEvent.press(saveButton);\n    await timer(300);\n\n    expect(ref.current.state.displayValue).toBe(currDate);\n    expect(tree.getByText(currDate)).toBeTruthy();\n  });\n\n  it('should handle blur event and validate on web', async () => {\n    const onBlurMock = jest.fn();\n    const triggerValidationMock = jest.fn();\n\n    Platform.OS = 'web';\n\n    let userAgent =\n      'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1';\n\n    window['navigator'] = { userAgent: userAgent };\n\n    const ref = createRef();\n\n    const tree = renderComponentWithWrappers({\n      ...props,\n      ref,\n      name: 'date1',\n      datepattern: 'yyyy-MM-dd',\n      locale: 'en',\n      onBlur: onBlurMock,\n      triggerValidation: triggerValidationMock,\n    });\n    await timer(200);\n\n    const dateInput = screen.getAllByTestId('date1_a')[0];\n    fireEvent.press(dateInput);\n\n    await timer();\n\n    const renderOptions = AppModalService.modalOptions;\n\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n\n    let subTree = render(<Content />);\n\n    AppModalService.animatedRefs = [\n      {\n        triggerExit: () => {},\n      },\n    ];\n\n    const cancelButton = subTree.getByLabelText('close');\n    fireEvent.press(cancelButton);\n    await timer(300);\n\n    expect(onBlurMock).toHaveBeenCalled();\n    expect(triggerValidationMock).toHaveBeenCalled();\n  });\n\n   //skeleton loader\n  it('should render skeleton with respect to root styles when show skeleton is true', () => {\n    const tree = render(<WmDate {...props} name=\"date1\" showskeleton={true}/>);\n    const viewEles = tree.UNSAFE_getAllByType(View);\n    expect(viewEles[1].props.style.width).toBe('80%');\n    expect(viewEles[1].props.style.height).toBe(16);\n    expect(viewEles[2].props.style.width).toBe(32);\n    expect(viewEles[2].props.style.height).toBe(32);\n  })\n\n});\n", "wavemaker-rn-runtime/test/components/input/epoch/datetime.component.spec.tsx": "import WmDatetime from '@wavemaker/app-rn-runtime/components/input/epoch/datetime/datetime.component';\n\nimport React, { ReactNode, createRef } from 'react';\nimport { Platform, Text, TouchableOpacity, View } from 'react-native';\nimport WmDatetimeProps from '@wavemaker/app-rn-runtime/components/input/epoch/datetime/datetime.props';\nimport { ScrollView } from 'react-native-gesture-handler';\nimport AppModalService from '@wavemaker/app-rn-runtime/runtime/services/app-modal.service';\nimport { AssetProvider } from '@wavemaker/app-rn-runtime/core/asset.provider';\nimport { ModalProvider } from '@wavemaker/app-rn-runtime/core/modal.service';\n\nimport { render, fireEvent, screen } from '@testing-library/react-native';\n\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\n\njest.mock('react-native-safe-area-context', () => {\n  return {\n    useSafeAreaInsets: jest.fn().mockReturnValue({\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n    }),\n    SafeAreaProvider: ({ children }) => children,\n  };\n});\n\njest.mock('expo-asset');\njest.mock('expo-font');\n\nconst timer = (time = 100) =>\n  new Promise((resolve: any, reject) => {\n    setTimeout(() => resolve(), time);\n  });\n\nconst loadAsset = (path) => path;\n\nAppModalService.modalsOpened = [];\n\nfunction renderComponentWithWrappers(props = {}) {\n  return render(\n    <ModalProvider value={AppModalService}>\n      <AssetProvider value={loadAsset}>\n        <WmDatetime {...props} />\n      </AssetProvider>\n    </ModalProvider>\n  );\n}\n\ndescribe('WmDatetime Component', () => {\n  let props;\n\n  beforeEach(() => {\n    props = new WmDatetimeProps();\n  });\n\n  it('should render with default properties correctly', async () => {\n    const ref = createRef();\n    render(<WmDatetime {...props} name=\"datetime1\" ref={ref} />);\n    const datetimeInput = screen.getAllByTestId('datetime1_a')[0];\n    fireEvent.press(datetimeInput);\n\n    await timer(200);\n\n    expect(screen.getByText(props.placeholder)).toBeTruthy();\n    expect(ref.current.state.showDatePicker).toBe(true);\n    expect(ref.current.state.showDatePickerModal).toBe(true);\n    expect(screen).toMatchSnapshot();\n  });\n\n  it('should apply the correct style class name when floatinglabel is present', () => {\n    props.floatinglabel = 'Test Label';\n    const ref = createRef();\n    render(<WmDatetime {...props} name=\"datetime1\" ref={ref} />);\n    const className = ref.current.getStyleClassName();\n    expect(className).toContain('app-datetime-with-label');\n  });\n\n  it('should show date picker modal on focus', async () => {\n    const ref = createRef();\n    const onTapMock = jest.fn();\n    render(\n      <WmDatetime {...props} name=\"datetime1\" ref={ref} onTap={onTapMock} />\n    );\n\n    const datetimeInput = screen.getAllByTestId('datetime1_a')[0];\n\n    fireEvent.press(datetimeInput);\n    await timer(300);\n    const selectDateText = screen.getByText('Select Date');\n    expect(selectDateText).toBeTruthy();\n    expect(screen.getByText('Select')).toBeTruthy();\n    expect(screen.getByText('Cancel')).toBeTruthy();\n    expect(onTapMock).toHaveBeenCalled();\n  });\n\n  it('should handle date and time change correctly', async () => {\n    const ref = createRef();\n    const onChangeMock = jest.fn();\n    const onBlurMock = jest.fn();\n\n    render(\n      <WmDatetime\n        {...props}\n        name=\"datetime1\"\n        ref={ref}\n        onChange={onChangeMock}\n        onBlur={onBlurMock}\n        datepattern=\"MMM d, y hh:mm:ss a\"\n      />\n    );\n\n    const datetimeInput = screen.getAllByTestId('datetime1_a')[0];\n    fireEvent.press(datetimeInput);\n\n    await timer(300);\n\n    expect(screen.getByText('Select Date'));\n\n    const scrollViewDate = screen.UNSAFE_getAllByType(ScrollView)[0];\n    const scrollViewMonth = screen.UNSAFE_getAllByType(ScrollView)[1];\n    const scrollViewYear = screen.UNSAFE_getAllByType(ScrollView)[2];\n    //selecting date\n    fireEvent(scrollViewDate, 'scroll', {\n      nativeEvent: {\n        contentOffset: {\n          x: 100,\n          y: 200,\n        },\n      },\n    });\n    fireEvent(scrollViewDate, 'momentumScrollEnd');\n\n    //selecting month\n    fireEvent(scrollViewMonth, 'scroll', {\n      nativeEvent: {\n        contentOffset: {\n          x: 100,\n          y: 200,\n        },\n      },\n    });\n    fireEvent(scrollViewMonth, 'momentumScrollEnd');\n\n    //selecting year\n    fireEvent(scrollViewYear, 'scroll', {\n      nativeEvent: {\n        contentOffset: {\n          x: 100,\n          y: 2000,\n        },\n      },\n    });\n    fireEvent(scrollViewYear, 'momentumScrollEnd');\n\n    await timer();\n\n    fireEvent.press(screen.getByText('Select'));\n\n    await timer(300);\n\n    expect(ref.current.state.props.datavalue).toBe('641845800000');\n    expect(ref.current.state.dateValue.toISOString()).toBe(\n      '1990-05-04T18:30:00.000Z'\n    );\n\n    expect(ref.current.state.displayValue).toBe('May 5, 1990 12:00:00 am');\n    expect(onChangeMock).toHaveBeenCalled();\n    expect(onBlurMock).toHaveBeenCalled();\n    expect(screen.getByText('May 5, 1990 12:00:00 am')).toBeTruthy();\n\n    expect(screen.getByText('Select Time'));\n\n    const scrollViewHour = screen.UNSAFE_getAllByType(ScrollView)[0];\n    const scrollViewMinute = screen.UNSAFE_getAllByType(ScrollView)[1];\n    const scrollViewMeridiem = screen.UNSAFE_getAllByType(ScrollView)[2];\n\n    //selecting date\n    fireEvent(scrollViewHour, 'scroll', {\n      nativeEvent: {\n        contentOffset: {\n          x: 100,\n          y: 200,\n        },\n      },\n    });\n    fireEvent(scrollViewHour, 'momentumScrollEnd');\n\n    //selecting month\n    fireEvent(scrollViewMinute, 'scroll', {\n      nativeEvent: {\n        contentOffset: {\n          x: 100,\n          y: 200,\n        },\n      },\n    });\n    fireEvent(scrollViewMinute, 'momentumScrollEnd');\n\n    //selecting year\n    fireEvent(scrollViewMeridiem, 'scroll', {\n      nativeEvent: {\n        contentOffset: {\n          x: 100,\n          y: 50,\n        },\n      },\n    });\n    fireEvent(scrollViewMeridiem, 'momentumScrollEnd');\n\n    await timer();\n\n    fireEvent.press(screen.getByText('Select'));\n\n    await timer(300);\n\n    expect(ref.current.state.props.datavalue).toBe('641907240000');\n    expect(ref.current.state.dateValue.toISOString()).toBe(\n      '1990-05-05T11:34:00.000Z'\n    );\n    expect(ref.current.state.displayValue).toBe('May 5, 1990 05:04:00 pm');\n    expect(onChangeMock).toHaveBeenCalled();\n    expect(onBlurMock).toHaveBeenCalled();\n    expect(screen.getByText('May 5, 1990 05:04:00 pm')).toBeTruthy();\n    // expect(onChangeMock).toHaveBeenCalledTimes(3);\n    expect(onBlurMock).toHaveBeenCalledTimes(2);\n  });\n\n  it('should call onFocus and onBlur correctly', async () => {\n    const onFocusMock = jest.fn();\n    const onBlurMock = jest.fn();\n\n    render(\n      <WmDatetime\n        {...props}\n        name=\"datetime1\"\n        onFocus={onFocusMock}\n        onBlur={onBlurMock}\n      />\n    );\n    const datetimeInput = screen.getAllByTestId('datetime1_a')[0];\n\n    fireEvent.press(datetimeInput);\n    await timer(300);\n\n    expect(onFocusMock).toHaveBeenCalled();\n\n    fireEvent.press(screen.getByText('Cancel'));\n    await timer(300);\n\n    expect(onBlurMock).toHaveBeenCalled();\n  });\n\n  it('should display current date if datavalue is CURRENT_DATE', async () => {\n    props.datavalue = 'CURRENT_DATE';\n    props.datepattern = 'yyyy-MM-dd';\n    const ref = createRef();\n    const currDate = new Date()\n      .toLocaleDateString('en-GB', {\n        year: 'numeric',\n        month: '2-digit',\n        day: '2-digit',\n      })\n      .split('/')\n      .reverse()\n      .join('-');\n    render(<WmDatetime {...props} name=\"datetime1\" ref={ref} />);\n\n    await timer(300);\n\n    expect(ref.current.state.dateValue).toBeTruthy();\n    expect(ref.current.state.displayValue).toBe(currDate);\n    expect(screen.getByText(currDate)).toBeTruthy();\n  });\n\n  it('should handle minimum date property correctly', () => {\n    const minDate = new Date(2022, 7, 10).toISOString();\n    const ref = createRef();\n    const currDate = new Date().toISOString().split('T')[0];\n\n    render(\n      <WmDatetime {...props} name=\"datetime1\" mindate={minDate} ref={ref} />\n    );\n\n    expect(ref.current.state.props.mindate.toISOString()).toEqual(minDate);\n\n    render(\n      <WmDatetime\n        {...props}\n        name=\"datetime1\"\n        mindate=\"CURRENT_DATE\"\n        ref={ref}\n      />\n    );\n\n    expect(ref.current.state.props.mindate.toISOString().split('T')[0]).toEqual(\n      currDate\n    );\n  });\n\n  it('should handle maximum date property correctly', () => {\n    const maxDate = new Date(2024, 7, 10).toISOString();\n    const ref = createRef();\n    const currDate = new Date().toISOString().split('T')[0];\n\n    render(\n      <WmDatetime {...props} name=\"datetime1\" maxdate={maxDate} ref={ref} />\n    );\n\n    expect(ref.current.state.props.maxdate.toISOString()).toEqual(maxDate);\n\n    render(\n      <WmDatetime\n        {...props}\n        name=\"datetime1\"\n        maxdate=\"CURRENT_DATE\"\n        ref={ref}\n      />\n    );\n\n    expect(ref.current.state.props.maxdate.toISOString().split('T')[0]).toEqual(\n      currDate\n    );\n  });\n\n  it('should render FloatingLabel if the floatinglabel prop is set', () => {\n    props.floatinglabel = 'Test Label';\n\n    const { getByText } = render(<WmDatetime {...props} />);\n    expect(getByText('Test Label')).toBeTruthy();\n  });\n\n  //// web cases\n\n  it('should render datetimepicker when Platform.OS = \"web\"', async () => {\n    Platform.OS = 'web';\n\n    let userAgent =\n      'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1';\n\n    window['navigator'] = { userAgent: userAgent };\n\n    const ref = createRef();\n\n    const options = {\n      month: 'short', // \"Sep\"\n      day: 'numeric', // \"2\"\n      year: 'numeric', // \"2024\"\n      hour: '2-digit', // \"03\"\n      minute: '2-digit', // \"56\"\n      // second: '2-digit', // \"37\"\n      hour12: true, // 24-hour format, removing \"AM\"/\"PM\"\n    };\n\n    const currDateTime = new Date()\n      .toLocaleString('en-US', options)\n      .replace(',', '');\n\n    const tree = renderComponentWithWrappers({\n      ...props,\n      ref,\n      name: 'datetime1',\n      datepattern: 'MMM d y, hh:mm a',\n      locale: 'en',\n    });\n    await timer(200);\n\n    const dateTimeInput = screen.getAllByTestId('datetime1_a')[0];\n    fireEvent.press(dateTimeInput);\n\n    await timer();\n\n    let renderOptions = AppModalService.modalOptions;\n\n    let Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n\n    let subTree1 = render(<Content />);\n\n    const saveButton = subTree1.getByText('save');\n    fireEvent.press(saveButton);\n    await timer(300);\n\n    renderOptions = AppModalService.modalOptions;\n\n    Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n\n    let subTree2 = render(<Content />);\n\n    const okButton = subTree2.getByText('Ok');\n    fireEvent.press(okButton);\n    await timer(300);\n\n    expect(ref.current.state.displayValue.toLowerCase()).toBe(\n      currDateTime.toLowerCase()\n    );\n    expect(tree.getByText(ref.current.state.displayValue)).toBeTruthy();\n  });\n\n  it('should render header, cancel and confirmation text as per the received props', async () => {\n    Platform.OS = 'ios';\n    const ref = createRef();\n\n    renderComponentWithWrappers({\n      ...props,\n      ref,\n      name: 'datetime1',\n      datepattern: 'MMM d y, hh:mm a',\n      locale: 'en',\n      dateheadertitle: 'Select a date',\n      datecanceltitle: 'Close',\n      dateconfirmationtitle: 'Okay',\n      timeheadertitle: 'Select a time',\n      timecanceltitle: 'Close',\n      timeconfirmationtitle: 'Okay'\n    });\n\n    const datetimeInput = screen.getAllByTestId('datetime1_a')[0];\n    fireEvent.press(datetimeInput);\n\n    await timer(300);\n    expect(screen.getByText('Select a date'));\n    expect(screen.getByText('Close'));\n    expect(screen.getByText('Okay'));\n\n    fireEvent.press(screen.getByText('Okay'));\n    await timer(300);\n    expect(screen.getByText('Select a time'));\n    expect(screen.getByText('Close'));\n    expect(screen.getByText('Okay'));\n  });\n\n   //skeleton loader\n   it('should render skeleton with respect to root styles when show skeleton is true', () => {\n    const tree = render(<WmDatetime {...props} name=\"datetime1\" showskeleton={true}/>);\n    const viewEles = tree.UNSAFE_getAllByType(View);\n    expect(viewEles[1].props.style.width).toBe('80%');\n    expect(viewEles[1].props.style.height).toBe(16);\n    expect(viewEles[2].props.style.width).toBe(32);\n    expect(viewEles[2].props.style.height).toBe(32);\n  })\n});\n", "wavemaker-rn-runtime/test/components/input/epoch/time.component.spec.tsx": "import WmTime from '@wavemaker/app-rn-runtime/components/input/epoch/time/time.component';\nimport WmTimeProps from '@wavemaker/app-rn-runtime/components/input/epoch/time/time.props';\n\nimport React, { ReactNode, createRef } from 'react';\nimport { Modal, Platform, Text, TouchableOpacity, View } from 'react-native';\nimport { ScrollView } from 'react-native-gesture-handler';\nimport AppModalService from '@wavemaker/app-rn-runtime/runtime/services/app-modal.service';\nimport { AssetProvider } from '@wavemaker/app-rn-runtime/core/asset.provider';\nimport { ModalProvider } from '@wavemaker/app-rn-runtime/core/modal.service';\n\nimport { render, fireEvent, screen } from '@testing-library/react-native';\n\nimport { useSafeAreaInsets } from 'react-native-safe-area-context';\n\njest.mock('react-native-safe-area-context', () => {\n  return {\n    useSafeAreaInsets: jest.fn().mockReturnValue({\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n    }),\n    SafeAreaProvider: ({ children }) => children,\n  };\n});\n\njest.mock('expo-asset');\njest.mock('expo-font');\n\nconst timer = (time = 100) =>\n  new Promise((resolve: any, reject) => {\n    setTimeout(() => resolve(), time);\n  });\n\nconst loadAsset = (path) => path;\n\nAppModalService.modalsOpened = [];\n\nfunction renderComponentWithWrappers(props = {}) {\n  return render(\n    <ModalProvider value={AppModalService}>\n      <AssetProvider value={loadAsset}>\n        <WmTime {...props} />\n      </AssetProvider>\n    </ModalProvider>\n  );\n}\n\ndescribe('WmTime Component', () => {\n  let props;\n\n  beforeEach(() => {\n    props = new WmTimeProps();\n  });\n\n  it('should render with default properties correctly', async () => {\n    const ref = createRef();\n    render(<WmTime {...props} name=\"time1\" ref={ref} />);\n    expect(screen).toMatchSnapshot();\n    const timeInput = screen.getAllByTestId('time1_a')[0];\n    fireEvent.press(timeInput);\n\n    await timer(200);\n\n    expect(screen.getByText(props.placeholder)).toBeTruthy();\n    expect(ref.current.state.showDatePicker).toBe(true);\n    expect(ref.current.state.showTimePickerModal).toBe(true);\n    expect(screen).toMatchSnapshot();\n  });\n\n  it('should apply the correct style class name when floatinglabel is present', () => {\n    props.floatinglabel = 'Test Label';\n    const ref = createRef();\n    render(<WmTime {...props} name=\"time1\" ref={ref} />);\n    const className = ref.current.getStyleClassName();\n    expect(className).toContain('app-time-with-label');\n  });\n\n  it('should show time picker modal on focus', async () => {\n    const ref = createRef();\n    const onTapMock = jest.fn();\n    render(<WmTime {...props} name=\"time1\" ref={ref} onTap={onTapMock} />);\n\n    const timeInput = screen.getAllByTestId('time1_a')[0];\n\n    fireEvent.press(timeInput);\n    await timer(300);\n    const selectDateText = screen.getByText('Select Time');\n    expect(selectDateText).toBeTruthy();\n    expect(screen.getByText('Select')).toBeTruthy();\n    expect(screen.getByText('Cancel')).toBeTruthy();\n    expect(onTapMock).toHaveBeenCalled();\n  });\n\n  it('should handle time change correctly - 12 hour format', async () => {\n    const ref = createRef();\n    const onChangeMock = jest.fn();\n    const onBlurMock = jest.fn();\n\n    render(\n      <WmTime\n        {...props}\n        name=\"time1\"\n        ref={ref}\n        onChange={onChangeMock}\n        onBlur={onBlurMock}\n        datepattern=\"hh:mm:ss a\"\n        outputformat=\"HH:mm:ss\"\n      />\n    );\n\n    const timeInput = screen.getAllByTestId('time1_a')[0];\n    fireEvent.press(timeInput);\n\n    await timer(300);\n\n    const scrollViewHour = screen.UNSAFE_getAllByType(ScrollView)[0];\n    const scrollViewMinute = screen.UNSAFE_getAllByType(ScrollView)[1];\n    const scrollViewMeridiem = screen.UNSAFE_getAllByType(ScrollView)[2];\n    //selecting hour\n    fireEvent(scrollViewHour, 'scroll', {\n      nativeEvent: {\n        contentOffset: {\n          x: 100,\n          y: 200,\n        },\n      },\n    });\n    fireEvent(scrollViewHour, 'momentumScrollEnd');\n\n    //selecting minute\n    fireEvent(scrollViewMinute, 'scroll', {\n      nativeEvent: {\n        contentOffset: {\n          x: 100,\n          y: 200,\n        },\n      },\n    });\n    fireEvent(scrollViewMinute, 'momentumScrollEnd');\n\n    //selecting meridiem\n    fireEvent(scrollViewMeridiem, 'scroll', {\n      nativeEvent: {\n        contentOffset: {\n          x: 100,\n          y: 50,\n        },\n      },\n    });\n    fireEvent(scrollViewMeridiem, 'momentumScrollEnd');\n\n    await timer();\n\n    fireEvent.press(screen.getByText('Select'));\n\n    await timer(300);\n\n    expect(ref.current.state.props.datavalue).toBe('17:04:00');\n    expect(ref.current.state.displayValue).toBe('05:04:00 pm');\n    expect(onChangeMock).toHaveBeenCalled();\n    expect(onBlurMock).toHaveBeenCalled();\n    expect(screen.getByText('05:04:00 pm')).toBeTruthy();\n  });\n\n  it('should handle time change correctly - 24 hour format', async () => {\n    const ref = createRef();\n    const onChangeMock = jest.fn();\n    const onBlurMock = jest.fn();\n\n    render(\n      <WmTime\n        {...props}\n        name=\"time1\"\n        ref={ref}\n        onChange={onChangeMock}\n        onBlur={onBlurMock}\n        datepattern=\"hh:mm:ss\"\n        outputformat=\"HH:mm:ss\"\n      />\n    );\n\n    const timeInput = screen.getAllByTestId('time1_a')[0];\n    fireEvent.press(timeInput);\n\n    await timer(300);\n\n    const scrollViewHour = screen.UNSAFE_getAllByType(ScrollView)[0];\n    const scrollViewMinute = screen.UNSAFE_getAllByType(ScrollView)[1];\n    //selecting hour\n    fireEvent(scrollViewHour, 'scroll', {\n      nativeEvent: {\n        contentOffset: {\n          x: 100,\n          y: 200,\n        },\n      },\n    });\n    fireEvent(scrollViewHour, 'momentumScrollEnd');\n\n    //selecting minute\n    fireEvent(scrollViewMinute, 'scroll', {\n      nativeEvent: {\n        contentOffset: {\n          x: 100,\n          y: 200,\n        },\n      },\n    });\n    fireEvent(scrollViewMinute, 'momentumScrollEnd');\n\n    await timer();\n\n    fireEvent.press(screen.getByText('Select'));\n\n    await timer(300);\n\n    expect(ref.current.state.props.datavalue).toBe('04:04:00');\n\n    expect(ref.current.state.displayValue).toBe('04:04:00');\n    expect(onChangeMock).toHaveBeenCalled();\n    expect(onBlurMock).toHaveBeenCalled();\n    expect(screen.getByText('04:04:00')).toBeTruthy();\n  });\n\n  it('should call onFocus and onBlur correctly', async () => {\n    const onFocusMock = jest.fn();\n    const onBlurMock = jest.fn();\n\n    render(\n      <WmTime\n        {...props}\n        name=\"time1\"\n        onFocus={onFocusMock}\n        onBlur={onBlurMock}\n      />\n    );\n    const timeInput = screen.getAllByTestId('time1_a')[0];\n\n    fireEvent.press(timeInput);\n    await timer(300);\n\n    expect(onFocusMock).toHaveBeenCalled();\n\n    fireEvent.press(screen.getByText('Cancel'));\n    await timer(300);\n\n    expect(onBlurMock).toHaveBeenCalled();\n  });\n\n  it('should display current time if datavalue is CURRENT_TIME', async () => {\n    props.datavalue = 'CURRENT_TIME';\n    props.datepattern = 'hh:mm:ss a';\n\n    const ref = createRef();\n    const hourValue = +new Date().toLocaleTimeString().substring(0, 2);\n    const currTime =\n      hourValue >= 10\n        ? new Date().toLocaleTimeString()\n        : '0' + new Date().toLocaleTimeString();\n\n    render(<WmTime {...props} name=\"time1\" ref={ref} />);\n\n    await timer(300);\n\n    expect(ref.current.state.dateValue).toBeTruthy();\n    expect(ref.current.state.displayValue).toBe(currTime.toLowerCase());\n    expect(screen.getByText(currTime.toLowerCase())).toBeTruthy();\n  });\n\n  it('should render FloatingLabel if the floatinglabel prop is set', () => {\n    props.floatinglabel = 'Test Label';\n\n    const { getByText } = render(<WmTime {...props} />);\n    expect(getByText('Test Label')).toBeTruthy();\n  });\n\n  it('should set showTimePickerModal to false when modal is dismissed', async () => {\n    const ref = createRef();\n    render(<WmTime {...props} name=\"time1\" ref={ref} />);\n    expect(screen).toMatchSnapshot();\n    const timeInput = screen.getAllByTestId('time1_a')[0];\n    fireEvent.press(timeInput);\n\n    await timer(200);\n    expect(ref.current.state.showTimePickerModal).toBe(true);\n\n    const modalEle = screen.UNSAFE_getByType(Modal);\n    fireEvent(modalEle, 'dismiss');\n    await timer(200);\n\n    expect(ref.current.state.showTimePickerModal).toBe(false);\n  });\n\n  //// web cases\n\n  it('should render timepicker when Platform.OS = \"web\"', async () => {\n    Platform.OS = 'web';\n\n    let userAgent =\n      'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1';\n\n    window['navigator'] = { userAgent: userAgent };\n\n    const ref = createRef();\n    const hourValue = +new Date().toLocaleTimeString().substring(0, 2);\n    const currTime =\n      hourValue >= 10\n        ? new Date().toLocaleTimeString()\n        : '0' + new Date().toLocaleTimeString();\n\n    const tree = renderComponentWithWrappers({\n      ...props,\n      ref,\n      name: 'time1',\n      datepattern: 'hh:mm:ss a',\n      locale: 'en',\n    });\n    await timer(200);\n\n    const timeInput = screen.getAllByTestId('time1_a')[0];\n    fireEvent.press(timeInput);\n\n    await timer();\n\n    const renderOptions = AppModalService.modalOptions;\n\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n\n    let subTree = render(<Content />);\n\n    const okButton = subTree.getByText('Ok');\n    fireEvent.press(okButton);\n    await timer(300);\n\n    expect(ref.current.state.displayValue).toBe(currTime.toLowerCase());\n    expect(tree.getByText(currTime.toLowerCase())).toBeTruthy();\n  });\n\n  it('should handle blur event and validate on web', async () => {\n    const onBlurMock = jest.fn();\n    const triggerValidationMock = jest.fn();\n\n    Platform.OS = 'web';\n\n    let userAgent =\n      'Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1';\n\n    window['navigator'] = { userAgent: userAgent };\n\n    const ref = createRef();\n\n    const tree = renderComponentWithWrappers({\n      ...props,\n      ref,\n      name: 'time1',\n      datepattern: 'hh:mm:ss a',\n      locale: 'en',\n      onBlur: onBlurMock,\n      triggerValidation: triggerValidationMock,\n    });\n    await timer(200);\n\n    const timeInput = screen.getAllByTestId('time1_a')[0];\n    fireEvent.press(timeInput);\n\n    await timer();\n\n    const renderOptions = AppModalService.modalOptions;\n\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n\n    let subTree = render(<Content />);\n\n    const cancelButton = subTree.getByText('Cancel');\n    fireEvent.press(cancelButton);\n    await timer(300);\n\n    expect(onBlurMock).toHaveBeenCalled();\n    expect(triggerValidationMock).toHaveBeenCalled();\n  });\n\n   //skeleton loader\n   it('should render skeleton with respect to root styles when show skeleton is true', () => {\n    const tree = render(<WmTime {...props} name=\"time1\" showskeleton={true}/>);\n    const viewEles = tree.UNSAFE_getAllByType(View);\n    expect(viewEles[1].props.style.width).toBe('80%');\n    expect(viewEles[1].props.style.height).toBe(16);\n    expect(viewEles[2].props.style.width).toBe(32);\n    expect(viewEles[2].props.style.height).toBe(32);\n  })\n});\n", "wavemaker-rn-runtime/test/components/chart/line-chart.component.spec.tsx": "import React, { ReactNode, createRef } from 'react';\nimport WmLineChart from '@wavemaker/app-rn-runtime/components/chart/line-chart/line-chart.component';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\n\nimport {\n  VictoryAxis,\n  VictoryChart,\n  VictoryLegend,\n  VictoryLine,\n  VictoryScatter,\n} from 'victory-native';\nimport {\n  fireEvent,\n  render,\n  waitFor,\n  screen,\n  act,\n  cleanup,\n} from '@testing-library/react-native';\nimport { constructSampleData } from '@wavemaker/app-rn-runtime/components/chart/staticdata';\n\nconst renderComponent = (props = {}) => {\n  return render(<WmLineChart name=\"test_BubbleChart\" {...props} />);\n};\nconst dataSet = [\n  {\n    x: 10,\n    y: 101,\n  },\n  {\n    x: 20,\n    y: 201,\n  },\n  {\n    x: 30,\n    y: 301,\n  },\n];\nconst defaultProps = {\n  dataset: dataSet,\n  xaxisdatakey: 'x',\n  yaxisdatakey: 'y',\n};\n\ndescribe('Test LineChart component', () => {\n  afterEach(() => {\n    jest.clearAllMocks();\n    cleanup();\n  });\n\n  //should render when default props are given and also shouldnot render when default props are not given\n\n  it('should render with null when default props was not given', () => {\n    const tree = renderComponent();\n    expect(Array.isArray(tree.toJSON())).toBe(false);\n    expect(tree.toJSON().children).toBeNull();\n  });\n\n  it('should render when default props was given', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n    });\n    expect(tree).toBeDefined();\n    expect(tree).toMatchSnapshot();\n  });\n\n  //events - on before and on transform\n\n  it('should call onBeforerender and onTransform events', () => {\n    const onBeforeRenderMock = jest.fn();\n    const onTransformMock = jest.fn();\n    const invokeEventCallbackMock = jest.spyOn(\n      WmLineChart.prototype,\n      'invokeEventCallback'\n    );\n    renderComponent({\n      ...defaultProps,\n      onBeforerender: onBeforeRenderMock,\n      onTransform: onTransformMock,\n    });\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n      'onBeforerender',\n      expect.anything()\n    );\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n      'onTransform',\n      expect.anything()\n    );\n    expect(onBeforeRenderMock).toHaveBeenCalledTimes(1);\n    expect(onTransformMock).toHaveBeenCalledTimes(1);\n  });\n\n  //accessibility\n\n  it('should apply accessibility props correctly', async () => {\n    const { getByRole, getByLabelText, getByA11yHint } = renderComponent({\n      ...defaultProps,\n      accessibilitylabel: 'LINECHART',\n      accessibilityrole: 'LINECHART',\n      hint: 'test LINECHART',\n      styles: {\n        root: {\n          backgroundColor: 'red',\n          width: 200,\n          height: 300,\n        },\n        text: {\n          color: 'red',\n        },\n      },\n    });\n    expect(getByLabelText('LINECHART')).toBeTruthy();\n    expect(getByRole('LINECHART')).toBeTruthy();\n    expect(getByA11yHint('test LINECHART')).toBeTruthy();\n    expect(getByRole('LINECHART').props.style.backgroundColor).toBe('red');\n    expect(getByRole('LINECHART').props.style.width).toBe(200);\n    expect(getByRole('LINECHART').props.style.height).toBe(300);\n  });\n\n  //show : false\n\n  it('should have width and height to be 0 when show is false', () => {\n    const { getByRole } = renderComponent({\n      ...defaultProps,\n      show: false,\n      accessibilityrole: 'LINECHART',\n    });\n    const viewEle = getByRole('LINECHART');\n    expect(viewEle.props.style.width).toBe(0);\n    expect(viewEle.props.style.height).toBe(0);\n  });\n\n  //title , subheading, icon\n\n  it('should render title', () => {\n    const { getByText } = renderComponent({\n      title: 'Line Chart',\n      ...defaultProps,\n      styles: {\n        title: {\n          color: 'red',\n          fontSize: 30,\n          lineHeight: 10,\n          paddingLeft: 20,\n        },\n        text: {\n          color: 'yellow',\n        },\n      },\n    });\n    expect(getByText('Line Chart')).toBeTruthy();\n    expect(getByText('Line Chart').props.style.color).toBe('red');\n    expect(getByText('Line Chart').props.style.fontSize).toBe(30);\n    expect(getByText('Line Chart').props.style.lineHeight).toBe(10);\n    expect(getByText('Line Chart').props.style.paddingLeft).toBe(20);\n  });\n\n  it('should render subheading', () => {\n    const { getByText } = renderComponent({\n      subheading: 'subHeading-Line Chart',\n      ...defaultProps,\n      styles: {\n        subHeading: {\n          fontSize: 20,\n          lineHeight: 30,\n          color: 'red',\n        },\n        text: {\n          color: 'pink',\n        },\n      },\n    });\n    const text = getByText('subHeading-Line Chart');\n    expect(text).toBeTruthy();\n    expect(text).toBeTruthy();\n    expect(text.props.style.fontSize).toBe(20);\n    expect(text.props.style.lineHeight).toBe(30);\n    expect(text.props.style.color).toBe('red');\n  });\n\n  it('should render Icon when iconclass is provided', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      iconclass: 'fa fa-edit',\n      styles: {\n        icon: {\n          icon: {\n            fontSize: 40,\n          },\n        },\n        text: {\n          color: 'red',\n        },\n      },\n    });\n    expect(tree.getByText('edit')).toBeTruthy();\n    expect(tree.getByText('edit').props.style[1].fontSize).toBe(40);\n  });\n\n  it('should not render Icon when iconclass is not provided', () => {\n    const tree = renderComponent({ ...defaultProps });\n    const wmIcon = tree.UNSAFE_queryByType(WmIcon);\n    expect(wmIcon).toBeNull();\n  });\n\n  //VictoryCharts starts here\n\n  it('should render victorycharts with styles - offset and styles', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      offsettop: 10,\n      offsetbottom: 20,\n      offsetright: 30,\n      offsetleft: 40,\n      styles: {\n        root: {\n          height: 100,\n          width: 250,\n        },\n        text: {\n          color: 'red',\n        },\n      },\n    });\n    const viewEle = tree.UNSAFE_getByType(VictoryChart);\n    expect(viewEle.props.padding.top).toBe(10);\n    expect(viewEle.props.padding.bottom).toBe(20);\n    expect(viewEle.props.padding.right).toBe(30);\n    expect(viewEle.props.padding.left).toBe(40);\n  });\n\n  //victoryLine\n\n  it('should render VictoryLine with - linethickValue, customcolors and interpolation , ', () => {\n    const colorScale = ['red', 'yellow', 'green'];\n    const linethickValue = 5;\n    const tree = renderComponent({\n      ...defaultProps,\n      linethickness: linethickValue,\n      customcolors: colorScale,\n    });\n\n    const viewEle = tree.UNSAFE_getByType(VictoryLine);\n    expect(viewEle.props.interpolation).toBe('linear');\n    expect(viewEle.props.style.data.strokeWidth).toBe(linethickValue);\n    expect(viewEle.props.style.data.stroke).toBe(colorScale[0]);\n    expect(viewEle.props.data[0].y).toBe(101);\n\n    tree.rerender(\n      <WmLineChart\n        {...defaultProps}\n        name=\"test_AreaChart\"\n        interpolation=\"cardinal\"\n      />\n    );\n    const victoryAreaEle1 = tree.UNSAFE_getByType(VictoryLine);\n    expect(victoryAreaEle1.props.interpolation).toBe('cardinal');\n\n    tree.rerender(\n      <WmLineChart\n        {...defaultProps}\n        name=\"test_AreaChart\"\n        interpolation=\"step\"\n      />\n    );\n    const victoryAreaEle2 = tree.UNSAFE_getByType(VictoryLine);\n    expect(victoryAreaEle2.props.interpolation).toBe('step');\n  });\n\n  //victoryScatter\n\n  it('should render VictoryScatter with colorScale', () => {\n    const colorScale = ['red', 'yellow', 'green'];\n    const tree = renderComponent({\n      ...defaultProps,\n      customcolors: colorScale,\n    });\n\n    const viewEle = tree.UNSAFE_getByType(VictoryScatter);\n    expect(viewEle.props.style.data.fill).toBe(colorScale[0]);\n    expect(viewEle.props.style.data.opacity).toBe(0.8);\n  });\n\n  //call onselect event\n  it('should call onSelect event', async () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmLineChart.prototype,\n      'invokeEventCallback'\n    );\n    const customRef = createRef<WmLineChart>();\n\n    const tree = renderComponent({\n      ...defaultProps,\n      offsetX: 10,\n      locationX: 14,\n      offsetY: 20,\n      locationY: 25,\n      ref: customRef,\n      tooltipXaxis: 1,\n      tooltipYaxis: 1,\n      isTooltipOpen: false,\n    });\n    const event = {\n      nativeEvent: {\n        offsetX: 10,\n        locationX: 14,\n        offsetY: 20,\n        locationY: 25,\n      },\n    };\n    const dataSet1 = {\n      data: [{ x: 10, y: 20, z: 30 }],\n      datum: {\n        x: 10,\n        y: 20,\n        z: 30,\n      },\n      index: 0,\n    };\n    act(() => {\n      customRef.current.onSelect(event, dataSet1);\n    });\n\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n      'onSelect',\n      expect.anything()\n    );\n  });\n\n  //get tool tip\n  it('should render get tooltip ', async () => {\n    const getTooltipMock = jest.spyOn(WmLineChart.prototype, 'getTooltip');\n    const customRef = createRef<WmLineChart>();\n    const { getByText } = renderComponent({\n      ...defaultProps,\n      caption: 'newcaption',\n      ref: customRef,\n    });\n    expect(getTooltipMock).toHaveBeenCalledTimes(1);\n    expect(getTooltipMock).toHaveReturnedWith(null);\n\n    const event = {\n      nativeEvent: {\n        offsetX: 10,\n        locationX: 14,\n        offsetY: 20,\n        locationY: 25,\n      },\n    };\n    const dataSet1 = {\n      data: [{ x: 10, y: 20, z: 30 }],\n      datum: {\n        x: 0,\n        y: 1,\n        z: 2,\n      },\n      index: 0,\n    };\n    act(() => {\n      customRef.current.onSelect(event, dataSet1);\n    });\n    await waitFor(() => {\n      expect(customRef.current.state.isTooltipOpen).toBe(true);\n      expect(getTooltipMock).not.toBeNull();\n      expect(getByText('10')).toBeTruthy();\n      expect(getByText('20')).toBeTruthy();\n    });\n  });\n\n  //Advanced settings xaxis, yaxis\n  it('checking Advanced Settings', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      xaxislabel: 'x',\n      xunits: 'cm',\n      showxdistance: 'true',\n      yaxislabel: 'y',\n      yunits: 'cm',\n      yaxislabeldistance: 2,\n      showydistance: 'true',\n    });\n    const viewEle = tree.UNSAFE_getAllByType(VictoryAxis);\n    expect(viewEle[0].props.label).toBe('x(cm)');\n    expect(viewEle[1].props.label).toBe('y(cm)');\n  });\n\n  //ShowLegend === 'hide'\n  it('showlegend set to hidden', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      showlegend: 'hide',\n      colorScale: ['red', 'yellow', 'green'],\n    });\n    expect(tree.UNSAFE_queryByType(VictoryLegend)).toBeFalsy();\n  });\n\n  //ShowLegend except hide\n  it('showlegend except hidden like showlegend as top,bottom,left,right', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      showlegend: 'top',\n      colorScale: ['red', 'yellow', 'green'],\n    });\n    expect(tree.UNSAFE_getByType(VictoryLegend)).toBeDefined();\n  });\n\n  //theme\n  it('should render theme', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      theme: 'Annabelle',\n    });\n    const viewEle1 = tree.UNSAFE_getByType(VictoryChart);\n    expect(viewEle1.props.theme.group.colorScale[0]).toBe('#393b79');\n    expect(viewEle1.props.theme.group.width).toBe(250);\n    expect(viewEle1.props.theme.group.height).toBe(250);\n    expect(viewEle1.props.theme.legend.colorScale[0]).toBe('#393b79');\n    expect(viewEle1.props.theme.legend.orientation).toBe('vertical');\n    expect(viewEle1.props.theme.legend.gutter).toBe(10);\n\n    const viewEle2 = tree.UNSAFE_getAllByType(VictoryLegend);\n    expect(viewEle2[0].props.theme.group.colorScale[0]).toBe('#393b79');\n    expect(viewEle2[0].props.theme.group.width).toBe(250);\n    expect(viewEle2[0].props.theme.group.height).toBe(250);\n    expect(viewEle2[0].props.theme.legend.colorScale[0]).toBe('#393b79');\n    expect(viewEle2[0].props.theme.legend.orientation).toBe('vertical');\n    expect(viewEle2[0].props.theme.legend.gutter).toBe(10);\n  });\n\n  //show xaxis\n  xit('showxaxis', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      showxaxis: false,\n    });\n    expect(tree.UNSAFE_getAllByType(VictoryAxis).length).toBe(1);\n  });\n\n  //show yaxis\n  it('showyaxis', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      showyaxis: false,\n    });\n    expect(tree.UNSAFE_getAllByType(VictoryAxis).length).toBe(1);\n  });\n\n  it('checking the ynumberformat is rounding y axis values to nearest whole number or not', () => {\n    const setYAxisFormatMock = jest.spyOn(\n      WmLineChart.prototype,\n      'setYAxisFormat'\n    );\n    const tree = renderComponent({\n      // ...defaultProps,\n      dataset: [\n        { x: 10, y: '101' },\n        { x: 20, y: '201' },\n        { x: 30, y: '301' },\n      ],\n      xaxisdatakey: 'x',\n      yaxisdatakey: 'y',\n      ynumberformat: '%',\n    });\n    expect(setYAxisFormatMock).toHaveBeenCalled();\n    // tickformat in victoryaxis defaultly taking y axis values and providing static values\n    expect(setYAxisFormatMock).toHaveReturnedWith(\n      '0%',\n      '15000%',\n      '20000%',\n      '30000%'\n    );\n\n    tree.rerender(\n      <WmLineChart\n        name=\"test_LineChart\"\n        {...defaultProps}\n        ynumberformat=\"Billion\"\n      />\n    );\n    expect(setYAxisFormatMock).toHaveReturnedWith(\n      '0.0B',\n      '0.0B',\n      '0.0B',\n      '0.0B'\n    );\n\n    tree.rerender(\n      <WmLineChart\n        name=\"test_LineChart\"\n        {...defaultProps}\n        ynumberformat=\"Million\"\n      />\n    );\n    expect(setYAxisFormatMock).toHaveReturnedWith(\n      '0.0M',\n      '0.0M',\n      '0.0M',\n      '0.0M'\n    );\n\n    tree.rerender(\n      <WmLineChart\n        name=\"test_LineChart\"\n        {...defaultProps}\n        ynumberformat=\"Thousand\"\n      />\n    );\n    expect(setYAxisFormatMock).toHaveReturnedWith(\n      '0.1K',\n      '0.2K',\n      '0.3K',\n      '0.4K'\n    );\n\n    tree.rerender(\n      <WmLineChart name=\"test_LineChart\" {...defaultProps} ynumberformat=\",r\" />\n    );\n    expect(setYAxisFormatMock).toHaveReturnedWith('150', '200', '250', '300');\n  });\n\n  it('should render chart component with default data when dataset is empty', () => {\n    const tree = renderComponent({\n      xaxisdatakey: 'x',\n      yaxisdatakey: 'y',\n      dataset: [],\n      type: 'Line',\n    });\n\n    expect(constructSampleData).toBeDefined();\n    const viewEle2 = tree.UNSAFE_getByType(VictoryLine);\n    expect(viewEle2.props.data[0].y).toBe(2);\n    expect(viewEle2.props.data[1].y).toBe(0);\n    expect(viewEle2.props.data[2].y).toBe(3);\n    expect(viewEle2.props.data[0].x).toBe(0);\n    expect(viewEle2.props.data[1].x).toBe(1);\n    expect(viewEle2.props.data[2].x).toBe(2);\n  });\n\n  //isrtl\n  xit('checking data', () => {\n    const isRTLmock = jest\n      .spyOn(WmLineChart.prototype, 'isRTL', 'get')\n      .mockImplementation(() => {\n        return true;\n      });\n\n    const tree = renderComponent({\n      ...defaultProps,\n    });\n    const vaxis = tree.UNSAFE_getAllByType(VictoryAxis);\n\n    const viewEle2 = tree.UNSAFE_getByType(VictoryLine);\n    expect(viewEle2.props.data[0].y).toBe(101);\n    expect(viewEle2.props.data[1].y).toBe(201);\n    expect(viewEle2.props.data[2].y).toBe(301);\n    expect(viewEle2.props.data[0].x).toBe(0);\n    expect(viewEle2.props.data[1].x).toBe(1);\n    expect(viewEle2.props.data[2].x).toBe(2);\n    const viewEle3 = tree.UNSAFE_getByType(VictoryScatter);\n    expect(viewEle3.props.data[0].y).toBe(301);\n    expect(viewEle3.props.data[1].y).toBe(201);\n    expect(viewEle3.props.data[2].y).toBe(101);\n    expect(viewEle3.props.data[0].x).toBe(2);\n    expect(viewEle3.props.data[1].x).toBe(1);\n    expect(viewEle3.props.data[2].x).toBe(0);\n\n    isRTLmock.mockReset();\n    jest.clearAllMocks();\n  });\n});\n", "wavemaker-rn-runtime/test/components/chart/area-chart.component.spec.tsx": "import React, { ReactNode, createRef } from 'react';\nimport {\n  fireEvent,\n  render,\n  waitFor,\n  screen,\n  act,\n  cleanup,\n} from '@testing-library/react-native';\nimport WmAreaChart from '@wavemaker/app-rn-runtime/components/chart/area-chart/area-chart.component';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport {\n  VictoryAxis,\n  VictoryArea,\n  VictoryChart,\n  VictoryLegend,\n  VictoryScatter,\n} from 'victory-native';\n\nconst renderComponent = (props = {}) => {\n  return render(<WmAreaChart {...props} name=\"test_AreaChart\" />);\n};\nconst dataSet = [\n  {\n    x: 5,\n    y: 10,\n  },\n  {\n    x: 15,\n    y: 20,\n  },\n  {\n    x: 25,\n    y: 30,\n  },\n];\nconst defaultProps = { dataset: dataSet, xaxisdatakey: 'x', yaxisdatakey: 'y' };\n\ndescribe('Test AreaChart component', () => {\n  afterEach(() => {\n    jest.clearAllMocks();\n    cleanup();\n  });\n\n  //should render when default props are given and also shouldnot render when default props are not given\n  it('Should render component', () => {\n    const tree = renderComponent(defaultProps);\n    expect(Array.isArray(tree.toJSON())).toBe(true);\n    expect(tree.toJSON()[1]).not.toBeNull();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('should render with null when props are not given', () => {\n    const tree = renderComponent();\n    expect(Array.isArray(tree.toJSON())).toBe(false);\n    expect(tree.toJSON().children).toBeNull();\n  });\n\n  //title, titlesIcon subheading\n  it('should render title', () => {\n    const { getByText } = renderComponent({\n      title: 'Area Chart',\n      ...defaultProps,\n      styles: {\n        title: {\n          color: 'red',\n          fontSize: 30,\n          lineHeight: 10,\n          paddingLeft: 20,\n        },\n        text: {\n          color: 'yellow',\n        },\n      },\n    });\n    expect(getByText('Area Chart')).toBeTruthy();\n    expect(getByText('Area Chart').props.style.color).toBe('red');\n    expect(getByText('Area Chart').props.style.fontSize).toBe(30);\n    expect(getByText('Area Chart').props.style.lineHeight).toBe(10);\n    expect(getByText('Area Chart').props.style.paddingLeft).toBe(20);\n  });\n\n  it('should render Icon when iconclass is provided', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      iconclass: 'fa fa-edit',\n      styles: {\n        icon: {\n          icon: {\n            fontSize: 40,\n          },\n        },\n        text: {\n          color: 'red',\n        },\n      },\n    });\n    expect(tree.getByText('edit')).toBeTruthy();\n    expect(tree.getByText('edit').props.style[1].fontSize).toBe(40);\n  });\n\n  it('should not render  Icon when iconclass is not provided', () => {\n    const tree = renderComponent({ ...defaultProps });\n    const wmIcon = tree.UNSAFE_queryByType(WmIcon);\n    expect(wmIcon).toBeNull();\n  });\n\n  it('should render subheading', () => {\n    const { getByText } = renderComponent({\n      subheading: 'subHeading-Area Chart',\n      ...defaultProps,\n      styles: {\n        subHeading: {\n          fontSize: 20,\n          lineHeight: 30,\n          color: 'red',\n        },\n        text: {\n          color: 'pink',\n        },\n      },\n    });\n    const text = getByText('subHeading-Area Chart');\n    expect(text).toBeTruthy();\n    expect(text.props.style.fontSize).toBe(20);\n    expect(text.props.style.lineHeight).toBe(30);\n    expect(text.props.style.color).toBe('red');\n  });\n\n  // events - onBeforerender and onTransform\n  it('should call onBeforerender and onTransform events', () => {\n    const onBeforeRenderMock = jest.fn();\n    const onTransformMock = jest.fn();\n    const invokeEventCallbackMock = jest.spyOn(\n      WmAreaChart.prototype,\n      'invokeEventCallback'\n    );\n    renderComponent({\n      ...defaultProps,\n      onBeforerender: onBeforeRenderMock,\n      onTransform: onTransformMock,\n    });\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n      'onBeforerender',\n      expect.anything()\n    );\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n      'onTransform',\n      expect.anything()\n    );\n    expect(onBeforeRenderMock).toHaveBeenCalledTimes(1);\n    expect(onTransformMock).toHaveBeenCalledTimes(1);\n  });\n\n  // on select\n  it('should call onSelect event', async () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmAreaChart.prototype,\n      'invokeEventCallback'\n    );\n\n    const customRef = createRef<WmAreaChart>();\n    renderComponent({\n      ...defaultProps,\n      offsetX: 10,\n      locationX: 14,\n      offsetY: 20,\n      locationY: 25,\n      ref: customRef,\n      tooltipXaxis: 1,\n      tooltipYaxis: 1,\n      isTooltipOpen: false,\n    });\n    const onSelect = {\n      nativeEvent: {\n        offsetX: 10,\n        locationX: 14,\n        offsetY: 20,\n        locationY: 25,\n      },\n    };\n    const dataSet1 = {\n      data: [{ x: 10, y: 20, z: 30 }],\n      datum: {\n        x: 10,\n        y: 20,\n        z: 30,\n      },\n      index: 0,\n    };\n    act(() => {\n      customRef.current.onSelect(onSelect, dataSet1);\n    });\n\n    await waitFor(() => {\n      expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n        'onSelect',\n        expect.anything()\n      );\n    });\n  });\n\n  // Accessiility\n  it('should apply accessibility props correctly', async () => {\n    const { getByRole, getByLabelText, getByA11yHint } = renderComponent({\n      ...defaultProps,\n      accessibilitylabel: 'Button',\n      accessibilityrole: 'Button',\n      hint: 'test button',\n      styles: {\n        root: {\n          backgroundColor: 'red',\n          width: 200,\n          height: 300,\n        },\n        text: {\n          color: 'red',\n        },\n      },\n    });\n    expect(getByLabelText('Button')).toBeTruthy();\n    expect(getByRole('Button')).toBeTruthy();\n    expect(getByA11yHint('test button')).toBeTruthy();\n    expect(getByRole('Button').props.style.backgroundColor).toBe('red');\n    expect(getByRole('Button').props.style.width).toBe(200);\n    expect(getByRole('Button').props.style.height).toBe(300);\n  });\n\n  //when width was updated or set\n  it('should render chart when width state is updated', () => {\n    const tree = renderComponent({ ...defaultProps });\n    fireEvent(screen.root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n        },\n      },\n    });\n    const viewEle = tree.UNSAFE_queryByType(VictoryChart);\n    expect(viewEle).toBeDefined();\n  });\n\n  it('should not render chart when width state is not updated', () => {\n    const tree = renderComponent({ ...defaultProps });\n    const victoryChart = tree.UNSAFE_queryByType(VictoryChart);\n    expect(victoryChart).toBeNull;\n  });\n\n  //show - false\n  it('should have width and height to be 0 when show is false', () => {\n    const { getByRole } = renderComponent({\n      ...defaultProps,\n      show: false,\n      accessibilityrole: 'AREACHART',\n    });\n    const viewEle = getByRole('AREACHART');\n    expect(viewEle.props.style.width).toBe(0);\n    expect(viewEle.props.style.height).toBe(0);\n  });\n\n  //victory charts\n  it('should render victorycharts with offset', async () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      ydomain: 'Min',\n      xdomain: 'Min',\n      type: 'Area',\n      offsettop: 10,\n      offsetbottom: 20,\n      offsetright: 30,\n      offsetleft: 40,\n    });\n    fireEvent(screen.root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n        },\n      },\n    });\n    \n    const viewEle = tree.UNSAFE_getByType(VictoryChart);\n\n    await waitFor(() => {\n      // expect(viewEle.props.minDomain).toBe();\n      expect(viewEle.props.padding.top).toBe(10);\n      expect(viewEle.props.padding.bottom).toBe(20);\n      expect(viewEle.props.padding.right).toBe(30);\n      expect(viewEle.props.padding.left).toBe(40);\n    });\n  });\n\n  it('mindomain is undefined', async () => {\n    const tree = renderComponent({\n      ...defaultProps,\n    });\n    fireEvent(screen.root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n        },\n      },\n    });\n    const viewEle = tree.UNSAFE_getByType(VictoryChart);\n\n    await waitFor(() => {\n      expect(viewEle.props.minDomain.x).toBe(undefined);\n      expect(viewEle.props.minDomain.y).toBe(undefined);\n    });\n  });\n\n  //victoryArea\n  it('should render victoryArea with linethickness, colorscale, interpolation, styles-strokewidth ', async () => {\n    const colorScale = ['red', 'yellow', 'green'];\n    const linethickValue = 5;\n    const tree = renderComponent({\n      ...defaultProps,\n      linethickness: linethickValue,\n      customcolors: colorScale,\n    });\n\n    fireEvent(screen.root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n        },\n      },\n    });\n    await waitFor(() => {\n      const viewEle = tree.UNSAFE_getByType(VictoryArea);\n      expect(viewEle.props.interpolation).toBe('linear');\n      expect(viewEle.props.style.data.strokeWidth).toBe(linethickValue);\n      expect(viewEle.props.style.data.stroke).toBe(colorScale[0]);\n      expect(viewEle.props.data[0].y).toBe(10);\n    });\n\n    tree.rerender(\n      <WmAreaChart\n        {...defaultProps}\n        name=\"test_AreaChart\"\n        interpolation=\"cardinal\"\n      />\n    );\n    await waitFor(() => {\n      const victoryAreaEle = tree.UNSAFE_getByType(VictoryArea);\n      expect(victoryAreaEle.props.interpolation).toBe('cardinal');\n    });\n\n    tree.rerender(\n      <WmAreaChart\n        {...defaultProps}\n        name=\"test_AreaChart\"\n        interpolation=\"step\"\n      />\n    );\n    await waitFor(() => {\n      const victoryAreaEle = tree.UNSAFE_getByType(VictoryArea);\n      expect(victoryAreaEle.props.interpolation).toBe('step');\n    });\n  });\n\n  //victoryScatter\n  it('should render VictoryScatter with colorScale and highlightpoints', async () => {\n    const colorScale = ['red', 'yellow', 'green'];\n    const tree = renderComponent({\n      ...defaultProps,\n      customcolors: colorScale,\n      highlightpoints: true,\n    });\n    fireEvent(screen.root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n        },\n      },\n    });\n    await waitFor(() => {\n      const viewEle = tree.UNSAFE_getByType(VictoryScatter);\n      expect(viewEle.props.style.data.opacity).toBe(0.8);\n      expect(viewEle.props.style.data.fill).toBe(colorScale[0]);\n    });\n    tree.rerender(\n      <WmAreaChart\n        {...defaultProps}\n        name=\"test_AreaChart\"\n        highlightpoints={false}\n      />\n    );\n    await waitFor(() => {\n      const viewEle = tree.UNSAFE_getByType(VictoryScatter);\n      expect(viewEle.props.style.data.fill).toBe(colorScale[0]);\n      expect(viewEle.props.style.data.opacity).toBe(0);\n    });\n  });\n\n  it('Advanced Settings-VictoryAxis', async () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      xaxislabel: 'x',\n      xunits: 'cm',\n      showxdistance: 'true',\n      yaxislabel: 'y',\n      yunits: 'cm',\n      yaxislabeldistance: 2,\n      showydistance: 'true',\n    });\n    fireEvent(screen.root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n        },\n      },\n    });\n    await waitFor(() => {\n      const viewEle = tree.UNSAFE_getAllByType(VictoryAxis);\n      expect(viewEle[0].props.label).toBe('x(cm)');\n      expect(viewEle[1].props.label).toBe('y(cm)');\n    });\n  });\n\n  //tooltip\n  it('should render get tooltip ', async () => {\n    const getTooltipMock = jest.spyOn(WmAreaChart.prototype, 'getTooltip');\n    const customRef = createRef<WmAreaChart>();\n    const { getByText } = renderComponent({\n      ...defaultProps,\n      caption: 'newcaption',\n      ref: customRef,\n    });\n    expect(getTooltipMock).toHaveBeenCalledTimes(1);\n    expect(getTooltipMock).toHaveReturnedWith(null);\n\n    const event = {\n      nativeEvent: {\n        offsetX: 10,\n        locationX: 14,\n        offsetY: 20,\n        locationY: 25,\n      },\n    };\n    const dataSet1 = {\n      data: [{ x: 10, y: 20, z: 30 }],\n      datum: {\n        x: 0,\n        y: 1,\n        z: 2,\n      },\n      index: 0,\n    };\n    act(() => {\n      customRef.current.onSelect(event, dataSet1);\n    });\n    await waitFor(() => {\n      expect(customRef.current.state.isTooltipOpen).toBe(true);\n      expect(getTooltipMock).not.toBeNull();\n      expect(getByText('5')).toBeTruthy();\n      expect(getByText('20')).toBeTruthy();\n    });\n  });\n\n  //legend\n  it('showlegend set to hidden', async () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      showlegend: 'hide',\n      colorScale: ['red', 'yellow', 'green'],\n    });\n    fireEvent(screen.root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n        },\n      },\n    });\n    await waitFor(() => {\n      expect(tree.UNSAFE_queryByType(VictoryLegend)).toBeFalsy();\n    });\n  });\n\n  it('showlegend except hidden like showlegend as top,left,right', async () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      showlegend: 'top',\n      colorScale: ['red', 'yellow', 'green'],\n    });\n    fireEvent(screen.root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n        },\n      },\n    });\n    await waitFor(() => {\n      expect(tree.UNSAFE_getByType(VictoryLegend)).toBeDefined();\n    });\n  });\n\n  //theme\n  it('should render theme', async () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      theme: 'Annabelle',\n    });\n    fireEvent(screen.root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n        },\n      },\n    });\n    const viewEle1 = tree.UNSAFE_getByType(VictoryChart);\n\n    await waitFor(() => {\n      expect(viewEle1.props.theme.group.colorScale[0]).toBe('#393b79');\n      expect(viewEle1.props.theme.group.width).toBe(250);\n      expect(viewEle1.props.theme.group.height).toBe(250);\n      expect(viewEle1.props.theme.legend.colorScale[0]).toBe('#393b79');\n      expect(viewEle1.props.theme.legend.orientation).toBe('vertical');\n      expect(viewEle1.props.theme.legend.gutter).toBe(10);\n    });\n  });\n\n  //showxaxis , showyaxis\n  xit('showxaxis', async () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      showxaxis: false,\n    });\n    fireEvent(screen.root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n        },\n      },\n    });\n    await waitFor(() => {\n      expect(tree.UNSAFE_getAllByType(VictoryAxis).length).toBe(1);\n    });\n  });\n\n  it('showyaxis', async () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      showyaxis: false,\n    });\n    fireEvent(screen.root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n        },\n      },\n    });\n    await waitFor(() => {\n      expect(tree.UNSAFE_getAllByType(VictoryAxis).length).toBe(1);\n    });\n  });\n});\n", "wavemaker-rn-runtime/test/components/chart/stack-chart.component.spec.tsx": "import React, { ReactNode, createRef } from 'react';\nimport {\n  fireEvent,\n  render,\n  waitFor,\n  screen,\n  act,\n  cleanup,\n} from '@testing-library/react-native';\nimport { Svg } from 'react-native-svg';\nimport WmStackChart from '@wavemaker/app-rn-runtime/components/chart/stack-chart/stack-chart.component';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport {\n  VictoryAxis,\n  VictoryChart,\n  VictoryLegend,\n  VictoryStack,\n  VictoryPie,\n} from 'victory-native';\nimport { Colors } from 'react-native/Libraries/NewAppScreen';\n\nconst renderComponent = (props = {}) => {\n  return render(<WmStackChart {...props} name=\"test_StackChart\" />);\n};\nconst dataSet = [\n  {\n    x: 5,\n    y: 10,\n  },\n  {\n    x: 15,\n    y: 20,\n  },\n  {\n    x: 25,\n    y: 30,\n  },\n];\nconst defaultProps = { dataset: dataSet, xaxisdatakey: 'x', yaxisdatakey: 'y', hint: 'stack chart' };\n\ndescribe('Test stackChart component', () => {\n  afterEach(() => {\n    jest.clearAllMocks();\n    cleanup();\n  });\n\n  it('Should render component', () => {\n    const tree = renderComponent(defaultProps);\n    expect(tree.toJSON()).not.toBeNull();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('should render with null when props are not given', () => {\n    const tree = renderComponent();\n    expect(Array.isArray(tree.toJSON())).toBe(false);\n    expect(tree.toJSON().children).toBeNull();\n  });\n\n  //events - onBeforerender onTransform\n  it('should call onBeforerender and onTransform events', () => {\n    const onBeforeRenderMock = jest.fn();\n    const onTransformMock = jest.fn();\n    const invokeEventCallbackMock = jest.spyOn(\n      WmStackChart.prototype,\n      'invokeEventCallback'\n    );\n    renderComponent({\n      ...defaultProps,\n      onBeforerender: onBeforeRenderMock,\n      onTransform: onTransformMock,\n    });\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n      'onBeforerender',\n      expect.anything()\n    );\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n      'onTransform',\n      expect.anything()\n    );\n    expect(onBeforeRenderMock).toHaveBeenCalledTimes(1);\n    expect(onTransformMock).toHaveBeenCalledTimes(1);\n  });\n\n  // on select\n  it('should call onSelect event', async () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmStackChart.prototype,\n      'invokeEventCallback'\n    );\n\n    const customRef = createRef<WmStackChart>();\n    renderComponent({\n      ...defaultProps,\n      offsetX: 10,\n      locationX: 14,\n      offsetY: 20,\n      locationY: 25,\n      ref: customRef,\n      tooltipXaxis: 1,\n      tooltipYaxis: 1,\n      isTooltipOpen: false,\n    });\n    const onSelect = {\n      nativeEvent: {\n        offsetX: 10,\n        locationX: 14,\n        offsetY: 20,\n        locationY: 25,\n      },\n    };\n    const dataSet1 = {\n      data: [{ x: 10, y: 20, z: 30 }],\n      datum: {\n        x: 10,\n        y: 20,\n        z: 30,\n        index: 0,\n      },\n      index: 0,\n    };\n    act(() => {\n      customRef.current.onSelect(onSelect, dataSet1);\n    });\n\n    await waitFor(() => {\n      expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n        'onSelect',\n        expect.anything()\n      );\n    });\n  });\n\n  //acessibility\n  it('should apply accessibility props correctly', async () => {\n    const { getByRole, getByLabelText, getByA11yHint } = renderComponent({\n      ...defaultProps,\n      accessibilitylabel: 'Button',\n      accessibilityrole: 'Button',\n      hint: 'test button',\n    });\n    expect(getByLabelText('Button')).toBeTruthy();\n    expect(getByRole('Button')).toBeTruthy();\n    expect(getByA11yHint('test button')).toBeTruthy();\n  });\n\n  //tooltip\n  it('should render get tooltip ', async () => {\n    const getTooltipMock = jest.spyOn(WmStackChart.prototype, 'getTooltip');\n    const customRef = createRef<WmStackChart>();\n    const { getByText } = renderComponent({\n      ...defaultProps,\n      caption: 'newcaption',\n      ref: customRef,\n    });\n    expect(getTooltipMock).toHaveBeenCalledTimes(1);\n    expect(getTooltipMock).toHaveReturnedWith(null);\n\n    const event = {\n      nativeEvent: {\n        offsetX: 10,\n        locationX: 14,\n        offsetY: 20,\n        locationY: 25,\n      },\n    };\n    const dataSet1 = {\n      data: [{ x: 10, y: 20, z: 30 }],\n      datum: {\n        x: 0,\n        y: 1,\n        z: 2,\n        index: 0,\n      },\n      index: 0,\n    };\n    act(() => {\n      customRef.current.onSelect(event, dataSet1);\n    });\n    await waitFor(() => {\n      expect(customRef.current.state.isTooltipOpen).toBe(true);\n      expect(getTooltipMock).not.toBeNull();\n      expect(getByText('5')).toBeTruthy();\n      expect(getByText('10')).toBeTruthy();\n    });\n  });\n\n  //victory charts starts here\n\n  //victory chart\n  it('should render victoryChart with offsetValues, when width was set', async () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      offsettop: 10,\n      offsetbottom: 10,\n      offsetleft: 10,\n      offsetright: 10,\n    });\n\n    const root = screen.getByAccessibilityHint(defaultProps.hint);\n\n    fireEvent(root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 250,\n        },\n      },\n    });\n    await waitFor(() => {\n      const viewEle = tree.UNSAFE_getByType(VictoryChart);\n      expect(viewEle.props.padding.top).toBe(10);\n      expect(viewEle.props.padding.bottom).toBe(10);\n      expect(viewEle.props.padding.left).toBe(10);\n      expect(viewEle.props.padding.right).toBe(10);\n      expect(viewEle.props.width).toBe(250);\n    });\n  });\n\n  it('should render victoryChart with respect to default width as 200', async () => {\n    const tree = renderComponent({\n      ...defaultProps,\n    });\n    await waitFor(() => {\n      const viewEle = tree.UNSAFE_getByType(VictoryChart);\n      expect(viewEle.props.width).toBe(200);\n    });\n  });\n\n  it('should render victoryChart with width and height with respect to rootStyles', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      styles: {\n        root: {\n          width: 300,\n        },\n        text: {\n          color: 'blue',\n        },\n      },\n    });\n    const viewEle = tree.UNSAFE_getByType(VictoryChart);\n    expect(viewEle.props.width).toBe(300);\n  });\n\n  //victoryLegend\n  it('should render chart with title, subheading', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      title: 'stackChart-Title',\n      subheading: 'stackChart-SubHeading',\n    });\n    const viewEle = tree.UNSAFE_getAllByType(VictoryLegend);\n    expect(viewEle[0].props.title[0]).toBe('stackChart-Title');\n    expect(viewEle[0].props.title[1]).toBe('stackChart-SubHeading');\n  });\n\n  it('getlegend should return null when showlegend is hide', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      showlegend: 'hide',\n    });\n\n    const viewEle = tree.UNSAFE_getAllByType(VictoryLegend);\n    expect(viewEle.length).toBe(1);\n  });\n\n  it('getlegend should return victorylegend when showlegend is bottom', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      customcolors: ['red', 'blue'],\n      showlegend: 'bottom',\n      styles: {\n        root: {\n          height: 200,\n        },\n        text: {\n          color: 'blue',\n        },\n      },\n    });\n    const viewEle = tree.UNSAFE_getAllByType(VictoryLegend);\n    expect(viewEle.length).toBe(2);\n    expect(viewEle[1].props.colorScale[0]).toBe('red');\n    expect(viewEle[1].props.colorScale[1]).toBe('blue');\n  });\n\n  it('getlegend should return victorylegend and the orientation prop was vertical, when showlegend is right or left', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      customcolors: ['red', 'blue'],\n      showlegend: 'right',\n      styles: {\n        root: {\n          height: 200,\n        },\n        text: {\n          color: 'blue',\n        },\n      },\n    });\n    const viewEle = tree.UNSAFE_getAllByType(VictoryLegend);\n    expect(viewEle.length).toBe(2);\n    expect(viewEle[1].props.colorScale[0]).toBe('red');\n    expect(viewEle[1].props.colorScale[1]).toBe('blue');\n    expect(viewEle[1].props.orientation).toBe('vertical');\n  });\n\n  //victoryAxis\n  it('should render VictoryAxis with tickvalues & tickformat', () => {\n    const thickness = 20,\n      padding = thickness / 2 + 5;\n    //rendering\n    const tree = renderComponent({\n      thickness: thickness,\n      ...defaultProps,\n    });\n    const viewEle = tree.UNSAFE_getByType(VictoryAxis);\n    const length = viewEle.props.tickValues.length;\n    expect(viewEle.props.tickValues[0]).toBeLessThanOrEqual(dataSet[0].x);\n    expect(viewEle.props.tickValues[length - 1]).toBeGreaterThanOrEqual(\n      dataSet[dataSet.length - 1].x\n    );\n    expect(viewEle.props.style.tickLabels.fill).toBe('#000000');\n    expect(viewEle.props.style.tickLabels.padding).toBe(padding); //default padding\n    expect(viewEle.props.style.axisLabel.padding).toBe(padding + thickness / 2);\n  });\n\n  it('if minvalue was 0 it should render victoryAxis with tickvalues', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      dataset: [\n        {\n          x: -5,\n          y: -10,\n        },\n        {\n          x: 15,\n          y: 20,\n        },\n        {\n          x: 25,\n          y: 30,\n        },\n      ],\n    });\n    const viewEle = tree.UNSAFE_getByType(VictoryAxis);\n    expect(viewEle.props.tickValues[0]).toBe(-dataSet[0].y);\n  });\n\n  it('tickLabels should be transparent when showyaxis is false', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      showyaxis: false,\n    });\n    const viewEle = tree.UNSAFE_getByType(VictoryAxis);\n    expect(viewEle.props.style.tickLabels.fill).toBe('transparent');\n  });\n\n  //victorystack\n  it('should render Victorystack with colorscale', () => {\n    const thickness = 20;\n    const tree = renderComponent({\n      ...defaultProps,\n      customcolors: ['red', 'blue', 'green'],\n      thickness: thickness,\n    });\n    const viewEle = tree.UNSAFE_getByType(VictoryStack);\n    expect(viewEle.props.colorScale[0]).toBe('red');\n    expect(viewEle.props.colorScale[1]).toBe('blue');\n    expect(viewEle.props.colorScale[2]).toBe('green');\n  });\n\n  it('shopuld render victorystack and getlegendview with 1 color ', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      customcolors: ['red'],\n    });\n    const viewEle = tree.UNSAFE_getByType(VictoryStack);\n    expect(viewEle.props.colorScale).toBe('red');\n    const legendEle = tree.UNSAFE_getAllByType(VictoryLegend);\n    expect(legendEle[1].props.colorScale).toBe('red');\n  });\n\n  //getBarChart\n  it('getBarChart function should return  victoryBar Component', () => {\n    const viewEle = jest.spyOn(WmStackChart.prototype, 'getBarChart');\n    const tree = renderComponent({\n      ...defaultProps,\n      dataset: dataSet[0],\n      name: 'wm-stack-chart',\n    });\n    expect(viewEle).toHaveBeenCalled();\n  });\n  // expect(viewEle).toHaveReturnedWith([\n  //   <VictoryBar\n  //     key={`wm-stack-chart` + '_' + 0}\n  //     cornerRadius={{ top: -5, bottom: -5 }}\n  //     data={[\n  //       {\n  //         x: 0,\n  //         y: 10,\n  //       },\n  //     ]}\n  //     width={750}\n  //   />,\n  // ]);\n\n  it('svg, victorylegend, getarcchart, getarcaxis should not render when viewtype === bar', async () => {\n    const getArcChartMock = jest.spyOn(WmStackChart.prototype, 'getArcChart');\n    const getArcAxisMock = jest.spyOn(WmStackChart.prototype, 'getArcChart');\n    const tree = renderComponent({\n      ...defaultProps,\n    });\n    const viewEle = tree.UNSAFE_getAllByType(VictoryLegend);\n    const svg = tree.UNSAFE_getAllByType(Svg);\n    expect(svg.length).toBe(2);\n    expect(viewEle.length).toBe(2);\n    expect(getArcChartMock).not.toHaveBeenCalled();\n    expect(getArcAxisMock).not.toHaveBeenCalled();\n  });\n\n  //theme\n  it('should render victory chart with theme', () => {\n    const Victory = (viewEle) => {\n      expect(viewEle[0].props.theme.group.colorScale[0]).toBe('#393b79');\n      expect(viewEle[0].props.theme.group.width).toBe(250);\n      expect(viewEle[0].props.theme.group.height).toBe(250);\n      expect(viewEle[0].props.theme.legend.colorScale[0]).toBe('#393b79');\n      expect(viewEle[0].props.theme.legend.orientation).toBe('vertical');\n      expect(viewEle[0].props.theme.legend.gutter).toBe(10);\n    };\n    const tree = renderComponent({\n      ...defaultProps,\n      theme: 'Annabelle',\n    });\n    const viewEle1 = tree.UNSAFE_getAllByType(VictoryChart);\n    Victory(viewEle1);\n\n    const viewEle2 = tree.UNSAFE_getAllByType(VictoryLegend);\n    Victory(viewEle2);\n\n    const viewEle3 = tree.UNSAFE_getAllByType(VictoryAxis);\n    Victory(viewEle3);\n  });\n\n  // const chartHeight = 300;\n  const chartWidth = 500;\n  const fireEventFunction = (chartWidth) => {\n    return fireEvent(screen.root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: chartWidth,\n        },\n      },\n    });\n  };\n\n  //default prop viewtype wass changed'\n  it('should render svg when default prop viewtype was changed', async () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      viewtype: 'Stack',\n    });\n    const viewEle = tree.UNSAFE_getAllByType(Svg);\n    const root = screen.getByAccessibilityHint(defaultProps.hint);\n    fireEvent(root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n        },\n      },\n    });\n    await waitFor(() => {\n      expect(viewEle[0].props.width).toBe(500);\n      expect(viewEle[0].props.height).toBe(250);\n    });\n  });\n\n  it('should render victoryLegend when default prop viewtype is not bar', async () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      viewtype: 'Stack',\n      title: 'stackChart-Title',\n      subheading: 'stackChart-SubHeading',\n    });\n    const SvgEle = tree.UNSAFE_getAllByType(Svg);\n    fireEventFunction(chartWidth);\n    const VictoryLegendEle = tree.UNSAFE_getAllByType(VictoryLegend);\n    await waitFor(() => {\n      expect(SvgEle[0].props.width).toBe(500);\n      // expect(SvgEle[0].props.height).toBe(chartHeight - 50);\n      expect(VictoryLegendEle[0].props.title[0]).toBe('stackChart-Title');\n      expect(VictoryLegendEle[0].props.title[1]).toBe('stackChart-SubHeading');\n    });\n  });\n\n  it('should call getArcChart when default prop viewtype was changed', async () => {\n    const chartHeight = 0,\n      thickness = 10;\n    const tree = renderComponent({\n      ...defaultProps,\n      viewtype: 'Stack',\n      customcolors: ['red', 'blue', 'green'],\n      thickness: thickness,\n    });\n    fireEventFunction(chartWidth);\n    const radius = Math.min(chartWidth / 2, chartHeight - 50);\n    const viewEle = tree.UNSAFE_getAllByType(VictoryPie);\n    expect(viewEle.length).toBe(4);\n    expect(viewEle[0].props.radius).toBe(radius);\n    expect(viewEle[1].props.radius).toBe(radius);\n    expect(viewEle[2].props.radius).toBe(radius);\n    expect(viewEle[0].props.colorScale[0]).toBe('green');\n    expect(viewEle[0].props.innerRadius).toBe(radius - thickness);\n  });\n\n  it('should call getArcAxis when default prop viewtype was changed', async () => {\n    const chartHeight = 0,\n      thickness = 10;\n    const tree = renderComponent({\n      ...defaultProps,\n      viewtype: 'Stack',\n      thickness: thickness,\n    });\n    fireEventFunction(chartWidth);\n    const radius = Math.min(chartWidth / 2, chartHeight - 50);\n    const viewEle = tree.UNSAFE_getAllByType(VictoryPie);\n    expect(viewEle[3].props.labelRadius).toBe(radius - thickness - 20);\n  });\n});\n", "wavemaker-rn-runtime/test/components/chart/pie-chart.component.spec.tsx": "import React, { ReactNode, createRef } from 'react';\nimport WmPieChart from '@wavemaker/app-rn-runtime/components/chart/pie-chart/pie-chart.component';\nimport { Svg } from 'react-native-svg';\nimport { Legend } from '@wavemaker/app-rn-runtime/components/chart/legend/legend.component';\nimport {\n  fireEvent,\n  render,\n  waitFor,\n  screen,\n  act,\n  cleanup,\n} from '@testing-library/react-native';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport { VictoryPie, VictoryLabel } from 'victory-native';\n\nconst onViewLayout = (element, Width, Height) => {\n  return fireEvent(element, 'layout', {\n    nativeEvent: {\n      layout: {\n        width: Width,\n        height: Height,\n      },\n    },\n  });\n};\n\nconst onInfoViewLayoutChange = (element, Height) => {\n  return fireEvent(element, 'layout', {\n    nativeEvent: {\n      layout: {\n        height: Height,\n      },\n    },\n  });\n};\n\nconst renderComponent = (props = {}) => {\n  return render(<WmPieChart {...props} name=\"test_PieChart\" />);\n};\nconst dataSet = [\n  { x: 'Cats', y: 35 },\n  { x: 'Dogs', y: 40 },\n  { x: 'Birds', y: 55 },\n];\nconst defaultProps = { dataset: dataSet, xaxisdatakey: 'x', yaxisdatakey: 'y', hint: 'pie chart' };\n\nconst timer = (time = 100) =>\n  new Promise((resolve: any, reject) => {\n    setTimeout(() => resolve(), time);\n  });\n\ndescribe('Test PieChart component', () => {\n  afterEach(() => {\n    jest.clearAllMocks();\n    cleanup();\n  });\n\n  //should render when default props are given and also shouldnot render when default props are not given\n  it('Should render component', () => {\n    const tree = renderComponent(defaultProps);\n    expect(Array.isArray(tree.toJSON())).toBe(true);\n    expect(tree.toJSON()).not.toBeNull();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('should render with null when props are not given', () => {\n    const tree = renderComponent();\n    expect(Array.isArray(tree.toJSON())).toBe(false);\n    expect(tree.toJSON().children).toBeNull();\n  });\n\n  //title, titlesIcon subheading\n  it('should render title', () => {\n    const { getByText } = renderComponent({\n      title: 'Pie-Chart',\n      ...defaultProps,\n      styles: {\n        title: {\n          color: 'red',\n          fontSize: 30,\n          lineHeight: 10,\n          paddingLeft: 20,\n        },\n        text: {\n          color: 'yellow',\n        },\n      },\n    });\n    expect(getByText('Pie-Chart')).toBeTruthy();\n    expect(getByText('Pie-Chart').props.style.color).toBe('red');\n    expect(getByText('Pie-Chart').props.style.fontSize).toBe(30);\n    expect(getByText('Pie-Chart').props.style.lineHeight).toBe(10);\n    expect(getByText('Pie-Chart').props.style.paddingLeft).toBe(20);\n  });\n\n  it('should render subheading', () => {\n    const { getByText } = renderComponent({\n      subheading: 'subHeading-Pie Chart',\n      ...defaultProps,\n      styles: {\n        subHeading: {\n          fontSize: 20,\n          lineHeight: 30,\n          color: 'red',\n        },\n        text: {\n          color: 'pink',\n        },\n      },\n    });\n    const text = getByText('subHeading-Pie Chart');\n    expect(text).toBeTruthy();\n    expect(text.props.style.fontSize).toBe(20);\n    expect(text.props.style.lineHeight).toBe(30);\n    expect(text.props.style.color).toBe('red');\n  });\n\n  it('should render Icon when iconclass is provided', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      iconclass: 'fa fa-edit',\n      styles: {\n        icon: {\n          icon: {\n            fontSize: 40,\n          },\n        },\n        text: {\n          color: 'red',\n        },\n      },\n    });\n    expect(tree.getByText('edit')).toBeTruthy();\n    expect(tree.getByText('edit').props.style[1].fontSize).toBe(40);\n  });\n\n  it('should not render Icon when iconclass is not provided', () => {\n    const tree = renderComponent({ ...defaultProps });\n    const wmIcon = tree.UNSAFE_queryByType(WmIcon);\n    expect(wmIcon).toBeNull();\n  });\n\n  // events - onBeforerender and onTransform\n  it('should call onBeforerender and onTransform events', () => {\n    const onBeforeRenderMock = jest.fn();\n    const onTransformMock = jest.fn();\n    const invokeEventCallbackMock = jest.spyOn(\n      WmPieChart.prototype,\n      'invokeEventCallback'\n    );\n    renderComponent({\n      ...defaultProps,\n      onBeforerender: onBeforeRenderMock,\n      onTransform: onTransformMock,\n    });\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n      'onBeforerender',\n      expect.anything()\n    );\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n      'onTransform',\n      expect.anything()\n    );\n    expect(onBeforeRenderMock).toHaveBeenCalledTimes(1);\n    expect(onTransformMock).toHaveBeenCalledTimes(1);\n  });\n\n  //onSelect\n  it('should call onSelect event', async () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmPieChart.prototype,\n      'invokeEventCallback'\n    );\n    const customRef = createRef<WmPieChart>();\n    renderComponent({\n      ...defaultProps,\n      offsetX: 10,\n      locationX: 14,\n      offsetY: 20,\n      locationY: 25,\n      ref: customRef,\n      tooltipXaxis: 1,\n      tooltipYaxis: 1,\n      isTooltipOpen: false,\n    });\n    const onSelect = {\n      nativeEvent: {\n        offsetX: 10,\n        locationX: 14,\n        offsetY: 20,\n        locationY: 25,\n      },\n    };\n    const dataSet1 = {\n      data: [{ x: 10, y: 20, z: 30 }],\n      datum: {\n        x: 10,\n        y: 20,\n        z: 30,\n      },\n      index: 0,\n      slice: {\n        value: 1,\n      },\n      style: {\n        fill: {\n          color: 'red',\n        },\n      },\n    };\n    act(() => {\n      customRef.current.onSelect(onSelect, dataSet1);\n    });\n\n    await waitFor(() => {\n      expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n        'onSelect',\n        expect.anything()\n      );\n    });\n  });\n\n  //Accessibility\n  it('should apply accessibility props correctly', async () => {\n    const { getByRole, getByLabelText, getByA11yHint } = renderComponent({\n      ...defaultProps,\n      accessibilitylabel: 'Pie',\n      accessibilityrole: 'Pie',\n      hint: 'test button',\n      styles: {\n        root: {\n          backgroundColor: 'red',\n          width: 200,\n          height: 300,\n        },\n        text: {\n          color: 'red',\n        },\n      },\n    });\n    expect(getByLabelText('Pie')).toBeTruthy();\n    expect(getByRole('Pie')).toBeTruthy();\n    expect(getByA11yHint('test button')).toBeTruthy();\n    expect(getByRole('Pie').props.style[1].backgroundColor).toBe('red');\n    expect(getByRole('Pie').props.style[1].width).toBe(200);\n    expect(getByRole('Pie').props.style[1].height).toBe(300);\n  });\n\n  //setting the width\n  it('if width was set then (svg, VictoryPie, victoryLegend) ', async () => {\n    const showlegend: string = 'left',\n      rootHeight = 0;\n    const tree = renderComponent({\n      ...defaultProps,\n    });\n\n    //updating the width\n    const viewWidth = 500;\n    const totalHeight = 300;\n    const root = screen.getByAccessibilityHint(defaultProps.hint);\n    onViewLayout(root, viewWidth, totalHeight);\n    const subChild = screen.getByAccessibilityHint(defaultProps.hint).children[0];\n    const infoHeight = 300;\n    const legendHeight = 0;\n    onInfoViewLayoutChange(subChild, infoHeight);\n    const chartHeight =\n      (rootHeight ? totalHeight : viewWidth) -\n      infoHeight -\n      (showlegend === 'right' ? 0 : legendHeight);\n\n    //expectations\n    await waitFor(() => {\n      const viewEle = tree.UNSAFE_getByType(Svg);\n      expect(viewEle).toBeDefined();\n      expect(viewEle.props.width).toBe(viewWidth);\n      expect(viewEle.props.height).toBe(chartHeight);\n      expect(tree.UNSAFE_queryByType(Legend)).toBeDefined();\n      expect(tree.UNSAFE_getByType(VictoryPie)).toBeDefined();\n    });\n  });\n\n  it('if width was not set then svg should not render', async () => {\n    const tree = renderComponent({\n      ...defaultProps,\n    });\n    await waitFor(() => {\n      expect(tree.UNSAFE_queryByType(Svg)).toBeNull();\n    });\n  });\n\n  //victory charts starts here\n\n  //victory pie and victoryLabel\n  it('Victory Pie and victoryLabel should render with user defined props', async () => {\n    const rootHeight = 0,\n      infoHeight = 10,\n      showlegend: string = 'top',\n      legendWidth = 0,\n      legendHeight = 0;\n\n    //spying on the function\n    const getLabelMock = jest.spyOn(WmPieChart.prototype, 'getLabel');\n\n    //rendering pieChart\n    const tree = renderComponent({\n      ...defaultProps,\n      showlegend: showlegend,\n      customcolors: ['tomato', 'orange', 'gold'],\n      showlabels: 'hide',\n      styles: {\n        centerLabel: {\n          color: 'brown',\n          fontSize: 30,\n        },\n        text: {\n          color: 'yellow',\n        },\n      },\n      centerlabel: 'centerlabel',\n    });\n\n    //updating the width and height\n    const viewWidth = 500;\n    const totalHeight = 510;\n    const root = screen.getByAccessibilityHint(defaultProps.hint)\n    onViewLayout(root, viewWidth, totalHeight);\n    const chartWidth = viewWidth - (showlegend === 'right' ? legendWidth : 0);\n    const chartHeight =\n      (rootHeight ? totalHeight : chartWidth) -\n      infoHeight -\n      (showlegend === 'right' ? 0 : legendHeight);\n    const origin = { x: viewWidth / 2, y: chartHeight / 2 };\n    const radius = (Math.min(viewWidth, chartHeight) - 40) / 2;\n\n    //expects\n    let viewEle, viewLabel;\n    await waitFor(() => {\n      viewEle = tree.UNSAFE_getByType(VictoryPie);\n      viewLabel = tree.UNSAFE_getAllByType(VictoryLabel);\n      expect(viewEle.props.radius).toBe(radius);\n      expect(viewEle.props.colorScale[0]).toBe('tomato');\n      expect(viewEle.props.colorScale[1]).toBe('orange');\n      expect(viewEle.props.colorScale[2]).toBe('gold');\n      expect(viewEle.props.endAngle).toBe(0);\n      expect(viewEle.props.innerRadius).toBe(0);\n      expect(viewEle.props.origin.x).toBe(origin.x);\n      expect(viewEle.props.origin.y).toBe(origin.y);\n      expect(getLabelMock).toHaveBeenCalled();\n      expect(viewEle.props.style.labels.display).toBe('none');\n\n      //victoryLabel\n      expect(viewLabel[3].props.x).toBe(origin.x);\n      expect(viewLabel[3].props.y).toBe(origin.y);\n      expect(viewLabel[3].props.style.color).toBe('brown');\n      expect(viewLabel[3].props.style.fontSize).toBe(30);\n      expect(viewLabel[3].props.style.fill).toBe('brown');\n      expect(viewLabel[3].props.text).toBe('centerlabel');\n    });\n\n    tree.rerender(\n      <WmPieChart {...defaultProps} name=\"test_PieChart\" showlabels=\"inside\" />\n    );\n    await waitFor(() => {\n      const viewEle = tree.UNSAFE_getByType(VictoryPie);\n      expect(viewEle.props.labelRadius).toBe(radius / 2);\n    });\n    tree.rerender(\n      <WmPieChart {...defaultProps} name=\"test_PieChart\" showlabels=\"outside\" />\n    );\n    await waitFor(() => {\n      const viewEle = tree.UNSAFE_getByType(VictoryPie);\n      expect(viewEle.props.labelRadius).toBe(radius + 8);\n    });\n  });\n\n  // show set to false\n  it('should have width and height to be 0 when show is false', () => {\n    const { getByRole } = renderComponent({\n      ...defaultProps,\n      show: false,\n      accessibilityrole: 'PIECHART',\n    });\n    const viewEle = getByRole('PIECHART');\n    expect(viewEle.props.style[1].width).toBe(0);\n    expect(viewEle.props.style[1].height).toBe(0);\n  });\n\n  //show legend set to right\n  it('show legend set to right', async () => {\n    const showlegend = 'right',\n      rootHeight = 0;\n\n    //rendering the piechart\n    const tree = renderComponent({\n      ...defaultProps,\n      showlegend: showlegend,\n    });\n\n    const viewWidth = 500;\n    const totalHeight = 510;\n    const root = screen.getByAccessibilityHint(defaultProps.hint);\n    onViewLayout(root, viewWidth, totalHeight);\n    const subChild = screen.getByAccessibilityHint(defaultProps.hint).children[0];\n    const infoHeight = 300;\n    const legendWidth = 300,\n      legendHeight = 100;\n    onInfoViewLayoutChange(subChild, infoHeight);\n    const child = screen.getByAccessibilityHint(defaultProps.hint).children;\n    const childOfSubChild = child[1].children[0].children[1];\n    onViewLayout(childOfSubChild, legendWidth, legendHeight);\n\n    //initialising chartwidth and height with given values\n    const chartWidth = viewWidth - (showlegend === 'right' ? legendWidth : 0);\n    const chartHeight =\n      (rootHeight ? totalHeight : chartWidth) -\n      infoHeight -\n      (showlegend === 'right' ? 0 : legendHeight);\n\n    await waitFor(() => {\n      const viewEle = tree.UNSAFE_queryByType(Svg);\n      expect(viewEle.props.width).toBe(chartWidth);\n      expect(viewEle.props.height).toBe(chartHeight);\n    });\n  });\n\n  it('if same width is updated at parent and child layout than svg shouldnot  render', async () => {\n    //rendering the piechart\n    const tree = renderComponent({\n      ...defaultProps,\n      showlegend: 'right',\n    });\n\n    //update width and height\n    const viewWidth = 500;\n    const totalHeight = 510;\n    const root = screen.getByAccessibilityHint(defaultProps.hint);\n    onViewLayout(root, viewWidth, totalHeight);\n    const child = screen.getByAccessibilityHint(defaultProps.hint).children;\n    const subChild = child[1].children[0].children[1];\n    const legendwidth = 500,\n      legendheight = 22;\n    onViewLayout(subChild, legendwidth, legendheight);\n\n    await timer(300);\n    await waitFor(() => {\n      expect(tree.UNSAFE_queryByType(Svg)).toBeNull();\n    });\n  });\n\n  //show legend set to bottom\n  it('if showlegend is bottom and width was set than svg should  render', async () => {\n    //rendering piechart\n    const tree = renderComponent({\n      ...defaultProps,\n      showlegend: 'bottom',\n    });\n\n    const viewWidth = 500;\n    const totalHeight = 0;\n    const root = screen.getByAccessibilityHint(defaultProps.hint);\n    onViewLayout(root, viewWidth, totalHeight);\n\n    await waitFor(() => {\n      expect(tree.UNSAFE_getByType(Svg)).toBeDefined();\n    });\n\n    const legendWidth = 500,\n      legendHeight = 22;\n    const child = screen.getByAccessibilityHint(defaultProps.hint).children[2];\n    onViewLayout(child, legendWidth, legendHeight);\n\n    await waitFor(() => {\n      expect(tree.UNSAFE_getByType(Svg)).toBeDefined();\n    });\n  });\n\n  //tooltip\n  it('should render get tooltip ', async () => {\n    const getTooltipMock = jest.spyOn(WmPieChart.prototype, 'getTooltip');\n    const customRef = createRef<WmPieChart>();\n    const { getByText, getAllByText } = renderComponent({\n      ...defaultProps,\n      caption: 'newcaption',\n      ref: customRef,\n    });\n\n    const event = {\n      nativeEvent: {\n        offsetX: 10,\n        locationX: 14,\n        offsetY: 20,\n        locationY: 25,\n      },\n    };\n    const dataSet1 = {\n      data: [{ x: 10, y: 20, z: 30 }],\n      datum: {\n        x: 0,\n        y: 1,\n        z: 2,\n      },\n      index: 0,\n      slice: {\n        value: 1,\n      },\n      style: {\n        fill: {\n          color: 'red',\n        },\n      },\n    };\n    act(() => {\n      customRef.current.onSelect(event, dataSet1);\n    });\n    await waitFor(() => {\n      expect(customRef.current.state.isTooltipOpen).toBe(true);\n      expect(getTooltipMock).not.toBeNull();\n      expect(getAllByText('Cats')).toBeTruthy();\n      expect(getByText('1')).toBeTruthy();\n    });\n  });\n\n  //get label\n  it('when label type is percent then getlabel should return value with percentage to the labels in the victorypieComponent', async () => {\n    const WmPieChartMock = jest.spyOn(WmPieChart.prototype, 'getLabel');\n    const tree = renderComponent({\n      ...defaultProps,\n      labeltype: 'percent',\n    });\n    const root = screen.getByAccessibilityHint(defaultProps.hint);\n    fireEvent(root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n          height: 22,\n        },\n      },\n    });\n    await waitFor(() => {\n      expect(WmPieChartMock).toHaveBeenCalled();\n      expect(WmPieChartMock).toHaveReturnedWith('42%');\n    });\n  });\n\n  it('when label type is key then getlabel should return key to the labels in the victorypieComponent', async () => {\n    const WmPieChartMock = jest.spyOn(WmPieChart.prototype, 'getLabel');\n    const tree = renderComponent({\n      ...defaultProps,\n      labeltype: 'key',\n    });\n    const root = screen.getByAccessibilityHint(defaultProps.hint);\n    fireEvent(root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n          height: 122,\n        },\n      },\n    });\n    await waitFor(() => {\n      expect(WmPieChartMock).toHaveBeenCalled();\n      expect(WmPieChartMock).toHaveReturnedWith('Cats', 'Dogs', 'Birds');\n    });\n  });\n\n  it('when label type is value then getlabel should return value to the labels in the victorypieComponent', async () => {\n    const WmPieChartMock = jest.spyOn(WmPieChart.prototype, 'getLabel');\n    const tree = renderComponent({\n      ...defaultProps,\n      labeltype: 'value',\n    });\n    const root = screen.getByAccessibilityHint(defaultProps.hint);\n    fireEvent(root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n          height: 122,\n        },\n      },\n    });\n    await waitFor(() => {\n      expect(WmPieChartMock).toHaveBeenCalled();\n      expect(WmPieChartMock).toHaveReturnedWith('35', '40', '55');\n    });\n  });\n\n  it('when label type is key-value then getlabel should return key-value to the labels in the victorypieComponent', async () => {\n    const WmPieChartMock = jest.spyOn(WmPieChart.prototype, 'getLabel');\n    const tree = renderComponent({\n      ...defaultProps,\n      labeltype: 'key-value',\n    });\n    const root = screen.getByAccessibilityHint(defaultProps.hint);\n    fireEvent(root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n          height: 122,\n        },\n      },\n    });\n    await waitFor(() => {\n      expect(WmPieChartMock).toHaveBeenCalled();\n      expect(WmPieChartMock).toHaveReturnedWith(\n        'Cats 35',\n        'Dogs 40',\n        'Birds 55'\n      );\n    });\n  });\n\n  //theme\n  it('should render theme', async () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      theme: 'Annabelle',\n    });\n    const root = screen.getByAccessibilityHint(defaultProps.hint);\n    fireEvent(root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n        },\n      },\n    });\n    await waitFor(() => {\n      const viewEle1 = tree.UNSAFE_getByType(VictoryPie);\n      expect(viewEle1.props.theme.group.colorScale[0]).toBe('#393b79');\n      expect(viewEle1.props.theme.group.width).toBe(250);\n      expect(viewEle1.props.theme.group.height).toBe(250);\n      expect(viewEle1.props.theme.legend.colorScale[0]).toBe('#393b79');\n      expect(viewEle1.props.theme.legend.orientation).toBe('vertical');\n      expect(viewEle1.props.theme.legend.gutter).toBe(10);\n    });\n  });\n\n  it('should render chart component with default data when dataset is empty', () => {\n    const SAMPLE_DATA1 = {\n      group1: 'Europe',\n      group2: 'Asia',\n      group3: 'America',\n      group4: 'Australia',\n    };\n\n    const { getByText } = renderComponent({\n      xaxisdatakey: 'x',\n      yaxisdatakey: 'y',\n      dataset: [],\n      type: 'Pie',\n    });\n\n    fireEvent(screen.root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n        },\n      },\n    });\n    // expect(tree).toMatchSnapshot();\n    expect(getByText(SAMPLE_DATA1.group1)).toBeTruthy();\n    expect(getByText(SAMPLE_DATA1.group2)).toBeTruthy();\n    expect(getByText(SAMPLE_DATA1.group3)).toBeTruthy();\n    expect(getByText(SAMPLE_DATA1.group4)).toBeTruthy();\n  });\n});\n", "wavemaker-rn-runtime/test/components/chart/legend.component.spec.tsx": "import React from 'react';\nimport { render } from '@testing-library/react-native';\nimport { Legend } from '@wavemaker/app-rn-runtime/components/chart/legend/legend.component';\n\ndescribe('Legend Component', () => {\n  const baseProps = {\n    data: [\n      { name: 'Category 1', color: 'red' },\n      { name: 'Category 2', color: 'blue' },\n      { name: 'Category 3', color: 'green' },\n    ],\n  };\n\n  test('should render Legend component correctly', () => {\n    const tree = render(<Legend {...baseProps} />);\n\n    baseProps.data.forEach((item) => {\n      expect(tree.getByText(item.name)).toBeTruthy();\n    });\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render with vertical orientation', () => {\n    const props = {\n      ...baseProps,\n      orientation: 'vertical',\n    };\n    const tree = render(<Legend {...props} />);\n\n    expect(tree.toJSON().props.style[0]).toMatchObject({\n      flexDirection: 'column',\n      justifyContent: 'center',\n    })\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render with horizontal orientation', () => {\n    const props = {\n      ...baseProps,\n      orientation: 'horizontal',\n    };\n    const tree = render(<Legend {...props} />);\n\n    expect(tree.toJSON().props.style[0]).toMatchObject({\n      flexDirection: 'row',\n      justifyContent: 'center',\n      flexWrap: 'wrap',\n    })\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should apply custom dotStyle to legend dots', () => {\n    const props = {\n      ...baseProps,\n      dotStyle: { borderRadius: 6 },\n    };\n    const { getByText } = render(<Legend {...props} />);\n\n    props.data.forEach((item) => {\n      const parentElement = getByText(item.name).parent?.parent;\n\n      const siblingElementStyleArr = parentElement?.children[0].props.style;\n      const style = {};\n      siblingElementStyleArr.forEach(item => {\n        if(!item) return;\n        Object.keys(item).forEach(key => {\n          style[key] = item[key]\n        })\n      })\n\n      expect(style).toMatchObject({\n        width: 12,\n        height: 12,\n        backgroundColor: item.color,\n        borderRadius: 6,\n      })\n    });\n  });\n\n  test('should apply custom textStyle to legend text', () => {\n    const props = {\n      ...baseProps,\n      testStyle: { fontSize: 16, color: 'purple' },\n    };\n    const { getByText } = render(<Legend {...props} />);\n\n    props.data.forEach((item) => {\n      const legendText = getByText(item.name);\n      const styleArr = legendText.props.style;\n      const style = {}\n\n      styleArr.forEach(item => {\n        if(!item) return;\n        Object.keys(item).forEach(key => {\n          style[key] = item[key]\n        })\n      })\n\n      expect(style).toMatchObject({\n        paddingLeft: 4,\n        fontSize: 16,\n        color: 'purple',\n      })\n    });\n  });\n});\n", "wavemaker-rn-runtime/test/components/chart/bubble-chart.component.spec.tsx": "import React, { ReactNode, createRef } from 'react';\nimport {\n  fireEvent,\n  render,\n  waitFor,\n  screen,\n  act,\n  cleanup,\n} from '@testing-library/react-native';\n// import { Text, TouchableOpacity } from 'react-native';\nimport WmBubbleChart from '@wavemaker/app-rn-runtime/components/chart/bubble-chart/bubble-chart.component';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport {\n  VictoryAxis,\n  VictoryChart,\n  VictoryLegend,\n  VictoryLine,\n  VictoryScatter,\n} from 'victory-native';\n\nconst renderComponent = (props = {}) => {\n  return render(\n    <WmBubbleChart\n      state={{ chartWidth: 300 }}\n      name=\"test_BubbleChart\"\n      {...props}\n      // style={[`${styles.root}, ${styles.text}`]}\n    />\n  );\n};\nconst dataSet = [\n  {\n    x: 10,\n    y: 101,\n  },\n  {\n    x: 20,\n    y: 201,\n  },\n  {\n    x: 30,\n    y: 301,\n  },\n];\nconst defaultProps = {\n  dataset: dataSet,\n  xaxisdatakey: 'x',\n  yaxisdatakey: 'y',\n};\n\ndescribe('Test BubbleChart component', () => {\n  afterEach(() => {\n    jest.clearAllMocks();\n    cleanup();\n  });\n\n  //should render when default props are given and also shouldnot render when default props are not given\n  it('should render with null when default props was not given', () => {\n    const tree = renderComponent();\n\n    expect(Array.isArray(tree.toJSON())).toBe(false);\n    expect(tree.toJSON().children).toBeNull();\n  });\n\n  it('should render when default props was given', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n    });\n    expect(tree).toBeDefined();\n  });\n\n  //title subheading titleIcon\n  it('should render bubblechart with title', () => {\n    const { getByText } = renderComponent({\n      ...defaultProps,\n      title: 'bubblechart-title',\n      styles: {\n        title: {\n          color: 'red',\n          fontSize: 30,\n          lineHeight: 10,\n          paddingLeft: 20,\n        },\n        text: {\n          color: 'yellow',\n        },\n      },\n    });\n    expect(getByText('bubblechart-title')).toBeTruthy();\n    expect(getByText('bubblechart-title').props.style.color).toBe('red');\n    expect(getByText('bubblechart-title').props.style.fontSize).toBe(30);\n    expect(getByText('bubblechart-title').props.style.lineHeight).toBe(10);\n    expect(getByText('bubblechart-title').props.style.paddingLeft).toBe(20);\n  });\n\n  it('should render bublechart with subheading', () => {\n    const { getByText } = renderComponent({\n      ...defaultProps,\n      subheading: 'bubblechart-subheading',\n      styles: {\n        subHeading: {\n          fontSize: 20,\n          lineHeight: 30,\n          color: 'red',\n        },\n        text: {\n          color: 'pink',\n        },\n      },\n    });\n    const text = getByText('bubblechart-subheading');\n    expect(text).toBeTruthy();\n    expect(text.props.style.fontSize).toBe(20);\n    expect(text.props.style.lineHeight).toBe(30);\n    expect(text.props.style.color).toBe('red');\n  });\n\n  it('should render Icon when iconclass is provided', () => {\n    const { getByText } = renderComponent({\n      ...defaultProps,\n      iconclass: 'fa fa-edit',\n      styles: {\n        icon: {\n          icon: {\n            fontSize: 40,\n          },\n        },\n        text: {\n          color: 'red',\n        },\n      },\n    });\n    expect(getByText('edit')).toBeTruthy();\n    expect(getByText('edit').props.style[1].fontSize).toBe(40);\n  });\n\n  it('should not render  Icon when iconclass is not provided', () => {\n    const tree = renderComponent({ ...defaultProps });\n    const wmIcon = tree.UNSAFE_queryByType(WmIcon);\n    expect(wmIcon).toBeNull();\n  });\n\n  // events - onBeforerender and onTransform\n  it('should call onBeforerender and onTransform events', () => {\n    const onBeforeRenderMock = jest.fn();\n    const onTransformMock = jest.fn();\n    const invokeEventCallbackMock = jest.spyOn(\n      WmBubbleChart.prototype,\n      'invokeEventCallback'\n    );\n    renderComponent({\n      ...defaultProps,\n      onBeforerender: onBeforeRenderMock,\n      onTransform: onTransformMock,\n    });\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n      'onBeforerender',\n      expect.anything()\n    );\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n      'onTransform',\n      expect.anything()\n    );\n    expect(onBeforeRenderMock).toHaveBeenCalledTimes(1);\n    expect(onTransformMock).toHaveBeenCalledTimes(1);\n  });\n\n  //onSelect event\n  it('should call onSelect event', async () => {\n    // change the assertions to check the functionality of onSelect method\n    const invokeEventCallbackMock = jest.spyOn(\n      WmBubbleChart.prototype,\n      'invokeEventCallback'\n    );\n\n    const customRef = createRef<WmBubbleChart>();\n    renderComponent({\n      ...defaultProps,\n      offsetX: 10,\n      locationX: 14,\n      offsetY: 20,\n      locationY: 25,\n      ref: customRef,\n      tooltipXaxis: 1,\n      tooltipYaxis: 1,\n      isTooltipOpen: false,\n    });\n    // onselect callback???\n    const event = {\n      nativeEvent: {\n        offsetX: 10,\n        locationX: 14,\n        offsetY: 20,\n        locationY: 25,\n      },\n    };\n    const dataSet1 = {\n      data: [{ x: 10, y: 20, z: 30 }],\n      datum: {\n        x: 10,\n        y: 20,\n        z: 30,\n      },\n      index: 0,\n    };\n    act(() => {\n      customRef.current.onSelect(event, dataSet1);\n    });\n    await waitFor(() => {\n      expect(customRef.current.state.isTooltipOpen).toBeTruthy();\n    });\n    expect(invokeEventCallbackMock).toHaveBeenCalled();\n  });\n\n  //accessibility\n  it('should apply accessibility props correctly', async () => {\n    const { getByRole, getByLabelText, getByA11yHint } = renderComponent({\n      ...defaultProps,\n      accessibilitylabel: 'BUBBLECHART',\n      accessibilityrole: 'BUBBLECHART',\n      hint: 'test BUBBLECHART',\n      styles: {\n        root: {\n          backgroundColor: 'red',\n          width: 200,\n          height: 300,\n        },\n        text: {\n          color: 'red',\n        },\n      },\n    });\n    expect(getByLabelText('BUBBLECHART')).toBeTruthy();\n    expect(getByRole('BUBBLECHART')).toBeTruthy();\n    expect(getByA11yHint('test BUBBLECHART')).toBeTruthy();\n    expect(getByRole('BUBBLECHART').props.style.backgroundColor).toBe('red');\n    expect(getByRole('BUBBLECHART').props.style.width).toBe(200);\n    expect(getByRole('BUBBLECHART').props.style.height).toBe(300);\n  });\n\n  //show - false\n  it('should have width and height to be 0 when show is false', () => {\n    const { getByRole } = renderComponent({\n      ...defaultProps,\n      show: false,\n      accessibilityrole: 'BUBBLECHART',\n    });\n    const viewEle = getByRole('BUBBLECHART');\n    expect(viewEle.props.style.width).toBe(0);\n    expect(viewEle.props.style.height).toBe(0);\n  });\n\n  //victorycharts\n  it('should render victorycharts with styles', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      offsettop: 10,\n      offsetbottom: 10,\n      offsetright: 10,\n      offsetleft: 10,\n      styles: {\n        root: {\n          height: 600,\n        },\n        text: {\n          color: 'red',\n        },\n      },\n    });\n    const viewEle = tree.UNSAFE_getByType(VictoryChart);\n    expect(viewEle.props.padding.top).toBe(10);\n    expect(viewEle.props.padding.bottom).toBe(10);\n    expect(viewEle.props.padding.right).toBe(10);\n    expect(viewEle.props.padding.left).toBe(10);\n    expect(viewEle.props.height).toBe(600);\n  });\n\n  //victorylegend\n  it('should render VictoryLegend with styles', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      containerComponent: 'Svg',\n    });\n    const viewEle = tree.UNSAFE_getAllByType(VictoryLegend);\n    expect(viewEle[0].props.containerComponent.type.displayName).toBe('Svg');\n  });\n\n  //shape\n  it('renders shape in updateData', () => {\n    const updateDataMock = jest.spyOn(WmBubbleChart.prototype, 'updateData');\n    const shapes = 'circle';\n    renderComponent({\n      ...defaultProps,\n      shape: shapes,\n    });\n    expect(updateDataMock).toHaveBeenCalled();\n    expect(updateDataMock.mock.calls[0][0][0][0].symbol).toBe(shapes);\n  });\n\n  //AdvancedSettings\n  it('checking Advanced Settings', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      xaxislabel: 'x',\n      xunits: 'cm',\n      showxdistance: 'true',\n      yaxislabel: 'y',\n      yunits: 'cm',\n      yaxislabeldistance: 2,\n      showydistance: 'true',\n    });\n\n    expect(screen).toMatchSnapshot();\n    const viewEle = tree.UNSAFE_getAllByType(VictoryAxis);\n    expect(viewEle[0].props.label).toBe('x(cm)');\n    expect(viewEle[1].props.label).toBe('y(cm)');\n  });\n\n  //victoryScatter\n  it('should render VictoryScatter with colorscale', () => {\n    const colorScale = ['red', 'yellow', 'green'];\n    const tree = renderComponent({\n      ...defaultProps,\n      customcolors: colorScale,\n    });\n    const viewEle = tree.UNSAFE_getAllByType(VictoryScatter);\n    expect(viewEle[0].props.colorScale).toBe(colorScale);\n    // expect(viewEle[0].props.name).toBe('test_BubbleChart_bubble_0');\n  });\n\n  //gettooltip\n  it('should render get tooltip ', async () => {\n    const getTooltipMock = jest.spyOn(WmBubbleChart.prototype, 'getTooltip');\n    const customRef = createRef<WmBubbleChart>();\n    const { getByText } = renderComponent({\n      ...defaultProps,\n      caption: 'newcaption',\n      ref: customRef,\n    });\n\n    expect(getTooltipMock).toHaveBeenCalledTimes(1);\n    expect(getTooltipMock).toHaveReturnedWith(null);\n\n    const event = {\n      nativeEvent: {\n        offsetX: 10,\n        locationX: 14,\n        offsetY: 20,\n        locationY: 25,\n      },\n    };\n    const dataSet1 = {\n      data: [{ x: 10, y: 20, z: 30 }],\n      datum: {\n        x: 0,\n        y: 1,\n        z: 2,\n      },\n      index: 0,\n    };\n    act(() => {\n      customRef.current.onSelect(event, dataSet1);\n    });\n    await waitFor(() => {\n      expect(customRef.current.state.isTooltipOpen).toBe(true);\n      expect(getTooltipMock).not.toBeNull();\n      expect(getByText('10')).toBeTruthy();\n      expect(getByText('20')).toBeTruthy();\n    });\n\n    expect(screen).toMatchSnapshot();\n\n    const textElemets = screen.getAllByText('10');\n  });\n\n  //showlegend\n  it('showlegend set to hidden', async () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      showlegend: 'hide',\n      colorScale: ['red', 'yellow', 'green'],\n    });\n\n    expect(tree.UNSAFE_getAllByType(VictoryLegend).length).toBe(1);\n  });\n\n  it('showlegend except hidden like showlegend as top,bottom,left,right', async () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      showlegend: 'top',\n      colorScale: ['red', 'yellow', 'green'],\n    });\n\n    expect(tree.UNSAFE_getAllByType(VictoryLegend).length).toBe(2);\n  });\n\n  //theme\n  it('should render theme', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      theme: 'Annabelle',\n    });\n    const viewEle1 = tree.UNSAFE_getByType(VictoryChart);\n    expect(viewEle1.props.theme.group.colorScale[0]).toBe('#393b79');\n    expect(viewEle1.props.theme.group.width).toBe(250);\n    expect(viewEle1.props.theme.group.height).toBe(250);\n    expect(viewEle1.props.theme.legend.colorScale[0]).toBe('#393b79');\n    expect(viewEle1.props.theme.legend.orientation).toBe('vertical');\n    expect(viewEle1.props.theme.legend.gutter).toBe(10);\n\n    const viewEle2 = tree.UNSAFE_getAllByType(VictoryLegend);\n    expect(viewEle2[0].props.theme.group.colorScale[0]).toBe('#393b79');\n    expect(viewEle2[0].props.theme.group.width).toBe(250);\n    expect(viewEle2[0].props.theme.group.height).toBe(250);\n    expect(viewEle2[0].props.theme.legend.colorScale[0]).toBe('#393b79');\n    expect(viewEle2[0].props.theme.legend.orientation).toBe('vertical');\n    expect(viewEle2[0].props.theme.legend.gutter).toBe(10);\n  });\n\n  xit('showxaxis', async () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      showxaxis: false,\n    });\n    fireEvent(screen.root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n        },\n      },\n    });\n    await waitFor(() => {\n      expect(tree.UNSAFE_getAllByType(VictoryAxis).length).toBe(1);\n    });\n  });\n\n  it('showyaxis', async () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      showyaxis: false,\n    });\n    fireEvent(screen.root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n        },\n      },\n    });\n    await waitFor(() => {\n      expect(tree.UNSAFE_getAllByType(VictoryAxis).length).toBe(1);\n    });\n  });\n});\n", "wavemaker-rn-runtime/test/components/chart/column-chart.component.spec.tsx": "import React, { ReactNode, createRef } from 'react';\nimport WmColumnChart from '@wavemaker/app-rn-runtime/components/chart/column-chart/column-chart.component';\nimport WmColumnChartProps from '@wavemaker/app-rn-runtime/components/chart/column-chart/column-chart.props';\nimport ThemeFactory from '@wavemaker/app-rn-runtime/components/chart/theme/chart.theme';\nimport {\n  VictoryAxis,\n  VictoryChart,\n  VictoryLegend,\n  VictoryGroup,\n  VictoryStack,\n  VictoryBar,\n} from 'victory-native';\nimport { render, waitFor, screen, act } from '@testing-library/react-native';\n\nconst renderComponent = (props = {}) => {\n  return render(\n    <WmColumnChart\n      state={{ chartWidth: 300 }}\n      name=\"test_BubbleChart\"\n      {...props}\n      // style={[`${styles.root}, ${styles.text}`]}\n    />\n  );\n};\n\ndescribe('Test BarChart component', () => {\n  const baseProps: WmColumnChartProps = {\n    id: 'bar-chart-1',\n    name: 'test_BarChar',\n    title: 'Sample Bar Chart',\n    subheading: 'This is a test bar chart',\n    dataset: [\n      { category: 'Category 1', value: 10 },\n      { category: 'Category 2', value: 20 },\n      { category: 'Category 3', value: 30 },\n    ],\n    xaxisdatakey: 'category',\n    yaxisdatakey: 'value',\n    showvalues: true,\n    horizontal: true,\n    viewtype: 'Grouped',\n    loadingdatamsg: 'Loading...',\n    nodatamessage: 'No data found',\n    customcolors: ['blue', 'green', 'red'],\n  };\n\n  //default props , title\n  it('should render WmBarChart component correctly', () => {\n    const tree = render(\n      <WmColumnChart\n        name=\"test_BarChart\"\n        dataset={baseProps.dataset}\n        xaxisdatakey={baseProps.xaxisdatakey}\n        yaxisdatakey={baseProps.yaxisdatakey}\n        title={baseProps.title}\n        subheading={baseProps.subheading}\n      />\n    ).toJSON();\n    expect(screen).toMatchSnapshot();\n\n    expect(tree).not.toBeNull();\n  });\n\n  it('should render with null when default props was not given', () => {\n    const tree = render(<WmColumnChart />);\n\n    expect(Array.isArray(tree.toJSON())).toBe(false);\n    expect(tree.toJSON().children).toBeNull();\n  });\n\n  it('should render bar chart with given dataset', () => {\n    const tree = render(<WmColumnChart {...baseProps} />);\n\n    expect(screen.getByText(baseProps.title)).toBeTruthy();\n    expect(screen.getByText(baseProps.subheading)).toBeTruthy();\n  });\n\n  it('should render title with icon', () => {\n    const tree = render(\n      <WmColumnChart {...baseProps} iconclass=\"fa fa-edit\" />\n    );\n\n    expect(screen.getByText(baseProps.title)).toBeTruthy();\n    expect(screen.getByText('edit')).toBeTruthy();\n  });\n\n  //3 events covered\n  it('should handle beforeRender event callback', () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmColumnChart.prototype,\n      'invokeEventCallback'\n    );\n    const tree = render(<WmColumnChart {...baseProps} />);\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n      'onBeforerender',\n      expect.anything()\n    );\n    expect(invokeEventCallbackMock).toHaveBeenCalled();\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n      'onBeforerender',\n      expect.anything()\n    );\n  });\n\n  it('should handle on Transform event callback', () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmColumnChart.prototype,\n      'invokeEventCallback'\n    );\n    const tree = render(<WmColumnChart {...baseProps} />);\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n      'onTransform',\n      expect.anything()\n    );\n    expect(invokeEventCallbackMock).toHaveBeenCalled();\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n      'onTransform',\n      expect.anything()\n    );\n  });\n\n  it('should handle onSelect event callback when a bar is selected', () => {\n    const invokeEventCallback = jest.spyOn(\n      WmColumnChart.prototype,\n      'invokeEventCallback'\n    );\n    const barRef: any = createRef();\n    render(<WmColumnChart {...baseProps} ref={barRef} />);\n\n    const mockEvent = { nativeEvent: {} };\n    const mockData = {\n      data: baseProps.dataset.map((item: any, index: number) => ({\n        y: item.value,\n        x: index,\n      })),\n      index: 0,\n      datum: { x: 0 },\n    };\n\n    if (barRef.current) {\n      jest.spyOn(barRef.current, 'onSelect');\n      barRef.current.onSelect(mockEvent, mockData);\n    }\n\n    expect(barRef.current.onSelect).toHaveBeenCalled();\n    expect(barRef.current.onSelect).toHaveBeenCalledWith(mockEvent, mockData);\n    expect(invokeEventCallback).toHaveBeenCalled();\n    expect(invokeEventCallback).toHaveBeenCalledWith(\n      'onSelect',\n      expect.anything()\n    );\n  });\n\n  it('should apply accessibility props correctly', async () => {\n    const tree = render(\n      <WmColumnChart\n        {...baseProps}\n        accessibilitylabel=\"Bar Chart Accessibility Label\"\n        accessibilityrole=\"Bar Chart Accessibility Role\"\n        hint=\"Bar Chart Accessibility Hint\"\n      />\n    );\n    expect(screen.getByLabelText('Bar Chart Accessibility Label')).toBeTruthy();\n    expect(screen.getByRole('Bar Chart Accessibility Role')).toBeTruthy();\n    expect(screen.getByA11yHint('Bar Chart Accessibility Hint')).toBeTruthy();\n  });\n\n  it('should have width and height to be 0 when show is false', () => {\n    render(\n      <WmColumnChart {...baseProps} show=\"false\" accessibilityrole=\"BarChart\" />\n    );\n    const viewEle = screen.getByRole('BarChart');\n    expect(viewEle.props.style.width).toBe(0);\n    expect(viewEle.props.style.height).toBe(0);\n  });\n\n  it('should render tooltip on select', async () => {\n    const getTooltipMock = jest.spyOn(WmColumnChart.prototype, 'getTooltip');\n    const customRef = createRef<WmColumnChart>();\n    const { getByText } = render(\n      <WmColumnChart {...baseProps} ref={customRef} />\n    );\n\n    const event = {\n      nativeEvent: {\n        offsetX: 'Category 1',\n        locationX: 14,\n        offsetY: 10,\n        locationY: 25,\n      },\n    };\n\n    const dataSet1 = {\n      data: baseProps.dataset.map((item: any, index: number) => ({\n        y: item.value,\n        x: index,\n      })),\n      datum: { x: 0, y: 1, z: 2 },\n      index: 0,\n    };\n    act(() => {\n      customRef.current.onSelect(event, dataSet1);\n    });\n    await waitFor(() => {\n      expect(customRef.current.state.isTooltipOpen).toBe(true);\n      expect(getTooltipMock).not.toBeNull();\n      expect(getByText('Category 1')).toBeTruthy();\n      expect(getByText('10')).toBeTruthy();\n    });\n  });\n\n  //advanced settings\n  it('should render legend when showlegend is \"bottom\"', () => {\n    const tree = render(<WmColumnChart {...baseProps} showlegend=\"bottom\" />);\n    const viewEle = tree.UNSAFE_getByType(VictoryLegend);\n    expect(viewEle).toBeTruthy();\n  });\n\n  it('should render legend when showlegend is \"top\"', () => {\n    const tree = render(<WmColumnChart {...baseProps} showlegend=\"top\" />);\n    const viewEle = tree.UNSAFE_getByType(VictoryLegend);\n    expect(viewEle).toBeTruthy();\n  });\n\n  it('should render VictoryStack when viewtype was stack', () => {\n    const tree = render(<WmColumnChart {...baseProps} viewtype=\"Stacked\" />);\n    const stackEle = tree.UNSAFE_getByType(VictoryStack);\n    const groupEle = tree.UNSAFE_queryByType(VictoryGroup);\n    expect(stackEle).toBeTruthy();\n    expect(groupEle).toBeNull();\n  });\n\n  it('should render the chart with grouped viewtype', () => {\n    const tree = render(<WmColumnChart {...baseProps} viewtype=\"Grouped\" />);\n    const groupEle = tree.UNSAFE_getByType(VictoryGroup);\n    const stackEle = tree.UNSAFE_queryByType(VictoryStack);\n    expect(groupEle).toBeTruthy();\n    expect(stackEle).toBeNull();\n  });\n\n  //Themes\n  it('should apply theme to chart', () => {\n    const themes = [\n      'Terrestrial',\n      'Annabelle',\n      'Azure',\n      'Retro',\n      'Mellow',\n      'Orient',\n      'GrayScale',\n      'Flyer',\n      'Luminosity',\n    ];\n    themes.forEach((theme) => {\n      const tree = render(<WmColumnChart {...baseProps} theme={theme} />);\n      const viewEle = tree.UNSAFE_getByType(VictoryChart);\n\n      const colors = viewEle.props.theme.group.colorScale;\n      const themeColors = ThemeFactory.getColorsObj(theme);\n\n      colors.map((color: string) => {\n        expect(themeColors).toContain(color);\n      });\n    });\n  });\n\n  //victoryCharts\n  it('should render victorycharts with offset styles', () => {\n    const tree = render(\n      <WmColumnChart\n        {...baseProps}\n        offsettop={10}\n        offsetbottom={10}\n        offsetright={10}\n        offsetleft={10}\n      />\n    );\n    const viewEle = tree.UNSAFE_getByType(VictoryChart);\n    expect(viewEle.props.padding.top).toBe(10);\n    expect(viewEle.props.padding.bottom).toBe(10);\n    expect(viewEle.props.padding.right).toBe(10);\n    expect(viewEle.props.padding.left).toBe(10);\n  });\n\n  //showvalues\n  it('if showvalue is true then label must appear', () => {\n    const tree = render(<WmColumnChart {...baseProps} showvalues={true} />);\n    const viewEle = tree.UNSAFE_getByType(VictoryBar);\n    expect(viewEle.props.labels).toBeDefined();\n  });\n\n  it('if show value is false then labels will not appear', () => {\n    const tree = render(<WmColumnChart {...baseProps} showvalues={false} />);\n    const viewEle = tree.UNSAFE_getByType(VictoryBar);\n    expect(viewEle.props.labels).toBeUndefined();\n  });\n\n  it('should apply custom colors to bars', () => {\n    const tree = render(<WmColumnChart {...baseProps} />);\n    const viewEle = tree.UNSAFE_getByType(VictoryGroup);\n    expect(viewEle.props.colorScale).toEqual(baseProps.customcolors);\n  });\n\n  it('should render x-axis label', () => {\n    const xaxislabel = 'x-axis-label';\n    const tree = render(\n      <WmColumnChart {...baseProps} xaxislabel={xaxislabel} />\n    );\n\n    const viewEle = tree.UNSAFE_getByType(VictoryChart);\n    const xaxis = viewEle.findAllByType(VictoryAxis);\n\n    expect(xaxis[0].props.label).toBe(xaxislabel);\n  });\n\n  it('should render y-axis label', () => {\n    const yaxislabel = 'y-axis-label';\n    const tree = render(\n      <WmColumnChart {...baseProps} xaxislabel={yaxislabel} />\n    );\n\n    const viewEle = tree.UNSAFE_getByType(VictoryChart);\n    const yaxis = viewEle.findAllByType(VictoryAxis);\n\n    expect(yaxis[0].props.label).toBe(yaxislabel);\n  });\n\n  it('should render x-axis units in the label', () => {\n    const xaxislabel = 'x-axis-label';\n    const xunits = 'x-units';\n    const tree = render(\n      <WmColumnChart {...baseProps} xaxislabel={xaxislabel} xunits={xunits} />\n    );\n\n    const viewEle = tree.UNSAFE_getByType(VictoryChart);\n    const xaxis = viewEle.findAllByType(VictoryAxis);\n\n    const expectedLabel = xaxislabel + `(${xunits})`;\n    expect(xaxis[0].props.label).toBe(expectedLabel);\n  });\n\n  it('should render chart component with default data when dataset is empty', () => {\n    const SAMPLE_DATA = {\n      group1: '01/01/2001',\n      group2: '01/01/2002',\n      group3: '01/01/2003',\n    };\n\n    const tree = render(\n      <WmColumnChart\n        xaxisdatakey=\"x\"\n        yaxisdatakey=\"y\"\n        dataset={[]}\n        type=\"Column\"\n      />\n    );\n\n    const viewEle2 = tree.UNSAFE_getByType(VictoryBar);\n    expect(viewEle2.props.data[0].y).toBe(3);\n    expect(viewEle2.props.data[0].x).toBe(0);\n  });\n});\n", "wavemaker-rn-runtime/test/components/chart/bar-chart.component.spec.tsx": "import React, { createRef, useRef } from 'react';\nimport WmBarChart from '@wavemaker/app-rn-runtime/components/chart/bar-chart/bar-chart.component';\nimport WmBarChartProps from '@wavemaker/app-rn-runtime/components/chart/bar-chart/bar-chart.props';\nimport { render, screen, waitFor } from '@testing-library/react-native';\nimport {\n  VictoryAxis,\n  VictoryChart,\n  VictoryGroup,\n  VictoryLegend,\n  VictoryLine,\n  VictoryStack,\n  VictoryScatter,\n  VictoryBar,\n  VictoryLabel,\n} from 'victory-native';\nimport ThemeFactory from '@wavemaker/app-rn-runtime/components/chart/theme/chart.theme';\nimport { act } from '@testing-library/react-native';\n\ndescribe('Test BarChart component', () => {\n  const baseProps: WmBarChartProps = {\n    id: 'bar-chart-1',\n    name: 'test_BarChar',\n    title: 'Sample Bar Chart',\n    subheading: 'This is a test bar chart',\n    dataset: [\n      { category: 'Category 1', value: 10 },\n      { category: 'Category 2', value: 20 },\n      { category: 'Category 3', value: 30 },\n    ],\n    xaxisdatakey: 'category',\n    yaxisdatakey: 'value',\n    showvalues: true,\n    horizontal: true,\n    viewtype: 'Grouped',\n    loadingdatamsg: 'Loading...',\n    nodatamessage: 'No data found',\n    customcolors: ['blue', 'green', 'red'],\n  };\n\n  it('should render WmBarChart component correctly', () => {\n    const tree = render(\n      <WmBarChart\n        name=\"test_BarChart\"\n        dataset={baseProps.dataset}\n        xaxisdatakey={baseProps.xaxisdatakey}\n        yaxisdatakey={baseProps.yaxisdatakey}\n        title={baseProps.title}\n        subheading={baseProps.subheading}\n      />\n    ).toJSON();\n    expect(tree).not.toBeNull();\n  });\n\n  it('should render with null when default props was not given', () => {\n    const tree = render(<WmBarChart />);\n\n    expect(Array.isArray(tree.toJSON())).toBe(false);\n    expect(tree.toJSON().children).toBeNull();\n  });\n\n  it('should render bar chart with given title & subheading', () => {\n    const tree = render(<WmBarChart {...baseProps} />);\n\n    expect(screen.getByText(baseProps.title)).toBeTruthy();\n    expect(screen.getByText(baseProps.subheading)).toBeTruthy();\n  });\n\n  it('should render title with icon', () => {\n    const tree = render(<WmBarChart {...baseProps} iconclass=\"fa fa-edit\" />);\n    expect(screen.getByText(baseProps.title)).toBeTruthy();\n    expect(screen.getByText('edit')).toBeTruthy();\n  });\n\n  it('should handle beforeRender event callback', () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmBarChart.prototype,\n      'invokeEventCallback'\n    );\n    const onBeforerenderMock = jest.fn();\n    const tree = render(\n      <WmBarChart {...baseProps} onBeforerender={onBeforerenderMock} />\n    );\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n      'onBeforerender',\n      expect.anything()\n    );\n    expect(onBeforerenderMock).toHaveBeenCalled();\n    expect(invokeEventCallbackMock).toHaveBeenCalled();\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n      'onBeforerender',\n      expect.anything()\n    );\n  });\n\n  it('should handle on Transform event callback', () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmBarChart.prototype,\n      'invokeEventCallback'\n    );\n    const onTransformMock = jest.fn();\n    const tree = render(\n      <WmBarChart {...baseProps} onTransform={onTransformMock} />\n    );\n\n    expect(onTransformMock).toHaveBeenCalled();\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n      'onTransform',\n      expect.anything()\n    );\n    expect(invokeEventCallbackMock).toHaveBeenCalled();\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n      'onTransform',\n      expect.anything()\n    );\n  });\n\n  it('should handle onSelect event callback when a bar is selected', () => {\n    const invokeEventCallback = jest.spyOn(\n      WmBarChart.prototype,\n      'invokeEventCallback'\n    );\n    const barRef: any = createRef();\n    const onSelectMock = jest.fn();\n    render(<WmBarChart {...baseProps} ref={barRef} onSelect={onSelectMock} />);\n\n    const mockEvent = { nativeEvent: {} };\n    const mockData = {\n      data: baseProps.dataset.map((item: any, index: number) => ({\n        y: item.value,\n        x: index,\n      })),\n      index: 0,\n      datum: { x: 0 },\n    };\n\n    if (barRef.current) {\n      jest.spyOn(barRef.current, 'onSelect');\n      barRef.current.onSelect(mockEvent, mockData);\n    }\n\n    expect(onSelectMock).toHaveBeenCalled();\n    expect(barRef.current.onSelect).toHaveBeenCalled();\n    expect(barRef.current.onSelect).toHaveBeenCalledWith(mockEvent, mockData);\n    expect(invokeEventCallback).toHaveBeenCalled();\n    expect(invokeEventCallback).toHaveBeenCalledWith(\n      'onSelect',\n      expect.anything()\n    );\n  });\n\n  it('should apply accessibility props correctly', async () => {\n    const tree = render(\n      <WmBarChart\n        {...baseProps}\n        accessibilitylabel=\"Bar Chart Accessibility Label\"\n        accessibilityrole=\"Bar Chart Accessibility Role\"\n        hint=\"Bar Chart Accessibility Hint\"\n      />\n    );\n    expect(screen.getByLabelText('Bar Chart Accessibility Label')).toBeTruthy();\n    expect(screen.getByRole('Bar Chart Accessibility Role')).toBeTruthy();\n    expect(screen.getByA11yHint('Bar Chart Accessibility Hint')).toBeTruthy();\n  });\n\n  it('should have width and height to be 0 when show is false', () => {\n    render(\n      <WmBarChart {...baseProps} show=\"false\" accessibilityrole=\"BarChart\" />\n    );\n    const viewEle = screen.getByRole('BarChart');\n    expect(viewEle.props.style.width).toBe(0);\n    expect(viewEle.props.style.height).toBe(0);\n  });\n\n  it('should render tooltip on select', async () => {\n    const getTooltipMock = jest.spyOn(WmBarChart.prototype, 'getTooltip');\n    const customRef = createRef<WmBarChart>();\n    const { getByText } = render(<WmBarChart {...baseProps} ref={customRef} />);\n\n    const event = {\n      nativeEvent: {\n        offsetX: 'Category 1',\n        locationX: 14,\n        offsetY: 10,\n        locationY: 25,\n      },\n    };\n\n    const dataSet1 = {\n      data: baseProps.dataset.map((item: any, index: number) => ({\n        y: item.value,\n        x: index,\n      })),\n      datum: { x: 0, y: 1, z: 2 },\n      index: 0,\n    };\n    act(() => {\n      customRef.current.onSelect(event, dataSet1);\n    });\n    await waitFor(() => {\n      expect(customRef.current.state.isTooltipOpen).toBe(true);\n      expect(getTooltipMock).not.toBeNull();\n      expect(getByText('Category 1')).toBeTruthy();\n      expect(getByText('10')).toBeTruthy();\n    });\n  });\n\n  //advanced settings\n  it('should render legend when showlegend is not \"hide\"', () => {\n    const tree = render(<WmBarChart {...baseProps} showlegend=\"bottom\" />);\n    const viewEle = tree.UNSAFE_getByType(VictoryLegend);\n\n    expect(viewEle).toBeTruthy();\n  });\n\n  it('showlegend set to hidden', async () => {\n    const tree = render(<WmBarChart {...baseProps} showlegend=\"hide\" />);\n    const viewEle = tree.UNSAFE_queryByType(VictoryLegend);\n    expect(viewEle).toBeNull();\n  });\n\n  it('should render the chart with stacked viewtype', () => {\n    const tree = render(<WmBarChart {...baseProps} viewtype=\"Stacked\" />);\n    const stackEle = tree.UNSAFE_getByType(VictoryStack);\n    const groupEle = tree.UNSAFE_queryByType(VictoryGroup);\n    expect(stackEle).toBeTruthy();\n    expect(groupEle).toBeNull();\n  });\n\n  it('should render the chart with grouped viewtype', () => {\n    const tree = render(<WmBarChart {...baseProps} viewtype=\"Grouped\" />);\n    const groupEle = tree.UNSAFE_getByType(VictoryGroup);\n    const stackEle = tree.UNSAFE_queryByType(VictoryStack);\n    expect(groupEle).toBeTruthy();\n    expect(stackEle).toBeNull();\n  });\n\n  it('should apply theme to chart', () => {\n    const themes = [\n      'Terrestrial',\n      'Annabelle',\n      'Azure',\n      'Retro',\n      'Mellow',\n      'Orient',\n      'GrayScale',\n      'Flyer',\n      'Luminosity',\n    ];\n    themes.forEach((theme) => {\n      const tree = render(<WmBarChart {...baseProps} theme={theme} />);\n      const viewEle = tree.UNSAFE_getByType(VictoryChart);\n\n      const colors = viewEle.props.theme.group.colorScale;\n      const themeColors = ThemeFactory.getColorsObj(theme);\n\n      colors.map((color: string) => {\n        expect(themeColors).toContain(color);\n      });\n    });\n  });\n\n  it('should render victorycharts with offset styles', () => {\n    const tree = render(\n      <WmBarChart\n        {...baseProps}\n        offsettop={10}\n        offsetbottom={10}\n        offsetright={10}\n        offsetleft={10}\n      />\n    );\n    const viewEle = tree.UNSAFE_getByType(VictoryChart);\n    expect(viewEle.props.padding.top).toBe(10);\n    expect(viewEle.props.padding.bottom).toBe(10);\n    expect(viewEle.props.padding.right).toBe(10);\n    expect(viewEle.props.padding.left).toBe(10);\n  });\n\n  it('should pass labels to chart on show values', () => {\n    const tree = render(<WmBarChart {...baseProps} showvalues={true} />);\n    const viewEle = tree.UNSAFE_getByType(VictoryBar);\n    expect(viewEle.props.labels).toBeDefined();\n  });\n\n  it(\"shouldn't pass labels on show values is false\", () => {\n    const tree = render(<WmBarChart {...baseProps} showvalues={false} />);\n    const viewEle = tree.UNSAFE_getByType(VictoryBar);\n    expect(viewEle.props.labels).toBeUndefined();\n  });\n\n  it('should apply custom colors to bars', () => {\n    const tree = render(<WmBarChart {...baseProps} />);\n    const viewEle = tree.UNSAFE_getByType(VictoryGroup);\n    expect(viewEle.props.colorScale).toEqual(baseProps.customcolors);\n  });\n\n  it('should render x-axis label', () => {\n    const xaxislabel = 'x-axis-label';\n    const tree = render(<WmBarChart {...baseProps} xaxislabel={xaxislabel} />);\n\n    const viewEle = tree.UNSAFE_getByType(VictoryChart);\n    const xaxis = viewEle.findAllByType(VictoryAxis);\n\n    expect(xaxis[0].props.label).toBe(xaxislabel);\n  });\n\n  it('should render y-axis label', () => {\n    const yaxislabel = 'y-axis-label';\n    const tree = render(<WmBarChart {...baseProps} xaxislabel={yaxislabel} />);\n\n    const viewEle = tree.UNSAFE_getByType(VictoryChart);\n    const yaxis = viewEle.findAllByType(VictoryAxis);\n\n    expect(yaxis[0].props.label).toBe(yaxislabel);\n  });\n\n  it('should render x-axis units in the label', () => {\n    const xaxislabel = 'x-axis-label';\n    const xunits = 'x-units';\n    const tree = render(\n      <WmBarChart {...baseProps} xaxislabel={xaxislabel} xunits={xunits} />\n    );\n\n    const viewEle = tree.UNSAFE_getByType(VictoryChart);\n    const xaxis = viewEle.findAllByType(VictoryAxis);\n\n    const expectedLabel = xaxislabel + `(${xunits})`;\n    expect(xaxis[0].props.label).toBe(expectedLabel);\n  });\n\n  it('should render y-axis label distance', () => {\n    const yaxislabeldistance = 5;\n    const tree = render(\n      <WmBarChart {...baseProps} yaxislabeldistance={yaxislabeldistance} />\n    );\n\n    const viewEle = tree.UNSAFE_getByType(VictoryChart);\n    const yaxis = viewEle.findAllByType(VictoryAxis);\n\n    expect(yaxis[0].props.axisLabelComponent.props.y).toBe(yaxislabeldistance);\n  });\n\n  it('should show x-axis', () => {\n    const getYAxisSpy = jest.spyOn(WmBarChart.prototype, 'getYAxis');\n    const tree = render(<WmBarChart {...baseProps} showxaxis={false} />);\n    expect(getYAxisSpy).toHaveBeenCalled();\n    expect(getYAxisSpy).not.toHaveReturnedWith(null);\n    getYAxisSpy.mockRestore();\n  });\n\n  it('should show y-axis', () => {\n    const getYAxisSpy = jest.spyOn(WmBarChart.prototype, 'getYAxis');\n    const tree = render(<WmBarChart {...baseProps} showyaxis={true} />);\n    expect(getYAxisSpy).toHaveBeenCalled();\n    expect(getYAxisSpy).not.toHaveReturnedWith(null);\n    getYAxisSpy.mockRestore();\n  });\n\n  it(\"shouldn't show y-axis\", () => {\n    const getYAxisSpy = jest.spyOn(WmBarChart.prototype, 'getYAxis');\n    const tree = render(<WmBarChart {...baseProps} showyaxis={false} />);\n    expect(getYAxisSpy).toHaveBeenCalled();\n    expect(getYAxisSpy).toHaveReturnedWith(null);\n    getYAxisSpy.mockRestore();\n  });\n\n  it('should have width and height', () => {\n    const tree = render(\n      <WmBarChart\n        {...baseProps}\n        styles={{\n          root: { width: 500, height: 500 },\n          text: {\n            color: 'red',\n          },\n        }}\n      />\n    );\n    const viewEle = tree.UNSAFE_getByType(VictoryChart);\n    expect(screen).toMatchSnapshot();\n  });\n\n  it('should render chart component with default data when dataset is empty', () => {\n    const tree = render(\n      <WmBarChart\n        {...baseProps}\n        xaxisdatakey=\"x\"\n        yaxisdatakey=\"y\"\n        dataset={[]}\n        type=\"Bar\"\n      />\n    );\n\n    const viewEle2 = tree.UNSAFE_getByType(VictoryBar);\n    expect(viewEle2.props.data[0].y).toBe(2000000);\n    expect(viewEle2.props.data[1].y).toBe(1000000);\n    expect(viewEle2.props.data[2].y).toBe(3000000);\n    expect(viewEle2.props.data[0].x).toBe(0);\n    expect(viewEle2.props.data[1].x).toBe(1);\n    expect(viewEle2.props.data[2].x).toBe(2);\n  });\n});\n", "wavemaker-rn-runtime/test/components/chart/donut-chart.component.spec.tsx": "import React, { ReactNode, createRef } from 'react';\nimport WmDonutChart from '@wavemaker/app-rn-runtime/components/chart/donut-chart/donut-chart.component';\nimport { Svg } from 'react-native-svg';\nimport { Legend } from '@wavemaker/app-rn-runtime/components/chart/legend/legend.component';\nimport {\n  fireEvent,\n  render,\n  waitFor,\n  screen,\n  act,\n  cleanup,\n} from '@testing-library/react-native';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport { VictoryPie, VictoryLabel } from 'victory-native';\nimport { View } from 'react-native';\n\n//onLayout Methods\nconst onViewLayout = (element, Width, Height) => {\n  return fireEvent(element, 'layout', {\n    nativeEvent: {\n      layout: {\n        width: Width,\n        height: Height,\n      },\n    },\n  });\n};\n\nconst onInfoViewLayoutChange = (element, Height) => {\n  return fireEvent(element, 'layout', {\n    nativeEvent: {\n      layout: {\n        height: Height,\n      },\n    },\n  });\n};\n\nconst renderComponent = (props = {}) => {\n  return render(<WmDonutChart {...props} name=\"test_donutChart\" />);\n};\nconst dataSet = [\n  { x: 'Cats', y: 35 },\n  { x: 'Dogs', y: 40 },\n  { x: 'Birds', y: 55 },\n];\nconst defaultProps = { dataset: dataSet, xaxisdatakey: 'x', yaxisdatakey: 'y', hint: 'donut chart' };\n\ndescribe('Test DonutChart component', () => {\n  afterEach(() => {\n    jest.clearAllMocks();\n    cleanup();\n  });\n\n  //it will render when default props is given and not renders when default props is not given\n  it('Should render component', () => {\n    const tree = renderComponent(defaultProps);\n    expect(Array.isArray(tree.toJSON())).toBe(true);\n    expect(tree.toJSON()).not.toBeNull();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('should render with null when props are not given', () => {\n    const tree = renderComponent();\n    \n    expect(Array.isArray(tree.toJSON())).toBe(false);\n    expect(tree.toJSON().children).toBeNull();\n  });\n\n  //should render with title, subheading, titlesIcon\n  it('should render title', () => {\n    const { getByText } = renderComponent({\n      title: 'Donut-Chart',\n      ...defaultProps,\n      styles: {\n        title: {\n          color: 'red',\n          fontSize: 30,\n          lineHeight: 10,\n          paddingLeft: 20,\n        },\n        text: {\n          color: 'yellow',\n        },\n      },\n    });\n    expect(getByText('Donut-Chart')).toBeTruthy();\n    expect(getByText('Donut-Chart').props.style.color).toBe('red');\n    expect(getByText('Donut-Chart').props.style.fontSize).toBe(30);\n    expect(getByText('Donut-Chart').props.style.lineHeight).toBe(10);\n    expect(getByText('Donut-Chart').props.style.paddingLeft).toBe(20);\n  });\n\n  it('should render subheading', () => {\n    const { getByText } = renderComponent({\n      subheading: 'subHeading-Donut Chart',\n      ...defaultProps,\n      styles: {\n        subHeading: {\n          fontSize: 20,\n          lineHeight: 30,\n          color: 'red',\n        },\n        text: {\n          color: 'pink',\n        },\n      },\n    });\n    const text = getByText('subHeading-Donut Chart');\n    expect(text).toBeTruthy();\n    expect(text.props.style.fontSize).toBe(20);\n    expect(text.props.style.lineHeight).toBe(30);\n    expect(text.props.style.color).toBe('red');\n  });\n\n  it('should render Icon when iconclass is provided', () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      iconclass: 'fa fa-edit',\n      styles: {\n        icon: {\n          icon: {\n            fontSize: 40,\n          },\n        },\n        text: {\n          color: 'red',\n        },\n      },\n    });\n    expect(tree.getByText('edit')).toBeTruthy();\n    expect(tree.getByText('edit').props.style[1].fontSize).toBe(40);\n  });\n\n  it('should not render Icon when iconclass is not provided', () => {\n    const tree = renderComponent({ ...defaultProps });\n    const wmIcon = tree.UNSAFE_queryByType(WmIcon);\n    expect(wmIcon).toBeNull();\n  });\n\n  //Accesseility\n  it('should apply accessibility props correctly', async () => {\n    const { getByRole, getByLabelText, getByA11yHint } = renderComponent({\n      ...defaultProps,\n      accessibilitylabel: 'Donut',\n      accessibilityrole: 'Donut',\n      hint: 'test button',\n      styles: {\n        root: {\n          backgroundColor: 'red',\n          width: 200,\n          height: 300,\n        },\n        text: {\n          color: 'red',\n        },\n      },\n    });\n    expect(getByLabelText('Donut')).toBeTruthy();\n    expect(getByRole('Donut')).toBeTruthy();\n    expect(getByA11yHint('test button')).toBeTruthy();\n    expect(getByRole('Donut').props.style[1].backgroundColor).toBe('red');\n    expect(getByRole('Donut').props.style[1].width).toBe(200);\n    expect(getByRole('Donut').props.style[1].height).toBe(300);\n  });\n\n  //Events - onBeforerender and onTransfrom\n  it('should call onBeforerender and onTransform events', () => {\n    const onBeforeRenderMock = jest.fn();\n    const onTransformMock = jest.fn();\n    const invokeEventCallbackMock = jest.spyOn(\n      WmDonutChart.prototype,\n      'invokeEventCallback'\n    );\n    renderComponent({\n      ...defaultProps,\n      onBeforerender: onBeforeRenderMock,\n      onTransform: onTransformMock,\n    });\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n      'onBeforerender',\n      expect.anything()\n    );\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n      'onTransform',\n      expect.anything()\n    );\n    expect(onBeforeRenderMock).toHaveBeenCalledTimes(1);\n    expect(onTransformMock).toHaveBeenCalledTimes(1);\n  });\n\n  //onSelect\n  it('should call onSelect event', async () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmDonutChart.prototype,\n      'invokeEventCallback'\n    );\n    const customRef = createRef<WmDonutChart>();\n    renderComponent({\n      ...defaultProps,\n      offsetX: 10,\n      locationX: 14,\n      offsetY: 20,\n      locationY: 25,\n      ref: customRef,\n      tooltipXaxis: 1,\n      tooltipYaxis: 1,\n      isTooltipOpen: false,\n    });\n    const onSelect = {\n      nativeEvent: {\n        offsetX: 10,\n        locationX: 14,\n        offsetY: 20,\n        locationY: 25,\n      },\n    };\n    const dataSet1 = {\n      data: [{ x: 10, y: 20, z: 30 }],\n      datum: {\n        x: 10,\n        y: 20,\n        z: 30,\n      },\n      index: 0,\n      slice: {\n        value: 1,\n      },\n      style: {\n        fill: {\n          color: 'red',\n        },\n      },\n    };\n    act(() => {\n      customRef.current.onSelect(onSelect, dataSet1);\n    });\n\n    await waitFor(() => {\n      expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n        'onSelect',\n        expect.anything()\n      );\n    });\n  });\n\n  //when the width was set then svg should render\n  it('if width was set than svg should  render', async () => {\n    const showlegend: string = 'left',\n      rootHeight = 0;\n\n    //rendering donutchart\n    const tree = renderComponent({\n      ...defaultProps,\n    });\n\n    //updating the width\n    const viewWidth = 500;\n    const totalHeight = 300;\n    const root = tree.getByAccessibilityHint(defaultProps.hint);\n    onViewLayout(root, viewWidth, totalHeight);\n    const subChild = tree.getByAccessibilityHint(defaultProps.hint).children[0];\n    const infoHeight = 300;\n    const legendHeight = 0;\n    onInfoViewLayoutChange(subChild, infoHeight);\n    const chartHeight =\n      (rootHeight ? totalHeight : viewWidth) -\n      infoHeight -\n      (showlegend === 'right' ? 0 : legendHeight);\n\n    await waitFor(() => {\n      const viewEle = tree.UNSAFE_getByType(Svg);\n      expect(viewEle).toBeDefined();\n      expect(viewEle.props.width).toBe(viewWidth);\n      expect(viewEle.props.height).toBe(chartHeight);\n      expect(tree.UNSAFE_queryByType(Legend)).toBeDefined();\n      expect(tree.UNSAFE_getByType(VictoryPie)).toBeDefined();\n    });\n  });\n\n  it('if width was not set then svg should not render', async () => {\n    const tree = renderComponent({\n      ...defaultProps,\n    });\n    await waitFor(() => {\n      expect(tree.UNSAFE_queryByType(Svg)).toBeNull();\n    });\n  });\n\n  //victory charts should render with props\n\n  //victory pie\n  it('Victory Pie should render with props', async () => {\n    const rootHeight = 0,\n      infoHeight = 10,\n      showlegend: string = 'top',\n      legendWidth = 0,\n      legendHeight = 0,\n      donutratio = 0.5;\n    //spying on the function\n    const WmDonutChartMock = jest.spyOn(WmDonutChart.prototype, 'getLabel');\n\n    //rendering donutChart\n    const tree = renderComponent({\n      ...defaultProps,\n      showlegend: 'top',\n      customcolors: ['tomato', 'orange', 'gold'],\n      showlabels: 'hide',\n      donutratio: donutratio,\n      styles: {\n        centerLabel: {\n          color: 'brown',\n          fontSize: 30,\n        },\n        text: {\n          color: 'yellow',\n        },\n      },\n      centerlabel: 'centerlabel',\n    });\n\n    //updating the width and height\n    const viewWidth = 500;\n    const totalHeight = 510;\n    const root = tree.getByAccessibilityHint(defaultProps.hint);\n    onViewLayout(root, viewWidth, totalHeight);\n    const chartWidth = viewWidth - (showlegend === 'right' ? legendWidth : 0);\n    const chartHeight =\n      (rootHeight ? totalHeight : chartWidth) -\n      infoHeight -\n      (showlegend === 'right' ? 0 : legendHeight);\n    const origin = { x: viewWidth / 2, y: chartHeight / 2 };\n    const radius = (Math.min(viewWidth, chartHeight) - 40) / 2;\n    let innerRadius = donutratio * radius;\n\n    await waitFor(() => {\n      const viewEle = tree.UNSAFE_getByType(VictoryPie);\n      expect(viewEle.props.radius).toBe(radius);\n      expect(viewEle.props.colorScale[0]).toBe('tomato');\n      expect(viewEle.props.colorScale[1]).toBe('orange');\n      expect(viewEle.props.colorScale[2]).toBe('gold');\n      expect(viewEle.props.endAngle).toBe(0);\n      expect(viewEle.props.innerRadius).toBe(innerRadius);\n      expect(viewEle.props.origin.x).toBe(origin.x);\n      expect(viewEle.props.origin.y).toBe(origin.y);\n      expect(WmDonutChartMock).toHaveBeenCalled();\n      expect(viewEle.props.style.labels.display).toBe('none');\n\n      //victoryLabel\n      const viewLabel = tree.UNSAFE_getAllByType(VictoryLabel);\n      expect(viewLabel[3].props.x).toBe(origin.x);\n      expect(viewLabel[3].props.y).toBe(origin.y);\n      expect(viewLabel[3].props.style.color).toBe('brown');\n      expect(viewLabel[3].props.style.fontSize).toBe(30);\n      expect(viewLabel[3].props.style.fill).toBe('brown');\n      expect(viewLabel[3].props.text).toBe('centerlabel');\n    });\n    tree.rerender(\n      <WmDonutChart\n        {...defaultProps}\n        name=\"test_PieChart\"\n        showlabels=\"inside\"\n      />\n    );\n    await waitFor(() => {\n      const viewEle = tree.UNSAFE_getByType(VictoryPie);\n      expect(viewEle.props.labelRadius).toBe(radius / 2);\n    });\n    tree.rerender(\n      <WmDonutChart\n        {...defaultProps}\n        name=\"test_PieChart\"\n        showlabels=\"outside\"\n      />\n    );\n    await waitFor(() => {\n      const viewEle = tree.UNSAFE_getByType(VictoryPie);\n      expect(viewEle.props.labelRadius).toBe(radius + 8);\n    });\n  });\n\n  // //victory label\n  // it('Victory Label should render with props', async () => {\n  //   const tree = renderComponent({\n  //     ...defaultProps,\n  //     showlegend: 'top',\n  //   });\n  //   fireEvent(screen.root, 'layout', {\n  //     nativeEvent: {\n  //       layout: {\n  //         width: 500,\n  //       },\n  //     },\n  //   });\n  //   await waitFor(() => {\n  //     const viewEle = tree.UNSAFE_getAllByType(VictoryLabel);\n  //     expect(viewEle[0].props.x).toBe(250);\n  //     expect(viewEle[0].props.y).toBe(12);\n  //     expect(viewEle[0].props.text).toBe('27%');\n  //   });\n  // });\n\n  //show legend set to right\n  it('show legend set to right', async () => {\n    const showlegend = 'right',\n      rootHeight = 0;\n\n    //rendering donutChart\n    const tree = renderComponent({\n      ...defaultProps,\n      showlegend: 'right',\n    });\n\n    const viewWidth = 500;\n    const totalHeight = 510;\n    const root = tree.getByAccessibilityHint(defaultProps.hint);\n    onViewLayout(root, viewWidth, totalHeight);\n    const subChild = tree.getByAccessibilityHint(defaultProps.hint).children[0];\n    const infoHeight = 300;\n    const legendWidth = 300,\n      legendHeight = 100;\n    onInfoViewLayoutChange(subChild, infoHeight);\n    const child = tree.getByAccessibilityHint(defaultProps.hint).children;\n    const childOfSubChild = child[1].children[0].children[1];\n    onViewLayout(childOfSubChild, legendWidth, legendHeight);\n\n    //initialising chartwidth and height with given values\n    const chartWidth = viewWidth - (showlegend === 'right' ? legendWidth : 0);\n    const chartHeight =\n      (rootHeight ? totalHeight : chartWidth) -\n      infoHeight -\n      (showlegend === 'right' ? 0 : legendHeight);\n\n    await waitFor(() => {\n      const viewEle = tree.UNSAFE_queryByType(Svg);\n      expect(viewEle.props.width).toBe(chartWidth);\n      expect(viewEle.props.height).toBe(chartHeight);\n    });\n  });\n\n  it('if same width is updated at parent and child layout than svg shouldnot  render', async () => {\n    //rendering donutChart\n    const tree = renderComponent({\n      ...defaultProps,\n      showlegend: 'right',\n    });\n\n    //update width and height\n    const viewWidth = 500;\n    const totalHeight = 510;\n    const root = tree.getByAccessibilityHint(defaultProps.hint);\n    onViewLayout(root, viewWidth, totalHeight);\n    const child = tree.getByAccessibilityHint(defaultProps.hint).children;\n    const subChild = child[1].children[0].children[1];\n    const legendwidth = 500,\n      legendheight = 22;\n    onViewLayout(subChild, legendwidth, legendheight);\n\n    await waitFor(() => {\n      expect(tree.UNSAFE_queryByType(Svg)).toBeNull();\n    });\n  });\n\n  //show legend set to bottom\n  it('if showlegend is bottom and width was set than svg should  render', async () => {\n    //rendering donutChart\n    const tree = renderComponent({\n      ...defaultProps,\n      showlegend: 'bottom',\n    });\n\n    const viewWidth = 500;\n    const totalHeight = 0;\n    const root = tree.getByAccessibilityHint(defaultProps.hint);\n    onViewLayout(root, viewWidth, totalHeight);\n\n    await waitFor(() => {\n      expect(tree.UNSAFE_getByType(Svg)).toBeDefined();\n    });\n\n    const legendWidth = 500,\n      legendHeight = 22;\n    const child = tree.getByAccessibilityHint(defaultProps.hint).children[2];\n    onViewLayout(child, legendWidth, legendHeight);\n\n    await waitFor(() => {\n      expect(tree.UNSAFE_getByType(Svg)).toBeDefined();\n    });\n  });\n\n  //getToolTip\n  it('should render get tooltip ', async () => {\n    const getTooltipMock = jest.spyOn(WmDonutChart.prototype, 'getTooltip');\n    const customRef = createRef<WmDonutChart>();\n    const { getByText, getAllByText } = renderComponent({\n      ...defaultProps,\n      caption: 'newcaption',\n      ref: customRef,\n    });\n\n    const event = {\n      nativeEvent: {\n        offsetX: 10,\n        locationX: 14,\n        offsetY: 20,\n        locationY: 25,\n      },\n    };\n    const dataSet1 = {\n      data: [{ x: 10, y: 20, z: 30 }],\n      datum: {\n        x: 0,\n        y: 1,\n        z: 2,\n      },\n      index: 0,\n      slice: {\n        value: 1,\n      },\n      style: {\n        fill: {\n          color: 'red',\n        },\n      },\n    };\n    act(() => {\n      customRef.current.onSelect(event, dataSet1);\n    });\n    await waitFor(() => {\n      expect(customRef.current.state.isTooltipOpen).toBe(true);\n      expect(getTooltipMock).not.toBeNull();\n      expect(getTooltipMock).toHaveBeenCalled();\n      expect(getAllByText('Cats')).toBeTruthy();\n      expect(getByText('1')).toBeTruthy();\n    });\n  });\n\n  //get label\n  it('when label type is percent then getlabel should return value with percentage to the labels in the victorypieComponent', async () => {\n    const WmDonutChartMock = jest.spyOn(WmDonutChart.prototype, 'getLabel');\n    const tree = renderComponent({\n      ...defaultProps,\n      labeltype: 'percent',\n    });\n    const root = tree.getByAccessibilityHint(defaultProps.hint);\n    fireEvent(root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n          height: 22,\n        },\n      },\n    });\n    await waitFor(() => {\n      expect(WmDonutChartMock).toHaveBeenCalled();\n      expect(WmDonutChartMock).toHaveReturnedWith('42%');\n    });\n  });\n\n  it('when label type is key then getlabel should return key to the labels in the victorypieComponent', async () => {\n    const WmDonutChartMock = jest.spyOn(WmDonutChart.prototype, 'getLabel');\n    const tree = renderComponent({\n      ...defaultProps,\n      labeltype: 'key',\n    });\n    const root = tree.getByAccessibilityHint(defaultProps.hint);\n    fireEvent(root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n          height: 122,\n        },\n      },\n    });\n    await waitFor(() => {\n      expect(WmDonutChartMock).toHaveBeenCalled();\n      expect(WmDonutChartMock).toHaveReturnedWith('Cats', 'Dogs', 'Birds');\n    });\n  });\n\n  it('when label type is value then getlabel should return value to the labels in the victorypieComponent', async () => {\n    const WmDonutChartMock = jest.spyOn(WmDonutChart.prototype, 'getLabel');\n    const tree = renderComponent({\n      ...defaultProps,\n      labeltype: 'value',\n    });\n    const root = tree.getByAccessibilityHint(defaultProps.hint);\n    fireEvent(root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n          height: 122,\n        },\n      },\n    });\n    await waitFor(() => {\n      expect(WmDonutChartMock).toHaveBeenCalled();\n      expect(WmDonutChartMock).toHaveReturnedWith('35', '40', '55');\n    });\n  });\n\n  it('when label type is key-value then getlabel should return key-value to the labels in the victorypieComponent', async () => {\n    const WmDonutChartMock = jest.spyOn(WmDonutChart.prototype, 'getLabel');\n    const tree = renderComponent({\n      ...defaultProps,\n      labeltype: 'key-value',\n    });\n    const root = tree.getByAccessibilityHint(defaultProps.hint);\n    fireEvent(root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n          height: 122,\n        },\n      },\n    });\n    await waitFor(() => {\n      expect(WmDonutChartMock).toHaveBeenCalled();\n      expect(WmDonutChartMock).toHaveReturnedWith(\n        'Cats 35',\n        'Dogs 40',\n        'Birds 55'\n      );\n    });\n  });\n\n  //theme\n  it('should render theme', async () => {\n    const tree = renderComponent({\n      ...defaultProps,\n      theme: 'Annabelle',\n    });\n    const root = tree.getByAccessibilityHint(defaultProps.hint);\n\n    fireEvent(root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n        },\n      },\n    });\n    await waitFor(() => {\n      const viewEle1 = tree.UNSAFE_getByType(VictoryPie);\n      expect(viewEle1.props.theme.group.colorScale[0]).toBe('#393b79');\n      expect(viewEle1.props.theme.group.width).toBe(250);\n      expect(viewEle1.props.theme.group.height).toBe(250);\n      expect(viewEle1.props.theme.legend.colorScale[0]).toBe('#393b79');\n      expect(viewEle1.props.theme.legend.orientation).toBe('vertical');\n      expect(viewEle1.props.theme.legend.gutter).toBe(10);\n    });\n  });\n\n  it('should render chart component with default data when dataset is empty', () => {\n    const SAMPLE_DATA1 = {\n      group1: 'Europe',\n      group2: 'Asia',\n      group3: 'America',\n      group4: 'Australia',\n    };\n\n    const { getByText } = renderComponent({\n      xaxisdatakey: 'x',\n      yaxisdatakey: 'y',\n      dataset: [],\n      type: 'Donut',\n    });\n\n    fireEvent(screen.root, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 500,\n        },\n      },\n    });\n    expect(getByText(SAMPLE_DATA1.group1)).toBeTruthy();\n    expect(getByText(SAMPLE_DATA1.group2)).toBeTruthy();\n    expect(getByText(SAMPLE_DATA1.group3)).toBeTruthy();\n    expect(getByText(SAMPLE_DATA1.group4)).toBeTruthy();\n  });\n});\n", "wavemaker-rn-runtime/test/components/basic/button.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport { AccessibilityInfo, Text, TouchableOpacity } from 'react-native';\nimport WmButton from '@wavemaker/app-rn-runtime/components/basic/button/button.component';\nimport {\n  fireEvent,\n  render,\n  waitFor,\n  screen,\n} from '@testing-library/react-native';\nimport WmButtonProps from '@wavemaker/app-rn-runtime/components/basic/button/button.props';\nimport { forEach } from 'lodash-es';\nimport { FontAwesome } from '@expo/vector-icons';\n\nconst defaultProps: WmButtonProps = {\n  //animation: 'fadeIn',\n  // animationdelay: 200,\n  caption: 'Test Button',\n  skeletonheight: undefined,\n  skeletonwidth: undefined,\n  accessibilityrole: 'button',\n  accessibilitylabel: 'test button',\n  hint: 'test button',\n  //badgevalue: '2',\n  //iconclass: 'fa fa-edit',\n  //iconposition: 'left',\n  //iconurl: 'https://wavemaker.com',\n  //iconheight: 20,\n  //iconwidth: 20,\n  //iconmargin: 2,\n  //onTap: jest.fn(),\n};\n\njest.mock('@expo/vector-icons', () => {\n  const { View, Text } = require('react-native');\n  return {\n    FontAwesome: jest.fn().mockImplementation(({ name, ...props }) => {\n      return (\n        <View>\n          <Text {...props}>{name}</Text>\n        </View>\n      );\n    }),\n  };\n});\n\nconst renderComponent = (props = {}) =>\n  render(<WmButton {...defaultProps} {...props} name=\"test_button\" />);\n\n/// properties binding tests\ndescribe('Button component property binding tests', () => {\n  it('should render correctly with default props', () => {\n    const tree = renderComponent();\n    expect(tree).toMatchSnapshot();\n    expect(tree.getByText('Test Button')).toBeTruthy();\n  });\n\n  it('should render with a given caption', () => {\n    const { getByText } = renderComponent({ caption: 'ButtonCaption' });\n    expect(getByText('ButtonCaption')).toBeTruthy();\n  });\n\n  it('should update parts when caption prop changes', () => {\n    const { getByText, rerender } = renderComponent();\n    expect(getByText('Test Button')).toBeTruthy();\n\n    rerender(<WmButton {...defaultProps} caption=\"New Caption\" />);\n    expect(getByText('New Caption')).toBeTruthy();\n  });\n\n  it('should apply accessibility props correctly', async () => {\n    const { getByRole, getByLabelText, getByA11yHint } = renderComponent({\n      name: 'testButton',\n      accessibilitylabel: 'Button',\n      accessibilityrole: 'Button',\n      hint: 'test button',\n      onTap: jest.fn(), // accessiibility props are also in tappable..\n    });\n    expect(getByLabelText('Button')).toBeTruthy();\n    expect(getByRole('Button')).toBeTruthy();\n    expect(getByA11yHint('test button')).toBeTruthy();\n  });\n\n  it('should handle animation props', () => {\n    const tree = renderComponent({\n      animation: 'fadeIn',\n      animationdelay: 500,\n      caption: 'Animated Button',\n      name: 'WmButton',\n    });\n\n    const animatedButton = tree.getByTestId('animatableView');\n    expect(animatedButton).toBeTruthy();\n    expect(animatedButton.props.animation).toBe('fadeIn');\n    expect(animatedButton.props.delay).toBe(500);\n  });\n\n  it('should trigger onTap callback', async () => {\n    const onTapMock = jest.fn();\n    const tree = render(<WmButton onTap={onTapMock} caption=\"Tap\" />);\n\n    fireEvent(tree.getByText('Tap'), 'press');\n\n    await waitFor(() => {\n      expect(onTapMock).toHaveBeenCalled();\n      const callArg = onTapMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmButton);\n    });\n  });\n\n  it('should trigger onDoubleTap callback', async () => {\n    const onDoubleTapMock = jest.fn();\n    const tree = render(\n      <WmButton onDoubletap={onDoubleTapMock} caption=\"DoubleTap\" />\n    );\n\n    fireEvent(tree.getByText('DoubleTap'), 'press');\n    fireEvent(tree.getByText('DoubleTap'), 'press');\n\n    await waitFor(() => {\n      expect(onDoubleTapMock).toHaveBeenCalled();\n      expect(onDoubleTapMock).toHaveBeenCalledTimes(1);\n      const callArg = onDoubleTapMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmButton);\n    });\n  });\n\n  it('should trigger onLongTap callback', async () => {\n    const onLongTapMock = jest.fn();\n    const tree = render(\n      <WmButton onLongtap={onLongTapMock} caption=\"LongTap\" />\n    );\n\n    fireEvent(tree.getByText('LongTap'), 'longPress');\n\n    await waitFor(() => {\n      expect(onLongTapMock).toHaveBeenCalled();\n      const callArg = onLongTapMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmButton);\n    });\n  });\n\n  xit('should trigger onTouchStart callback', async () => {\n    // const onTapMock = jest.fn();\n    const onTouchStartMock = jest.fn();\n    const tree = render(\n      <WmButton\n        // onTap={onTapMock}\n        onTouchstart={onTouchStartMock}\n        caption=\"Touchstart\"\n      />\n    );\n\n    fireEvent(tree.getByText('Touchstart'), 'press');\n\n    await waitFor(() => {\n      expect(onTouchStartMock).toHaveBeenCalled();\n      const callArg = onTouchStartMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmButton);\n    });\n  });\n\n  xit('should trigger onTouchEnd callback', async () => {\n    // const onTapMock = jest.fn(); // in tappable onTouchEnd is not added in the if condition , hence had to add onTap as well\n    const onTouchEndMock = jest.fn();\n    const tree = render(\n      <WmButton\n        // onTap={onTapMock}\n        onTouchend={onTouchEndMock}\n        caption=\"Touchend\"\n      />\n    );\n\n    fireEvent(tree.getByText('Touchend'), 'pressOut');\n\n    await waitFor(() => {\n      expect(onTouchEndMock).toHaveBeenCalled();\n      const callArg = onTouchEndMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmButton);\n    });\n  });\n\n  it('should handle empty or null caption gracefully', () => {\n    const { rerender, queryByTestId } = renderComponent();\n\n    rerender(<WmButton {...defaultProps} caption=\"\" />);\n    expect(queryByTestId('test_button_caption')).toBeNull();\n\n    rerender(<WmButton {...defaultProps} caption={null} />);\n    expect(queryByTestId('test_button_caption')).toBeNull();\n  });\n\n  it('should render with a given badge value', () => {\n    const { getByText } = renderComponent({ badgevalue: 8 });\n    expect(getByText('8')).toBeTruthy();\n  });\n\n  it('should render width and height', () => {\n    const width = 50;\n    const height = 70;\n    const { getByTestId } = renderComponent({\n      styles: {\n        root: {\n          width: width,\n          height: height,\n        },\n      },\n    });\n    const viewEle = getByTestId('non_animatableView');\n    expect(viewEle.props.style[0].width).toBe(width);\n    expect(viewEle.props.style[0].height).toBe(height);\n  });\n\n  it('should have width and height to be 0 when show is false', () => {\n    const { getByTestId } = renderComponent({ show: false });\n\n    const viewEle = getByTestId('non_animatableView');\n    expect(viewEle.props.style[0].width).toBe(0);\n    expect(viewEle.props.style[0].height).toBe(0);\n  });\n\n  it('should render a skeleton with given width and height', () => {\n    const tree = renderComponent({\n      showskeleton: true,\n      skeletonheight: '100',\n      skeletonwidth: '50',\n    });\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('should render skeleton with root width and height when skeleton width and height are not provided', () => {\n    const width = 50;\n    const height = 70;\n    const tree = renderComponent({\n      showskeleton: true,\n      styles: {\n        root: {\n          width: width,\n          height: height,\n        },\n      },\n    });\n\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('should render a disabled button', async () => {\n    const onTapMock = jest.fn();\n    const tree = renderComponent({\n      disabled: true,\n      onTap: onTapMock,\n      caption: 'Tap',\n    });\n    const viewEle = tree.getByTestId('non_animatableView');\n    expect(viewEle.props.style[0].opacity).toBe(0.5);\n\n    fireEvent(tree.getByText('Tap'), 'press');\n\n    await waitFor(() => {\n      expect(onTapMock).not.toHaveBeenCalled();\n    });\n  });\n\n  it('should render custom styles with properly', () => {\n    const bgColor = '#234555';\n    const txtColor = '#325623';\n    const tree = renderComponent({\n      name: 'button',\n      caption: 'Test_button',\n      styles: {\n        root: {\n          backgroundColor: bgColor,\n        },\n        text: {\n          color: txtColor,\n        },\n      },\n    });\n    const viewEle = tree.getByTestId('non_animatableView');\n    const textEle = tree.getByText('Test_button');\n    expect(viewEle.props.style[0].backgroundColor).toBe(bgColor);\n    expect(textEle.props.style.color).toBe(txtColor);\n  });\n\n  it('should render with a icon properly', async () => {\n    const iconProps = {\n      iconclass: 'fa fa-edit',\n      iconposition: 'left',\n      iconheight: 20,\n      iconwidth: 20,\n      iconmargin: 2,\n    };\n\n    const prepareIcon = jest.spyOn(WmButton.prototype, 'prepareIcon');\n    const tree = renderComponent({ ...iconProps });\n\n    await waitFor(() => {\n      expect(prepareIcon).toHaveBeenCalledTimes(1);\n    });\n\n    expect(tree.getByText('edit')).toBeTruthy();\n  });\n});\n", "wavemaker-rn-runtime/test/components/basic/spinner.component.spec.tsx": "import React from 'react';\nimport { Platform, Image } from 'react-native';\nimport Lottie from 'react-lottie-player';\nimport { act, render, waitFor } from '@testing-library/react-native';\nimport WmSpinner from '@wavemaker/app-rn-runtime/components/basic/spinner/spinner.component';\nimport { AssetProvider } from '@wavemaker/app-rn-runtime/core/asset.provider';\n\nconst renderComponent = (props = {}) => {\n  const defaultProps = {\n    id: 'test-spinner',\n    caption: 'Loading...',\n    iconclass: 'fa fa-circle-o-notch fa-spin',\n    iconsize: 30,\n  };\n  const loadAsset = (path) => path;\n\n  return render(\n    <AssetProvider value={loadAsset}>\n      <WmSpinner {...defaultProps} {...props} />\n    </AssetProvider>\n  );\n};\n\njest.mock('react-lottie-player');\n\n//WmPicture mock\njest.mock(\n  '@wavemaker/app-rn-runtime/components/basic/picture/picture.component',\n  () => {\n    const { View, Text, Image } = require('react-native');\n    const CustomComponent = (props) => (\n      <View>\n        <Text>{props.id}</Text>\n        <Image\n          source={{ uri: props.picturesource }}\n          width={props.imagewidth}\n          height={props.imageheight}\n        />\n      </View>\n    );\n\n    return CustomComponent;\n  }\n);\n\ndescribe('Spinner component', () => {\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  test('should render component with default props', () => {\n    const { toJSON, getByText } = renderComponent();\n    expect(getByText('circle-o-notch')).toBeTruthy();\n    expect(getByText('Loading...')).toBeTruthy();\n    expect(toJSON()).toMatchSnapshot();\n  });\n\n  test('should render component with icon when iconclass is provided', () => {\n    const props = {\n      iconclass: 'fa fa-edit fa-spin',\n    };\n    const { toJSON, getByText } = renderComponent(props);\n\n    expect(getByText('edit')).toBeTruthy();\n    expect(toJSON()).toMatchSnapshot();\n  });\n\n  test('renders with image when image is provided', () => {\n    const props = {\n      image:\n        'https://www.wavemaker.com/wp-content/uploads/2024/02/WaveMaker-Logo-1.svg',\n      imageheight: '20',\n      imagewidth: 20,\n    };\n    const { toJSON, UNSAFE_queryByType } = renderComponent(props);\n\n    expect(UNSAFE_queryByType(Image)).toBeTruthy();\n    expect(UNSAFE_queryByType(Image)?.props.source).toMatchObject({\n      uri: props.image,\n    });\n    expect(toJSON()).toMatchSnapshot();\n  });\n\n  xit('renders with lottie when lottie is provided', async () => {\n    (Platform as any).OS = 'ios';\n    const lottieFileName = 'lottieAnimationData.json';\n    const props = {\n      iconclass: null,\n      image: null,\n      lottie: {\n        json: lottieFileName,\n        loader: 'circleSpinner',\n      },\n    };\n    const { toJSON, getByTestId, getByText } = renderComponent(props);\n\n    await waitFor(() => {\n      expect(getByTestId('test-spinner_lottie')).toBeTruthy();\n      expect(getByTestId('test-spinner_lottie').props.sourceName).toBe(\n        lottieFileName\n      );\n      expect(getByText('Loading...')).toBeTruthy();\n      expect(toJSON()).toMatchSnapshot();\n    });\n  });\n\n  test('renders caption when caption is provided', () => {\n    const { getByText } = renderComponent({ caption: 'Please wait...' });\n    const caption = getByText('Please wait...');\n\n    act(() => {\n      expect(caption).toBeTruthy();\n    });\n  });\n\n  test('does not render caption when caption is not provided', () => {\n    const props = { caption: null };\n    const { queryByText } = renderComponent(props);\n\n    const caption = queryByText('Loading...');\n    expect(caption).toBeNull();\n  });\n\n  test('adds lottie colors correctly based on theme', () => {\n    const props = { lottie: 'spinIcon' };\n    const instance = new WmSpinner(props);\n\n    const lottiePath = {\n      json: require('./mockData/lottie-animation.json'),\n    };\n    const coloredLottie = instance.addClasstoLottie(lottiePath);\n\n    expect(coloredLottie).toBeTruthy();\n  });\n\n  test('renders lottie player correctly on web', () => {\n    (Platform as any).OS = 'web'; // Set platform to web\n    const { toJSON, UNSAFE_getByType } = renderComponent({\n      lottie: {\n        json: require('./mockData/lottie-animation.json'),\n        loader: 'circleSpinner',\n      },\n    });\n\n    expect(UNSAFE_getByType(Lottie)).toBeTruthy(); // react-lottie-player won't show in snapshot as its a web component.\n    expect(toJSON()).toMatchSnapshot();\n  });\n});\n", "wavemaker-rn-runtime/test/components/basic/message.component.spec.tsx": "import React from 'react';\nimport { render, fireEvent, waitFor } from '@testing-library/react-native';\nimport WmMessage from '@wavemaker/app-rn-runtime/components/basic/message/message.component';\nimport WmMessageProps from '@wavemaker/app-rn-runtime/components/basic/message/message.props';\nimport { ThemeProvider } from '@wavemaker/app-rn-runtime/styles/theme';\nimport WmButton from '@wavemaker/app-rn-runtime/components/basic/button/button.component';\nimport { Animatedview } from '@wavemaker/app-rn-runtime/components/basic/animatedview.component';\n\n// Mock Theme\nconst mockTheme = {\n  getStyle: (styleName: string) => ({}), // Adjust based on required styles\n  mergeStyle: (style1, style2) => ({ ...style1, ...style2 }),\n};\n\nconst renderWithTheme = (component: React.ReactElement) => {\n  return render(<ThemeProvider value={mockTheme}>{component}</ThemeProvider>);\n};\n\nconst DEFAULT_TITLE = {\n  success: 'Success',\n  warning: 'Warning',\n  error: 'Error',\n  info: 'Info',\n  loading: 'Processing',\n} as any;\n\nconst MESSAGE_ICONS = {\n  success: 'wm-sl-l sl-check',\n  warning: 'wm-sl-l sl-alarm-bell',\n  error: 'fa fa-times-circle',\n  info: 'wi wi-info',\n  loading: 'fa fa-spinner fa-spin',\n};\n\ndescribe('WmMessage', () => {\n  it('renders correctly with default props', () => {\n    const props: WmMessageProps = {};\n\n    const tree = render(<WmMessage {...props} />);\n    expect(tree).toMatchSnapshot();\n    const defaultTitle = tree.getByText('Success'); // Default title for type 'success'\n    const defaultCaption = tree.getByText('Message'); // Default caption\n\n    expect(defaultTitle).toBeTruthy();\n    expect(defaultCaption).toBeTruthy();\n  });\n\n  it('renders with different message types', () => {\n    const types: WmMessageProps['type'][] = [\n      'success',\n      'warning',\n      'error',\n      'info',\n      'loading',\n    ];\n\n    types.forEach((type) => {\n      const props: WmMessageProps = { type };\n\n      const { getByText } = render(<WmMessage {...props} />);\n      const typeTitle = getByText(DEFAULT_TITLE[type]);\n\n      expect(typeTitle).toBeTruthy();\n    });\n  });\n\n  it('renders with custom title and caption', () => {\n    const props: WmMessageProps = {\n      title: 'Custom Title',\n      caption: 'Custom Caption',\n    };\n\n    const { getByText } = render(<WmMessage {...props} />);\n    const customTitle = getByText('Custom Title');\n    const customCaption = getByText('Custom Caption');\n\n    expect(customTitle).toBeTruthy();\n    expect(customCaption).toBeTruthy();\n  });\n\n  it('renders the close button when `hideclose` is false', () => {\n    const props: WmMessageProps = { hideclose: false };\n\n    const { getByText } = render(<WmMessage {...props} />);\n    const closeButton = getByText('close');\n\n    expect(closeButton).toBeTruthy();\n  });\n\n  it('does not render the close button when `hideclose` is true', () => {\n    const props: WmMessageProps = { hideclose: true };\n\n    const { queryByText } = render(<WmMessage {...props} />);\n    expect(queryByText('close')).toBeNull();\n  });\n\n  it('should have width and height to be 0 when show is false', () => {\n    const props = {\n      show: false,\n    };\n    const { getByTestId } = render(<WmMessage {...props} />);\n    const buttonGroup = getByTestId('animatableView');\n\n    expect(buttonGroup.props.style.width).toBe(0);\n    expect(buttonGroup.props.style.height).toBe(0);\n  });\n\n  it('renders with given width and height', () => {\n    const width = 70;\n    const height = 100;\n    const props = {\n      styles: {\n        root: {\n          width: width,\n          height: height,\n        },\n      },\n    };\n    const { getByTestId } = render(<WmMessage {...props} />);\n    const buttonGroup = getByTestId('animatableView');\n\n    expect(buttonGroup.props.style.width).toBe(width);\n    expect(buttonGroup.props.style.height).toBe(height);\n  });\n\n  it('invokes `onClose` callback when the close button is tapped', async () => {\n    const onCloseMock = jest.fn();\n    const props: WmMessageProps = { onClose: onCloseMock };\n\n    const { getByText } = render(<WmMessage {...props} />);\n    const closeButton = getByText('close');\n\n    fireEvent.press(closeButton);\n    await waitFor(() => {\n      expect(onCloseMock).toHaveBeenCalled();\n    });\n  });\n\n  it('applies animation props correctly', () => {\n    const props: WmMessageProps = { animation: 'fadeIn', animationdelay: 100 };\n\n    const { getByTestId } = render(<WmMessage {...props} />);\n    const animatedView = getByTestId('animatableView');\n\n    expect(animatedView.props.animation).toBe('fadeIn');\n    expect(animatedView.props.delay).toBe(100);\n  });\n\n  it('applies accessibility properties correctly', () => {\n    const props: WmMessageProps = {\n      accessibilitylabel: 'test-label',\n      hint: 'test-hint',\n      accessibilityrole: 'alert',\n    };\n\n    const { getAllByLabelText } = render(<WmMessage {...props} />);\n    const elements = getAllByLabelText('test-label');\n    elements.forEach((element) => {\n      expect(element).toBeTruthy();\n      expect(element.props.accessibilityRole).toBe('alert');\n      expect(element.props.accessibilityLabel).toBe('test-label');\n      expect(element.props.accessibilityHint).toBe('test-hint');\n    });\n  });\n\n  it('should handle state changes', () => {\n    const props = { show: true };\n\n    const { getByText, rerender, getByTestId } = render(\n      <WmMessage {...props} />\n    );\n    expect(getByText('Message')).toBeTruthy();\n\n    rerender(<WmMessage {...props} show={false} />);\n\n    const buttonGroup = getByTestId('animatableView');\n\n    expect(buttonGroup.props.style.width).toBe(0);\n    expect(buttonGroup.props.style.height).toBe(0);\n  });\n\n  it('renders correct icon for each message type', () => {\n    const types = ['success', 'warning', 'error', 'info', 'loading'];\n\n    types.forEach((type) => {\n      const props: WmMessageProps = { type };\n\n      const { getByText } = render(<WmMessage {...props} />);\n      switch (type) {\n        case 'success':\n          expect(getByText('check')).toBeTruthy();\n          break;\n        case 'warning':\n          expect(getByText('alarm-bell')).toBeTruthy();\n          break;\n        case 'error':\n          expect(getByText('times-circle')).toBeTruthy();\n          break;\n        case 'info':\n          expect(getByText('info')).toBeTruthy();\n          break;\n        case 'loading':\n          expect(getByText('spinner')).toBeTruthy();\n          break;\n      }\n    });\n  });\n});\n", "wavemaker-rn-runtime/test/components/basic/anchor.component.spec.tsx": "import React from 'react';\nimport WmAnchor from '@wavemaker/app-rn-runtime/components/basic/anchor/anchor.component';\nimport { NavigationServiceProvider } from '@wavemaker/app-rn-runtime/core/navigation.service';\nimport {\n  act,\n  cleanup,\n  fireEvent,\n  render,\n  waitFor,\n} from '@testing-library/react-native';\nimport mockNavigationService from '../../__mocks__/navigation.service';\nimport { AssetProvider } from '@wavemaker/app-rn-runtime/core/asset.provider';\nimport * as WmUtils from '@wavemaker/app-rn-runtime/core/utils';\nimport * as accessibilityUtils from '@wavemaker/app-rn-runtime/core/accessibility';\n\nconst renderComponent = (props = {}) => {\n  const loadAsset = (path) => path;\n\n  return render(\n    <NavigationServiceProvider value={mockNavigationService}>\n      <AssetProvider value={loadAsset}>\n        <WmAnchor {...props} />\n      </AssetProvider>\n    </NavigationServiceProvider>\n  );\n};\n\nconst getStyleObject = (styleArr, styleObj) => {\n  if (!styleArr) return;\n\n  if (!Array.isArray(styleArr)) {\n    Object.keys(styleArr).forEach((key) => {\n      styleObj[key] = styleArr[key];\n    });\n\n    return;\n  }\n\n  styleArr.forEach((item) => {\n    getStyleObject(item, styleObj);\n  });\n\n  return styleObj;\n};\n\ndescribe('Test Anchor component', () => {\n  beforeEach(() => {\n    jest\n      .spyOn(accessibilityUtils, 'isScreenReaderEnabled')\n      .mockReturnValue(false);\n  });\n  afterEach(() => cleanup());\n\n  test('should render anchor component', () => {\n    const tree = renderComponent({\n      id: 'test-anchor',\n      iconclass: 'fa fa-link',\n      iconposition: 'left',\n      caption: 'Click here',\n      hyperlink: 'http://example.com',\n      encodeurl: false,\n      animation: 'bounce',\n      skeletonwidth: '100%',\n      skeletonheight: '100%',\n      badgevalue: 5,\n      onTap: jest.fn(),\n    });\n\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('show render icon along with caption in anchor when iconclass and iconposition is provided in props', () => {\n    const tree = renderComponent({\n      id: 'test-anchor',\n      iconclass: 'fa fa-link',\n      iconposition: 'left',\n      caption: 'Test caption',\n    });\n\n    expect(tree).toMatchSnapshot();\n    expect(tree.queryByText('link')).not.toBeNull();\n    expect(tree.queryByText('Test caption')).not.toBeNull();\n  });\n\n  test('should not trigger navigation when there is no hyperlink', async () => {\n    const onTapMock = jest.fn();\n    const tree = renderComponent({\n      id: 'test-anchor',\n      iconclass: 'fa fa-link',\n      iconposition: 'left',\n      caption: 'Click here',\n      hyperlink: null,\n      onTap: onTapMock,\n    });\n    fireEvent.press(tree.getByText('Click here'));\n\n    await waitFor(() => {\n      expect(onTapMock).toHaveBeenCalled();\n      expect(mockNavigationService.openUrl).not.toHaveBeenCalled();\n    });\n  });\n\n  test('should triggers onTap event prop', async () => {\n    const onTapMock = jest.fn();\n    const tree = renderComponent({\n      id: 'test-anchor',\n      iconclass: 'fa fa-link',\n      iconposition: 'left',\n      caption: 'Click here',\n      onTap: onTapMock,\n    });\n    fireEvent.press(tree.getByText('Click here'));\n\n    await waitFor(() => {\n      expect(onTapMock).toHaveBeenCalled();\n    });\n  });\n\n  test('should triggers onDoubleTap event prop', async () => {\n    const onTapMock = jest.fn();\n    const tree = renderComponent({\n      id: 'test-anchor',\n      iconclass: 'fa fa-link',\n      iconposition: 'left',\n      caption: 'Click here',\n      onDoubleTap: onTapMock,\n    });\n    fireEvent.press(tree.getByText('Click here'));\n    fireEvent.press(tree.getByText('Click here'));\n\n    await waitFor(() => {\n      expect(onTapMock).toHaveBeenCalled();\n    });\n  });\n\n  test('should triggers onLongTap event prop', async () => {\n    const onTapMock = jest.fn();\n    const tree = renderComponent({\n      id: 'test-anchor',\n      iconclass: 'fa fa-link',\n      iconposition: 'left',\n      caption: 'Click here',\n      onLongTap: onTapMock,\n    });\n    fireEvent(tree.getByText('Click here'), 'longPress');\n\n    await waitFor(() => {\n      expect(onTapMock).toHaveBeenCalled();\n    });\n  });\n\n  test('should trigger navigation on hyperlink tap', async () => {\n    const tree = renderComponent({\n      id: 'test-anchor',\n      iconclass: 'fa fa-link',\n      iconposition: 'left',\n      caption: 'Click here',\n      hyperlink: 'http://example.com',\n      encodeurl: false,\n      target: '_top',\n      onTap: jest.fn(),\n    });\n    fireEvent.press(tree.getByText('Click here'));\n\n    await waitFor(() => {\n      expect(mockNavigationService.openUrl).toHaveBeenCalledWith(\n        'http://example.com',\n        { target: '_top' }\n      );\n    });\n  });\n\n  test('should trigger navigation on hyperlink tap with the provided hyper link and target to be \"_blank\" when target is not passed in props', async () => {\n    const tree = renderComponent({\n      id: 'test-anchor',\n      iconclass: 'fa fa-link',\n      iconposition: 'left',\n      caption: 'Click here',\n      hyperlink: 'http://example.com',\n      onTap: jest.fn(),\n    });\n    fireEvent.press(tree.getByText('Click here'));\n\n    await waitFor(() => {\n      expect(mockNavigationService.openUrl).toHaveBeenCalledWith(\n        'http://example.com',\n        { target: '_blank' }\n      );\n    });\n  });\n\n  test('should render skeleton when showskeleton is true', () => {\n    const tree = renderComponent({\n      showskeleton: true,\n      skeletonheight: '100',\n      skeletonwidth: '50',\n      name: 'wm-anchor',\n    });\n\n    expect(tree.queryByTestId('test-anchor_caption')).toBeNull();\n    expect(tree).toMatchSnapshot();\n  });\n\n  //TODO: find a way to set animate state as true in WmSkeleton component.\n  test('should render skeleton when showskeleton is true and should take roots height and width', async () => {\n    const tree = renderComponent({\n      showskeleton: true,\n      name: 'wm-anchor',\n      styles: {\n        root: {\n          width: 80,\n          height: 80,\n        },\n      },\n    });\n\n    await waitFor(() => {\n      expect(tree).toMatchSnapshot();\n      expect(tree.toJSON().props.style.height).toBe(80);\n      expect(tree.toJSON().props.style.width).toBe(80);\n    });\n  });\n\n  test('should render skeleton when showskeleton is true with skeletonheight and skeletonwidth', async () => {\n    const tree = renderComponent({\n      showskeleton: true,\n      skeletonheight: 88,\n      skeletonwidth: 89,\n      name: 'wm-anchor',\n    });\n\n    await waitFor(() => {\n      expect(tree).toMatchSnapshot();\n      expect(tree.toJSON().props.style.height).toBe(88);\n      expect(tree.toJSON().props.style.width).toBe(89);\n    });\n  });\n\n  test('should not render when show props is \"false', () => {\n    const tree = renderComponent({\n      id: 'test-anchor',\n      iconclass: 'fa fa-link',\n      iconposition: 'left',\n      caption: 'Click here',\n      show: false,\n    });\n\n    expect(tree.toJSON().props.style).toMatchObject({ width: 0, height: 0 });\n  });\n\n  test('should render the badge correctly for badge value', () => {\n    const tree = renderComponent({\n      id: 'test-anchor',\n      iconclass: 'fa fa-link',\n      iconposition: 'left',\n      caption: 'Click here',\n      hyperlink: 'http://example.com',\n      encodeurl: false,\n      animation: 'bounce',\n      skeletonwidth: '100%',\n      skeletonheight: '100%',\n      badgevalue: 10,\n    });\n    const badgeElement = tree.getByText('10');\n\n    expect(badgeElement).toHaveProperty('children', ['10']);\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('renders icon as per given iconClass and iconPosition', () => {\n    const tree = renderComponent({\n      id: 'test-anchor',\n      caption: 'Click here',\n      hyperlink: 'http://example.com',\n      encodeurl: false,\n      animation: 'bounce',\n      skeletonwidth: '100%',\n      skeletonheight: '100%',\n      iconclass: 'fa fa-home',\n      iconposition: 'top',\n      accessibilitylabel: 'wm-icon',\n    });\n\n    expect(tree.queryByText('home')).not.toBeNull();\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render accessibility properties correctly', () => {\n    const tree = renderComponent({\n      id: 'test-anchor',\n      caption: 'Click here',\n      hyperlink: 'http://example.com',\n      encodeurl: false,\n      animation: 'bounce',\n      skeletonwidth: '100%',\n      skeletonheight: '100%',\n      iconclass: 'fa fa-home',\n      iconposition: 'top',\n      accessibilitylabel: 'Anchor',\n      hint: 'Go to example.com',\n    });\n    const anchorComponent = tree.queryByA11yHint('Go to example.com');\n\n    expect(anchorComponent).not.toBeNull();\n    expect(tree.queryByLabelText('Anchor')).not.toBeNull();\n    expect(tree.queryByAccessibilityHint('Go to example.com')).not.toBeNull();\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('handles icon related styles and properties correctly', () => {\n    const iconUrl = 'https://docs.wavemaker.com/learn/img/WM_blue_logo.png';\n\n    const tree = renderComponent({\n      iconwidth: 20,\n      iconheight: 20,\n      name: 'test-anchor',\n      iconposition: 'left',\n      accessibilitylabel: 'anchor',\n      iconurl: iconUrl,\n      iconmargin: 10,\n      badge: 10,\n    });\n    const iconComponent = tree.getByTestId('test-anchor_icon_icon');\n\n    expect(iconComponent.props.style.height).toBe(20);\n    expect(iconComponent.props.style.width).toBe(20);\n    expect(iconComponent.props.style.margin).toBe(10);\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should encode URL when encodeurl is true', async () => {\n    const encodeUrl = jest.spyOn(WmUtils, 'encodeUrl');\n\n    const tree = renderComponent({\n      id: 'test-anchor',\n      iconclass: 'fa fa-link',\n      iconposition: 'left',\n      caption: 'Click here',\n      animation: 'bounce',\n      skeletonwidth: '100%',\n      skeletonheight: '100%',\n      badgevalue: 5,\n      onTap: jest.fn(),\n      hyperlink: 'http://example.com',\n      encodeurl: true,\n    });\n    fireEvent.press(tree.getByText('Click here'));\n\n    await waitFor(() => {\n      expect(mockNavigationService.openUrl).toHaveBeenCalledWith(\n        'http://example.com',\n        {\n          target: '_blank',\n        }\n      );\n\n      expect(encodeUrl).toHaveBeenCalled();\n    });\n  });\n\n  test('should render caption with default value as \"Link\"', async () => {\n    const tree = renderComponent({\n      id: 'test-anchor',\n      iconclass: 'fa fa-link',\n      iconposition: 'left',\n      animation: 'bounce',\n      skeletonwidth: '100%',\n      skeletonheight: '100%',\n      badgevalue: 5,\n      onTap: jest.fn(),\n    });\n\n    expect(tree).toMatchSnapshot();\n    expect(tree.queryByText('Link')).not.toBeNull(); // default value of caption is \"Link\".\n  });\n\n  test('should not render caption when falsy value is passed in caption', async () => {\n    const tree = renderComponent({\n      id: 'test-anchor',\n      iconclass: 'fa fa-link',\n      iconposition: 'left',\n      caption: '',\n      animation: 'bounce',\n      skeletonwidth: '100%',\n      skeletonheight: '100%',\n      badgevalue: 5,\n      onTap: jest.fn(),\n    });\n\n    expect(tree).toMatchSnapshot();\n    expect(tree.queryByText('Link')).toBeNull(); // default value of caption is \"Link\".\n  });\n\n  test('should render icon to the right of caption when iconposition is \"right\"', () => {\n    const tree = renderComponent({\n      id: 'test-anchor',\n      iconclass: 'fa fa-link',\n      iconposition: 'right',\n      caption: 'Click here',\n      animation: 'bounce',\n      skeletonwidth: '100%',\n      skeletonheight: '100%',\n      badgevalue: 5,\n      onTap: jest.fn(),\n    });\n\n    const startingIndex = 1; // as first component is background component;\n    const anchorChildren = tree.getByTestId('test-anchor_a').children;\n    const anchorStyleArr = tree.getByTestId('test-anchor_a').props.style;\n    const anchorStyle = getStyleObject(anchorStyleArr, {});\n\n    expect(anchorStyle).toMatchObject({ flexDirection: 'row' });\n    expect(anchorChildren[startingIndex].props.accessibilityLabel).toBe(\n      'Click here'\n    );\n    expect(anchorChildren[startingIndex + 1].props.iconclass).toBe(\n      'fa fa-link'\n    );\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render icon to the left of caption when iconposition is \"left\"', () => {\n    const tree = renderComponent({\n      id: 'test-anchor',\n      iconclass: 'fa fa-link',\n      iconposition: 'left',\n      caption: 'Click here',\n      animation: 'bounce',\n      skeletonwidth: '100%',\n      skeletonheight: '100%',\n      badgevalue: 5,\n      onTap: jest.fn(),\n    });\n\n    const startingIndex = 1; // as first component is background component;\n    const anchorChildren = tree.getByTestId('test-anchor_a').children;\n    const anchorStyleArr = tree.getByTestId('test-anchor_a').props.style;\n    const anchorStyle = getStyleObject(anchorStyleArr, {});\n\n    expect(anchorStyle).toMatchObject({ flexDirection: 'row' });\n    expect(anchorChildren[startingIndex].props.iconclass).toBe('fa fa-link');\n    expect(anchorChildren[startingIndex + 1].props.accessibilityLabel).toBe(\n      'Click here'\n    );\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render icon to the top of caption when iconposition is \"top\"', () => {\n    const tree = renderComponent({\n      id: 'test-anchor',\n      iconclass: 'fa fa-link',\n      iconposition: 'top',\n      caption: 'Click here',\n      animation: 'bounce',\n      skeletonwidth: '100%',\n      skeletonheight: '100%',\n      badgevalue: 5,\n      onTap: jest.fn(),\n    });\n\n    const startingIndex = 1; // as first component is background component;\n    const anchorChildren = tree.getByTestId('test-anchor_a').children;\n    const anchorStyleArr = tree.getByTestId('test-anchor_a').props.style;\n    const anchorStyle = getStyleObject(anchorStyleArr, {});\n\n    expect(anchorStyle).toMatchObject({ flexDirection: 'column' });\n    expect(anchorChildren[startingIndex].props.iconclass).toBe('fa fa-link');\n    expect(anchorChildren[startingIndex + 1].props.accessibilityLabel).toBe(\n      'Click here'\n    );\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('tappable component in anchor should take 100% of width and height when root height and with is provided ', () => {\n    const tree = renderComponent({\n      id: 'test-anchor',\n      iconclass: 'fa fa-link',\n      iconposition: 'right',\n      caption: 'Click here',\n      animation: 'bounce',\n      badgevalue: 5,\n      onTap: jest.fn(),\n      styles: {\n        root: {\n          height: 81,\n          width: 83,\n        },\n      },\n    });\n\n    expect(tree.toJSON().props.style).toMatchObject({\n      height: 81,\n      width: 83,\n    });\n    expect(tree).toMatchSnapshot();\n  });\n});\n", "wavemaker-rn-runtime/test/components/basic/modal.component.spec.tsx": "import React from 'react';\nimport { Modal, Text } from 'react-native';\nimport WmModal from '@wavemaker/app-rn-runtime/components/basic/modal/modal.component';\nimport { render } from '@testing-library/react-native';\nimport { TestIdPrefixProvider } from '@wavemaker/app-rn-runtime/core/testid.provider';\n\nconst renderComponent = (props = {}) => {\n  const defaultProps = {\n    id: 'test-modal',\n    show: true,\n    animationType: 'slide',\n    styles: {\n      root: { backgroundColor: 'rgba(0, 0, 0, 0.5)' },\n      content: { borderColor: 'red', borderWidth: 2 },\n    },\n    children: <Text>Modal Content</Text>,\n  };\n  return render(\n    <TestIdPrefixProvider value={'unit-test'}>\n      <WmModal {...defaultProps} {...props} />\n    </TestIdPrefixProvider>\n  );\n};\n\ndescribe('Modal component', () => {\n  test('renders the WmModal with given props', () => {\n    const tree = renderComponent();\n\n    expect(tree.getByText('Modal Content')).toBeTruthy();\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('applies the correct animation type', () => {\n    const tree = renderComponent({ animationType: 'fade' });\n\n    expect(tree.UNSAFE_getByType(Modal).props.animationType).toBe('fade');\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('applies styles correctly from props', () => {\n    const tree = renderComponent();\n    const rootStyle = tree.toJSON().props.style;\n    const contentStyle = tree.toJSON().children[0].props.style;\n\n    expect(rootStyle).toEqual(\n      expect.objectContaining({ backgroundColor: 'rgba(0, 0, 0, 0.5)' })\n    );\n    expect(contentStyle).toEqual(\n      expect.objectContaining({ borderColor: 'red', borderWidth: 2 })\n    );\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('applies default styles if no custom styles provided', () => {\n    const tree = renderComponent({ styles: {} });\n    const rootStyle = tree.toJSON().props.style;\n    const contentStyle = tree.toJSON().children[0].props.style;\n\n    expect(rootStyle).not.toEqual(undefined);\n    expect(contentStyle).not.toEqual(undefined);\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('renders children correctly', () => {\n    const tree = renderComponent({\n      children: <Text>Custom Modal Content</Text>,\n    });\n\n    expect(tree.getByText('Custom Modal Content')).toBeTruthy();\n    expect(tree).toMatchSnapshot();\n  });\n\n  xit('renders correctly when modal is hidden', () => {\n    const tree = renderComponent({ show: false });\n\n    expect(tree.queryByText('Modal Content')).toBeNull();\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('renders centered modal when centered styles are applied', () => {\n    const tree = renderComponent({\n      styles: {\n        root: {\n          flex: 1,\n          justifyContent: 'center',\n          alignItems: 'center',\n          alignSelf: 'center',\n          backgroundColor: 'rgba(0, 0, 0, 0.5)',\n        },\n        content: {\n          alignSelf: 'center',\n          borderColor: 'blue',\n          borderWidth: 2,\n        },\n      },\n    });\n\n    const rootStyle = tree.toJSON().props.style;\n    const contentStyle = tree.toJSON().children[0].props.style;\n\n    expect(rootStyle).toEqual(\n      expect.objectContaining({\n        flex: 1,\n        justifyContent: 'center',\n        alignItems: 'center',\n        alignSelf: 'center',\n      })\n    );\n    expect(contentStyle).toEqual(\n      expect.objectContaining({\n        alignSelf: 'center',\n        borderColor: 'blue',\n        borderWidth: 2,\n      })\n    );\n    expect(tree).toMatchSnapshot();\n  });\n});\n", "wavemaker-rn-runtime/test/components/basic/progress-circle.component.spec.tsx": "// progress-circle.test.tsx\nimport React, { createRef } from 'react';\nimport {\n  fireEvent,\n  render,\n  screen,\n  waitFor,\n} from '@testing-library/react-native';\nimport { Text } from 'react-native';\n\nimport '@testing-library/jest-native/extend-expect';\nimport WmProgressCircle from '@wavemaker/app-rn-runtime/components/basic/progress-circle/progress-circle.component';\nimport WmProgressCircleProps from '@wavemaker/app-rn-runtime/components/basic/progress-circle/progress-circle.props';\nimport { AnimatedCircularProgress } from 'react-native-circular-progress';\nimport { Tappable } from '../../../src/core/tappable.component';\nimport Color from 'color';\nimport ThemeVariables from '../../../src/styles/theme.variables';\n\n// Mock AnimatedCircularProgress due to its inherent animations\njest.mock('react-native-circular-progress', () => ({\n  AnimatedCircularProgress: jest.fn(),\n}));\n\nconst themeVariables = new ThemeVariables();\n\ndescribe('WmProgressCircle', () => {\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  xit('renders correctly with default props', () => {\n    render(<WmProgressCircle />);\n    expect(screen.getByRole('progresscircle')).toBeTruthy();\n    const animatedProgress = screen.UNSAFE_getByType(AnimatedCircularProgress);\n    expect(animatedProgress.props.fill).toBe(\n      new WmProgressCircleProps().datavalue\n    );\n    expect(screen).toMatchSnapshot();\n  });\n\n  it('calculates the progress value correctly', () => {\n    render(<WmProgressCircle datavalue={50} minvalue={0} maxvalue={100} />);\n    const animatedProgress = screen.UNSAFE_getByType(AnimatedCircularProgress);\n    expect(animatedProgress.props.fill).toBe(50);\n  });\n\n  it('renders title and subtitle when captionplacement is not hidden', async () => {\n    const props = {\n      datavalue: 50,\n      minvalue: 0,\n      maxvalue: 100,\n      title: 'Test Title',\n      subtitle: 'Test Subtitle',\n    };\n    render(<WmProgressCircle {...props} />);\n    const animatedProgressChild = screen\n      .UNSAFE_getByType(AnimatedCircularProgress)\n      .props.children();\n    const textElements = animatedProgressChild.props.children;\n    expect(textElements[0].props.children).toBe(props.title);\n    expect(textElements[1].props.children).toBe(props.subtitle);\n  });\n\n  xit('applies accessibility properties correctly', () => {\n    render(\n      <WmProgressCircle\n        accessibilitylabel=\"ProgressCircle\"\n        hint=\"progresscircle\"\n      />\n    );\n    expect(screen.getByLabelText('ProgressCircle')).toBeTruthy();\n    expect(screen.getByRole('progresscircle')).toBeTruthy();\n    expect(screen.getByA11yHint('progresscircle')).toBeTruthy();\n  });\n\n  it('calculates radius on layout change', async () => {\n    const ref = createRef();\n    const { getByTestId } = render(\n      <WmProgressCircle datavalue={50} ref={ref} />\n    );\n\n    const updateStateMock = jest.spyOn(\n      WmProgressCircle.prototype,\n      'updateState'\n    );\n    ref.current.onLayout({\n      nativeEvent: { layout: { width: 100, height: 50 } },\n    });\n    await waitFor(() => {\n      expect(updateStateMock).toHaveBeenCalled();\n      expect(ref.current.state.radius).toBe(50);\n    });\n\n    ref.current.onLayout({\n      nativeEvent: { layout: { width: 100 } },\n    });\n\n    await waitFor(() => {\n      expect(updateStateMock).toHaveBeenCalled();\n      expect(ref.current.state.radius).toBe(100);\n    });\n\n    ref.current.onLayout({\n      nativeEvent: { layout: { height: 50 } },\n    });\n\n    await waitFor(() => {\n      expect(updateStateMock).toHaveBeenCalled();\n      expect(ref.current.state.radius).toBe(50);\n    });\n  });\n\n  xit('hides text when caption placement is hidden', () => {\n    render(<WmProgressCircle captionplacement=\"hidden\" />);\n    const asdf = screen.getByTestId('undefined_title');\n    const animatedProgressChild = screen\n      .UNSAFE_getByType(AnimatedCircularProgress)\n      .props.children();\n    const textElements = animatedProgressChild.props.children;\n    expect(textElements[0].props.children).toBe('');\n  });\n\n  it('should trigger onTap callback with WmProgressCircle instance as one of the arguments', async () => {\n    const onTapMock = jest.fn();\n    const tree = render(<WmProgressCircle onTap={onTapMock} />);\n    const animatedCircularProgress = tree.UNSAFE_getByType(\n      AnimatedCircularProgress\n    );\n    fireEvent(animatedCircularProgress, 'press');\n\n    await waitFor(() => {\n      expect(onTapMock).toHaveBeenCalled();\n      const callArg = onTapMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmProgressCircle);\n    });\n  });\n\n  it('should trigger onDoubleTap callback with WmProgressCircle instance as one of the arguments', async () => {\n    const onDoubleTapMock = jest.fn();\n    const tree = render(<WmProgressCircle onDoubletap={onDoubleTapMock} />);\n    const animatedCircularProgress = tree.UNSAFE_getByType(\n      AnimatedCircularProgress\n    );\n    fireEvent(animatedCircularProgress, 'press');\n    fireEvent(animatedCircularProgress, 'press');\n\n    await waitFor(() => {\n      expect(onDoubleTapMock).toHaveBeenCalled();\n      const callArg = onDoubleTapMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmProgressCircle);\n    });\n  });\n\n  it('should trigger onLongTap callback with WmProgressCircle instance as one of the arguments', async () => {\n    const onLongTapMock = jest.fn();\n    const tree = render(<WmProgressCircle onLongtap={onLongTapMock} />);\n    const animatedCircularProgress = tree.UNSAFE_getByType(\n      AnimatedCircularProgress\n    );\n    fireEvent(animatedCircularProgress, 'longPress');\n\n    await waitFor(() => {\n      expect(onLongTapMock).toHaveBeenCalled();\n      const callArg = onLongTapMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmProgressCircle);\n    });\n  });\n\n  xit('should trigger onTouchStart callback with WmProgressCircle instance as one of the arguments', async () => {\n    // const onTapMock = jest.fn();\n    const onTouchStartMock = jest.fn();\n    const tree = render(\n      <WmProgressCircle\n        // onTap={onTapMock}\n        onTouchstart={onTouchStartMock}\n      />\n    );\n    const animatedCircularProgress = tree.UNSAFE_getByType(\n      AnimatedCircularProgress\n    );\n    fireEvent(animatedCircularProgress, 'press');\n\n    await waitFor(() => {\n      expect(onTouchStartMock).toHaveBeenCalled();\n      const callArg = onTouchStartMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmProgressCircle);\n    });\n  });\n\n  xit('should trigger onTouchEnd callback with WmProgressCircle instance as one of the arguments', async () => {\n    // const onTapMock = jest.fn();\n    const onTouchEndMock = jest.fn();\n    const tree = render(\n      <WmProgressCircle\n        // onTap={onTapMock}\n        onTouchend={onTouchEndMock}\n      />\n    );\n    const animatedCircularProgress = tree.UNSAFE_getByType(\n      AnimatedCircularProgress\n    );\n    fireEvent(animatedCircularProgress, 'pressOut');\n\n    await waitFor(() => {\n      expect(onTouchEndMock).toHaveBeenCalled();\n      const callArg = onTouchEndMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmProgressCircle);\n    });\n  });\n\n  it('should have width and height to be 0 when show is false', () => {\n    const tree = render(<WmProgressCircle show={false} />);\n    const rootElement = tree.root;\n    expect(rootElement.props.style.width).toBe(0);\n    expect(rootElement.props.style.height).toBe(0);\n  });\n\n  it('should render with style defined for the respective type', () => {\n    const props = {\n      type: 'success',\n    };\n    render(<WmProgressCircle {...props} />);\n    const animatedCircularProgress = screen.UNSAFE_getByType(\n      AnimatedCircularProgress\n    );\n    expect(animatedCircularProgress.props.backgroundColor).toBe(\n      Color(themeVariables.progressCircleSuccessColor)\n        .fade(0.8)\n        .rgb()\n        .toString()\n    );\n  });\n});\n", "wavemaker-rn-runtime/test/components/basic/progress-bar.component.spec.tsx": "import React from 'react';\nimport {\n  act,\n  fireEvent,\n  render,\n  waitFor,\n} from '@testing-library/react-native';\nimport WmProgressBar from '@wavemaker/app-rn-runtime/components/basic/progress-bar/progress-bar.component';\nimport WmProgressBarProps from '@wavemaker/app-rn-runtime/components/basic/progress-bar/progress-bar.props';\nimport ThemeVariables from '../../../src/styles/theme.variables';\nimport Color from 'color';\n\ndescribe('WmProgressBar Component', () => {\n  const commonProps: WmProgressBarProps = {\n    type: 'default',\n    datavalue: 30,\n    minvalue: 0,\n    maxvalue: 100,\n  };\n  const themeVariables = new ThemeVariables();\n\n  it('should render with default properties', () => {\n    const tree = render(<WmProgressBar {...commonProps} />);\n    act(() => {\n      jest.runAllTimers();\n    });\n    expect(tree.getByRole('progressbar')).toBeTruthy();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('should render with different datavalue, minvalue, and maxvalue', () => {\n    const props: WmProgressBarProps = {\n      ...commonProps,\n      datavalue: 40,\n      minvalue: 0,\n      maxvalue: 80,\n    };\n\n    let value =\n      ((props.datavalue - props.minvalue) / (props.maxvalue - props.minvalue)) *\n      100;\n\n    const { getByRole } = render(<WmProgressBar {...props} />);\n    act(() => {\n      jest.runAllTimers();\n    });\n    const progressBar = getByRole('progressbar');\n    expect(progressBar).toBeTruthy();\n\n    fireEvent(progressBar, 'layout', {nativeEvent : {\n      layout: { width : 100}\n    }})\n\n    const animatedStyle = progressBar.props.children.props.children.props.style[1]\n    const expectedValue = animatedStyle.transform[0].translateX._parent._value * 100 \n    expect(expectedValue).toBe(value);\n\n  });\n\n  it('should render with style defined for the respective type', () => {\n    const props: WmProgressBarProps = {\n      ...commonProps,\n      type: 'success',\n    };\n    const { getByRole } = render(<WmProgressBar {...props} />);\n    act(() => {\n      jest.runAllTimers();\n    });\n    const progressBar = getByRole('progressbar');\n\n    expect(progressBar).toBeTruthy();\n    const progressBarChildView = progressBar._fiber.stateNode.children[0];\n    expect(progressBarChildView.props.style.backgroundColor).toBe(\n      Color(themeVariables.progressBarSuccessColor).alpha(0.2).rgb().toString()\n    );\n  });\n\n  xit('should render with accessibility properties', () => {\n    const props = {\n      ...commonProps,\n      accessibilitylabel: 'Loading progress',\n      hint: 'progressbar',\n    };\n    const { getByLabelText, getByRole, getByA11yHint } = render(\n      <WmProgressBar {...props} />\n    );\n    act(() => {\n      jest.runAllTimers();\n    });\n    const progressBar = getByLabelText('Loading progress');\n\n    expect(progressBar).toBeTruthy();\n    expect(getByRole('progressbar')).toBeTruthy();\n    expect(getByLabelText(props.accessibilitylabel)).toBeTruthy();\n    expect(getByA11yHint(props.hint)).toBeTruthy();\n  });\n\n  it('should render with given linear gradient background', () => {\n    const props = {\n      ...commonProps,\n      styles: {\n        root: {\n          progressBar: {\n            backgroundColor:\n              'linear-gradient(90deg, rgba(255,0,0,1), rgba(0,0,255,1))',\n          },\n        },\n      },\n    };\n    const tree = render(<WmProgressBar {...props} />);\n\n    expect(tree.root.props.style.progressBar.backgroundColor).toBe(\n      'linear-gradient(90deg, rgba(255,0,0,1), rgba(0,0,255,1))'\n    );\n  });\n\n  it('should handle datavalue greater than maxvalue', () => {\n    const props: WmProgressBarProps = {\n      ...commonProps,\n      datavalue: 110,\n      maxvalue: 100,\n    };\n    const { getByRole } = render(<WmProgressBar {...props} />);\n    act(() => {\n      jest.runAllTimers();\n    });\n    const progressBar = getByRole('progressbar');\n    expect(progressBar).toBeTruthy();\n  });\n\n  it('should handle datavalue less than minvalue', () => {\n    const props: WmProgressBarProps = {\n      ...commonProps,\n      datavalue: -10,\n      minvalue: 0,\n    };\n    const { getByRole } = render(<WmProgressBar {...props} />);\n    act(() => {\n      jest.runAllTimers();\n    });\n    const progressBar = getByRole('progressbar');\n    expect(progressBar).toBeTruthy();\n  });\n\n  it('should trigger onTap callback with WmProgressBar instance as one of the arguments', async () => {\n    const onTapMock = jest.fn();\n    const tree = render(<WmProgressBar onTap={onTapMock} />);\n\n    fireEvent(tree.getByRole('progressbar'), 'press');\n\n    await waitFor(() => {\n      expect(onTapMock).toHaveBeenCalled();\n      const callArg = onTapMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmProgressBar);\n    });\n  });\n\n  it('should trigger onDoubleTap callback with WmProgressBar instance as one of the arguments', async () => {\n    const onDoubleTapMock = jest.fn();\n    const tree = render(<WmProgressBar onDoubletap={onDoubleTapMock} />);\n\n    fireEvent(tree.getByRole('progressbar'), 'press');\n    fireEvent(tree.getByRole('progressbar'), 'press');\n\n    await waitFor(() => {\n      expect(onDoubleTapMock).toHaveBeenCalled();\n      const callArg = onDoubleTapMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmProgressBar);\n    });\n  });\n\n  it('should trigger onLongTap callback with WmProgressBar instance as one of the arguments', async () => {\n    const onLongTapMock = jest.fn();\n    const tree = render(<WmProgressBar onLongtap={onLongTapMock} />);\n\n    fireEvent(tree.getByRole('progressbar'), 'longPress');\n\n    await waitFor(() => {\n      expect(onLongTapMock).toHaveBeenCalled();\n      const callArg = onLongTapMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmProgressBar);\n    });\n  });\n\n  xit('should trigger onTouchStart callback with WmProgressBar instance as one of the arguments', async () => {\n    // const onTapMock = jest.fn();\n    const onTouchStartMock = jest.fn();\n    const tree = render(\n      <WmProgressBar\n        //  onTap={onTapMock}\n        onTouchstart={onTouchStartMock}\n      />\n    );\n\n    fireEvent(tree.getByRole('progressbar'), 'press');\n\n    await waitFor(() => {\n      expect(onTouchStartMock).toHaveBeenCalled();\n      const callArg = onTouchStartMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmProgressBar);\n    });\n  });\n\n  xit('should trigger onTouchEnd callback with WmProgressBar instance as one of the arguments', async () => {\n    // const onTapMock = jest.fn();\n    const onTouchEndMock = jest.fn();\n    const tree = render(\n      <WmProgressBar\n        // onTap={onTapMock}\n        onTouchend={onTouchEndMock}\n      />\n    );\n\n    fireEvent(tree.getByRole('progressbar'), 'pressOut');\n\n    await waitFor(() => {\n      expect(onTouchEndMock).toHaveBeenCalled();\n      const callArg = onTouchEndMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmProgressBar);\n    });\n  });\n\n  it('should have width and height to be 0 when show is false', () => {\n    const tree = render(<WmProgressBar {...commonProps} show={false} />);\n    act(() => {\n      jest.runAllTimers();\n    });\n    const rootElement = tree.root;\n    expect(rootElement.props.style.width).toBe(0);\n    expect(rootElement.props.style.height).toBe(0);\n  });\n});\n", "wavemaker-rn-runtime/test/components/basic/search.component.spec.tsx": "import React, { createRef } from 'react';\nimport {\n  render,\n  fireEvent,\n  waitFor,\n  act,\n  screen,\n  cleanup,\n} from '@testing-library/react-native';\nimport WmSearch, {\n  WmSearchState,\n} from '@wavemaker/app-rn-runtime/components/basic/search/search.component';\nimport WmSearchProps from '@wavemaker/app-rn-runtime/components/basic/search/search.props';\nimport { ModalProvider } from '@wavemaker/app-rn-runtime/core/modal.service';\nimport { TextInput } from 'react-native';\nimport { DataProvider } from '@wavemaker/app-rn-runtime/components/basic/search/local-data-provider';\nimport AppModalService from '@wavemaker/app-rn-runtime/runtime/services/app-modal.service';\nimport { AssetProvider } from '@wavemaker/app-rn-runtime/core/asset.provider';\nimport { Platform } from 'react-native';\n\nconst dataItems = [\n  {\n    name: 'name0',\n    dataValue: 'dataValue0',\n  },\n  {\n    name: 'name1',\n    dataValue: 'dataValue1',\n  },\n  {\n    name: 'name2',\n    dataValue: 'dataValue2',\n  },\n];\n\nconst timer = (time = 100) =>\n  new Promise((resolve: any, reject) => {\n    setTimeout(() => resolve(), time);\n  });\n\nconst loadAsset = (path) => path;\n\nconst defaultProps: WmSearchProps = {\n  autofocus: false,\n  query: '',\n  searchkey: '',\n  type: 'search',\n  datacompletemsg: 'No more data to load',\n  placeholder: 'Search',\n  limit: 0,\n  minchars: 0,\n  imagewidth: 32,\n  imageheight: 32,\n  searchon: 'typing',\n  onSubmit: jest.fn(),\n  onChange: jest.fn(),\n  result: [],\n  showclear: false,\n  showSearchIcon: true,\n  invokeEvent: jest.fn(),\n  formFieldInstance: undefined,\n  accessibilitylabel: undefined,\n  hint: undefined,\n  accessibilityrole: 'search',\n  renderitempartial: (item: any, index: number, partialName: string) =>\n    React.ReactNode,\n};\n\nAppModalService.modalsOpened = [];\n\nfunction renderComponentWithWrappers(props = {}) {\n  return render(\n    <ModalProvider value={AppModalService}>\n      <AssetProvider value={loadAsset}>\n        <WmSearch\n          {...defaultProps}\n          searchon=\"typing\"\n          dataset={dataItems}\n          searchkey=\"name\"\n          datafield=\"name\"\n          displaylabel=\"name\"\n          // type=\"autocomplete\"\n          {...props}\n        />\n      </AssetProvider>\n    </ModalProvider>\n  );\n}\n\nfunction mapValues(response) {\n  return response.map((item) => ({\n    name: item.displayfield,\n    dataValue: item.datafield,\n  }));\n}\n\ndescribe('WmSearch Component', () => {\n  const invokeEventCallback = jest.spyOn(\n    WmSearch.prototype,\n    'invokeEventCallback'\n  );\n  const updateState = jest.spyOn(WmSearch.prototype, 'updateState');\n\n  beforeEach(() => {\n    // AppModalService.modalsOpened = [];\n  });\n\n  afterEach(() => {\n    AppModalService.modalsOpened = [];\n    jest.clearAllMocks();\n    jest.resetModules();\n    cleanup();\n  });\n\n  it('should render the component correctly', () => {\n    const tree = render(<WmSearch {...defaultProps} />);\n    expect(tree.getByPlaceholderText('Search')).toBeTruthy();\n    expect(tree.getByText('search')).toBeTruthy();\n  });\n\n  it('should handle blur event', async () => {\n    const { getByPlaceholderText } = render(\n      <WmSearch\n        {...defaultProps}\n        dataset={dataItems}\n        searchkey=\"name\"\n        datafield=\"dataValue\"\n        displaylabel=\"name\"\n      />\n    );\n    const searchInput = getByPlaceholderText('Search');\n    // const onBlur = jest.spyOn(WmSearch.prototype, 'onBlur');\n\n    fireEvent(searchInput, 'onBlur');\n    await waitFor(() => {\n      expect(invokeEventCallback).toHaveBeenCalled();\n    });\n    // expect(invokeEventCallback).toHaveBeenCalledWith('onBlur', [\n    //   null,\n    //   WmSearch,\n    // ]);\n    expect(invokeEventCallback).toHaveBeenCalledWith('onBlur', [\n      null,\n      expect.anything(),\n    ]);\n  });\n\n  it('should handle focus event', async () => {\n    const { getByPlaceholderText } = render(\n      <WmSearch\n        {...defaultProps}\n        dataset={dataItems}\n        searchkey=\"name\"\n        datafield=\"dataValue\"\n        displaylabel=\"name\"\n      />\n    );\n    const searchInput = getByPlaceholderText('Search');\n\n    fireEvent(searchInput, 'onFocus');\n    await waitFor(() => {\n      expect(invokeEventCallback).toHaveBeenCalled();\n    });\n    // expect(invokeEventCallback).toHaveBeenCalledWith('onFocus', [\n    //   null,\n    //   WmSearch,\n    // ]);\n    expect(invokeEventCallback).toHaveBeenCalledWith('onFocus', [\n      null,\n      expect.anything(),\n    ]);\n  });\n\n  it('should not render search items when disabled is true', async () => {\n    AppModalService.modalsOpened = [];\n    const ref = createRef();\n\n    const tree = renderComponentWithWrappers({\n      type: 'search',\n      ref,\n      disabled: true,\n    });\n\n    ref.current.view = {\n      measure: (callback: Function) => {\n        callback(0, 0, 100, 50, 10, 20);\n      },\n    } as any;\n\n    const searchInput = tree.getByPlaceholderText('Search');\n\n    fireEvent(searchInput, 'onFocus');\n    fireEvent.changeText(searchInput, 'name1');\n    await act(async () => {\n      await ref.current.computePosition();\n    });\n\n    await timer(500);\n\n    const renderOptions = AppModalService.modalOptions; //[0];\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const subTree = render(<Content />);\n    expect(subTree.queryByText('name1')).toBeNull();\n  });\n\n  it('should not render search items when readonly is true', async () => {\n    // AppModalService.modalsOpened = [];\n    const ref = createRef();\n    const tree = renderComponentWithWrappers({\n      type: 'autocomplete',\n      ref,\n      readonly: true,\n    });\n    ref.current.view = {\n      measure: (callback: Function) => {\n        callback(0, 0, 100, 50, 10, 20);\n      },\n    } as any;\n\n    const searchInput = tree.getByPlaceholderText('Search');\n\n    fireEvent(searchInput, 'onFocus');\n    await act(async () => {\n      await ref.current.computePosition();\n    });\n\n    await timer(500);\n\n    // const renderOptions = AppModalService.modalsOpened[0];\n    const renderOptions = AppModalService.modalOptions;\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const subTree = render(<Content />);\n\n    expect(subTree.queryByText('name1')).toBeNull();\n    expect(subTree.queryByText('name2')).toBeNull();\n    expect(subTree.queryByText('name0')).toBeNull();\n    expect(subTree.queryByText(ref.current.props.datacompletemsg)).toBeNull();\n  });\n\n  it('should not render search dropdown modal when dataset is empty', async () => {\n    // AppModalService.modalsOpened = [];\n    const ref = createRef();\n    const tree = renderComponentWithWrappers({\n      type: 'autocomplete',\n      ref,\n      dataset: [],\n      searchkey: '',\n      datafield: '',\n      displaylabel: '',\n    });\n    ref.current.view = {\n      measure: (callback: Function) => {\n        callback(0, 0, 100, 50, 10, 20);\n      },\n    } as any;\n\n    const searchInput = tree.getByPlaceholderText('Search');\n\n    fireEvent(searchInput, 'onFocus');\n    await act(async () => {\n      await ref.current.computePosition();\n    });\n\n    await timer();\n    const renderOptions = AppModalService.modalOptions;\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const subTree = render(<Content />);\n\n    await timer();\n\n    expect(ref.current.state.isOpened).toBeFalsy();\n    await waitFor(() => {\n      expect(subTree.queryByText('name1')).toBeNull();\n      expect(subTree.queryByText('name0')).toBeNull();\n      expect(subTree.queryByText('name2')).toBeNull();\n    });\n  });\n\n  it('should not render search dropdown modal when modal has display:none style applied', async () => {\n    // AppModalService.modalsOpened = [];\n    const ref = createRef();\n    const tree = renderComponentWithWrappers({\n      type: 'autocomplete',\n      ref,\n      styles: {\n        modal: {\n          display: 'none',\n        },\n      },\n    });\n    ref.current.view = {\n      measure: (callback: Function) => {\n        callback(0, 0, 100, 50, 10, 20);\n      },\n    } as any;\n\n    const searchInput = tree.getByPlaceholderText('Search');\n\n    fireEvent(searchInput, 'onFocus');\n    await act(async () => {\n      await ref.current.computePosition();\n    });\n\n    await timer();\n\n    // const renderOptions = AppModalService.modalsOpened[0];\n    const renderOptions = AppModalService.modalOptions;\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const subTree = render(<Content />);\n\n    await timer();\n\n    expect(ref.current.state.isOpened).toBeFalsy();\n    await waitFor(() => {\n      expect(subTree.queryByText('name1')).toBeNull();\n      expect(subTree.queryByText('name0')).toBeNull();\n      expect(subTree.queryByText('name2')).toBeNull();\n    });\n  });\n\n  it('should call respective callbacks when an item is selected', async () => {\n    // AppModalService.modalsOpened = [];\n    const ref = createRef();\n    const onItemSelectMock = jest.spyOn(WmSearch.prototype, 'onItemSelect');\n    const tree = renderComponentWithWrappers({\n      type: 'search',\n      ref,\n    });\n    ref.current.view = {\n      measure: (callback: Function) => {\n        callback(0, 0, 100, 50, 10, 20);\n      },\n    } as any;\n\n    const searchInput = tree.getByPlaceholderText('Search');\n\n    fireEvent(searchInput, 'onFocus');\n    fireEvent.changeText(searchInput, 'name1');\n    await act(async () => {\n      await ref.current.computePosition();\n    });\n\n    await timer(500);\n\n    const renderOptions = AppModalService.modalOptions;\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const subTree = render(<Content />);\n    const selectItem = subTree.getByText('name1');\n    fireEvent(selectItem, 'press');\n\n    await timer(300);\n\n    await waitFor(() => {\n      expect(onItemSelectMock).toHaveBeenCalled();\n      // expect(searchInput.props.defaultValue).toBe('name1');\n    });\n    // expect(invokeEventCallback).toHaveBeenCalledWith('onSubmit', [null, '']);\n    expect(searchInput.props.defaultValue).toBe('name1');\n  });\n\n  it('should show all the data on focus when type is autocomplete', async () => {\n    const ref = createRef();\n    const { getByPlaceholderText } = render(\n      <WmSearch\n        ref={ref}\n        {...defaultProps}\n        dataset={dataItems}\n        searchkey=\"name\"\n        datafield=\"dataValue\"\n        displaylabel=\"name\"\n        type=\"autocomplete\"\n      />\n    );\n    const updateFilteredDataMock = jest.spyOn(\n      WmSearch.prototype,\n      'updateFilteredData'\n    );\n    const searchInput = getByPlaceholderText('Search');\n\n    fireEvent(searchInput, 'onFocus');\n    await waitFor(() => {\n      expect(updateFilteredDataMock).toHaveBeenCalledWith(defaultProps.query);\n      expect(ref.current.state.data.length).toBe(dataItems.length);\n    });\n  });\n\n  it('should handle text input change', async () => {\n    const { getByPlaceholderText } = render(<WmSearch {...defaultProps} />);\n    const searchInput = getByPlaceholderText('Search');\n    // const onChangeText = jest.spyOn(WmSearch.prototype, 'invokeEventCallback');\n    fireEvent.changeText(searchInput, 'test');\n    await waitFor(() => {\n      // expect(defaultProps.onChange).toHaveBeenCalledWith(\n      //   undefined,\n      //   expect.anything(),\n      //   'test',\n      //   ''\n      // );\n      expect(invokeEventCallback).toHaveBeenCalledWith('onChange', [\n        undefined,\n        expect.anything(),\n        'test',\n        '',\n      ]);\n    });\n    expect(updateState).toHaveBeenCalled();\n  });\n\n  it('should handle clear search when type is search', async () => {\n    const ref = createRef();\n    const { getByPlaceholderText, getByText } = render(\n      <WmSearch\n        {...defaultProps}\n        query=\"name\"\n        showclear={true}\n        ref={ref}\n        dataset={dataItems}\n        searchkey=\"name\"\n        datafield=\"dataValue\"\n        displaylabel=\"name\"\n      />\n    );\n    const searchInput = getByPlaceholderText('Search');\n    fireEvent.changeText(searchInput, 'name2');\n\n    fireEvent.press(getByText('clear'));\n    await waitFor(() => {\n      expect(invokeEventCallback).toHaveBeenCalledWith('onClear', [\n        null,\n        expect.anything(),\n      ]);\n      // expect(ref.current.state.data.length).toBe(0);\n    });\n  });\n\n  it('should handle clear search when type is autocomplete', async () => {\n    const ref = createRef();\n    const { getByPlaceholderText, getByText } = render(\n      <WmSearch\n        {...defaultProps}\n        query=\"name\"\n        showclear={true}\n        ref={ref}\n        dataset={dataItems}\n        searchkey=\"name\"\n        datafield=\"dataValue\"\n        displaylabel=\"name\"\n        type=\"autocomplete\"\n      />\n    );\n    const searchInput = getByPlaceholderText('Search');\n    fireEvent.changeText(searchInput, 'name2');\n    const updateFilteredDataMock = jest.spyOn(\n      WmSearch.prototype,\n      'updateFilteredData'\n    );\n    fireEvent.press(getByText('clear'));\n    await waitFor(() => {\n      expect(invokeEventCallback).toHaveBeenCalledWith('onClear', [\n        null,\n        expect.anything(),\n      ]);\n      expect(updateFilteredDataMock).toHaveBeenCalledWith('');\n      expect(ref.current.state.data.length).toBe(dataItems.length);\n    });\n  });\n\n  it('should handle search icon press and filter data when searchon = \"onsearchiconclick\"', async () => {\n    const searchText = 'name2';\n    const ref = createRef<WmSearch>();\n    const tree = render(\n      <WmSearch\n        ref={ref}\n        {...defaultProps}\n        searchon=\"onsearchiconclick\"\n        dataset={dataItems}\n        searchkey=\"name\"\n        datafield=\"dataValue\"\n        displaylabel=\"name\"\n      />\n    );\n    const searchIconPress = jest.spyOn(WmSearch.prototype, 'searchIconPress');\n    const searchInput = tree.getByPlaceholderText('Search');\n    const updateFilteredDataMock = jest.spyOn(\n      WmSearch.prototype,\n      'updateFilteredData'\n    );\n    fireEvent.changeText(searchInput, searchText);\n    fireEvent.press(tree.getByText('search'));\n    await waitFor(() => {\n      expect(searchIconPress).toHaveBeenCalled();\n    });\n    expect(updateState).toHaveBeenCalled();\n    expect(updateFilteredDataMock).toHaveBeenCalled();\n    expect(ref.current.state.data[0]).toMatchObject({\n      displayfield: searchText,\n    });\n  });\n\n  it('should handle search icon press and invoke itemselect events when searchon = \"typing\" ', async () => {\n    const searchText = 'name2';\n    const ref = createRef();\n    const tree = render(\n      <WmSearch\n        ref={ref}\n        {...defaultProps}\n        searchon=\"typing\"\n        dataset={dataItems}\n        searchkey=\"name\"\n        datafield=\"name\"\n        displaylabel=\"name\"\n      />\n    );\n    const onItemSelectMock = jest.spyOn(WmSearch.prototype, 'onItemSelect');\n    const searchInput = tree.getByPlaceholderText('Search');\n    fireEvent.changeText(searchInput, searchText);\n    fireEvent.press(tree.getByText('search'));\n    await waitFor(() => {\n      expect(onItemSelectMock).toHaveBeenCalled();\n      // expect(ref.current.state.props.datavalue).toBe(searchText);\n    });\n    expect(invokeEventCallback).toHaveBeenCalledWith('onSelect', [\n      null,\n      expect.anything(),\n      searchText,\n    ]);\n    expect(invokeEventCallback).toHaveBeenCalledWith('onSubmit', [\n      null,\n      expect.anything(),\n    ]);\n  });\n\n  it('should handle input change and filter data', async () => {\n    const ref = createRef();\n    const tree = render(\n      <WmSearch\n        ref={ref}\n        {...defaultProps}\n        searchon=\"typing\"\n        dataset={dataItems}\n        searchkey=\"name\"\n        datafield=\"dataValue\"\n        displaylabel=\"name\"\n      />\n    );\n    const searchText = 'name1';\n    const updateFilteredDataMock = jest.spyOn(\n      WmSearch.prototype,\n      'updateFilteredData'\n    );\n    const searchInput = tree.getByPlaceholderText('Search');\n    fireEvent.changeText(searchInput, searchText);\n\n    await waitFor(() => {\n      expect(updateFilteredDataMock).toHaveBeenCalled();\n      expect(ref.current.state.data[0]).toMatchObject({\n        displayfield: searchText,\n      });\n    });\n  });\n\n  it('should filter data even without searchKey', async () => {\n    const ref = createRef();\n    const tree = render(\n      <WmSearch\n        ref={ref}\n        {...defaultProps}\n        searchon=\"typing\"\n        dataset={dataItems}\n        datafield=\"dataValue\"\n        displaylabel=\"name\"\n      />\n    );\n    const searchText = 'name1';\n    const updateFilteredDataMock = jest.spyOn(\n      WmSearch.prototype,\n      'updateFilteredData'\n    );\n    const searchInput = tree.getByPlaceholderText('Search');\n    fireEvent.changeText(searchInput, searchText);\n\n    await waitFor(() => {\n      expect(updateFilteredDataMock).toHaveBeenCalled();\n      expect(ref.current.state.data[0]).toMatchObject({\n        displayfield: searchText,\n      });\n    });\n  });\n\n  it('should filter data when dataset is not an object array', async () => {\n    const ref = createRef();\n    const tree = render(\n      <WmSearch\n        ref={ref}\n        {...defaultProps}\n        searchon=\"typing\"\n        dataset={['name2', 'name3', 'name4', 'name5']}\n      />\n    );\n    const searchText = 'name4';\n    const updateFilteredDataMock = jest.spyOn(\n      WmSearch.prototype,\n      'updateFilteredData'\n    );\n    const searchInput = tree.getByPlaceholderText('Search');\n    fireEvent.changeText(searchInput, searchText);\n\n    await waitFor(() => {\n      expect(updateFilteredDataMock).toHaveBeenCalled();\n      expect(ref.current.state.data[0]).toMatchObject({\n        displayfield: searchText,\n      });\n    });\n  });\n\n  it('should autofocus when autofocus property is true', async () => {\n    const { getByPlaceholderText } = render(\n      <WmSearch {...defaultProps} autofocus={true} />\n    );\n    const searchInput = getByPlaceholderText('Search');\n    await waitFor(() => expect(searchInput.props.autoFocus).toBe(true));\n  });\n\n  it('should not filter data if minchars is not reached', async () => {\n    const ref = createRef();\n    const tree = render(\n      <WmSearch\n        ref={ref}\n        {...defaultProps}\n        searchon=\"typing\"\n        dataset={dataItems}\n        searchkey=\"name\"\n        datafield=\"dataValue\"\n        displaylabel=\"name\"\n        minchars={5}\n      />\n    );\n    const filterMock = jest.spyOn(DataProvider.prototype, 'filter');\n    const searchInput = tree.getByPlaceholderText('Search');\n    fireEvent.changeText(searchInput, 'name');\n\n    await waitFor(() => {\n      expect(filterMock).not.toHaveBeenCalled();\n    });\n    expect(ref.current.state.data.length).toBe(0);\n  });\n\n  it('should not filter data if search text is empty', async () => {\n    const ref = createRef();\n    const tree = render(\n      <WmSearch\n        ref={ref}\n        {...defaultProps}\n        searchon=\"typing\"\n        dataset={dataItems}\n        searchkey=\"name\"\n        datafield=\"dataValue\"\n        displaylabel=\"name\"\n      />\n    );\n    const filterMock = jest.spyOn(DataProvider.prototype, 'filter');\n    const searchInput = tree.getByPlaceholderText('Search');\n    fireEvent.changeText(searchInput, '');\n\n    await waitFor(() => {\n      expect(filterMock).not.toHaveBeenCalled();\n    });\n    expect(ref.current.state.data.length).toBe(0);\n  });\n\n  it('should invoke variable and update dataitems if update is required', async () => {\n    const resolvedDataItems = {\n      dataSet: [\n        {\n          name: 'name4',\n          dataValue: 'dataValue4',\n        },\n        {\n          name: 'name5',\n          dataValue: 'dataValue5',\n        },\n      ],\n    };\n    const ref = createRef();\n    const initMock = jest\n      .spyOn(DataProvider.prototype, 'init')\n      .mockResolvedValue(true);\n    const invokeVariableMock = jest\n      .spyOn(DataProvider.prototype, 'invokeVariable')\n      .mockReturnValue(Promise.resolve(resolvedDataItems));\n    const setDataItems = jest.spyOn(WmSearch.prototype, 'setDataItems');\n    const tree = render(\n      <WmSearch\n        ref={ref}\n        {...defaultProps}\n        searchon=\"typing\"\n        dataset={dataItems}\n        searchkey=\"name\"\n        datafield=\"dataValue\"\n        displaylabel=\"name\"\n      />\n    );\n    ref.current.updateState({\n      props: {\n        query: 'name1',\n      },\n    });\n    const searchInput = tree.getByPlaceholderText('Search');\n    fireEvent.changeText(searchInput, 'name2');\n\n    await waitFor(() => {\n      expect(invokeVariableMock).toHaveBeenCalled();\n      expect(setDataItems).toHaveBeenCalled();\n      let received = mapValues(ref.current.state.dataItems);\n      expect(received.toString()).toBe(resolvedDataItems.dataSet.toString());\n    });\n  });\n\n  it('should render search items when type is autocomplete', async () => {\n    // AppModalService.modalsOpened = [];\n    const ref = createRef();\n    const tree = renderComponentWithWrappers({ type: 'autocomplete', ref });\n    ref.current.view = {\n      measure: (callback: Function) => {\n        callback(0, 0, 100, 50, 10, 20);\n      },\n    } as any;\n\n    const searchInput = tree.getByPlaceholderText('Search');\n\n    fireEvent(searchInput, 'onFocus');\n    await act(async () => {\n      await ref.current.computePosition();\n    });\n\n    await timer();\n\n    // const renderOptions = AppModalService.modalsOpened[0];\n    const renderOptions = AppModalService.modalOptions;\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const subTree = render(<Content />);\n    expect(subTree.getByText('name1')).toBeTruthy();\n    expect(subTree.getByText('name2')).toBeTruthy();\n    expect(subTree.getByText('name0')).toBeTruthy();\n    expect(subTree.getByText(ref.current.props.datacompletemsg)).toBeTruthy();\n  });\n\n \n\n  it('should limit the number of displayed items', async () => {\n    // AppModalService.modalsOpened = [];\n    const ref = createRef();\n\n    const tree = renderComponentWithWrappers({\n      type: 'autocomplete',\n      ref,\n      limit: 2,\n    });\n\n    ref.current.view = {\n      measure: (callback: Function) => {\n        callback(0, 0, 100, 50, 10, 20);\n      },\n    } as any;\n\n    const searchInput = tree.getByPlaceholderText('Search');\n\n    fireEvent(searchInput, 'onFocus');\n    await act(async () => {\n      await ref.current.computePosition();\n    });\n\n    await timer();\n\n    // const renderOptions = AppModalService.modalsOpened[0];\n    const renderOptions = AppModalService.modalOptions;\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const subTree = render(<Content />);\n\n    await waitFor(() => {\n      expect(subTree.getByText('name1')).toBeTruthy();\n      expect(subTree.getByText('name0')).toBeTruthy();\n      expect(subTree.queryByText('name2')).toBeNull();\n    });\n  });\n\n  it('should render search items when type is search', async () => {\n    // AppModalService.modalsOpened = [];\n    const ref = createRef();\n\n    const tree = renderComponentWithWrappers({\n      type: 'search',\n      ref,\n    });\n    ref.current.view = {\n      measure: (callback: Function) => {\n        callback(0, 0, 100, 50, 10, 20);\n      },\n    } as any;\n\n    const searchInput = tree.getByPlaceholderText('Search');\n\n    fireEvent(searchInput, 'onFocus');\n    fireEvent.changeText(searchInput, 'name1');\n    await act(async () => {\n      await ref.current.computePosition();\n    });\n\n    await timer(500);\n\n    const renderOptions = AppModalService.modalOptions; //[0];\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const subTree = render(<Content />);\n    expect(subTree.getByText('name1')).toBeTruthy();\n  });\n\n  it('should compute dropdown position correctly', async () => {\n    const wmSearch = new WmSearch(defaultProps);\n    wmSearch.view = {\n      measure: (callback: Function) => {\n        callback(0, 0, 100, 50, 10, 20);\n      },\n    } as any;\n    await act(async () => {\n      await wmSearch.computePosition();\n    });\n    expect(wmSearch.state.position).toEqual({ left: 10, top: 70 });\n  });\n\n  it('should prepare modal options correctly', () => {\n    const wmSearch = new WmSearch(defaultProps);\n    const content = <></>;\n    const styles = { modalContent: { borderWidth: 2 } };\n    const modalService = { hideModal: jest.fn() } as any;\n\n    wmSearch.searchInputWidth = 200;\n    const options = wmSearch.prepareModalOptions(content, styles, modalService);\n\n    expect(options.modalStyle).toEqual({});\n    expect(options.contentStyle).toEqual({\n      borderWidth: 2,\n      left: 4,\n      top: 0,\n      width: 196,\n    });\n    expect(options.isModal).toBe(true);\n    expect(typeof options.onClose).toBe('function');\n  });\n\n  it('should dismiss keyboard when modal is closed', () => {\n    const wmSearch = new WmSearch(defaultProps);\n    const content = <></>;\n    const styles = { modalContent: { borderWidth: 2 } };\n    const modalService = { hideModal: jest.fn() } as any;\n\n    wmSearch.searchInputWidth = 200;\n    const options = wmSearch.prepareModalOptions(content, styles, modalService);\n    options.onClose();\n\n    expect(wmSearch.state.isOpened).toBe(false);\n  });\n\n  it('should set accessibility props correctly', () => {\n    const tree = render(\n      <WmSearch\n        {...defaultProps}\n        accessibilitylabel=\"Search Input\"\n        hint=\"Enter search text\"\n      />\n    );\n    expect(tree.getByLabelText('Search Input')).toBeTruthy();\n    expect(tree.getByA11yHint('Enter search text')).toBeTruthy();\n    expect(tree.getByRole('search')).toBeTruthy();\n  });\n\n  it('should not render clear button when type readonly is true', async () => {\n    const ref = createRef();\n    const { queryByText, getByPlaceholderText } = render(\n      <WmSearch\n        {...defaultProps}\n        query=\"name\"\n        showclear={true}\n        ref={ref}\n        dataset={dataItems}\n        searchkey=\"name\"\n        datafield=\"dataValue\"\n        displaylabel=\"name\"\n        readonly={true}\n        datavalue={'dataValue1'}\n      />\n    );\n    const clearButton = queryByText('clear');\n\n    expect(clearButton).toBe(null);\n    expect(getByPlaceholderText('Search').props.defaultValue).toBe(\n      'dataValue1'\n    );\n  });\n\n  it('should not render clear button when type disabled is true', async () => {\n    AppModalService.modalsOpened = [];\n\n    const ref = createRef();\n    const { queryByText, getByPlaceholderText } = render(\n      <WmSearch\n        {...defaultProps}\n        query=\"name\"\n        showclear={true}\n        ref={ref}\n        dataset={dataItems}\n        searchkey=\"name\"\n        datafield=\"dataValue\"\n        displaylabel=\"name\"\n        type=\"autocomplete\"\n        disabled={true}\n        datavalue={'dataValue1'}\n      />\n    );\n\n    const clearButton = queryByText('clear');\n    expect(clearButton).toBe(null);\n    expect(getByPlaceholderText('Search').props.defaultValue).toBe(\n      'dataValue1'\n    );\n  });\n\n  it('should handle layout change and update width accordingly', async () => {\n    const ref = createRef();\n    render(<WmSearch {...defaultProps} ref={ref} />);\n    const searchTextElement = screen.getByPlaceholderText('Search');\n    fireEvent(searchTextElement, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 100,\n          height: 100,\n        },\n      },\n    });\n\n    expect(ref.current.searchInputWidth).toBe(100);\n  });\n\n  it('should handle onchange event', async () => {\n    const originalPlatform = Platform.OS;\n    Platform.OS = 'web';\n    const ref = createRef();\n    render(<WmSearch {...defaultProps} ref={ref} />);\n    const updateStateMock = jest.spyOn(WmSearch.prototype, 'updateState');\n    const searchTextElement = screen.getByPlaceholderText('Search');\n    fireEvent(searchTextElement, 'change', {\n      target: {\n        value: 'nam',\n        selectionStart: 3,\n      },\n    });\n\n    await timer(300);\n    expect(ref.current.cursor).toBe(3);\n    expect(updateStateMock).toHaveBeenCalledWith({\n      props: { query: 'nam' },\n    } as WmSearchState);\n\n    Platform.OS = originalPlatform;\n  });\n\n  it('should render with custom icon when iconclass prop is set', async () => {\n    render(<WmSearch {...defaultProps} iconclass=\"fa fa-edit\" />);\n\n    expect(screen.getByText('edit')).toBeTruthy();\n    expect(screen).toMatchSnapshot();\n  });\n\n  it('should reflect changes after a delay when debouncetime prop has value greater than 0', async () => {\n    const customRef = createRef<WmSearch>();\n\n    render(<WmSearch {...defaultProps} iconclass=\"fa fa-edit\" ref={customRef} debouncetime={200}/>);\n    const updateStateMock = jest.spyOn(WmSearch.prototype, 'updateState');\n    const searchTextElement = screen.getByPlaceholderText('Search');\n    const handleChange = jest.spyOn(customRef.current, 'handleChange');\n\n    fireEvent(searchTextElement, 'changeText', \"hello\");\n    expect(handleChange).not.toHaveBeenCalled();\n\n    await timer(202);\n\n    expect(handleChange).toHaveBeenCalled();\n  });\n\n  it('should reflect changes immediately when debouncetime prop has value equal to 0', async () => {\n    const customRef = createRef<WmSearch>();\n\n    render(<WmSearch {...defaultProps} iconclass=\"fa fa-edit\" ref={customRef} debouncetime={0}/>);\n    const updateStateMock = jest.spyOn(WmSearch.prototype, 'updateState');\n    const searchTextElement = screen.getByPlaceholderText('Search');\n    const handleChange = jest.spyOn(customRef.current, 'handleChange');\n\n    fireEvent(searchTextElement, 'changeText', \"hello\");\n    expect(handleChange).toHaveBeenCalled();\n  });\n});\n", "wavemaker-rn-runtime/test/components/basic/picture.component.spec.tsx": "import React, { createRef } from 'react';\nimport { Image } from 'react-native';\nimport {\n  act,\n  cleanup,\n  fireEvent,\n  render,\n  waitFor,\n} from '@testing-library/react-native';\n// import * as lodash from 'lodash-es';\nimport WmPicture from '@wavemaker/app-rn-runtime/components/basic/picture/picture.component';\nimport { defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { AssetProvider } from '@wavemaker/app-rn-runtime/core/asset.provider';\n\nconst renderComponent = (props = {}) => {\n  const defaultProps = {\n    animation: null,\n    animationdelay: null,\n    picturesource: null,\n    pictureplaceholder:\n      'https://www.wavemaker.com/wp-content/uploads/2024/02/WaveMaker-Logo-1.svg',\n    shape: null,\n    isSvg: null,\n    resizemode: 'stretch',\n    name: 'wm',\n  };\n\n  const loadAsset = (path) => path;\n\n  return render(\n    <AssetProvider value={loadAsset}>\n      <WmPicture {...defaultProps} {...props} />\n    </AssetProvider>\n  );\n};\n\nconst getStyleObject = (styleArr, styleObj) => {\n  if (!styleArr) return;\n\n  if (!Array.isArray(styleArr)) {\n    Object.keys(styleArr).forEach((key) => {\n      styleObj[key] = styleArr[key];\n    });\n\n    return;\n  }\n\n  styleArr.forEach((item) => {\n    getStyleObject(item, styleObj);\n  });\n\n  return styleObj;\n};\n\ndescribe('Picture component', () => {\n  afterEach(() => {\n    const DEFAULT_CLASS = 'app-picture';\n    BASE_THEME.registerStyle((themeVariables, addStyle) => {\n      const defaultStyles = defineStyles({\n        root: {\n          overflow: 'hidden',\n          width: 270,\n          rippleColor: themeVariables.transparent,\n        },\n        text: {},\n        picture: {\n          width: '100%',\n          height: '100%',\n        },\n        skeleton: {\n          root: {\n            width: '100%',\n            height: 128,\n          },\n        },\n      });\n\n      addStyle(DEFAULT_CLASS, '', defaultStyles);\n      addStyle('rounded-image', '', {\n        picture: {\n          borderRadius: 6,\n        },\n      });\n      addStyle('thumbnail-image', '', {\n        root: {\n          backgroundColor: themeVariables.pictureThumbBgColor,\n          borderWidth: 1,\n          borderStyle: 'solid',\n          borderColor: themeVariables.pictureThumbBorderColor,\n          borderRadius: 6,\n          paddingTop: 8,\n          paddingBottom: 8,\n          paddingLeft: 8,\n          paddingRight: 8,\n        },\n      });\n    });\n\n    cleanup();\n  });\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  test('should not render component when image source is falsy', async () => {\n    const customRef = createRef();\n    const tree = renderComponent({\n      ref: customRef,\n      pictureplaceholder: null,\n      picturesource: null,\n    });\n\n    await waitFor(() => {\n      expect(Array.isArray(tree.toJSON())).toBe(false);\n      expect(tree.toJSON().children).toBeNull();\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should render image when full path is not present', async () => {\n    const customRef = createRef();\n    const tree = renderComponent({\n      ref: customRef,\n      pictureplaceholder: 'WaveMaker-Logo-1.svg',\n    });\n    act(() => {\n      customRef.current.setState({\n        naturalImageWidth: 10,\n        naturalImageHeight: 10,\n      });\n    });\n\n    const childElementWithLayout = tree.toJSON()[1].children[0];\n\n    fireEvent(childElementWithLayout, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 100,\n          height: 100,\n        },\n      },\n    });\n\n    await waitFor(() => {\n      expect(tree.getByTestId('wm_picture')).toBeTruthy();\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should render image with source from picturesource when both picturesource and pictureplaceholder is present', async () => {\n    const customRef = createRef();\n    const tree = renderComponent({\n      ref: customRef,\n      pictureplaceholder: 'placeholder-image.png',\n      picturesource: 'WaveMaker-Logo-1.svg',\n    });\n    act(() => {\n      customRef.current.setState({\n        naturalImageWidth: 10,\n        naturalImageHeight: 10,\n      });\n    });\n\n    const childElementWithLayout = tree.toJSON()[1].children[0];\n\n    fireEvent(childElementWithLayout, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 100,\n          height: 100,\n        },\n      },\n    });\n\n    await waitFor(() => {\n      expect(tree.getByTestId('wm_picture')).toBeTruthy();\n      expect(tree.getByTestId('wm_picture').props.source).toBe(\n        'WaveMaker-Logo-1.svg'\n      );\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should render component', async () => {\n    const customRef = createRef();\n    const tree = renderComponent({ ref: customRef });\n    act(() => {\n      customRef.current.setState({\n        naturalImageWidth: 10,\n        naturalImageHeight: 10,\n      });\n    });\n\n    const childElementWithLayout = tree.toJSON()[1].children[0];\n\n    fireEvent(childElementWithLayout, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 100,\n          height: 100,\n        },\n      },\n    });\n\n    await waitFor(() => {\n      expect(tree.getByTestId('wm_picture')).toBeTruthy();\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  // TODO: Check why updateStateMock is called only once but it should call twice.\n  // test('should render component with width and height extracted from Image component of react-native', async () => {\n  //   const height = 122;\n  //   const width = 123;\n  //   // const lodashMock = jest.spyOn(lodash, 'isNumber').mockReturnValue(true);\n  //   jest.spyOn(Image, 'resolveAssetSource').mockReturnValue({\n  //     height,\n  //     width,\n  //     scale: 1,\n  //     uri: ''\n  //   })\n\n  //   const customRef = createRef();\n  //   const tree = renderComponent({\n  //     ref: customRef,\n  //     // isSvg: true,\n  //     picturesource: 1,\n  //     pictureplaceholder: null,\n  //     styles: {\n  //       root: {\n  //         height: 130\n  //       }\n  //     }\n  //    });\n  //   const updateStateMock = jest.spyOn(customRef.current, 'updateState');\n  //   act(() => {\n  //     customRef.current.setState({\n  //       naturalImageWidth: 10,\n  //       naturalImageHeight: 10,\n  //     });\n  //   });\n  //   const childElementWithLayout = tree.toJSON().children[0];\n\n  //   fireEvent(childElementWithLayout, 'layout', {\n  //     nativeEvent: {\n  //       layout: {\n  //         width: 100,\n  //         height: 100,\n  //       },\n  //     },\n  //   });\n\n  //   await waitFor(() => {\n  //     expect(updateStateMock).toHaveBeenCalledWith({\n  //       naturalImageWidth: width,\n  //       naturalImageHeight: height,\n  //     })\n  //     expect(tree.getByTestId('wm_picture')).toBeTruthy();\n  //     expect(tree).toMatchSnapshot();\n  //   });\n  // });\n\n  test('should render component style according to root style', async () => {\n    const customRef = createRef();\n    const tree = renderComponent({\n      ref: customRef,\n      styles: {\n        root: {\n          height: '104',\n          backgroundColor: '#000',\n        },\n      },\n    });\n\n    act(() => {\n      customRef.current.setState({\n        naturalImageWidth: 10,\n        naturalImageHeight: 10,\n      });\n    });\n\n    const childElementWithLayout = tree.toJSON()[1].children[0];\n\n    fireEvent(childElementWithLayout, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 100,\n          height: 100,\n        },\n      },\n    });\n\n    const componentStyleArr = tree.toJSON()[1].props.style;\n    const componentStyle = getStyleObject(componentStyleArr, {});\n\n    await waitFor(() => {\n      expect(tree.getByTestId('wm_picture')).toBeTruthy();\n      expect(componentStyle).toMatchObject({\n        height: '104',\n        backgroundColor: '#000',\n      });\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should apply correct accessiblitylabel', async () => {\n    const customRef = createRef();\n    const tree = renderComponent({\n      ref: customRef,\n      accessibilitylabel: 'wm-picture',\n    });\n\n    act(() => {\n      customRef.current.setState({\n        naturalImageWidth: 10,\n        naturalImageHeight: 10,\n      });\n    });\n\n    const childElementWithLayout = tree.toJSON()[1].children[0];\n\n    fireEvent(childElementWithLayout, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 100,\n          height: 100,\n        },\n      },\n    });\n\n    await waitFor(() => {\n      expect(tree.getByLabelText('wm-picture')).toBeTruthy();\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should not render the component when show props is false', () => {\n    const tree = renderComponent({\n      isSvg: 'no',\n      show: false,\n    });\n\n    const componentStyleArr = tree.toJSON()[1].props.style;\n    const componentStyle = {};\n    componentStyleArr.forEach((item) => {\n      if (!item) return;\n      Object.keys(item).forEach((key) => {\n        componentStyle[key] = item[key];\n      });\n    });\n\n    expect(componentStyle).toMatchSnapshot({ height: 0, width: 0 });\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should apply accessibilityrole correctly', async () => {\n    const customRef = createRef();\n    const tree = renderComponent({\n      ref: customRef,\n      accessibilitylabel: 'wm-picture',\n      accessibilityrole: 'wm-picture-role',\n    });\n\n    act(() => {\n      customRef.current.setState({\n        naturalImageWidth: 10,\n        naturalImageHeight: 10,\n      });\n    });\n\n    const childElementWithLayout = tree.toJSON()[1].children[0];\n\n    fireEvent(childElementWithLayout, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 100,\n          height: 100,\n        },\n      },\n    });\n\n    await waitFor(() => {\n      expect(tree.getByRole('wm-picture-role')).toBeTruthy();\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should render component width according to naturalImageWidth and naturalImageHeight state of the component when native width of the device is falsy', async () => {\n    const naturalImageWidth = 10;\n    const naturalImageHeight = 10;\n    const nativeHeight = 100;\n\n    const customRef = createRef();\n    const tree = renderComponent({\n      ref: customRef,\n      styles: {\n        root: {\n          height: '100%',\n        },\n      },\n    });\n    const updateStateMock = jest.spyOn(customRef.current, 'updateState');\n\n    act(() => {\n      customRef.current.setState({\n        naturalImageWidth: naturalImageWidth,\n        naturalImageHeight: naturalImageHeight,\n        imageWidth: 100,\n      });\n    });\n\n    const childElementWithLayout = tree.toJSON()[1].children[0];\n\n    fireEvent(childElementWithLayout, 'layout', {\n      nativeEvent: {\n        layout: {\n          height: nativeHeight,\n        },\n      },\n    });\n\n    await waitFor(() => {\n      expect(tree.getByTestId('wm_picture')).toBeTruthy();\n      expect(updateStateMock).toHaveBeenCalledWith({\n        imageHeight: nativeHeight,\n        imageWidth: (nativeHeight * naturalImageWidth) / naturalImageHeight,\n      });\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should not update state when native layout height and width are falsy', async () => {\n    const naturalImageWidth = 10;\n    const naturalImageHeight = 10;\n\n    const customRef = createRef();\n    const tree = renderComponent({\n      ref: customRef,\n      styles: {\n        root: {\n          height: '100%',\n        },\n      },\n    });\n    const updateStateMock = jest.spyOn(customRef.current, 'updateState');\n\n    act(() => {\n      customRef.current.setState({\n        naturalImageWidth: naturalImageWidth,\n        naturalImageHeight: naturalImageHeight,\n        imageWidth: 100,\n      });\n    });\n\n    const childElementWithLayout = tree.toJSON()[1].children[0];\n\n    fireEvent(childElementWithLayout, 'layout', {\n      nativeEvent: {\n        layout: {},\n      },\n    });\n\n    await waitFor(() => {\n      expect(tree.getByTestId('wm_picture')).toBeTruthy();\n      expect(updateStateMock).not.toHaveBeenCalled();\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should apply the resize mode in Image component from resizemode prop', async () => {\n    const customRef = createRef();\n    const tree = renderComponent({\n      ref: customRef,\n      accessibilitylabel: 'wm-picture',\n      accessibilityrole: 'wm-picture-role',\n      resizemode: 'contain',\n    });\n\n    act(() => {\n      customRef.current.setState({\n        naturalImageWidth: 10,\n        naturalImageHeight: 10,\n      });\n    });\n\n    const childElementWithLayout = tree.toJSON()[1].children[0];\n\n    fireEvent(childElementWithLayout, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 100,\n          height: 100,\n        },\n      },\n    });\n\n    await waitFor(() => {\n      expect(tree.getByLabelText('wm-picture')).toBeTruthy();\n      expect(tree.getByLabelText('wm-picture').props.resizeMode).toBe(\n        'contain'\n      );\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should not render Image component when native layout height is not present', async () => {\n    const customRef = createRef();\n    const tree = renderComponent({\n      ref: customRef,\n      accessibilitylabel: 'wm-picture',\n      accessibilityrole: 'wm-picture-role',\n      resizemode: 'contain',\n    });\n\n    act(() => {\n      customRef.current.setState({\n        naturalImageWidth: 10,\n        naturalImageHeight: 10,\n      });\n    });\n\n    const childElementWithLayout = tree.toJSON()[1].children[0];\n\n    fireEvent(childElementWithLayout, 'layout', {\n      nativeEvent: {\n        layout: {\n          width: 100,\n        },\n      },\n    });\n\n    await waitFor(() => {\n      expect(tree.queryByLabelText('wm-picture')).toBeNull();\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should not render Image component when native layout width is not present', async () => {\n    const customRef = createRef();\n    const tree = renderComponent({\n      ref: customRef,\n      accessibilitylabel: 'wm-picture',\n      accessibilityrole: 'wm-picture-role',\n      resizemode: 'contain',\n    });\n\n    act(() => {\n      customRef.current.setState({\n        naturalImageWidth: 10,\n        naturalImageHeight: 10,\n      });\n    });\n\n    const childElementWithLayout = tree.toJSON()[1].children[0];\n\n    fireEvent(childElementWithLayout, 'layout', {\n      nativeEvent: {\n        layout: {\n          height: 100,\n        },\n      },\n    });\n\n    await waitFor(() => {\n      expect(tree.queryByLabelText('wm-picture')).toBeNull();\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should render Image component style according to shape prop as circle', async () => {\n    const customRef = createRef();\n    const tree = renderComponent({\n      ref: customRef,\n      accessibilitylabel: 'wm-picture',\n      accessibilityrole: 'wm-picture-role',\n      shape: 'circle',\n    });\n\n    act(() => {\n      customRef.current.setState({\n        naturalImageWidth: 10,\n        naturalImageHeight: 10,\n      });\n    });\n\n    const childElementWithLayout = tree.toJSON()[1].children[0];\n\n    fireEvent(childElementWithLayout, 'layout', {\n      nativeEvent: {\n        layout: {\n          height: 100,\n          width: 100,\n        },\n      },\n    });\n\n    await waitFor(() => {\n      const imageComponent = tree.queryByLabelText('wm-picture');\n      const imageComponentStyleArr = imageComponent.props.style;\n      const imageComponentStyle = {};\n      imageComponentStyleArr.forEach((item) => {\n        Object.keys(item).forEach((key) => {\n          imageComponentStyle[key] = item[key];\n        });\n      });\n\n      expect(imageComponentStyle).toMatchObject({ borderRadius: 50 });\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should render Image component style according to shape prop as rounded', async () => {\n    const customRef = createRef();\n    const tree = renderComponent({\n      ref: customRef,\n      accessibilitylabel: 'wm-picture',\n      accessibilityrole: 'wm-picture-role',\n      shape: 'rounded',\n    });\n\n    act(() => {\n      customRef.current.setState({\n        naturalImageWidth: 10,\n        naturalImageHeight: 10,\n      });\n    });\n\n    const childElementWithLayout = tree.toJSON()[1].children[0];\n\n    fireEvent(childElementWithLayout, 'layout', {\n      nativeEvent: {\n        layout: {\n          height: 100,\n          width: 100,\n        },\n      },\n    });\n\n    await waitFor(() => {\n      const theme = customRef.current.theme.getStyle('rounded-image');\n      const imageComponent = tree.getByLabelText('wm-picture');\n      const imageComponentStyleArr = imageComponent.props.style;\n      const imageComponentStyle = {};\n      imageComponentStyleArr.forEach((item) => {\n        Object.keys(item).forEach((key) => {\n          imageComponentStyle[key] = item[key];\n        });\n      });\n\n      expect(imageComponentStyle).toMatchObject(theme.picture);\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should render Image component style according to shape prop as thumbnail', async () => {\n    const customRef = createRef();\n    const tree = renderComponent({\n      ref: customRef,\n      accessibilitylabel: 'wm-picture',\n      accessibilityrole: 'wm-picture-role',\n      shape: 'thumbnail',\n    });\n\n    act(() => {\n      customRef.current.setState({\n        naturalImageWidth: 10,\n        naturalImageHeight: 10,\n      });\n    });\n\n    const childElementWithLayout = tree.toJSON()[1].children[0];\n\n    fireEvent(childElementWithLayout, 'layout', {\n      nativeEvent: {\n        layout: {\n          height: 100,\n          width: 100,\n        },\n      },\n    });\n\n    await waitFor(() => {\n      const theme = customRef.current?.theme.getStyle('thumbnail-image');\n      const componentStyleArr = tree.toJSON()[1].props.style;\n      const componentStyle = {};\n      componentStyleArr.forEach((item) => {\n        if (!item) return;\n        Object.keys(item).forEach((key) => {\n          componentStyle[key] = item[key];\n        });\n      });\n\n      expect(componentStyle).toMatchObject(theme.root);\n      expect(tree.getByLabelText('wm-picture')).toBeTruthy();\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should be null when isSvg prop is falsy and naturalImageWidth state is falsy', () => {\n    const tree = renderComponent({\n      isSvg: null,\n    });\n\n    expect(Array.isArray(tree.toJSON())).toBe(false);\n    expect(tree.toJSON().children).toBeNull();\n  });\n\n  test('should render skeleton when showskeleton prop is true', () => {\n    const tree = renderComponent({\n      showskeleton: true,\n      styles: {\n        root: {\n          height: 125,\n          width: 125,\n        },\n      },\n    });\n\n    expect(tree.toJSON()[1].props.style).toMatchObject({\n      height: 125,\n      width: 125,\n    });\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render skeleton when showskeleton prop is true with skeletonheight and skeletonwidth provided in props', () => {\n    const tree = renderComponent({\n      showskeleton: true,\n      skeletonheight: 200,\n      skeletonwidth: 125,\n    });\n\n    expect(tree.toJSON()[1].props.style).toMatchObject({\n      height: 200,\n      width: 125,\n    });\n    expect(tree).toMatchSnapshot();\n  });\n\n  xit('should render skeleton with styles with respect to shape as rounded', async () => {\n    BASE_THEME.registerStyle((themeVariables, addStyle) => {\n      addStyle('rounded-image', '', {\n        picture: {\n          height: 125,\n          width: 125,\n        },\n      });\n    });\n\n    const customRef = createRef();\n    const tree = renderComponent({\n      ref: customRef,\n      accessibilitylabel: 'wm-picture',\n      accessibilityrole: 'wm-picture-role',\n      shape: 'rounded',\n      showskeleton: true,\n      styles: {\n        root: {\n          height: null,\n          width: null,\n        },\n      },\n    });\n\n    act(() => {\n      customRef.current.setState({\n        imageWidth: 100,\n        imageHeight: 100,\n      });\n    });\n\n    const theme = customRef.current.theme.getStyle('rounded-image');\n    const imageComponentStyle = tree.toJSON()[1].props.style;\n    await waitFor(() => {\n      expect(imageComponentStyle.height).toBe(theme.picture.height);\n      expect(imageComponentStyle.width).toBe(theme.picture.width);\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  xit('should render skeleton with styles with respect to shape as thumbnail', async () => {\n    BASE_THEME.registerStyle((themeVariables, addStyle) => {\n      addStyle('thumbnail-image', '', {\n        root: {\n          height: 125,\n          width: 125,\n        },\n      });\n    });\n\n    const customRef = createRef();\n    const tree = renderComponent({\n      ref: customRef,\n      accessibilitylabel: 'wm-picture',\n      accessibilityrole: 'wm-picture-role',\n      shape: 'thumbnail',\n      showskeleton: true,\n      styles: {\n        root: {\n          height: null,\n          width: null,\n        },\n      },\n    });\n\n    act(() => {\n      customRef.current.setState({\n        imageWidth: 100,\n        imageHeight: 100,\n      });\n    });\n\n    const theme = customRef.current.theme.getStyle('thumbnail-image');\n    const imageComponentStyle = tree.toJSON()[1].props.style;\n    await waitFor(() => {\n      expect(imageComponentStyle.height).toBe(theme.root.height);\n      expect(imageComponentStyle.width).toBe(theme.root.width);\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  xit('should render skeleton with styles with respect to shape as circle', async () => {\n    BASE_THEME.registerStyle((themeVariables, addStyle) => {\n      addStyle('thumbnail-image', '', {\n        root: {\n          height: 125,\n          width: 125,\n        },\n      });\n    });\n\n    const customRef = createRef();\n    const tree = renderComponent({\n      ref: customRef,\n      accessibilitylabel: 'wm-picture',\n      accessibilityrole: 'wm-picture-role',\n      shape: 'thumbnail',\n      showskeleton: true,\n      styles: {\n        root: {\n          height: null,\n          width: null,\n        },\n      },\n    });\n\n    act(() => {\n      customRef.current.setState({\n        imageWidth: 100,\n        imageHeight: 100,\n      });\n    });\n\n    const theme = customRef.current.theme.getStyle('thumbnail-image');\n    const imageComponentStyle = tree.toJSON()[1].props.style;\n    await waitFor(() => {\n      expect(imageComponentStyle.height).toBe(theme.root.height);\n      expect(imageComponentStyle.width).toBe(theme.root.width);\n      expect(tree).toMatchSnapshot();\n    });\n  });\n});\n", "wavemaker-rn-runtime/test/components/basic/skeleton.component.spec.tsx": "import React, { createRef } from 'react';\nimport { LinearGradient } from 'expo-linear-gradient';\nimport WmSkeleton, {\n  createSkeleton,\n} from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\nimport WmSkeletonState from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.props';\nimport BASE_THEME, {\n  ThemeProvider,\n} from '@wavemaker/app-rn-runtime/styles/theme';\nimport {\n  act,\n  cleanup,\n  fireEvent,\n  render,\n  waitFor,\n} from '@testing-library/react-native';\nimport { TestIdPrefixProvider } from '@wavemaker/app-rn-runtime/core/testid.provider';\n\nconst renderComponent = (props: WmSkeletonState = {}) => {\n  return render(\n    <TestIdPrefixProvider value={'wm-skeleton'}>\n      <ThemeProvider value={BASE_THEME}>\n        <WmSkeleton {...props} />\n      </ThemeProvider>\n    </TestIdPrefixProvider>\n  );\n};\n\ndescribe('Test Skeleton component', () => {\n  beforeAll(() => {\n    jest.doMock('@wavemaker/app-rn-runtime/styles/theme');\n  });\n\n  afterEach(() => {\n    cleanup();\n  });\n\n  afterAll(() => {\n    jest.clearAllMocks();\n  });\n\n  test('should not visible when show prop is false', () => {\n    const tree = renderComponent({\n      show: false,\n    });\n\n    expect(tree.toJSON().props.style).toMatchObject({\n      height: 0,\n      width: 0,\n    });\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('renders WmSkeleton correctly with default props', async () => {\n    const testRef = createRef();\n    const tree = renderComponent({\n      ref: testRef,\n    });\n    testRef.current.skeletonloaderRef = {\n      measure: (callback) => {\n        callback(0, 0, 30, 30, 0, 0);\n      },\n    };\n\n    fireEvent(tree.root, 'layout');\n\n    await waitFor(() => {\n      expect(tree.UNSAFE_getByType(LinearGradient)).toBeDefined();\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should not render gradient component when animate state remains false: ', async () => {\n    const testRef = createRef();\n    const tree = renderComponent({\n      ref: testRef,\n    });\n\n    await waitFor(() => {\n      expect(tree).toMatchSnapshot();\n      expect(tree.toJSON().children).toBeNull();\n      expect(tree.UNSAFE_queryByType(LinearGradient)).toBeFalsy();\n    });\n  });\n\n  test('renders WmSkeleton with custom layout', () => {\n    const testRef = createRef();\n    const customProps = {\n      ref: testRef,\n      styles: {\n        root: {\n          height: '100px',\n          width: '125px',\n        },\n      },\n    };\n    const tree = renderComponent(customProps);\n\n    testRef.current.skeletonloaderRef = {\n      measure: (callback) => {\n        callback(0, 0, 30, 30, 0, 0);\n      },\n    };\n\n    fireEvent(tree.root, 'layout');\n\n    expect(tree).toMatchSnapshot();\n    expect(tree.root.props.style.width).toBe('125px');\n    expect(tree.root.props.style.height).toBe('100px');\n  });\n\n  test('renders animated gradient correctly', () => {\n    const testRef = createRef();\n    const customProps = {\n      ref: testRef,\n    };\n    const tree = renderComponent(customProps);\n\n    testRef.current.skeletonloaderRef = {\n      measure: (callback) => {\n        callback(0, 0, 30, 30, 0, 0);\n      },\n    };\n\n    fireEvent(tree.root, 'layout');\n\n    const gradientElement = tree.UNSAFE_getByType(LinearGradient);\n    expect(gradientElement).toBeTruthy();\n  });\n\n  test('applies custom styles to skeleton', () => {\n    const testRef = createRef();\n    const customStyles = {\n      root: { backgroundColor: 'blue' },\n      animatedView: { backgroundColor: 'red' },\n      gradient: { borderColor: 'green' },\n    };\n    const tree = renderComponent({\n      ref: testRef,\n      styles: customStyles,\n    });\n\n    testRef.current.skeletonloaderRef = {\n      measure: (callback) => {\n        callback(0, 0, 30, 30, 0, 0);\n      },\n    };\n\n    fireEvent(tree.root, 'layout');\n\n    const skeletonElement = tree.toJSON();\n    const animatedElement = skeletonElement.children[0];\n    const gradientElementStyleArr =\n      tree.UNSAFE_getByType(LinearGradient).props.style;\n    const gradientElementStyle = {};\n    gradientElementStyleArr.forEach((item) => {\n      Object.keys(item).forEach((key) => {\n        gradientElementStyle[key] = item[key];\n      });\n    });\n\n    expect(tree).toMatchSnapshot();\n    expect(skeletonElement.props.style).toMatchObject({\n      backgroundColor: 'blue',\n    });\n    expect(animatedElement.props.style).toMatchObject({\n      backgroundColor: 'red',\n    });\n    expect(gradientElementStyle).toMatchObject({\n      backgroundColor: 'red',\n      borderColor: 'green',\n    });\n  });\n\n  test('createSkeleton function works correctly', () => {\n    const skeletonStyles = {\n      root: { backgroundColor: 'gray' },\n    };\n\n    const wrapper = {\n      width: 100,\n      height: 50,\n      borderRadius: 10,\n      marginTop: 5,\n    };\n\n    const style = createSkeleton(BASE_THEME, skeletonStyles, wrapper).props\n      .styles;\n    expect(style.root.width).toBe(100);\n    expect(style.root.height).toBe(50);\n    expect(style.root.borderRadius).toBe(10);\n    expect(style.root.marginTop).toBe(5);\n  });\n\n  // test('animation runs correctly', () => {\n  //   const tree = renderComponent();\n  //   const animatedView = tree.getByTestId('animated-view');\n  //   expect(animatedView).toHaveProperty(\n  //     'props.style.transform[0].rotate',\n  //     '-20deg'\n  //   );\n  // });\n\n  // test('animation stops correctly', () => {\n  //   const tree = renderComponent();\n  //   tree.unmount();\n  //   const animatedView = tree.getByTestId('animated-view');\n  //   expect(animatedView.props.style.transform[0].translateX).toBeUndefined();\n  // });\n});\n", "wavemaker-rn-runtime/test/components/basic/custom.component.spec.tsx": "import React from 'react';\nimport { Text, View } from 'react-native';\nimport { cleanup, render, waitFor } from '@testing-library/react-native';\nimport WmCustom from '@wavemaker/app-rn-runtime/components/basic/custom/custom.component';\n\nconst renderComponent = (props = {}) => {\n  const defaultProps = {\n    id: 'test-custom',\n    renderview: (props) => <Text {...props}>{props.text}</Text>,\n    text: 'Custom Content',\n    skeletonheight: '100px',\n    skeletonwidth: '200px',\n    name: 'wm-custom',\n    accessibilitylabel: 'wm-custom-label',\n  };\n  return render(<WmCustom {...defaultProps} {...props} />);\n};\n\ndescribe('Custom component', () => {\n  afterEach(() => {\n    cleanup();\n  });\n\n  test('children should be null or empty when renderview return null', () => {\n    const tree = renderComponent({\n      renderview: () => null,\n    });\n\n    expect(tree.queryByText('Custom Content')).toBeNull();\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('renders the WmCustom component with given props', () => {\n    const tree = renderComponent();\n    expect(tree.getByText('Custom Content')).toBeTruthy();\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('renders custom view returned by renderview prop', () => {\n    const customView = (props) => (\n      <View>\n        <Text>{props.extraText}</Text>\n      </View>\n    );\n    const { getByText } = renderComponent({\n      renderview: customView,\n      extraText: 'Extra Text',\n    });\n    expect(getByText('Extra Text')).toBeTruthy();\n  });\n\n  test('should render the WmCustom component with children component', () => {\n    const children = <Text>Children component</Text>;\n    const renderView = ({ text, children }) => (\n      <View>\n        <Text>{text}</Text>\n        <Text>{children}</Text>\n      </View>\n    );\n\n    const tree = renderComponent({ children, renderview: renderView });\n    expect(tree.getByText('Custom Content')).toBeTruthy();\n    expect(tree.getByText('Children component')).toBeTruthy();\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('applies styles from props', () => {\n    const tree = renderComponent({\n      styles: { root: { backgroundColor: 'red' } },\n    });\n\n    expect(tree.toJSON().props.style).toEqual(\n      expect.objectContaining({ backgroundColor: 'red' })\n    );\n  });\n\n  test('should render skeleton when showskeleton is true', async () => {\n    const tree = renderComponent({\n      showskeleton: true,\n      skeletonheight: '10px',\n      skeletonwidth: '10px',\n    });\n\n    expect(tree.toJSON()?.props.style.height).toEqual('10px');\n    expect(tree.toJSON()?.props.style.width).toEqual('10px');\n    expect(tree.toJSON()?.props.style.backgroundColor).toEqual('#eeeeee');\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render skeleton with root style when showskeleton is true and, skeletonheight and skeletonwidth is not provided or falsy value', () => {\n    const tree = renderComponent({\n      showskeleton: true,\n      skeletonheight: null,\n      skeletonwidth: null,\n      styles: {\n        root: {\n          height: '125px',\n          width: '122px',\n        },\n      },\n    });\n\n    expect(tree.toJSON()?.props.style.height).toEqual('125px');\n    expect(tree.toJSON()?.props.style.width).toEqual('122px');\n    expect(tree.toJSON()?.props.style.backgroundColor).toEqual('#eeeeee');\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('applies theme styles', () => {\n    const themeStyles = {\n      root: { backgroundColor: 'green' },\n    };\n    const tree = render(\n      <WmCustom\n        id=\"test-custom\"\n        renderview={(props) => <Text>{props.text}</Text>}\n        text=\"Custom Content\"\n        styles={themeStyles}\n      />\n    );\n    const rootElement = tree.toJSON();\n    expect(rootElement.props.style).toEqual(\n      expect.objectContaining({ backgroundColor: 'green' })\n    );\n    expect(tree).toMatchSnapshot();\n  });\n});\n", "wavemaker-rn-runtime/test/components/basic/lottie.component.spec.tsx": "import React, { createRef } from 'react';\nimport { Platform } from 'react-native';\nimport { act, fireEvent, render, waitFor } from '@testing-library/react-native';\nimport Lottie from 'react-lottie-player';\nimport LottieView from 'lottie-react-native';\nimport axios from 'axios';\nimport WmLottie from '@wavemaker/app-rn-runtime/components/basic/lottie/lottie.component';\nimport { AssetProvider } from '@wavemaker/app-rn-runtime/core/asset.provider';\n\nconst renderComponent = (props = {}) => {\n  const loadAsset = (data) => ({ url: data });\n\n  const defaultProps = {\n    id: 'testLottie',\n    autoplay: true,\n    loop: true,\n    speed: 1,\n    source: 'lottieAnimation.json',\n  };\n  return render(\n    <AssetProvider value={loadAsset}>\n      <WmLottie {...defaultProps} {...props} />\n    </AssetProvider>\n  );\n};\n\njest.mock('axios');\njest.mock('react-lottie-player');\n\ndescribe('Lottie component', () => {\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  test('renders lottie player correctly on web', async () => {\n    (Platform as any).OS = 'web';\n    axios.get.mockResolvedValue({\n      data: require('./mockData/lottie-animation.json'),\n    });\n    const tree = renderComponent();\n\n    await waitFor(() => {\n      expect(tree.UNSAFE_getByType(Lottie)).toBeTruthy();\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('renders lottie player correctly on native', async () => {\n    (Platform as any).OS = 'ios'; // Set platform to ios\n\n    const tree = renderComponent();\n\n    await waitFor(() => {\n      expect(tree.UNSAFE_getByType(LottieView)).toBeTruthy();\n      expect(tree).toMatchSnapshot();\n    });\n  });\n\n  test('should call onComplete in web lottie', async () => {\n    (Platform as any).OS = 'web';\n\n    const customRef = createRef();\n    const updateStateMock = jest.spyOn(WmLottie.prototype, 'updateState');\n    const invokeEventCallbackMock = jest.spyOn(\n      WmLottie.prototype,\n      'invokeEventCallback'\n    );\n\n    axios.get.mockResolvedValue({\n      data: require('./mockData/lottie-animation.json'),\n    });\n    const tree = renderComponent({ ref: customRef });\n\n    await waitFor(() => {\n      expect(tree.UNSAFE_getByType(Lottie)).toBeTruthy();\n      expect(tree).toMatchSnapshot();\n    });\n\n    fireEvent(tree.UNSAFE_getByType(Lottie), 'onComplete');\n\n    expect(updateStateMock).toHaveBeenCalledWith({\n      isCompleted: true,\n    });\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith('onComplete', [\n      null,\n      customRef.current.proxy,\n    ]);\n  });\n\n  test('should call onAnimationFinish in native lottie', async () => {\n    (Platform as any).OS = 'ios'; // Set platform to ios\n\n    const customRef = createRef();\n    const updateStateMock = jest.spyOn(WmLottie.prototype, 'updateState');\n    const invokeEventCallbackMock = jest.spyOn(\n      WmLottie.prototype,\n      'invokeEventCallback'\n    );\n    const tree = renderComponent({ ref: customRef });\n\n    await waitFor(() => {\n      expect(tree.UNSAFE_getByType(LottieView)).toBeTruthy();\n      expect(tree).toMatchSnapshot();\n    });\n\n    fireEvent(tree.UNSAFE_getByType(LottieView), 'onAnimationFinish');\n\n    expect(updateStateMock).toHaveBeenCalledWith({\n      isCompleted: true,\n    });\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith('onComplete', [\n      null,\n      customRef.current.proxy,\n    ]);\n  });\n\n  test('should invoke event callback with onPlay when autoplay prop is true in web lottie', async () => {\n    (Platform as any).OS = 'web';\n\n    const customRef = createRef();\n    const invokeEventCallbackMock = jest.spyOn(\n      WmLottie.prototype,\n      'invokeEventCallback'\n    );\n\n    axios.get.mockResolvedValue({\n      data: require('./mockData/lottie-animation.json'),\n    });\n    const tree = renderComponent({ ref: customRef, autoPlay: true });\n\n    await waitFor(() => {\n      expect(tree.UNSAFE_getByType(Lottie)).toBeTruthy();\n      expect(tree).toMatchSnapshot();\n    });\n\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith('onPlay', [\n      null,\n      customRef.current.proxy,\n    ]);\n  });\n\n  test('should invoke event callback with onPlay when autoplay prop is true in native lottie', async () => {\n    (Platform as any).OS = 'ios'; // Set platform to ios\n\n    const customRef = createRef();\n    const invokeEventCallbackMock = jest.spyOn(\n      WmLottie.prototype,\n      'invokeEventCallback'\n    );\n    const tree = renderComponent({ ref: customRef, autoPlay: true });\n\n    await waitFor(() => {\n      expect(tree.UNSAFE_getByType(LottieView)).toBeTruthy();\n      expect(tree).toMatchSnapshot();\n    });\n\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith('onPlay', [\n      null,\n      customRef.current.proxy,\n    ]);\n  });\n\n  test('should invoke event callback with onReady when autoplay prop is false in web lottie', async () => {\n    (Platform as any).OS = 'web';\n\n    const customRef = createRef();\n    const invokeEventCallbackMock = jest.spyOn(\n      WmLottie.prototype,\n      'invokeEventCallback'\n    );\n\n    axios.get.mockResolvedValue({\n      data: require('./mockData/lottie-animation.json'),\n    });\n    const tree = renderComponent({ ref: customRef, autoPlay: false });\n\n    await waitFor(() => {\n      expect(tree.UNSAFE_getByType(Lottie)).toBeTruthy();\n      expect(tree).toMatchSnapshot();\n    });\n\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith('onReady', [\n      null,\n      customRef.current.proxy,\n    ]);\n  });\n\n  test('should invoke event callback with onPlay when autoplay prop is false in native lottie', async () => {\n    (Platform as any).OS = 'ios'; // Set platform to ios\n\n    const customRef = createRef();\n    const invokeEventCallbackMock = jest.spyOn(\n      WmLottie.prototype,\n      'invokeEventCallback'\n    );\n    const tree = renderComponent({ ref: customRef, autoPlay: false });\n\n    await waitFor(() => {\n      expect(tree.UNSAFE_getByType(LottieView)).toBeTruthy();\n      expect(tree).toMatchSnapshot();\n    });\n\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith('onPlay', [\n      null,\n      customRef.current.proxy,\n    ]);\n  });\n\n  test('should render children as null when loadAsset is not provided through context', () => {\n    const tree = render(<WmLottie />);\n\n    expect(tree.toJSON()?.children).toBeNull();\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should invoke event callback with onPlay event when play method in the component is called', async () => {\n    (Platform as any).OS = 'ios'; // Set platform to ios\n\n    const customRef = createRef();\n    const invokeEventCallbackMock = jest.spyOn(\n      WmLottie.prototype,\n      'invokeEventCallback'\n    );\n    const tree = renderComponent({ ref: customRef });\n\n    await waitFor(() => {\n      expect(tree.UNSAFE_getByType(LottieView)).toBeTruthy();\n      expect(tree).toMatchSnapshot();\n    });\n\n    act(() => {\n      customRef.current.play();\n    });\n\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith('onPlay', [\n      null,\n      customRef.current.proxy,\n    ]);\n  });\n\n  test('should call reset method in the component when play method in the component is called while isCompleted state is true', async () => {\n    (Platform as any).OS = 'ios'; // Set platform to ios\n\n    const customRef = createRef();\n    const resetMock = jest.spyOn(WmLottie.prototype, 'reset');\n    const tree = renderComponent({ ref: customRef });\n\n    act(() => {\n      customRef.current.updateState({ isCompleted: true });\n    });\n\n    await waitFor(() => {\n      expect(tree.UNSAFE_getByType(LottieView)).toBeTruthy();\n      expect(tree).toMatchSnapshot();\n    });\n\n    act(() => {\n      customRef.current.play();\n    });\n\n    await waitFor(() => {\n      expect(resetMock).toHaveBeenCalled();\n    });\n  });\n\n  test('should invoke event callback with onPlay event and sate isCompleted state to false when reset method in the component is called', async () => {\n    (Platform as any).OS = 'ios'; // Set platform to ios\n\n    const customRef = createRef();\n    const updateStateMock = jest.spyOn(WmLottie.prototype, 'updateState');\n    const invokeEventCallbackMock = jest.spyOn(\n      WmLottie.prototype,\n      'invokeEventCallback'\n    );\n    const tree = renderComponent({ ref: customRef });\n\n    await waitFor(() => {\n      expect(tree.UNSAFE_getByType(LottieView)).toBeTruthy();\n      expect(tree).toMatchSnapshot();\n    });\n\n    act(() => {\n      customRef.current.reset();\n    });\n\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith('onPlay', [\n      null,\n      customRef.current.proxy,\n    ]);\n    expect(updateStateMock).toHaveBeenCalledWith({ isCompleted: false });\n  });\n\n  test('should call reset and play method in Lottie when reset method in the component is called for native lottie', async () => {\n    (Platform as any).OS = 'ios'; // Set platform to ios\n\n    const customRef = createRef();\n    const updateStateMock = jest.spyOn(WmLottie.prototype, 'updateState');\n    const invokeEventCallbackMock = jest.spyOn(\n      WmLottie.prototype,\n      'invokeEventCallback'\n    );\n    const tree = renderComponent({ ref: customRef });\n\n    await waitFor(() => {\n      expect(tree.UNSAFE_getByType(LottieView)).toBeTruthy();\n      expect(tree).toMatchSnapshot();\n    });\n\n    const lottieResetMock = jest.spyOn(customRef.current.lottie.current , 'reset');\n    const lottiePlayMock = jest.spyOn(customRef.current.lottie.current , 'play');\n\n    act(() => {\n      customRef.current.reset();\n    });\n\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith('onPlay', [\n      null,\n      customRef.current.proxy,\n    ]);\n    expect(updateStateMock).toHaveBeenCalledWith({ isCompleted: false });\n    expect(lottieResetMock).toHaveBeenCalled();\n    expect(lottiePlayMock).toHaveBeenCalled();\n  });\n\n  test('should invoke event callback with onPause event when pause method in the component is called', async () => {\n    (Platform as any).OS = 'ios'; // Set platform to ios\n\n    const customRef = createRef();\n    const invokeEventCallbackMock = jest.spyOn(\n      WmLottie.prototype,\n      'invokeEventCallback'\n    );\n    const tree = renderComponent({ ref: customRef });\n\n    await waitFor(() => {\n      expect(tree.UNSAFE_getByType(LottieView)).toBeTruthy();\n      expect(tree).toMatchSnapshot();\n    });\n\n    const lottiePauseMock = jest.spyOn(customRef.current.lottie.current , 'pause');\n\n    act(() => {\n      customRef.current.pause();\n    });\n\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith('onPause', [\n      null,\n      customRef.current.proxy,\n    ]);\n    expect(lottiePauseMock).toHaveBeenCalled();\n  });\n});\n", "wavemaker-rn-runtime/test/components/basic/tooltip.component.spec.tsx": "import React from 'react';\nimport { Text } from 'react-native';\nimport WmTooltip, {\n  WmTooltipStyles,\n} from '@wavemaker/app-rn-runtime/components/basic/tooltip/tooltip.component';\nimport { render } from '@testing-library/react-native';\n\nconst renderComponent = (props = {}) => {\n  const defaultProps = {\n    name: 'wm-tooltip',\n    id: 'test-tooltip',\n    text: 'Tooltip Text',\n    showTooltip: true,\n    direction: 'up',\n    tooltipStyle: {},\n    tooltipLabelStyle: {},\n    tooltipTriangleStyle: {},\n    children: <Text>Hover over me</Text>,\n  };\n  return render(<WmTooltip {...defaultProps} {...props} />);\n};\n\ndescribe('WmTooltip component', () => {\n  test('should render the WmTooltip correctly with given props', () => {\n    const tree = renderComponent();\n\n    expect(tree.getByText('Tooltip Text')).toBeTruthy();\n    expect(tree.getByText('Hover over me')).toBeTruthy();\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('renders the tooltip in the correct direction - up', () => {\n    const tree = renderComponent({ direction: 'up' });\n\n    expect(tree.toJSON().children[0].props.style).toMatchObject({ top: -60 });\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('renders the tooltip in the correct direction - down', () => {\n    const tree = renderComponent({ direction: 'down' });\n\n    expect(tree.toJSON().children[0].props.style).toMatchObject({\n      bottom: -40,\n    });\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('renders the tooltip in the correct direction - left', () => {\n    const tree = renderComponent({ direction: 'left' });\n\n    expect(tree.toJSON().children[0].props.style).toMatchObject({ left: -40 });\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('renders the tooltip in the correct direction - right', () => {\n    const tree = renderComponent({ direction: 'right' });\n\n    expect(tree.toJSON().children[0].props.style).toMatchObject({ right: -40 });\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('handles tooltipStyle property correctly', () => {\n    const tooltipStyle = { backgroundColor: 'red', padding: 15 };\n    const tree = renderComponent({ tooltipStyle });\n\n    expect(tree.toJSON().children[0].props.style).toEqual(\n      expect.objectContaining(tooltipStyle)\n    );\n    expect(tree.toJSON().children[0].children[1].props.style).toContainEqual(\n      expect.objectContaining({\n        borderBottomColor: tooltipStyle.backgroundColor,\n      })\n    );\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('handles tooltipLabelStyle property correctly', () => {\n    const tooltipLabelStyle = { color: 'blue', fontSize: 18 };\n    const tree = renderComponent({ tooltipLabelStyle });\n    const tooltipText = tree.getByText('Tooltip Text');\n\n    expect(tooltipText.props.style).toEqual(\n      expect.arrayContaining([expect.objectContaining(tooltipLabelStyle)])\n    );\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('handles tooltipTriangleStyle property correctly', () => {\n    const tooltipTriangleStyle = { borderBottomColor: 'green' };\n    const tree = renderComponent({ tooltipTriangleStyle });\n    const triangleComponent = tree.toJSON().children[0].children[1];\n\n    expect(triangleComponent.props.style).toEqual(\n      expect.arrayContaining([expect.objectContaining(tooltipTriangleStyle)])\n    );\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('does not render tooltip when showTooltip is false', () => {\n    const tree = renderComponent({ showTooltip: false });\n\n    expect(tree.queryByText('Tooltip Text')).toBeNull();\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should apply the style prop correctly', () => {\n    const themeTooltipStyle = {\n      root: {\n        backgroundColor: 'pink',\n      },\n      tooltip: {\n        backgroundColor: 'yellow',\n      },\n      triangle: {\n        backgroundColor: 'purple',\n      },\n    } as WmTooltipStyles;\n\n    const tree = renderComponent({ styles: themeTooltipStyle });\n    const triangleComponentStyleArr =\n      tree.toJSON().children[0].children[1].props.style;\n    const triangleComponentStyle = {};\n    triangleComponentStyleArr.forEach((item) => {\n      Object.keys(item).forEach((key) => {\n        triangleComponentStyle[key] = item[key];\n      });\n    });\n\n    expect(tree.toJSON().props.style).toMatchObject({\n      backgroundColor: 'pink',\n    });\n    expect(triangleComponentStyle).toMatchObject({\n      backgroundColor: 'purple',\n      borderBottomColor: 'yellow',\n    });\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('renders children correctly', () => {\n    const tree = renderComponent({ children: <Text>Test Children</Text> });\n\n    expect(tree.getByText('Test Children')).toBeTruthy();\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render the component with style \"top: -60\" when direction prop is falsy', () => {\n    const tree = renderComponent({\n      direction: '',\n    });\n\n    expect(tree.toJSON().children[0].props.style).toMatchObject({ top: -60 });\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should rotate the triangle component to 180deg when direction prop is falsy', () => {\n    const tree = renderComponent({\n      direction: '',\n    });\n    const triangleComponentStyleArr =\n      tree.toJSON().children[0].children[1].props.style;\n    const triangleComponentStyle = {};\n    triangleComponentStyleArr.forEach((item) => {\n      Object.keys(item).forEach((key) => {\n        triangleComponentStyle[key] = item[key];\n      });\n    });\n\n    expect(triangleComponentStyle).toMatchObject({\n      transform: [{ rotate: '180deg' }],\n    });\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('the triangle component should have style property \"bottom: -10\" when direction prop is falsy', () => {\n    const tree = renderComponent({\n      direction: '',\n    });\n    const triangleComponentStyleArr =\n      tree.toJSON().children[0].children[1].props.style;\n    const triangleComponentStyle = {};\n    triangleComponentStyleArr.forEach((item) => {\n      Object.keys(item).forEach((key) => {\n        triangleComponentStyle[key] = item[key];\n      });\n    });\n\n    expect(triangleComponentStyle).toMatchObject({\n      bottom: -10,\n    });\n    expect(tree).toMatchSnapshot();\n  });\n});\n", "wavemaker-rn-runtime/test/components/basic/audio.component.spec.tsx": "import React, { ReactNode, createRef } from 'react';\nimport { Text, TouchableOpacity, View } from 'react-native';\nimport WmAudio from '@wavemaker/app-rn-runtime/components/basic/audio/audio.component';\nimport WmAudioProps from '@wavemaker/app-rn-runtime/components/basic/audio/audio.props';\nimport {\n  render,\n  screen,\n  fireEvent,\n  waitFor,\n  act,\n} from '@testing-library/react-native';\nimport { Sound } from 'expo-av/build/Audio';\nimport { AssetProvider } from '@wavemaker/app-rn-runtime/core/asset.provider';\n\nconst mockAVPlaybackStatusSuccess = {\n  isLoaded: true,\n  uri: '',\n  durationMillis: 2000, // 2 minutes in milliseconds\n  positionMillis: 0, // Start position\n  isPlaying: true, // Whether it's currently playing\n  isMuted: false, // Whether the sound is muted\n  volume: 1.0, // Full volume\n  rate: 1.0, // Normal playback speed\n  shouldCorrectPitch: true,\n  isLooping: false, // Not looping\n  didJustFinish: false, // Whether the sound just finished playing\n};\n\nconst timer = (time = 100) =>\n  new Promise((resolve: any, reject) => {\n    setTimeout(() => resolve(), time);\n  });\n\nconst createAsyncMock = jest.spyOn(Sound, 'createAsync').mockResolvedValue({\n  sound: {\n    playAsync: jest.fn(),\n    pauseAsync: jest.fn().mockResolvedValue(mockAVPlaybackStatusSuccess),\n    unloadAsync: jest.fn(),\n    setPositionAsync: jest.fn(),\n    setStatusAsync: jest.fn().mockResolvedValue(mockAVPlaybackStatusSuccess),\n    getStatusAsync: jest.fn().mockResolvedValue(mockAVPlaybackStatusSuccess),\n    replayAsync: jest.fn(),\n  },\n  status: {\n    isLoaded: true,\n    durationMillis: 2000,\n  },\n});\n\nconst renderComponent = (props = {}) => {\n  let defaultProps: WmAudioProps;\n  defaultProps = new WmAudioProps();\n  defaultProps.controls = true;\n  defaultProps.mp3format = 'https://www.example.com/audio.mp3';\n  const loadAsset = (path) => path;\n\n  return render(\n    <AssetProvider value={loadAsset}>\n      <WmAudio {...defaultProps} {...props} />\n    </AssetProvider>\n  );\n};\n\ndescribe('WmAudio component', () => {\n  beforeEach(() => {});\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  // Check Rendering with Default Props\n  it('renders correctly with default props', () => {\n    renderComponent({ name: 'audio' });\n    expect(screen).toMatchSnapshot();\n    expect(screen.getByTestId('audio_slider')).toBeTruthy();\n    expect(screen.getByTestId('audio_mute_icon')).toBeTruthy();\n    expect(screen.getByTestId('audio_play_icon')).toBeTruthy();\n  });\n\n  // Playing and Pausing Audio\n  it('handles playing and pausing audio correctly', async () => {\n    renderComponent({ name: 'audio' });\n    const playButton = screen.getByTestId('audio_play_icon');\n    fireEvent.press(playButton);\n\n    await timer(300);\n    expect(createAsyncMock).toHaveBeenCalled();\n\n    expect(screen.getByTestId('audio_pause_icon')).toBeTruthy();\n\n    const pauseButton = screen.getByTestId('audio_pause_icon');\n    fireEvent.press(pauseButton);\n\n    await timer(300);\n\n    expect(screen.getByTestId('audio_play_icon')).toBeTruthy();\n  });\n\n  // Mute and Unmute\n  it('handles mute and unmute correctly', async () => {\n    renderComponent({ name: 'audio' });\n\n    const playButton = screen.getByTestId('audio_play_icon');\n    fireEvent.press(playButton);\n\n    await timer(300);\n\n    const muteButton = screen.getByTestId('audio_mute_icon');\n    fireEvent.press(muteButton);\n\n    await waitFor(() => {\n      expect(screen.getByTestId('audio_unmute_icon')).toBeTruthy();\n    });\n\n    const unmuteButton = screen.getByTestId('audio_unmute_icon');\n    fireEvent.press(unmuteButton);\n\n    await waitFor(() => {\n      expect(screen.getByTestId('audio_mute_icon')).toBeTruthy();\n    });\n  });\n\n  // Lifecycle Methods\n  it('calls componentDidMount and componentWillUnmount correctly', async () => {\n    const componentDidMountSpy = jest.spyOn(\n      WmAudio.prototype,\n      'componentDidMount'\n    );\n    const componentWillUnmountSpy = jest.spyOn(\n      WmAudio.prototype,\n      'componentWillUnmount'\n    );\n    const { unmount } = renderComponent({\n      name: 'audio',\n    });\n\n    expect(componentDidMountSpy).toHaveBeenCalled();\n\n    unmount();\n    expect(componentWillUnmountSpy).toHaveBeenCalled();\n  });\n\n  // Accessibility Props\n  xit('applies accessibility props correctly', () => {\n    renderComponent({ name: 'audio', accessibilitylabel: 'Audio Player' });\n\n    expect(screen.getByLabelText('Audio Player')).toBeTruthy();\n  });\n\n  // Autoplay\n  it('automatically plays audio when autoplay is true', async () => {\n    renderComponent({ name: 'audio', autoplay: true });\n\n    await timer(1000);\n    expect(Sound.createAsync).toHaveBeenCalled();\n  });\n\n  // Slider Handling\n  it('handles slider correctly', async () => {\n    const ref = createRef();\n    const mockSetPositionAsync = jest.spyOn(\n      Sound.prototype,\n      'setPositionAsync'\n    );\n    renderComponent({ name: 'audio', autoplay: true, ref });\n\n    await timer(1000);\n\n    const mockSetPositionAsyncRef = jest.spyOn(\n      ref.current.sound,\n      'setPositionAsync'\n    );\n\n    const slider = screen.getByTestId('audio_slider');\n    fireEvent(slider, 'valueChange', 2);\n\n    await waitFor(() => {\n      expect(Sound.createAsync).toHaveBeenCalled();\n      expect(mockSetPositionAsyncRef).toHaveBeenCalledWith(2000);\n    });\n  });\n\n  // Loop\n  it('replays audio when loop is true', async () => {\n    const ref = createRef();\n\n    const mockReplayAsync = jest.spyOn(Sound.prototype, 'replayAsync');\n    renderComponent({ name: 'audio', loop: true, autoplay: true, ref });\n\n    await timer(1000);\n\n    const mockReplayAsyncRef = jest.spyOn(ref.current.sound, 'replayAsync');\n\n    expect(Sound.createAsync).toHaveBeenCalled();\n\n    await timer(1000);\n    await timer(1000);\n    await timer(1000);\n\n    await waitFor(() => {\n      expect(mockReplayAsyncRef).toHaveBeenCalled();\n    });\n  });\n\n  // Handle Props Change\n  it('handles prop changes correctly', async () => {\n    let defaultProps = new WmAudioProps();\n    defaultProps.controls = true;\n    defaultProps.mp3format = 'https://www.example.com/audio.mp3';\n    const { rerender } = renderComponent({ name: 'audio' });\n    const loadAsset = (path) => path;\n\n    const newProps = {\n      ...defaultProps,\n      mp3format: 'https://www.example.com/newaudio.mp3',\n      autoplay: true,\n    };\n    rerender(\n      <AssetProvider value={loadAsset}>\n        <WmAudio {...newProps} />\n      </AssetProvider>\n    );\n\n    await waitFor(() => {\n      expect(createAsyncMock).toHaveBeenCalledWith(\n        { uri: 'https://www.example.com/newaudio.mp3' },\n        { isMuted: false }\n      );\n    });\n  });\n\n     //skeleton loader\n    it('should render skeleton when show skeleton is true', () => {\n      const tree = renderComponent({ name: 'audio', showskeleton:true});\n      const viewEles = tree.UNSAFE_getAllByType(View);\n      expect(viewEles[2].props.style.height).toBe(16);\n      expect(viewEles[2].props.style.width).toBe(200);\n    })\n});\n", "wavemaker-rn-runtime/test/components/basic/video.component.spec.tsx": "import React, { createRef } from 'react';\nimport {\n  render,\n  screen,\n  fireEvent,\n  act,\n  waitFor,\n} from '@testing-library/react-native';\nimport WmVideo from '@wavemaker/app-rn-runtime/components/basic/video/video.component';\nimport { AssetProvider } from '@wavemaker/app-rn-runtime/core/asset.provider';\nimport { createVideoPlayer } from 'expo-video';\n\n\njest.mock('expo-video', () => {\n  const { View } = require('react-native');\n  return {\n    VideoView: jest.fn((props) => <View {...props} />),\n    createVideoPlayer: jest.fn(() => ({\n      play: jest.fn(),\n      pause: jest.fn(),\n      release: jest.fn(),\n      addListener: jest.fn(),\n      removeListener: jest.fn(),\n    })),\n  };\n});\n\nconst loadAsset = (path) => path;\n\nconst renderComponent = (props: any = {}) =>\n  render(\n    <AssetProvider value={loadAsset}>\n      <WmVideo {...props} />\n    </AssetProvider>\n  );\n\ndescribe('WmVideo Component Tests', () => {\n  afterEach(() => {\n    jest.clearAllMocks();\n    jest.clearAllTimers();\n  });\n\n  it('renders component with default props', () => {\n    renderComponent();\n    expect(screen).toMatchSnapshot();\n  });\n\n  it('handles mp4 video source URL correctly', async () => {\n    renderComponent({\n      name: 'test',\n      mp4format: 'https://example.com/video.mp4',\n      webmformat: '',\n      autoplay: false,\n    });\n\n    expect(createVideoPlayer).toHaveBeenCalledWith({\n        uri: 'https://example.com/video.mp4',\n      });\n    });\n\n    it('handles webm video source URL correctly', async () => {\n      const ref : any = createRef();\n      renderComponent({\n        name: 'test',\n        mp4format: '',\n        webmformat: 'https://example.com/video.webm',\n        autoplay: true,\n        ref: ref\n      });\n  \n      expect(createVideoPlayer).toHaveBeenCalledWith({\n          uri: 'https://example.com/video.webm',\n        });\n\n      const player = ref?.current?.player\n      const playMock = jest.spyOn(player, 'play')\n\n      expect(player.addListener).toHaveBeenCalledWith(\n        'statusChange', expect.any(Function)\n      );\n\n      const [_statusCb, statusChangeCallback] = player.addListener.mock.calls.find(\n        ([eventName]: string[]) => eventName === 'statusChange'\n      );\n\n      statusChangeCallback({ status: 'readyToPlay'})\n\n      await waitFor(() => {\n        expect(playMock).toHaveBeenCalled();\n      });\n\n    });\n\n  it('handles mp4 video local source correctly', async () => {\n      const sourcePath = 'resources/videos/sample_video_bear.mp4'\n      renderComponent({\n        name: 'test',\n        mp4format: sourcePath,\n        webmformat: '',\n        autoplay: false,\n      });\n      \n    expect(createVideoPlayer).toHaveBeenCalledWith(sourcePath);\n\n  });\n\n  it('autoplays video when autoplay is true', async () => {\n    const ref : any = createRef();\n    renderComponent({\n      name: 'test',\n      mp4format: 'https://example.com/video.mp4',\n      autoplay: true,\n      muted: true, \n      ref: ref\n    });\n\n    const player = ref?.current?.player\n    const playMock = jest.spyOn(player, 'play')\n\n    expect(player.addListener).toHaveBeenCalledWith(\n      'statusChange', expect.any(Function)\n    );\n\n    const [_statusCb, statusChangeCallback] = player.addListener.mock.calls.find(\n      ([eventName]: string[]) => eventName === 'statusChange'\n    );\n\n    statusChangeCallback({ status: 'readyToPlay'})\n\n    await waitFor(() => {\n      expect(playMock).toHaveBeenCalled();\n    });\n\n  });\n\n  it('renders height and width properly', () => {\n    renderComponent({\n      name: 'test',\n      mp4format: 'https://example.com/video.mp4',\n    });\n\n    const videoView = screen.getByTestId('test_video');\n    expect(videoView.props.style).toMatchObject({\n      width: '100%',\n      height: '100%',\n      flex: 1,\n    });\n  });\n\n  it('handles event listeners properly', async () => {\n    const ref: any = createRef();\n    renderComponent({\n      name: 'test',\n      mp4format: 'https://example.com/video.mp4',\n      autoplay: true,\n      ref,\n    });\n\n    const player = ref?.current?.player;\n\n    expect(player.addListener).toHaveBeenCalledWith(\n      'playingChange',\n      expect.any(Function)\n    );\n    expect(player.addListener).toHaveBeenCalledWith(\n      'statusChange',\n      expect.any(Function)\n    );\n\n    const [_eventName, statusChangeCallback] = player.addListener.mock.calls.find(\n      ([eventName]: string[]) => eventName === 'statusChange'\n    );\n\n    act(() => {\n      statusChangeCallback({ status: 'readyToPlay' });\n    });\n\n    expect(player.play).toHaveBeenCalled();\n  });\n\n  it('renders skeleton loader when video is not ready', () => {\n    renderComponent({\n      name: 'test',\n      showskeleton: true,\n    });\n    expect(screen).toMatchSnapshot();\n  });\n\n\n  it('shows video poster before playback starts & autoplay false', () => {\n    renderComponent({\n      name: 'test',\n      mp4format: 'https://example.com/video.mp4',\n      videoposter: 'https://example.com/poster.png',\n      autoplay: false\n    });\n\n    const poster = screen.getByTestId('test_video_poster');\n    expect(poster.props.source).toEqual({\n      uri: 'https://example.com/poster.png',\n    });\n  });\n\n  it('hide video poster before playback starts & autoplay true', () => {\n    renderComponent({\n      name: 'test',\n      mp4format: 'https://example.com/video.mp4',\n      videoposter: 'https://example.com/poster.png',\n      autoplay: true\n    });\n\n    const poster = screen.queryByTestId('test_video_poster');\n    expect(poster).toBeNull();\n  });\n\n  it('should play the video on tap on videoposter', ()=>{\n    const ref: any = createRef();\n    renderComponent({\n      name: 'test',\n      mp4format: 'https://example.com/video.mp4',\n      videoposter: 'https://example.com/poster.png',\n      ref: ref\n    });\n\n    const player = ref?.current?.player;\n\n    const poster = screen.getByTestId('test_video_poster');\n    fireEvent(poster, 'press')\n\n    expect(player.play).toHaveBeenCalled();\n\n  })\n\n  it('applies accessibility props correctly', () => {\n    renderComponent({\n      name: 'test',\n      mp4format: 'https://example.com/video.mp4',\n      accessibilitylabel: 'Accessible_video',\n      hint: 'Video',\n      accessibilityrole: 'Video',\n    });\n\n    // // video\n    expect(screen.getByLabelText('Accessible_video')).toBeTruthy();\n    expect(screen.getByRole('Video')).toBeTruthy();\n    expect(screen.getByA11yHint('Video')).toBeTruthy();\n\n    // poster\n    expect(screen.getByLabelText('Accessible_video_poster')).toBeTruthy();\n    expect(screen.getByRole('Video_poster')).toBeTruthy();\n    expect(screen.getByA11yHint('Video_poster')).toBeTruthy();\n  });\n\n  it('handles props correctly', async () => {\n    const ref : any = createRef();\n    renderComponent({\n      name: 'test',\n      mp4format: 'https://example.com/video.mp4',\n      loop: true,\n      muted: true, \n      ref: ref\n    });\n\n    const player = ref?.current?.player\n    expect(player.loop).toBe(true);\n    expect(player.muted).toBe(true);\n  });\n\n});", "wavemaker-rn-runtime/test/components/basic/icon.component.spec.tsx": "import React from 'react';\nimport { Text } from 'react-native';\nimport {\n  render,\n  fireEvent,\n  waitFor,\n  cleanup,\n} from '@testing-library/react-native';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport { AssetProvider } from '@wavemaker/app-rn-runtime/core/asset.provider';\nimport { TestIdPrefixProvider } from '@wavemaker/app-rn-runtime/core/testid.provider';\n\nconst renderComponent = (props) => {\n  const loadAsset = (path) => path;\n\n  return render(\n    <TestIdPrefixProvider value={'unit-test'}>\n      <AssetProvider value={loadAsset}>\n        <WmIcon\n          iconposition={'left'}\n          accessibilitylabel=\"wm-icon\"\n          name={'wm-icon'}\n          {...props}\n        />\n      </AssetProvider>\n    </TestIdPrefixProvider>\n  );\n};\n\ndescribe('WmIcon Component', () => {\n  afterEach(() => {\n    cleanup();\n  });\n\n  test('renders the icon with the correct icon class', () => {\n    const tree = renderComponent({\n      iconclass: 'fa fa-edit',\n    });\n\n    const iconComponent = tree.queryByText('edit');\n\n    expect(iconComponent).not.toBeNull();\n    expect(iconComponent).toHaveProperty('children', ['edit']);\n    expect(iconComponent?.type).toBe('Text');\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('renders the icon with waveicon class', () => {\n    const tree = renderComponent({\n      iconclass: 'wi wi-edit',\n    });\n\n    const iconComponent = tree.queryByText('edit');\n\n    expect(iconComponent).not.toBeNull();\n    expect(iconComponent).toHaveProperty('children', ['edit']);\n    expect(iconComponent?.type).toBe('Text');\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('renders the icon with stream line light icon class', () => {\n    const tree = renderComponent({\n      iconclass: 'wm-sl-l sl-edit',\n    });\n\n    const iconComponent = tree.queryByText('edit');\n\n    expect(iconComponent).not.toBeNull();\n    expect(iconComponent).toHaveProperty('children', ['edit']);\n    expect(iconComponent?.type).toBe('Text');\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('renders the icon with stream line regular icon class', () => {\n    const tree = renderComponent({\n      iconclass: 'wm-sl-r sl-edit',\n    });\n\n    const iconComponent = tree.queryByText('edit');\n\n    expect(iconComponent).not.toBeNull();\n    expect(iconComponent).toHaveProperty('children', ['edit']);\n    expect(iconComponent?.type).toBe('Text');\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('clicking the icon triggers the expected action', () => {\n    const mockOnClick = jest.fn();\n\n    const tree = renderComponent({\n      iconclass: 'fa fa-edit',\n      onTap: mockOnClick,\n    });\n\n    expect(tree).toMatchSnapshot();\n    fireEvent(tree.getByLabelText('wm-icon'), 'press');\n    waitFor(() => {\n      expect(mockOnClick).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  test('icon size changes correctly when iconsize prop is provided', async () => {\n    const tree = renderComponent({\n      iconsize: 40,\n      iconclass: 'fa fa-edit',\n    });\n\n    expect(tree).toMatchSnapshot();\n    expect(tree.getByText('edit').props.size).toBe(40);\n  });\n\n  test('external icon should load when url is given', () => {\n    const iconUrl = 'https://docs.wavemaker.com/learn/img/WM_blue_logo.png';\n\n    const tree = renderComponent({\n      iconurl: { iconUrl },\n    });\n\n    expect(tree).toMatchSnapshot();\n    expect(\n      tree.getByTestId('unit-test_wm-icon_icon').props.source.iconUrl\n    ).toBe(iconUrl);\n  });\n\n  test('caption should display next to the icon when caption prop is provided', () => {\n    const tree = renderComponent({\n      iconclass: 'fa fa-edit',\n      iconposition: 'left',\n      accessibilitylabel: 'icon',\n      caption: 'test-button',\n    });\n\n    expect(tree.getByText('test-button')).toBeDefined();\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('caption should display left to the icon when iconposition is \"right\"', () => {\n    const tree = renderComponent({\n      iconclass: 'fa fa-edit',\n      iconposition: 'right',\n      accessibilitylabel: 'icon',\n      caption: 'test-button',\n    });\n\n    const startingIndex = 1; // as first component is background component;\n    const childrenComponents = tree.getByTestId('non_animatableView').children;\n\n    expect(tree.getByText('test-button')).toBeDefined();\n    expect(childrenComponents[startingIndex].props).toMatchObject({\n      children: 'test-button',\n    });\n    expect(\n      childrenComponents[startingIndex + 1].props.children.props\n    ).toMatchObject({ name: 'edit' });\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('caption should display left to the icon when iconposition is \"left\"', () => {\n    const tree = renderComponent({\n      iconclass: 'fa fa-edit',\n      iconposition: 'left',\n      accessibilitylabel: 'icon',\n      caption: 'test-button',\n    });\n\n    const startingIndex = 1; // as first component is background component;\n    const childrenComponents = tree.getByTestId('non_animatableView').children;\n\n    expect(tree.getByText('test-button')).toBeDefined();\n    expect(\n      childrenComponents[startingIndex].props.children.props\n    ).toMatchObject({ name: 'edit' });\n    expect(childrenComponents[startingIndex + 1].props).toMatchObject({\n      children: 'test-button',\n    });\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('icon should component should get type or value as empty string or falsy value when iconclass dose not have icon name of fontaswom icons', () => {\n    const tree = renderComponent({\n      iconclass: 'fa',\n      iconposition: 'right',\n      accessibilitylabel: 'icon',\n      name: 'test-wm',\n    });\n\n    expect(tree).toMatchSnapshot();\n    expect(tree.UNSAFE_queryByType(Text).props.children).toBeFalsy();\n  });\n\n  test('icon should component should get type or value as empty string or falsy value when iconclass dose not have icon name of wavicon icons', () => {\n    const tree = renderComponent({\n      iconclass: 'wi',\n      iconposition: 'right',\n      accessibilitylabel: 'icon',\n      name: 'test-wm',\n    });\n\n    expect(tree).toMatchSnapshot();\n    expect(tree.UNSAFE_queryByType(Text).props.children).toBeFalsy();\n  });\n\n  test('icon should component should get type or value as empty string or falsy value when iconclass dose not have icon name of streamline-regular-icon icons', () => {\n    const tree = renderComponent({\n      iconclass: 'wm-sl-r',\n      iconposition: 'right',\n      accessibilitylabel: 'icon',\n      name: 'test-wm',\n    });\n\n    expect(tree).toMatchSnapshot();\n    expect(tree.UNSAFE_queryByType(Text).props.children).toBeFalsy();\n  });\n\n  test('icon should component should get type or value as empty string or falsy value when iconclass dose not have icon name of streamline-light-icon icons', () => {\n    const tree = renderComponent({\n      iconclass: 'wm-sl-l',\n      iconposition: 'right',\n      accessibilitylabel: 'icon',\n      name: 'test-wm',\n    });\n\n    expect(tree).toMatchSnapshot();\n    expect(tree.UNSAFE_queryByType(Text).props.children).toBeFalsy();\n  });\n\n  test('only caption should display when iconposition prop is not provided or the value is falsy', () => {\n    const tree = renderComponent({\n      iconclass: 'fa fa-edit',\n      accessibilitylabel: 'icon',\n      iconposition: '',\n      caption: 'test-button',\n    });\n\n    expect(tree).toMatchSnapshot();\n    expect(tree.getByText('test-button')).toBeDefined();\n    expect(tree.queryByText('edit')).toBeNull();\n  });\n\n  // test('accessibility label as \"test-label\" should be present when accessibilitylabel prop is set to \"test-label\"', () => {\n  //   const tree = renderComponent({\n  //     iconclass: 'fa fa-edit',\n  //     accessibilitylabel: 'test-label',\n  //     onTap: () => {},\n  //   });\n\n  //   expect(tree).toMatchSnapshot();\n  //   expect(tree.getByLabelText('test-label')).toBeTruthy();\n  // });\n\n  test('should not render icon when iconclass is falsy ', () => {\n    const tree = renderComponent({\n      iconclass: '',\n      accessibilitylabel: 'test-label',\n      onTap: () => {},\n    });\n\n    expect(tree).toMatchSnapshot();\n    expect(tree.UNSAFE_queryByType(Text)).toBeNull();\n  });\n\n  // should render accessibility props even when onTap is not passed\n  xit('should render icon with accessibility props when passed', () => {\n    const tree = renderComponent({\n      iconclass: 'fa fa-edit',\n      accessibilitylabel: 'test-label',\n      accessibilityrole: 'wm-icon-ar',\n      hint: 'this is icon',\n      caption: 'icon-caption',\n      // onTap: () => {},\n    });\n\n    expect(tree.getByLabelText('test-label')).toBeDefined();\n    expect(tree.getByAccessibilityHint('this is icon')).toBeDefined();\n    expect(tree.toJSON().props).toMatchObject({\n      accessibilityRole: 'wm-icon-ar',\n    });\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render only caption when iconclass is falsy and caption is has value', () => {\n    const tree = renderComponent({\n      iconclass: '',\n      accessibilitylabel: 'test-label',\n      accessibilityrole: 'wm-icon-ar',\n      caption: 'icon-caption',\n      onTap: () => {},\n    });\n\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render with animations as spin', () => {\n    const tree = renderComponent({\n      animation: 'spin',\n    });\n\n    expect(tree.getByTestId('animatableView').props).toMatchObject({\n      animation: 'spin',\n    });\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render with animations as pulse', () => {\n    const tree = renderComponent({\n      animation: 'pulse',\n    });\n\n    expect(tree.getByTestId('animatableView').props).toMatchObject({\n      animation: 'pulse',\n    });\n    expect(tree).toMatchSnapshot();\n  });\n});\n", "wavemaker-rn-runtime/test/components/basic/buttongroup.component.spec.tsx": "import React from 'react';\nimport { render } from '@testing-library/react-native';\nimport WmButtongroupProps from '@wavemaker/app-rn-runtime/components/basic/buttongroup/buttongroup.props';\nimport WmButtongroup from '@wavemaker/app-rn-runtime/components/basic/buttongroup/buttongroup.component';\nimport { ThemeProvider } from '@wavemaker/app-rn-runtime/styles/theme';\nimport WmButton from '@wavemaker/app-rn-runtime/components/basic/button/button.component';\nimport { Text } from 'react-native';\n\n// Mock theme\nconst mockTheme = {\n  buttonGrpBorderColor: '#000000',\n  buttonGrpBgColor: '#ffffff',\n};\n\nconst renderWithTheme = (component: React.ReactElement) => {\n  return render(<ThemeProvider value={mockTheme}>{component}</ThemeProvider>);\n};\n\ndescribe('WmButtongroup', () => {\n  it('renders correctly with default props', () => {\n    const props = {\n      vertical: false,\n      name: 'buttongroup1',\n    };\n    const tree = render(<WmButtongroup {...props} />);\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders with `vertical` prop set to true', () => {\n    const props = {\n      vertical: true,\n    };\n    const tree = render(<WmButtongroup {...props} />);\n    const buttonGroupRoot = tree.root;\n\n    expect(buttonGroupRoot.props.style).toContainEqual({\n      flexDirection: 'column',\n    });\n  });\n\n  it('renders skeleton when `showskeleton` is true', () => {\n    const props = {\n      vertical: false,\n      showskeleton: true,\n      skeletonwidth: 90,\n      skeletonheight: 40,\n      children: <Text>Child Element</Text>,\n    };\n    const tree = render(<WmButtongroup {...props} />);\n    expect(tree.queryByText('Child Element')).toBeNull();\n    expect(tree).toMatchSnapshot();\n    expect(tree.root.props.style.height).toBe(props.skeletonheight);\n    expect(tree.root.props.style.width).toBe(props.skeletonwidth);\n  });\n\n  it('should render skeleton with root width and height when skeleton width and height are not provided', () => {\n    const width = 50;\n    const height = 70;\n    const props = {\n      showskeleton: true,\n      styles: {\n        root: {\n          width: width,\n          height: height,\n        },\n      },\n    };\n    const tree = render(<WmButtongroup {...props} />);\n    expect(tree).toMatchSnapshot();\n    expect(tree.root.props.style.height).toBe(height);\n    expect(tree.root.props.style.width).toBe(width);\n  });\n\n  it('should have width and height to be 0 when show is false', () => {\n    const props = {\n      vertical: false,\n      show: false,\n    };\n    const tree = render(<WmButtongroup {...props} />);\n    const buttonGroupRoot = tree.root;\n\n    expect(buttonGroupRoot.props.style[0].width).toBe(0);\n    expect(buttonGroupRoot.props.style[0].height).toBe(0);\n  });\n\n  it('renders with given width', () => {\n    const width = 70;\n    const props = {\n      vertical: false,\n      styles: {\n        root: {\n          width: width,\n        },\n      },\n    };\n\n    const tree = render(<WmButtongroup {...props} />);\n    const buttonGroupRoot = tree.root;\n    expect(buttonGroupRoot.props.style[0].width).toBe(width);\n  });\n\n  it('renders children correctly', () => {\n    const props = {\n      vertical: false,\n    };\n    const { getByText } = render(\n      <WmButtongroup {...props}>\n        <WmButton caption=\"Button1\" />\n        <WmButton caption=\"Button2\" />\n      </WmButtongroup>\n    );\n\n    expect(getByText('Button1')).toBeTruthy();\n    expect(getByText('Button2')).toBeTruthy();\n  });\n\n  it('should render custom styles with properly', () => {\n    const bgColor = '#234555';\n    const props = {\n      styles: {\n        root: {\n          backgroundColor: bgColor,\n        },\n      },\n    };\n\n    const tree = render(<WmButtongroup {...props} />);\n    const buttonGroupRoot = tree.root;\n    expect(buttonGroupRoot.props.style[0].backgroundColor).toBe(bgColor);\n  });\n\n  xit('applies styles correctly based on props and themes', () => {\n    const props = {\n      vertical: false,\n      children: <></>,\n    };\n\n    const tree = render(<WmButtongroup {...props} />);\n    const buttonGroupRoot = tree.root;\n\n    expect(buttonGroupRoot.props.style).toContainEqual({\n      borderColor: mockTheme.buttonGrpBorderColor,\n      backgroundColor: mockTheme.buttonGrpBgColor,\n    });\n  });\n});\n", "wavemaker-rn-runtime/test/components/basic/label.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport { Text, TouchableOpacity, StyleSheet, TextStyle } from 'react-native';\nimport renderer from 'react-test-renderer';\nimport { render, fireEvent, waitFor } from '@testing-library/react-native';\n\n//import WmLabel from '@wavemaker/app-rn-runtime/components/basic/label/label.component';\n\nimport WmLabel from '@wavemaker/app-rn-runtime/components/basic/label/label.component';\nimport WmLabelProps from '@wavemaker/app-rn-runtime/components/basic/label/label.props';\n\nimport { NavigationService } from '@wavemaker/app-rn-runtime/core/navigation.service';\nimport { BaseComponent, ParentContext } from '../../../src/core/base.component';\nimport { AccessibilityInfo } from 'react-native';\n\nimport ThemeVariables from '../../../src/styles/theme.variables';\nimport { NavigationServiceProvider } from '../../../src/core/navigation.service';\nimport mockNavigationService from '../../__mocks__/navigation.service';\nimport {\n  NamedStyles,\n  Theme,\n  ThemeEvent,\n  ThemeProvider,\n  styleGeneratorFn,\n} from '../../../src/styles/theme';\nimport EventNotifier from '../../../src/core/event-notifier';\nimport BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport MaskedView from '@react-native-masked-view/masked-view';\nimport { LinearGradient } from 'expo-linear-gradient';\njest.mock('@react-native-masked-view/masked-view', () => 'MaskedView');\njest.mock('expo-linear-gradient', () => ({\n  LinearGradient: 'LinearGradient'\n}));\n\nconst defaultProps: WmLabelProps = {\n  caption: 'Test Label',\n  required: false,\n  isValid: true,\n  wrap: true,\n  nooflines: undefined,\n  accessibilityrole: 'text',\n  //onTap: jest.fn(),\n};\n\nconst renderComponent = (props = {}) =>\n  render(<WmLabel {...defaultProps} {...props} />);\n\nconst styles = StyleSheet.create({\n  appLabel: {\n    backgroundColor: '#678742',\n    color: '#257489',\n  },\n});\nconst theme1 = Theme.BASE;\nconst theme: Theme = {\n  name: '',\n  eventNotifer: new EventNotifier(),\n  children: [],\n  styles: {\n    appLabel: {\n      root: { backgroundColor: '#678742' },\n      text: { color: '#257489' },\n    },\n  },\n  cache: {},\n  traceEnabled: false,\n  styleGenerators: [],\n  parent: null,\n  subscribe: jest.fn(),\n  notify: jest.fn(),\n  replaceVariables: jest.fn(),\n  clearCache: jest.fn(),\n  registerStyle: jest.fn(),\n  checkStyleProperties: jest.fn(),\n  addStyle: jest.fn(),\n  addTrace: jest.fn(),\n  flatten: jest.fn(),\n  mergeStyle: jest.fn(),\n  cleanseStyleProperties: jest.fn(),\n  getStyle: jest.fn(),\n  $new: jest.fn(),\n  destroy: jest.fn(),\n  getTextStyle: jest.fn(),\n  reset: jest.fn(),\n};\n\ndescribe('WmLabel Component', () => {\n  afterEach(() => {\n    jest.clearAllMocks();\n    jest.resetModules();\n  });\n\n  it('should render correctly with default props', () => {\n    const tree = renderComponent();\n    expect(tree).toMatchSnapshot();\n    expect(tree.getByText('Test Label')).toBeTruthy();\n  });\n\n  it('should render width and height', () => {\n    const width = 50;\n    const height = 70;\n    const tree = renderComponent({\n      styles: {\n        root: {\n          width: width,\n          height: height,\n        },\n      },\n    });\n    const viewEle = tree.getByTestId('non_animatableView');\n    expect(viewEle.props.style.width).toBe(width);\n    expect(viewEle.props.style.height).toBe(height);\n  });\n\n  it('should have width and height to be 0 when show is false', () => {\n    const { getByTestId } = renderComponent({ show: false });\n\n    const viewEle = getByTestId('non_animatableView');\n    expect(viewEle.props.style.width).toBe(0);\n    expect(viewEle.props.style.height).toBe(0);\n  });\n\n  it('should render custom styles with properly', () => {\n    const bgColor = '#234555';\n    const txtColor = '#325623';\n    const tree = renderComponent({\n      name: 'label',\n      styles: {\n        root: {\n          backgroundColor: bgColor,\n        },\n        text: {\n          color: txtColor,\n        },\n      },\n    });\n    const viewEle = tree.getByTestId('non_animatableView');\n    const textEle = tree.getByText('Test Label');\n    expect(viewEle.props.style.backgroundColor).toBe(bgColor);\n    expect(textEle.props.style.color).toBe(txtColor);\n  });\n\n  it('should render a skeleton with given width and height', () => {\n    const tree = renderComponent({\n      showskeleton: true,\n      skeletonheight: '100',\n      skeletonwidth: '50',\n    });\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('should render a multiline skeleton', () => {\n    const tree = renderComponent({\n      showskeleton: true,\n      skeletonheight: '100',\n      skeletonwidth: '50',\n      multilineskeleton: true,\n    });\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('should render skeleton with root width and height when skeleton width and height are not provided', () => {\n    const width = 50;\n    const height = 70;\n    const tree = renderComponent({\n      showskeleton: true,\n      styles: {\n        root: {\n          width: width,\n          height: height,\n        },\n      },\n    });\n\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('should render with caption as \"Label\" when no caption is passed', () => {\n    const { getByText } = render(<WmLabel />);\n    expect(getByText('Label')).toBeTruthy();\n  });\n\n  it('should render with a given caption', () => {\n    const { getByText } = renderComponent({ caption: 'Caption' });\n    expect(getByText('Caption')).toBeTruthy();\n  });\n\n  it('should render different parts correctly if caption contains links', () => {\n    const caption = 'This is a [link](http://wavemaker.com)';\n    const { getByText } = renderComponent({ caption });\n    expect(getByText('This is a ')).toBeTruthy();\n    expect(getByText('link')).toBeTruthy();\n  });\n\n  it('should update parts when caption prop changes', () => {\n    const { getByText, rerender } = renderComponent();\n    expect(getByText('Test Label')).toBeTruthy();\n\n    rerender(<WmLabel {...defaultProps} caption=\"New Caption\" />);\n    expect(getByText('New Caption')).toBeTruthy();\n  });\n\n  it('should apply accessibility props correctly', async () => {\n    const testprops = {\n      name: 'testLabel',\n      accessibilitylabel: 'label',\n      hint: 'label widget',\n    };\n    const { getByA11yHint, getByLabelText, getByRole } = renderComponent({\n      ...testprops,\n    });\n\n    await waitFor(() => {\n      expect(getByRole('text')).toBeTruthy();\n      expect(getByLabelText(testprops.accessibilitylabel)).toBeTruthy();\n      expect(getByA11yHint(testprops.hint)).toBeTruthy();\n    });\n  });\n\n  it('should apply numberOfLines prop correctly', async () => {\n    const { getByText } = renderComponent({\n      name: 'testLabel',\n      nooflines: 3,\n    });\n    expect(getByText('Test Label').props.numberOfLines).toBe(3);\n  });\n\n  it('should handle animation and delay props', () => {\n    const testprops = {\n      animation: 'fadeIn',\n      animationdelay: 500,\n      caption: 'Animated Label',\n      name: 'WmLabel',\n    };\n    const tree = renderComponent({\n      ...testprops,\n    });\n\n    const animatedLabel = tree.getByTestId('animatableView');\n    expect(animatedLabel).toBeTruthy();\n    expect(animatedLabel.props.animation).toBe(testprops.animation);\n    expect(animatedLabel.props.delay).toBe(testprops.animationdelay);\n  });\n\n  it('should trigger onTap callback with WmLabel instance as one of the arguments', async () => {\n    const onTapMock = jest.fn();\n    const tree = render(<WmLabel onTap={onTapMock} caption=\"Tap\" />);\n\n    fireEvent(tree.getByText('Tap'), 'press');\n\n    await waitFor(() => {\n      expect(onTapMock).toHaveBeenCalled();\n      const callArg = onTapMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmLabel);\n    });\n  });\n\n  it('should trigger onDoubleTap callback with WmLabel instance as one of the arguments', async () => {\n    const onDoubleTapMock = jest.fn();\n    const tree = render(\n      <WmLabel onDoubletap={onDoubleTapMock} caption=\"DoubleTap\" />\n    );\n\n    fireEvent(tree.getByText('DoubleTap'), 'press');\n    fireEvent(tree.getByText('DoubleTap'), 'press');\n\n    await waitFor(() => {\n      expect(onDoubleTapMock).toHaveBeenCalled();\n      const callArg = onDoubleTapMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmLabel);\n    });\n  });\n\n  it('should trigger onLongTap callback with WmLabel instance as one of the arguments', async () => {\n    const onLongTapMock = jest.fn();\n    const tree = render(\n      <WmLabel onLongtap={onLongTapMock} caption=\"LongTap\" />\n    );\n\n    fireEvent(tree.getByText('LongTap'), 'longPress');\n\n    await waitFor(() => {\n      expect(onLongTapMock).toHaveBeenCalled();\n      const callArg = onLongTapMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmLabel);\n    });\n  });\n\n  xit('should trigger onTouchStart callback with WmLabel instance as one of the arguments', async () => {\n    // const onTapMock = jest.fn();\n    const onTouchStartMock = jest.fn();\n    const tree = render(\n      <WmLabel\n        // onTap={onTapMock}\n        onTouchstart={onTouchStartMock}\n        caption=\"Touchstart\"\n      />\n    );\n\n    fireEvent(tree.getByText('Touchstart'), 'press');\n\n    await waitFor(() => {\n      expect(onTouchStartMock).toHaveBeenCalled();\n      const callArg = onTouchStartMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmLabel);\n    });\n  });\n\n  xit('should trigger onTouchEnd callback with WmLabel instance as one of the arguments', async () => {\n    // const onTapMock = jest.fn();\n    const onTouchEndMock = jest.fn();\n    const tree = render(\n      <WmLabel\n        // onTap={onTapMock}\n        onTouchend={onTouchEndMock}\n        caption=\"Touchend\"\n      />\n    );\n\n    fireEvent(tree.getByText('Touchend'), 'pressOut');\n\n    await waitFor(() => {\n      expect(onTouchEndMock).toHaveBeenCalled();\n      const callArg = onTouchEndMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmLabel);\n    });\n  });\n\n  it('should handle link navigation when link is tapped', () => {\n    const caption = 'Go to [Wavemaker](https://wavemaker.com)';\n    const { getByText } = render(\n      <NavigationServiceProvider value={mockNavigationService}>\n        <WmLabel caption={caption} />\n      </NavigationServiceProvider>\n    );\n    fireEvent.press(getByText('Wavemaker'));\n    expect(mockNavigationService.openUrl).toHaveBeenCalledWith(\n      'https://wavemaker.com',\n      '_blank'\n    );\n  });\n\n  it('should invoke JavaScript function for javascript link', () => {\n    const caption = 'Run [Function](javascript:someFunction)';\n    const { getByText } = renderComponent({\n      caption,\n    });\n    const invokeEventCallback = jest.spyOn(\n      WmLabel.prototype,\n      'invokeEventCallback'\n    );\n    fireEvent.press(getByText('Function'));\n    expect(invokeEventCallback).toHaveBeenCalledWith('someFunction', [\n      null,\n      expect.anything(),\n    ]);\n  });\n\n  it('should render with required asterisk if required prop is true', async () => {\n    const tree = renderComponent({ required: true });\n    expect(tree.getByText('*')).toBeTruthy();\n  });\n\n  it('should render with required asterisk if required prop is true when caption has a link', async () => {\n    const tree = renderComponent({\n      required: true,\n      caption: 'Go to [Wavemaker](https://wavemaker.com)',\n    });\n    expect(tree.getByText('*')).toBeTruthy();\n  });\n\n  ////////////////////tests with issues/////////////////////////\n\n  xit('should handle isValid prop and render text with appropriate color', () => {\n    const { getByText, rerender } = renderComponent({\n      caption: 'Invalid label',\n      isValid: false,\n    });\n\n    const tree = renderComponent({\n      caption: 'Invalid label',\n      name: 'invalid-label',\n      isValid: false,\n    });\n    // const tree = render(\n    //   <WmLabel caption=\"Invalid label\" name=\"invalid-label\" isValid={false} />\n    // );\n\n    //expect(tree).toMatchSnapshot();\n\n    const textElement = getByText('Invalid label');\n    expect(textElement.props.style.color).toBe('red');\n\n    rerender(<WmLabel {...defaultProps} caption=\"Valid text\" isValid={true} />);\n    expect(textElement.props.style.color).not.toBe('red');\n  });\n\n  it('should render custom classes with properly', () => {\n    const caption = 'custom label';\n\n    const tree = render(\n      //<ParentContext.Provider value={BaseComponent}>\n      <ThemeProvider value={theme1}>\n        <WmLabel caption={caption} />\n      </ThemeProvider>\n      // </ParentContext.Provider>\n    );\n    // expect(tree).toMatchSnapshot();\n  });\n\n  it('should render text with given gradient color', () => {\n    const gradientColor = 'linear-gradient(90deg, rgba(255,0,0,1), rgba(0,0,255,1))';\n    const { UNSAFE_getByType } = renderComponent({\n      caption: 'Gradient Text',\n      styles: {\n        text: {\n          color: gradientColor,\n        },\n      },\n    });\n    \n    // Check if MaskedView is being used for the gradient\n    const maskedView = UNSAFE_getByType(MaskedView);\n    expect(maskedView).toBeTruthy();\n    \n    // Check if LinearGradient component is used with correct props\n    const linearGradient = UNSAFE_getByType(LinearGradient);\n    expect(linearGradient).toBeTruthy();\n    expect(linearGradient.props.colors).toEqual(['rgba(255,0,0,1)', 'rgba(0,0,255,1)']);\n    expect(linearGradient.props.start).toEqual({ x: 0, y: 0 });\n    expect(linearGradient.props.end).toEqual({ x: 1, y: 0 });\n  });\n});\n", "wavemaker-rn-runtime/test/components/navigation/appnavbar.component.spec.tsx": "import React, { createRef, ReactNode } from 'react';\nimport WmAppNavbar from '@wavemaker/app-rn-runtime/components/navigation/appnavbar/appnavbar.component';\nimport WmPicture from '@wavemaker/app-rn-runtime/components/basic/picture/picture.component';\nimport {\n  fireEvent,\n  render,\n  waitFor,\n  screen,\n  act,\n} from '@testing-library/react-native';\nimport {\n  Platform,\n  BackHandler as RNBackHandler,\n  BackHandlerStatic as RNBackHandlerStatic,\n} from 'react-native';\n\nconst renderComponent = (props = {}) => {\n  return render(<WmAppNavbar name=\"test_Navbar\" {...props} />);\n};\n\nconst timer = (time = 100) =>\n  new Promise((resolve: any, reject) => {\n    setTimeout(() => resolve(), time);\n  });\n\ninterface BackHandlerStatic extends RNBackHandlerStatic {\n  mockPressBack(): void;\n}\n\njest.mock('react-native/Libraries/Utilities/BackHandler', () =>\n  // eslint-disable-next-line jest/no-mocks-import\n  require('react-native/Libraries/Utilities/__mocks__/BackHandler')\n);\n\nconst BackHandler = RNBackHandler as BackHandlerStatic;\n\ndescribe('Test Navbar component', () => {\n  it('should render app-navbar component', () => {\n    const tree = renderComponent().toJSON();\n    expect(tree).toMatchSnapshot();\n    expect(tree).not.toBeNull();\n    expect(tree).toBeDefined();\n  });\n\n  xit('should render badge component when badge value is given', () => {\n    const tree = renderComponent({ badgevalue: 100 });\n    expect(tree.getByTestId('test_Navbar_badge')).toBeTruthy();\n  });\n\n  it('shouldnot render badge component when badge value is not given', () => {\n    const tree = renderComponent();\n    expect(tree.queryByTestId('test_Navbar_badge')).toBeFalsy();\n  });\n\n  it('should render appnavbar with default and custom root-styles', () => {\n    const tree = renderComponent();\n    expect(screen.root.props.style.flexDirection).toBe('row');\n    expect(screen.root.props.style.backgroundColor).toBe('#4263eb');\n    expect(screen.root.props.style.alignItems).toBe('center');\n    expect(screen.root.props.style.height).toBe(80);\n    expect(screen.root.props.style.paddingHorizontal).toBe(12);\n    const styles = {\n      root: {\n        backgroundColor: 'red',\n        height: 250,\n        paddingHorizontal: 50,\n      },\n    };\n    tree.rerender(<WmAppNavbar name=\"test_Navbar\" styles={styles} />);\n    expect(screen.root.props.style.backgroundColor).toBe('red');\n    expect(screen.root.props.style.height).toBe(250);\n    expect(screen.root.props.style.paddingHorizontal).toBe(50);\n  });\n\n  it('should render DrawerButton icon when showDrawerButton is true with respect to default and custom styles', () => {\n    const tree = renderComponent({\n      showDrawerButton: true,\n    });\n\n    expect(tree.getByText('hamburger-menu')).toBeDefined();\n    const IconEle = tree.getByText('hamburger-menu');\n\n    expect(IconEle.props.style[1].paddingLeft).toBe(0); //default styles\n    expect(IconEle.props.style[1].paddingRight).toBe(8);\n    expect(IconEle.props.style[1].fontSize).toBe(32);\n    expect(IconEle.props.style[1].color).toBe('#151420');\n\n    const styles = {\n      leftnavIcon: {\n        root: {\n          fontSize: 47,\n          color: 'blue',\n        },\n        icon: {\n          paddingLeft: 0,\n          paddingRight: 15,\n          fontSize: 40,\n          color: 'red',\n        },\n      },\n    };\n\n    //rerender\n    tree.rerender(<WmAppNavbar name=\"test_Navbar\" styles={styles} />);\n\n    expect(IconEle.props.style[1].paddingLeft).toBe(0); //custom styles\n    expect(IconEle.props.style[1].paddingRight).toBe(15);\n    expect(IconEle.props.style[1].fontSize).toBe(40);\n    expect(IconEle.props.style[1].color).toBe('red');\n    expect(IconEle.props.size).toBe(47);\n  });\n\n  it('should render Drawer button with provided icon when showDrawerButton is true', () => {\n    const { getByText } = renderComponent({\n      showDrawerButton: true,\n      leftnavpaneliconclass: 'fa fa-DrawerButton',\n    });\n    expect(getByText('DrawerButton')).toBeTruthy();\n  });\n\n  it('should not render Drawer button when showDrawerButton is false', () => {\n    const { queryByText } = renderComponent({\n      showDrawerButton: false,\n      leftnavpaneliconclass: 'fa fa-DrawerButton',\n    });\n    expect(queryByText('DrawerButton')).toBeNull();\n  });\n\n  it('should call onDrawerbuttonpress event when drawerbutton is pressed', async () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmAppNavbar.prototype,\n      'invokeEventCallback'\n    );\n    const onDrawerbuttonpressMock = jest.fn();\n\n    //render\n    renderComponent({\n      showDrawerButton: true,\n      onDrawerbuttonpress: onDrawerbuttonpressMock,\n    });\n\n    const iconElement = screen.getByTestId('test_Navbar_leftnavbtn_icon');\n    fireEvent.press(iconElement);\n    await timer(500);\n    await waitFor(() => {\n      expect(onDrawerbuttonpressMock).toHaveBeenCalled();\n      expect(invokeEventCallbackMock).toHaveBeenCalled();\n    });\n  });\n\n  it('should render backButton icon when backButton is true', () => {\n    const tree = renderComponent({\n      backbutton: true,\n      backbuttonlabel: 'caption',\n    });\n\n    expect(tree.getByText('back')).toBeTruthy();\n  });\n\n  it('should render backbutton with custom icon when backbutton is true', () => {\n    const { getByText } = renderComponent({\n      backbutton: true,\n      backbuttoniconclass: 'fa fa-backbutton',\n    });\n    expect(getByText('backbutton')).toBeTruthy();\n  });\n\n  it('should not render backbutton when backbutton is false', () => {\n    const { queryByText } = renderComponent({\n      backbutton: false,\n      backbuttoniconclass: 'fa fa-backbutton',\n    });\n    expect(queryByText('backbutton')).toBeNull();\n  });\n\n  it('should call onBackbtnclick event when backbutton is pressed', async () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmAppNavbar.prototype,\n      'invokeEventCallback'\n    );\n    const onBackBtnPressMock = jest.fn();\n\n    //render\n    renderComponent({\n      backbutton: true,\n      backbuttoniconclass: 'fa fa-backbutton',\n      onBackbtnclick: onBackBtnPressMock,\n    });\n\n    const iconElement = screen.getByText('backbutton');\n    fireEvent.press(iconElement);\n    await timer(500);\n    await waitFor(() => {\n      expect(onBackBtnPressMock).toHaveBeenCalled();\n      expect(invokeEventCallbackMock).toHaveBeenCalled();\n    });\n  });\n\n  it('should render appnavBar with default and custom middleSection-styles', () => {\n    const tree = renderComponent();\n    const viewEle = screen.root.children;\n\n    expect(viewEle[2].props.style.alignItems).toBe('center'); //default styles\n    expect(viewEle[2].props.style.flexDirection).toBe('row');\n\n    const styles = {\n      middleSection: {\n        alignItems: 'flex-start',\n        flexDirection: 'column',\n      },\n    };\n\n    //rerender\n    tree.rerender(<WmAppNavbar name=\"test_Navbar\" styles={styles} />);\n\n    expect(viewEle[2].props.style.alignItems).toBe('flex-start'); //custom styles\n    expect(viewEle[2].props.style.flexDirection).toBe('column');\n  });\n\n  it('should render Picture when imgsrc prop is given', () => {\n    const tree = renderComponent({ imgsrc: 'http://placehold.it/360x150' });\n    const viewEle = tree.UNSAFE_getByType(WmPicture);\n    expect(viewEle).toBeDefined();\n    expect(viewEle.props.picturesource).toBe('http://placehold.it/360x150');\n    expect(viewEle.props.styles.root.width).toBe(32); //default styles\n    expect(viewEle.props.styles.root.height).toBe(32);\n  });\n\n  it('should not render Picture when imgsrc prop is not given', () => {\n    const tree = renderComponent();\n    expect(tree.UNSAFE_queryByType(WmPicture)).toBeNull();\n  });\n\n  it('should render appnavbar with text of default and custom styles', () => {\n    //render\n    const tree = renderComponent({ title: 'appNavBar' });\n    const viewEle = tree.getByText('appNavBar');\n\n    expect(viewEle).toBeTruthy();\n    expect(viewEle.props.style.textTransform).toBe('capitalize'); //default styles\n    expect(viewEle.props.style.color).toBe('#151420');\n    expect(viewEle.props.style.fontSize).toBe(24);\n    expect(viewEle.props.style.fontFamily).toBe('Roboto');\n    expect(viewEle.props.style.fontWeight).toBe('500');\n    expect(viewEle.props.style.textAlign).toBe('center');\n\n    const styles = {\n      content: {\n        textTransform: 'capitalize',\n        color: 'red',\n        fontSize: 40,\n        fontFamily: 'Georgia',\n        fontWeight: '800',\n      },\n    };\n\n    //rerender\n    tree.rerender(<WmAppNavbar name=\"test_Navbar\" styles={styles} />);\n\n    expect(viewEle.props.style.textTransform).toBe('capitalize'); //custom styles\n    expect(viewEle.props.style.color).toBe('red');\n    expect(viewEle.props.style.fontSize).toBe(40);\n    expect(viewEle.props.style.fontFamily).toBe('Georgia');\n    expect(viewEle.props.style.fontWeight).toBe('800');\n  });\n\n  it('should render appnavBar with default and custom rightSection-styles', () => {\n    //render\n    const tree = renderComponent({});\n\n    const children = screen.root.children[3];\n\n    expect(children.props.style.flex).toBe(1);\n    expect(children.props.style.flexDirection).toBe('row');\n    expect(children.props.style.justifyContent).toBe('flex-end');\n\n    const styles = {\n      rightSection: {\n        flex: 2,\n        flexDirection: 'column',\n        justifyContent: 'flex-start',\n        color: 'red',\n      },\n    };\n\n    //rerender\n    tree.rerender(<WmAppNavbar name=\"test_Navbar\" styles={styles} />);\n\n    expect(children.props.style.flex).toBe(2);\n    expect(children.props.style.flexDirection).toBe('column');\n    expect(children.props.style.justifyContent).toBe('flex-start');\n  });\n\n  xit('should render searchIcon with styles when searchbutton is true', () => {\n    //render\n    const tree = renderComponent({ searchbutton: true });\n\n    expect(tree.getByText('search')).toBeTruthy();\n    const IconEle = tree.getByText('search');\n\n    expect(IconEle[1].props.iconclass).toBe('wm-sl-l sl-search');\n    expect(IconEle[1].props.styles.root.alignItems).toBe('flex-start'); //default styles\n    expect(IconEle[1].props.styles.icon.fontSize).toBe(32);\n    expect(IconEle[1].props.styles.icon.color).toBe('#151420');\n\n    const styles = {\n      leftnavIcon: {\n        root: {\n          alignItems: 'flex-end',\n        },\n        icon: {\n          fontSize: 50,\n          color: 'red',\n        },\n      },\n    };\n\n    //rerender\n    tree.rerender(<WmAppNavbar name=\"test_Navbar\" styles={styles} />);\n\n    expect(IconEle[1].props.styles.root.alignItems).toBe('flex-end'); //custom styles\n    expect(IconEle[1].props.styles.icon.fontSize).toBe(50);\n    expect(IconEle[1].props.styles.icon.color).toBe('red');\n  });\n\n  it('should not render Icon when searchbutton is false', () => {\n    const { queryByText } = renderComponent({\n      searchbutton: false,\n      searchbuttoniconclass: 'fa fa-searchbutton',\n    });\n    expect(screen).toMatchSnapshot();\n    expect(queryByText('searchbutton')).toBeNull();\n  });\n\n  it('should call onSearchbuttonpress event when searchIcon is pressed', async () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmAppNavbar.prototype,\n      'invokeEventCallback'\n    );\n    const onSearchbuttonpressMock = jest.fn();\n\n    //render\n    const { getByText } = renderComponent({\n      searchbutton: true,\n      searchbuttoniconclass: 'fa fa-searchbutton',\n      onSearchbuttonpress: onSearchbuttonpressMock,\n    });\n\n    const iconElement = screen.getByText('searchbutton');\n    fireEvent.press(iconElement);\n    await timer(500);\n    await waitFor(() => {\n      expect(onSearchbuttonpressMock).toHaveBeenCalled();\n      expect(invokeEventCallbackMock).toHaveBeenCalled();\n    });\n  });\n\n  //show\n  it('when show is false width and height set to be zero', () => {\n    renderComponent({ show: false });\n    const rootElement = screen.root;\n    expect(rootElement.props.style.width).toBe(0);\n    expect(rootElement.props.style.height).toBe(0);\n  });\n\n  it('should handle hardwareBackButton press when platform is android ', async () => {\n    jest.useFakeTimers();\n    Platform.OS = 'android';\n    const onBackBtnPressMock = jest.fn();\n    renderComponent({\n      onBackbtnclick: onBackBtnPressMock,\n    });\n    // act(() => {\n    BackHandler.mockPressBack();\n    jest.runAllTimers();\n    // });\n    await waitFor(() => {\n      expect(onBackBtnPressMock).toHaveBeenCalled();\n    });\n  });\n});\n", "wavemaker-rn-runtime/test/components/navigation/navitem.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport WmNavItem from '@wavemaker/app-rn-runtime/components/navigation/navitem/navitem.component';\nimport WmNavItemProps from '@wavemaker/app-rn-runtime/components/navigation/navitem/navitem.props';\n\nimport {\n  render,\n  screen,\n  fireEvent,\n  waitFor,\n} from '@testing-library/react-native';\nimport WmAnchor from '@wavemaker/app-rn-runtime/components/basic/anchor/anchor.component';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport { TouchableOpacity, View } from 'react-native';\nimport { NavigationServiceProvider } from '../../../src/core/navigation.service';\nimport mockNavigationService from '../../__mocks__/navigation.service';\n\n// jest.mock(\n//   '@wavemaker/app-rn-runtime/components/basic/anchor/anchor.component',\n//   () => 'WmAnchor'\n// );\n// jest.mock(\n//   '@wavemaker/app-rn-runtime/components/basic/icon/icon.component',\n//   () => 'WmIcon'\n// );\nlet defaultProps;\n\ndescribe('WmNavItem', () => {\n  beforeEach(() => {\n    defaultProps = {\n      item: {\n        label: 'Home',\n        link: '#',\n        badge: '1',\n        icon: 'fa fa-check',\n      },\n      accessibilitylabel: 'nav_item',\n      hint: 'nav_item',\n    };\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  // View Prop Variations\n  it('renders correctly with view = \"anchor\" ', () => {\n    const props = { ...defaultProps, view: 'anchor' };\n    render(<WmNavItem {...props} />);\n    expect(screen.getByText('Home')).toBeTruthy();\n    expect(screen.getByText('check')).toBeTruthy();\n  });\n\n  it('renders correctly with view=\"dropdown\"', () => {\n    const props = { ...defaultProps, view: 'dropdown' };\n    render(<WmNavItem {...props} />);\n    expect(screen.getByText('Home')).toBeTruthy();\n    expect(screen.getByText('check')).toBeTruthy();\n  });\n\n  // Item Selection\n  it('calls onSelect callback when an item is selected', async () => {\n    const onSelectMock = jest.fn();\n    const onSelectItemMock = jest.spyOn(WmNavItem.prototype, 'onSelectItem');\n    const props = { ...defaultProps, view: 'anchor', onSelect: onSelectMock };\n    render(\n      <NavigationServiceProvider value={mockNavigationService}>\n        <WmNavItem {...props} />\n      </NavigationServiceProvider>\n    );\n    const anchor = screen.getByText('Home');\n    fireEvent.press(anchor);\n\n    await waitFor(() => {\n      expect(onSelectItemMock).toHaveBeenCalled();\n      expect(mockNavigationService.openUrl).toHaveBeenCalled();\n    });\n  });\n\n  // Toggle Collapse State\n  it('toggles collapsed state when dropdown is clicked', async () => {\n    const props = { ...defaultProps, view: 'dropdown', name: 'test' };\n    const { rerender } = render(<WmNavItem {...props} />);\n\n    const touchable = screen.UNSAFE_getByType(TouchableOpacity);\n    fireEvent.press(touchable);\n    rerender(<WmNavItem {...props} />);\n    await waitFor(() => {\n      expect(screen.queryByText('sort-down')).toBe(null);\n      expect(screen.queryByText('sort-up')).toBeTruthy();\n    });\n  });\n\n  // Children Elements\n  it('renders children elements when provided', () => {\n    const props = {\n      ...defaultProps,\n      children: <View testID=\"child-element\" />,\n    };\n    render(<WmNavItem {...props} />);\n    expect(screen.getByTestId('child-element')).toBeTruthy();\n  });\n\n  // Handling undefined or null props\n  it('handles undefined or null item, caption or view gracefully', () => {\n    const props = { ...defaultProps, item: null, caption: null, view: null };\n    render(<WmNavItem {...props} />);\n    expect(screen.queryByText('Home')).toBeFalsy();\n  });\n\n  it('handles accessibility props correctly', () => {\n    const props = { ...defaultProps, view: 'dropdown' };\n    render(<WmNavItem {...props} />);\n    expect(screen.getByRole('link')).toBeTruthy();\n    expect(screen.getByLabelText(defaultProps.item.label)).toBeTruthy();\n    // expect(screen.getByA11yHint(defaultProps.hint)).toBeTruthy();\n  });\n\n  it('handles show property correctly', () => {\n    const props = { ...defaultProps, show: false, view: 'anchor' };\n    render(<WmNavItem {...props} />);\n    const rootElement = screen.root;\n    expect(rootElement.props.style.width).toBe(0);\n    expect(rootElement.props.style.height).toBe(0);\n  });\n\n  it('calls displayexpression function if provided', () => {\n    const getDisplayExpressionMock = jest.fn();\n    const props = {\n      ...defaultProps,\n      getDisplayExpression: getDisplayExpressionMock,\n      view: 'anchor',\n    };\n    render(<WmNavItem {...props} />);\n    expect(getDisplayExpressionMock).toHaveBeenCalled();\n  });\n});\n", "wavemaker-rn-runtime/test/components/navigation/navbar.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport { Text, TouchableOpacity } from 'react-native';\nimport WmNavbar from '@wavemaker/app-rn-runtime/components/navigation/navbar/navbar.component';\nimport {\n  render,\n  screen,\n  fireEvent,\n  waitFor,\n} from '@testing-library/react-native';\nimport WmNavItem from '@wavemaker/app-rn-runtime/components/navigation/navitem/navitem.component';\nimport WmNavbarProps from '@wavemaker/app-rn-runtime/components/navigation/navbar/navbar.props';\nimport { NavigationServiceProvider } from '../../../src/core/navigation.service';\nimport mockNavigationService from '../../__mocks__/navigation.service';\n\n// jest.mock(\n//   '@wavemaker/app-rn-runtime/components/navigation/navitem/navitem.component',\n//   () => 'WmNavItem'\n// );\n\ndescribe('WmNavbar', () => {\n  let defaultProps;\n  let dataItems = [\n    {\n      key: '1',\n      label: 'Home',\n      link: '#home',\n      icon: 'fa fa-home',\n      itemchildren: [],\n    },\n    {\n      key: '2',\n      label: 'About',\n      link: '#about',\n      icon: 'fa fa-info',\n      itemchildren: [],\n    },\n  ];\n\n  beforeEach(() => {\n    defaultProps = {\n      dataset: dataItems,\n      itemlabel: 'label',\n      itemlink: 'link',\n      itemicon: 'icon',\n    };\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  // Check Rendering with Default Props\n  it('renders correctly with default props', () => {\n    render(<WmNavbar {...defaultProps} />);\n    expect(screen.getByText('home')).toBeTruthy();\n    expect(screen.getByText('Home')).toBeTruthy();\n    expect(screen.getByText('info')).toBeTruthy();\n    expect(screen.getByText('About')).toBeTruthy();\n  });\n\n  // Dataset Handling\n  it('handles dataset properly and renders items based on it', () => {\n    render(<WmNavbar {...defaultProps} />);\n    const items = screen.UNSAFE_getAllByType(WmNavItem);\n    expect(items).toHaveLength(2);\n    expect(screen.getByText('Home')).toBeTruthy();\n    expect(screen.getByText('About')).toBeTruthy();\n  });\n\n  // Prop Update Handling\n  it('responds to prop updates correctly', async () => {\n    const { rerender } = render(<WmNavbar {...defaultProps} />);\n\n    await waitFor(() => {\n      expect(screen.getByText('Home')).toBeTruthy();\n      expect(screen.getByText('About')).toBeTruthy();\n    });\n\n    const newDataset = [\n      {\n        key: '1',\n        label: 'Contact',\n        link: '#contact',\n        icon: 'contact',\n      },\n      {\n        key: '2',\n        label: 'Blog',\n        link: '#blog',\n        icon: 'blog',\n      },\n    ];\n    rerender(<WmNavbar {...defaultProps} dataset={newDataset} />);\n\n    await waitFor(() => {\n      expect(screen.getByText('Contact')).toBeTruthy();\n      expect(screen.getByText('Blog')).toBeTruthy();\n    });\n  });\n\n  // Rendering Child Components\n  it('renders nested child components correctly', async () => {\n    const nestedDataset = [\n      {\n        key: '1',\n        label: 'Services',\n        link: '#services',\n        icon: 'services',\n        itemchildren: [\n          {\n            key: '1-1',\n            label: 'Consulting',\n            link: '#consulting',\n            icon: 'consulting',\n          },\n          {\n            key: '1-2',\n            label: 'Development',\n            link: '#development',\n            icon: 'development',\n          },\n        ],\n      },\n    ];\n    const props = {\n      ...defaultProps,\n      dataset: nestedDataset,\n      itemchildren: 'itemchildren',\n    };\n    render(<WmNavbar {...props} />);\n    expect(screen.getByText('Services')).toBeTruthy();\n    fireEvent.press(screen.getByText('sort-down'));\n    await waitFor(() => {\n      expect(screen.getByText('Consulting')).toBeTruthy();\n      expect(screen.getByText('Development')).toBeTruthy();\n    });\n  });\n\n  // Click Handling\n  it('calls onSelect callback when an item is selected', async () => {\n    const onSelectMock = jest.fn();\n    const props = { ...defaultProps, onSelect: onSelectMock };\n\n    render(\n      <NavigationServiceProvider value={mockNavigationService}>\n        <WmNavbar {...props} />\n      </NavigationServiceProvider>\n    );\n    const anchor = screen.getByText('Home');\n    fireEvent.press(anchor);\n    await waitFor(() => {\n      expect(onSelectMock).toHaveBeenCalled();\n      expect(mockNavigationService.openUrl).toHaveBeenCalled();\n    });\n  });\n\n  // Accessibility Props\n  it('applies accessibility props correctly', () => {\n    render(<WmNavbar {...defaultProps} />);\n    expect(screen.getByLabelText('Home')).toBeTruthy();\n    expect(screen.getByLabelText('About')).toBeTruthy();\n  });\n\n  // Edge Cases: Empty Dataset\n  it('handles empty dataset gracefully', () => {\n    const props = { ...defaultProps, dataset: [] };\n    render(<WmNavbar {...props} />);\n    expect(screen.queryByText('Home')).toBeNull();\n    expect(screen.queryByText('About')).toBeNull();\n  });\n\n  // Test Indentation\n  it('applies indentation styles correctly', () => {\n    const props = { ...defaultProps, indent: 20 };\n    render(<WmNavbar {...props} />);\n    const navItems = screen.UNSAFE_getAllByType(WmNavItem);\n    navItems.forEach((navItem) => {\n      expect(navItem.props.styles.navAnchorItem.root.paddingLeft).toBe(20);\n    });\n  });\n\n  // State Management\n  it('correctly sets state and renders based on state', () => {\n    const instance = new WmNavbar(defaultProps);\n    instance.setDataItems(defaultProps.dataset);\n    expect(instance.state.dataItems).toHaveLength(2);\n  });\n});\n", "wavemaker-rn-runtime/test/components/navigation/menu.component.spec.tsx": "import React from 'react';\nimport { fireEvent, render, screen, waitFor } from '@testing-library/react-native';\n\nimport WmMenu from '@wavemaker/app-rn-runtime/components/navigation/menu/menu.component';\nimport AppModalService from '@wavemaker/app-rn-runtime/runtime/services/app-modal.service';\nimport { ModalProvider } from '@wavemaker/app-rn-runtime/core/modal.service';\n\nconst timer = (time = 200) => new Promise((resolve: any, reject) => {setTimeout(()=>resolve(), time)})\n\nconst renderComponent = (props = {}) => {\n  const defaultProps = {\n    name: 'test',\n    dataset: 'Menu Item 1, Menu Item 2, Menu Item 3'\n  }\n\n  AppModalService.modalsOpened = [];\n\n  return render(\n    <ModalProvider value={AppModalService}>\n      <WmMenu {...defaultProps} {...props}/>\n    </ModalProvider>\n  )\n}\n\ndescribe('Test Menu component', () => {\n  test('should render component', () => {\n    renderComponent();\n    expect(screen.getByTestId('test_menu_trigger_a')).toBeTruthy();\n    expect(screen).toMatchSnapshot();\n  });\n\n  test('should render component with caption', () => {\n    renderComponent({\n      caption: 'wm-menu'\n    });\n    expect(screen.getByTestId('test_menu_trigger_a')).toBeTruthy();\n    expect(screen.getByText('wm-menu')).toBeTruthy();\n    expect(screen).toMatchSnapshot();\n  })\n\n  test('should show items on menu press', async () => {\n    renderComponent();\n    fireEvent(screen.getByTestId('test_menu_trigger_a'), 'press');\n    await timer(300);\n\n    const menuItemsComponent = AppModalService.modalOptions;\n    const Component = () => {\n      return (\n        <>{menuItemsComponent.content}</>\n      )\n    }\n    const tree = render(<Component/>)\n\n    await waitFor(() => {\n      expect(tree.getByText('Menu Item 1')).toBeTruthy();\n      expect(tree.getByText('Menu Item 2')).toBeTruthy();\n      expect(tree.getByText('Menu Item 3')).toBeTruthy();\n      expect(tree).toMatchSnapshot();\n    })\n  });\n\n  test('should close menu when menu item is pressed', async () => {\n    renderComponent();\n    fireEvent(screen.getByTestId('test_menu_trigger_a'), 'press');\n    await timer(300);\n\n    const menuItemsComponent = AppModalService.modalOptions;\n    const Component = () => {\n      return (\n        <>{menuItemsComponent.content}</>\n      )\n    }\n    const tree = render(<Component/>)\n\n    const hideMock = jest.spyOn(AppModalService, 'hideModal');\n\n    await waitFor(() => {\n      expect(tree.getByText('Menu Item 1')).toBeTruthy();\n      expect(tree.getByText('Menu Item 2')).toBeTruthy();\n      expect(tree.getByText('Menu Item 3')).toBeTruthy();\n      expect(tree).toMatchSnapshot();\n    });\n\n    fireEvent(tree.getByText('Menu Item 1'), 'press');\n\n    await waitFor(() => {\n      expect(hideMock).toHaveBeenCalled();\n      expect(AppModalService.modalsOpened.length).toBe(0);\n      expect(Object.keys(AppModalService.modalOptions).length).toBe(0)\n    })\n  })\n\n  test('should trigger onSelect function when menu item is pressed', async () => {\n    const onSelectMock = jest.fn();\n    renderComponent({\n      onSelect: onSelectMock\n    });\n    fireEvent(screen.getByTestId('test_menu_trigger_a'), 'press');\n    await timer(300);\n\n    const menuItemsComponent = AppModalService.modalOptions;\n    const Component = () => {\n      return (\n        <>{menuItemsComponent.content}</>\n      )\n    }\n    const tree = render(<Component/>)\n\n    const hideMock = jest.spyOn(AppModalService, 'hideModal');\n\n    await waitFor(() => {\n      expect(tree.getByText('Menu Item 1')).toBeTruthy();\n      expect(tree.getByText('Menu Item 2')).toBeTruthy();\n      expect(tree.getByText('Menu Item 3')).toBeTruthy();\n      expect(tree).toMatchSnapshot();\n    });\n\n    fireEvent(tree.getByText('Menu Item 1'), 'press');\n\n    await waitFor(() => {\n      expect(hideMock).toHaveBeenCalled();\n      expect(AppModalService.modalsOpened.length).toBe(0);\n      expect(Object.keys(AppModalService.modalOptions).length).toBe(0)\n      expect(onSelectMock).toHaveBeenCalled();\n    })\n  });\n\n  test('should render custom dataset', async () => {\n    renderComponent({\n      dataset: [\n        {\n          label: 'WM Item 1',\n          icon: 'fa fa-edit'\n        },\n        {\n          label: 'WM Item 2',\n          icon: 'fa fa-create'\n        },\n        {\n          label: 'WM Item 3',\n          icon: 'fa fa-delete'\n        }\n      ]\n    });\n    fireEvent(screen.getByTestId('test_menu_trigger_a'), 'press');\n    await timer(300);\n\n    const menuItemsComponent = AppModalService.modalOptions;\n    const Component = () => {\n      return (\n        <>{menuItemsComponent.content}</>\n      )\n    }\n    const tree = render(<Component/>)\n\n    await waitFor(() => {\n      expect(tree.getByText('WM Item 1')).toBeTruthy();\n      expect(tree.getByText('WM Item 2')).toBeTruthy();\n      expect(tree.getByText('WM Item 3')).toBeTruthy();\n      expect(tree.getByText('edit')).toBeTruthy();\n      expect(tree.getByText('delete')).toBeTruthy();\n      expect(tree.getByText('create')).toBeTruthy();\n      expect(tree).toMatchSnapshot();\n    });\n  })\n\n  test('should apply custom styles ', () => {\n    renderComponent({\n      show: true, \n      styles: {\n        root: {\n          backgroundColor: 'red'\n        }\n      },\n    });\n\n    expect(screen.toJSON()?.[2].props.style).toMatchObject({\n      backgroundColor: 'red'\n    });\n    expect(screen).toMatchSnapshot();\n  })\n\n  test('should not display when show is false', () => {\n    renderComponent({\n      show: false\n    });\n\n    expect(screen.toJSON()?.[2].props.style).toMatchObject({\n      height: 0,\n      width: 0\n    });\n    expect(screen).toMatchSnapshot();\n  });\n  \n});\n", "wavemaker-rn-runtime/test/components/navigation/popover.component.spec.tsx": "import React, { createRef } from 'react';\nimport { View, Text } from 'react-native';\nimport WmPopover from '@wavemaker/app-rn-runtime/components/navigation/popover/popover.component';\nimport { ModalProvider } from '@wavemaker/app-rn-runtime/core/modal.service';\nimport {\n  render,\n  fireEvent,\n  waitFor,\n  cleanup,\n} from '@testing-library/react-native';\nimport { BackgroundComponent } from '@wavemaker/app-rn-runtime/styles/background.component';\nimport { Animatedview } from '@wavemaker/app-rn-runtime/components/basic/animatedview.component';\nimport { Tappable } from '@wavemaker/app-rn-runtime/core/tappable.component';\nimport AppModalService from '@wavemaker/app-rn-runtime/runtime/services/app-modal.service';\nimport { ScrollView } from 'react-native-gesture-handler';\n\nconst renderComponent = (props = {}) => {\n  AppModalService.modalsOpened = [];\n  return render(\n    <ModalProvider value={AppModalService}>\n      <WmPopover name=\"test_Popover\" {...props} />\n    </ModalProvider>\n  );\n};\n\nconst fireEventLayoutFun = (component) => {\n  return fireEvent(component.root, 'layout', {\n    nativeEvent: {\n      layout: {\n        x: 100,\n        y: 100,\n        px: 100,\n        py: 100,\n        width: 200,\n        height: 200,\n      },\n    },\n  });\n};\n\nconst timer = (time = 100) =>\n  new Promise((resolve: any, reject) => {\n    setTimeout(() => resolve(), time);\n  });\n\ndescribe('Popover component tests', () => {\n  afterEach(() => {\n    cleanup();\n    jest.clearAllMocks();\n  });\n\n  it('should render the popover component', () => {\n    const tree = renderComponent();\n    expect(tree).toBeDefined();\n    expect(tree).not.toBeNull();\n    expect(tree).toMatchSnapshot();\n  });\n\n  //accessibility props\n  it('should apply accessibility props correctly', () => {\n    const { getByRole, getByLabelText, getByA11yHint } = renderComponent({\n      name: 'testButton',\n      accessibilitylabel: 'Popover',\n      accessibilityrole: 'Popover',\n      hint: 'test Popover',\n    });\n    expect(getByLabelText('Popover')).toBeTruthy();\n    expect(getByRole('Popover')).toBeTruthy();\n    expect(getByA11yHint('test Popover')).toBeTruthy();\n  });\n\n  //Anchor tag\n  it('should render the clickable anchor with provided animation, caption, badgeValue', () => {\n    const tree = renderComponent({\n      animation: 'fadeIn',\n      caption: 'Link',\n      badgevalue: 200,\n    });\n    const viewEle = tree.UNSAFE_getByType(Animatedview);\n    expect(tree.getByText('Link')).toBeTruthy();\n    expect(tree.getByText('200')).toBeTruthy();\n    expect(viewEle.props.entryanimation).toBe('fadeIn');\n  });\n\n  it('should render the clickable link with provided icon', () => {\n    const tree = renderComponent({\n      iconclass: 'wm-sl-l sl-home-2',\n      iconmargin: 2,\n    });\n    expect(tree.getByText('home-2')).toBeTruthy();\n  });\n\n  it('should render popover content when the clickable link is tapped', async () => {\n    const renderPopoverContentMock = jest.spyOn(\n      WmPopover.prototype,\n      'renderPopoverContent'\n    );\n    const notifyMock = jest.spyOn(WmPopover.prototype, 'notify');\n    const onShowMock = jest.fn();\n\n    const tree = renderComponent({\n      title: 'popoverTitle',\n      onShow: onShowMock,\n      children: (\n        <View>\n          <Text>Children in WmContainer</Text>\n        </View>\n      ),\n    });\n\n    const viewText = tree.getByText('Link');\n    expect(viewText).toBeTruthy();\n\n    fireEvent.press(viewText);\n\n    await timer(300);\n\n    //in popover there is modalService.showModal\n    //and in modalprovider value is AppModalService so in AppModalService there is showmodal\n    //in showmodal the modal is pushing into modalopened array\n    //because of this reason the below one is written\n    const renderOptions = AppModalService.modalsOpened[0];\n\n    //in that modal there is content\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n\n    //and rendering that content to produce snapshot\n    const contentTree = render(<Content />);\n    expect(contentTree.getByText('popoverTitle')); //popover contentBox title\n    expect(contentTree.getByText('Children in WmContainer')).toBeTruthy(); //popover contentBox content\n\n    const ScrollViewEle = contentTree.UNSAFE_getByType(ScrollView);\n    expect(ScrollViewEle).not.toBeNull();\n    expect(ScrollViewEle).toBeDefined();\n    //fireEvent\n    fireEvent(ScrollViewEle, 'scroll');\n\n    await waitFor(() => {\n      expect(onShowMock).toHaveBeenCalled();\n      expect(renderPopoverContentMock).toHaveBeenCalled();\n      expect(notifyMock).toHaveBeenCalled();\n    });\n  });\n\n  //AutoOpen = true\n  it('should render popover content by default when autoopen is true', async () => {\n    const renderPopoverContentMock = jest.spyOn(\n      WmPopover.prototype,\n      'renderPopoverContent'\n    );\n    const notifyMock = jest.spyOn(WmPopover.prototype, 'notify');\n    const onShowMock = jest.fn();\n\n    const tree = renderComponent({\n      onShow: onShowMock,\n      autoopen: true,\n      title: 'popoverTitle',\n      children: (\n        <View>\n          <Text>Children in WmContainer</Text>\n        </View>\n      ),\n    });\n\n    const viewText = tree.getByText('Link');\n    expect(viewText).toBeTruthy();\n\n    const renderOptions = AppModalService.modalsOpened[0];\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n\n    const contentTree = render(<Content />);\n    expect(contentTree.getByText('popoverTitle')); //popover contentBox title\n    expect(contentTree.getByText('Children in WmContainer')).toBeTruthy(); //popover contentBox content\n\n    const ScrollViewEle = contentTree.UNSAFE_getByType(ScrollView);\n    expect(ScrollViewEle).not.toBeNull();\n    expect(ScrollViewEle).toBeDefined();\n\n    //fireEvent to scroll\n    fireEvent(ScrollViewEle, 'scroll');\n\n    await timer();\n\n    await waitFor(() => {\n      expect(onShowMock).toHaveBeenCalled();\n      expect(renderPopoverContentMock).toHaveBeenCalled();\n      expect(notifyMock).toHaveBeenCalled();\n    });\n  });\n\n  //Auto Close = always\n  it('should autoclose the popover modal when one of the item is selected if autoclose = \"always\"', async () => {\n    const onHideMock = jest.fn();\n\n    const props = {\n      title: 'contentTitle',\n      autoclose: 'always',\n      onHide: onHideMock,\n    };\n\n    AppModalService.modalsOpened = [];\n    const tree = render(\n      <ModalProvider value={AppModalService}>\n        <WmPopover name=\"test_Popover\" {...props}>\n          <Text>test_label</Text>\n        </WmPopover>\n      </ModalProvider>\n    );\n\n    const viewText = tree.getByText('Link');\n    expect(viewText).toBeTruthy();\n\n    //fireevent to open\n    fireEvent.press(viewText);\n\n    await timer(300);\n\n    const renderOptions = AppModalService.modalsOpened[0];\n\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n\n    const contentTree = render(<Content />);\n\n    const viewEle = contentTree.getByText('test_label');\n    expect(viewEle).toBeTruthy();\n    await timer();\n\n    expect(contentTree.getByText('contentTitle')).toBeTruthy();\n\n    //fireevent to close\n    fireEvent(viewEle, 'press');\n\n    await waitFor(() => {\n      expect(onHideMock).toHaveBeenCalled();\n    });\n  });\n\n  //Auto Close = disabled\n  it('should not autoclose the popover modal when selected if autoclose=\" disabled \"', async () => {\n    const onHideMock = jest.fn();\n\n    //render\n    const tree = renderComponent({\n      title: 'contentTitle',\n      autoclose: 'disabled',\n      onHide: onHideMock,\n      renderPartial: (props, onLoad) => {\n        return <Text>test_label</Text>;\n      },\n    });\n\n    const viewText = tree.getByText('Link');\n    expect(viewText).toBeTruthy();\n\n    //fireevent to open\n    fireEvent.press(viewText);\n\n    await timer(300);\n\n    const renderOptions = AppModalService.modalsOpened[0];\n\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n\n    const contentTree = render(<Content />);\n    await timer();\n\n    const viewEle = contentTree.getByText('test_label');\n    expect(viewEle).toBeTruthy();\n\n    expect(contentTree.getByText('contentTitle')).toBeTruthy();\n\n    //fireevent to close\n    fireEvent(viewEle, 'press');\n    await timer();\n\n    expect(onHideMock).not.toHaveBeenCalled();\n  });\n\n  //onLoad Event\n  it('should invoke onLoad callback when popover content is loaded if content source is from partial', async () => {\n    const onLoadMock = jest.fn();\n\n    //render\n    const tree = renderComponent({\n      title: 'contentTitle',\n      onLoad: onLoadMock,\n      renderPartial: (props, onLoad) => {\n        onLoad();\n      },\n    });\n\n    //fireEvent to open\n    const viewEle = tree.getByText('Link');\n    fireEventLayoutFun(tree);\n    fireEvent.press(viewEle);\n\n    await timer(300);\n    const renderOptions = AppModalService.modalsOpened[0];\n\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n\n    const contentTree = render(<Content />);\n\n    expect(contentTree.getByText('contentTitle')).toBeTruthy();\n\n    await waitFor(() => {\n      expect(onLoadMock).toHaveBeenCalled();\n    });\n  });\n\n  it('should call prepareModalOptions method and update the state, when ontap event is invoked', async () => {\n    const prepareModalOptionsMock = jest.spyOn(\n      WmPopover.prototype,\n      'prepareModalOptions'\n    );\n    const ref = createRef<WmPopover>();\n\n    //render\n    const tree = renderComponent({ ref: ref, contentanimation: 'bounceIn' });\n\n    //fireevent to open\n    const viewEle = tree.getByText('Link');\n    fireEventLayoutFun(tree);\n    fireEvent.press(viewEle);\n\n    await waitFor(() => {\n      expect(prepareModalOptionsMock).toHaveBeenCalled();\n      const viewEle = ref.current.state.modalOptions;\n      expect(viewEle.animation).toBe('bounceIn');\n      expect(viewEle.centered).toBe(true);\n    });\n  });\n\n  //onlayout\n  it('should update the (state - position) when default popoverwidth provided in props', async () => {\n    const ref = createRef<WmPopover>();\n    //render\n    const tree = renderComponent({ type: 'dropdown', ref: ref });\n    // fireEventLayoutFun(tree);\n    const viewEle = tree.getByText('Link');\n    fireEventLayoutFun(tree);\n    fireEvent.press(viewEle);\n\n    const x = 10,\n      y = 20;\n    const width = 100,\n      height = 200;\n    const px = 30,\n      py = 40;\n    ref.current.view.measure = (fun: Function) => {\n      fun(x, y, width, height, px, py);\n    };\n    ref.current.computePosition();\n    await waitFor(() => {\n      expect(ref.current.state.position.left).toBe(px),\n        expect(ref.current.state.position.top).toBe(py + height);\n    });\n  });\n\n  it('should update the (state - position) when popoverwidth provided in props', async () => {\n    const ref = createRef<WmPopover>();\n    //render\n    const popoverwidth = '800';\n    const tree = renderComponent({\n      type: 'dropdown',\n      ref: ref,\n      popoverwidth: popoverwidth,\n    });\n\n    const viewEle = tree.getByText('Link');\n    fireEventLayoutFun(tree);\n    fireEvent.press(viewEle);\n\n    const x = 10,\n      y = 20;\n    const width = 100,\n      height = 200;\n    const px = 30,\n      py = 40;\n    ref.current.view.measure = (fun: Function) => {\n      fun(x, y, width, height, px, py);\n    };\n    ref.current.computePosition();\n    await waitFor(() => {\n      expect(ref.current.state.position.left).toBe(\n        px + width - parseInt(popoverwidth)\n      ),\n        expect(ref.current.state.position.top).toBe(py + height);\n    });\n  });\n\n  //show\n  it('should have width and height to be 0 when show is false', () => {\n    const tree = renderComponent({ show: false });\n    const viewEle = tree.root;\n    expect(viewEle.props.style.width).toBe(0);\n    expect(viewEle.props.style.height).toBe(0);\n  });\n});\n", "wavemaker-rn-runtime/test/components/container/wizard.component.spec.tsx": "import React, { createRef, ReactNode } from 'react';\nimport { Text, TouchableOpacity, View } from 'react-native';\nimport WmWizard from '@wavemaker/app-rn-runtime/components/container/wizard/wizard.component';\n\nimport WmWizardProps from '@wavemaker/app-rn-runtime/components/container/wizard/wizard.props';\nimport {\n  render,\n  fireEvent,\n  screen,\n  waitFor,\n  act,\n} from '@testing-library/react-native';\nimport WmWizardstep from '@wavemaker/app-rn-runtime/components/container/wizard/wizardstep/wizardstep.component';\nimport WmWizardstepProps from '@wavemaker/app-rn-runtime/components/container/wizard/wizardstep/wizardstep.props';\n\n// Mock\nimport AppModalService from '@wavemaker/app-rn-runtime/runtime/services/app-modal.service';\nimport { ModalProvider } from '@wavemaker/app-rn-runtime/core/modal.service';\n\nconst timer = async (time: number = 100) => {\n  await new Promise((resolve: any, reject) => {\n    setTimeout(() => {\n      resolve();\n    }, time);\n  });\n};\n\ndescribe('Test Wizard component', () => {\n  const wizardStepPropsObject = { ...new WmWizardstepProps() };\n  const wizardPropsObject = { ...new WmWizardProps() };\n\n  const steps = [\n    <WmWizardstep\n      {...wizardStepPropsObject}\n      key={0}\n      index={0}\n      title=\"Step 1\"\n      name=\"step1\"\n    >\n      <Text>Content of Step 1</Text>\n    </WmWizardstep>,\n    <WmWizardstep\n      {...wizardStepPropsObject}\n      key={1}\n      index={1}\n      title=\"Step 2\"\n      name=\"step2\"\n    >\n      <Text>Content of Step 2</Text>\n    </WmWizardstep>,\n    <WmWizardstep\n      {...wizardStepPropsObject}\n      key={2}\n      index={2}\n      title=\"Step 3\"\n      name=\"step3\"\n    >\n      <Text>Content of Step 3</Text>\n    </WmWizardstep>,\n  ];\n\n  const defaultProps = {\n    actionsalignment: 'right',\n    children: steps,\n    cancelable: true,\n    cancelbtnlabel: 'Cancel',\n    donebtnlabel: 'Done',\n    nextbtnlabel: 'Next',\n    previousbtnlabel: 'Previous',\n    defaultstep: 'step1',\n    progresstype: 'default',\n    headernavigation: true,\n  } as unknown as WmWizardProps;\n\n  const renderComponent = (props = {}) => {\n    AppModalService.modalsOpened = [];\n    return render(\n      <ModalProvider value={AppModalService}>\n        <WmWizard {...defaultProps} {...props} name=\"test_wizard\" />\n      </ModalProvider>\n    );\n  };\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('Check validity of sample component', () => {\n    const tree = renderComponent();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders without crashing', async () => {\n    const ref = createRef();\n    const tree = renderComponent({ ref });\n\n    await timer(300);\n\n    await waitFor(() => {\n      expect(screen.getByText('Step 1')).toBeTruthy();\n      expect(screen.getByText('Content of Step 1')).toBeTruthy();\n    });\n  });\n\n  it('should render when defaultstep is none', async () => {\n    const tree = renderComponent({ defaultstep: 'none' });\n    await timer(500);\n\n    expect(tree).toMatchSnapshot();\n\n    expect(tree.queryByText('Step 1')).toBeNull();\n    expect(tree.queryByText('Content of Step 1')).toBeNull();\n  });\n\n  it('should navigate to the next step when the next button is clicked', async () => {\n    renderComponent();\n    await timer(300);\n\n    fireEvent.press(screen.getByText(defaultProps.nextbtnlabel));\n    await waitFor(() => {\n      expect(screen.getByText('Step 2')).toBeTruthy();\n    });\n  });\n\n  it('should navigate to the previous step when the previous button is clicked', async () => {\n    renderComponent({ defaultstep: 'step2' });\n    await timer(300);\n\n    fireEvent.press(screen.getByText(defaultProps.previousbtnlabel));\n    await waitFor(() => {\n      expect(screen.getByText('Step 1')).toBeTruthy();\n    });\n  });\n\n  it('renders wizard steps', async () => {\n    const ref = createRef();\n    renderComponent({ ref });\n    await timer(300);\n\n    expect(screen.getByText('Step 1')).toBeTruthy();\n    await waitFor(() => {\n      expect(screen.getByText('Content of Step 1')).toBeTruthy();\n    });\n\n    fireEvent.press(screen.getByText(defaultProps.nextbtnlabel));\n    await waitFor(() => {\n      fireEvent.press(screen.getByText('Step 2'));\n      expect(screen.getByText('Content of Step 2')).toBeTruthy();\n    });\n\n    fireEvent.press(screen.getByText(defaultProps.nextbtnlabel));\n    await waitFor(() => {\n      fireEvent.press(screen.getByText('Step 3'));\n      expect(screen.getByText('Content of Step 3')).toBeTruthy();\n      expect(screen.getByText(defaultProps.donebtnlabel)).toBeTruthy();\n    });\n  });\n\n  it('should call onDone callback when the done button is clicked on the last step', async () => {\n    const mockDoneCallback = jest.fn();\n    const invokeEventCallbackMock = jest.spyOn(\n      WmWizard.prototype,\n      'invokeEventCallback'\n    );\n    const props = {\n      ...defaultProps,\n      defaultstep: 'step3',\n      onDone: mockDoneCallback,\n    };\n\n    renderComponent(props);\n    await timer(300);\n\n    fireEvent.press(screen.getByText('Done'));\n    await waitFor(() => {\n      expect(mockDoneCallback).toHaveBeenCalled();\n      expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n        'onDone',\n        expect.anything()\n      );\n    });\n  });\n\n  it('should call onCancel callback when the cancel button is clicked', async () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmWizard.prototype,\n      'invokeEventCallback'\n    );\n    const mockCancelCallback = jest.fn();\n    const props = { ...defaultProps, onCancel: mockCancelCallback };\n\n    const { getByText } = renderComponent(props);\n    await timer(300);\n\n    fireEvent.press(getByText('Cancel'));\n    await waitFor(() => {\n      expect(mockCancelCallback).toHaveBeenCalled();\n      expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n        'onCancel',\n        expect.anything()\n      );\n    });\n  });\n\n  test('should skip the hidden steps when pressed next or prev button', async () => {\n    const steps = [\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={0}\n        index={0}\n        title=\"Step 1\"\n        name=\"step1\"\n        enableskip={true}\n      >\n        <Text>Content of Step 1</Text>\n      </WmWizardstep>,\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={1}\n        index={1}\n        title=\"Step 2\"\n        name=\"step2\"\n        enableskip={true}\n      >\n        <Text>Content of Step 2</Text>\n      </WmWizardstep>,\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={2}\n        index={2}\n        title=\"Step 3\"\n        name=\"step3\"\n        enableskip={true}\n        show={false}\n      >\n      <Text>Content of Step 3</Text>\n      </WmWizardstep>,\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={3}\n        index={3}\n        title=\"Step 4\"\n        name=\"step4\"\n        enableskip={true}\n      >\n      <Text>Content of Step 4</Text>\n      </WmWizardstep>,\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={4}\n        index={4}\n        title=\"Step 5\"\n        name=\"step5\"\n        enableskip={true}\n        show={true}\n      >\n      <Text>Content of Step 5</Text>\n      </WmWizardstep>,\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={5}\n        index={5}\n        title=\"Step 6\"\n        name=\"step6\"\n        enableskip={true}\n        show={true}\n      >\n      <Text>Content of Step 6</Text>\n      </WmWizardstep>,\n    ];\n    \n    const customRef = createRef<WmWizard>();\n    renderComponent({ children: steps, ref: customRef });\n    await timer();\n\n    const nextButton = screen.getByTestId('test_wizard_nextbtn_a');\n    fireEvent(nextButton, 'press');\n    await timer();\n    fireEvent(nextButton, 'press');\n    await timer();\n    fireEvent(nextButton, 'press');\n    await timer();\n\n    await waitFor(() => {\n      expect(customRef.current?.state.currentStep).toBe(3)\n    })\n  })\n\n  it('should call onSkip callback when the skip button is clicked', async () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmWizard.prototype,\n      'invokeEventCallback'\n    );\n    const steps = [\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={0}\n        index={0}\n        title=\"Step 1\"\n        name=\"step1\"\n        enableskip={true}\n      >\n        <Text>Content of Step 1</Text>\n      </WmWizardstep>,\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={1}\n        index={1}\n        title=\"Step 2\"\n        name=\"step2\"\n        enableskip={true}\n      >\n        <Text>Content of Step 2</Text>\n      </WmWizardstep>,\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={2}\n        index={2}\n        title=\"Step 3\"\n        name=\"step3\"\n        enableskip={true}\n      >\n        <Text>Content of Step 3</Text>\n      </WmWizardstep>,\n    ];\n\n    const props = {\n      ...defaultProps,\n      children: steps,\n      onSkip: jest.fn(),\n    };\n\n    const { getByText } = renderComponent(props);\n    await timer(300);\n\n    fireEvent.press(getByText('Skip'));\n\n    await waitFor(() => {\n      expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n        'onChange',\n        expect.anything()\n      );\n    });\n  });\n\n  it('should call change function when the next button is clicked', async () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmWizard.prototype,\n      'invokeEventCallback'\n    );\n    const mockChangeCallback = jest.fn();\n    const props = { ...defaultProps, onChange: mockChangeCallback };\n\n    const { getByText } = renderComponent(props);\n    await timer(300);\n\n    fireEvent.press(getByText(defaultProps.nextbtnlabel));\n    await waitFor(() => {\n      expect(mockChangeCallback).toHaveBeenCalled();\n      expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n        'onChange',\n        expect.anything()\n      );\n    });\n  });\n\n  it('should call change function when the previous button is clicked', async () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmWizard.prototype,\n      'invokeEventCallback'\n    );\n    const mockChangeCallback = jest.fn();\n    const props = {\n      ...defaultProps,\n      defaultstep: 'step2',\n      onChange: mockChangeCallback,\n    };\n\n    const { getByText } = renderComponent(props);\n    await timer(300);\n\n    fireEvent.press(getByText(defaultProps.previousbtnlabel));\n    await waitFor(() => {\n      expect(mockChangeCallback).toHaveBeenCalled();\n      expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n        'onChange',\n        expect.anything()\n      );\n    });\n  });\n\n  it('should align the actions to left', async () => {\n    const ref = createRef();\n    renderComponent({ actionsalignment: 'left', ref });\n    expect(screen).toMatchSnapshot();\n    await timer(300);\n    \n    const component = screen.UNSAFE_getAllByType(View)[1];\n\n    expect(component.props.children[3].props.style[1].flexDirection).toBe('row');\n  });\n\n  it('should align the actions to right', async () => {\n    const ref = createRef();\n    renderComponent({ actionsalignment: 'right', ref });\n    await timer(300);\n\n    const component = screen.UNSAFE_getAllByType(View)[1];\n\n    expect(component.props.children[3].props.style[1].flexDirection).toBe(\n      'row-reverse'\n    );\n  });\n\n  it('updates default step', async () => {\n    renderComponent({ defaultstep: 'step2' });\n    await timer(300);\n\n    await waitFor(() => {\n      expect(screen.getByText('Step 2')).toBeTruthy();\n      expect(screen.getByText('Content of Step 2')).toBeTruthy();\n    });\n  });\n\n  it('should render cancel button', async () => {\n    renderComponent();\n    await timer(300);\n    expect(screen.getByText(defaultProps.cancelbtnlabel)).toBeTruthy();\n  });\n\n  it(\"shouldn't render cancel button\", async () => {\n    renderComponent({ cancelable: false });\n    await timer(300);\n    expect(screen.queryByText(defaultProps.cancelbtnlabel)).toBeFalsy();\n  });\n\n  it('should handle show property', async () => {\n    renderComponent({ show: false });\n    await timer(300);\n    expect(screen.root.props.style).toMatchObject({\n      height: 0,\n      width: 0,\n    });\n  });\n\n  xit('should render Progress Circle Header', async () => {\n    const renderProgressCircleHeaderSpy = jest.spyOn(\n      WmWizard.prototype,\n      'renderProgressCircleHeader'\n    );\n    const tree = renderComponent({ classname: 'progress-circle-header' });\n    await timer(300);\n    expect(tree).toMatchSnapshot();\n    expect(renderProgressCircleHeaderSpy).toHaveBeenCalled();\n    renderProgressCircleHeaderSpy.mockRestore();\n    expect(\n      tree.getByTestId('test_wizard_progress_progresscircle')\n    ).toBeTruthy();\n  });\n\n  it('renders wizard steps for progress circle header', async () => {\n    const ref = createRef();\n    renderComponent({ ref, classname: 'progress-circle-header' });\n    await timer(300);\n\n    expect(screen.getByText('Step 1')).toBeTruthy();\n    await waitFor(() => {\n      expect(screen.getByText('Content of Step 1')).toBeTruthy();\n    });\n\n    fireEvent.press(screen.getByText(defaultProps.nextbtnlabel));\n    await waitFor(() => {\n      fireEvent.press(screen.getByText('Step 2'));\n      expect(screen.getByText('Content of Step 2')).toBeTruthy();\n    });\n\n    fireEvent.press(screen.getByText(defaultProps.nextbtnlabel));\n    await waitFor(() => {\n      fireEvent.press(screen.getByText('Step 3'));\n      expect(screen.getByText('Content of Step 3')).toBeTruthy();\n      expect(screen.getByText(defaultProps.donebtnlabel)).toBeTruthy();\n    });\n  });\n\n  it('should skip the step when the skip link is clicked', async () => {\n    const steps = [\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={0}\n        index={0}\n        title=\"Step 1\"\n        name=\"step1\"\n        enableskip={true}\n      >\n        <Text>Content of Step 1</Text>\n      </WmWizardstep>,\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={1}\n        index={1}\n        title=\"Step 2\"\n        name=\"step2\"\n        enableskip={true}\n      >\n        <Text>Content of Step 2</Text>\n      </WmWizardstep>,\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={2}\n        index={2}\n        title=\"Step 3\"\n        name=\"step3\"\n        enableskip={true}\n      >\n        <Text>Content of Step 3</Text>\n      </WmWizardstep>,\n    ];\n    renderComponent({ children: steps });\n    await timer(300);\n    fireEvent.press(screen.getByText('Skip'));\n    await waitFor(() => {\n      expect(screen.getByText('Step 2')).toBeTruthy();\n    });\n    fireEvent.press(screen.getByText('Skip'));\n    await waitFor(() => {\n      expect(screen.getByText('Step 3')).toBeTruthy();\n    });\n    fireEvent.press(screen.getByText('Skip'));\n  });\n\n  it(\"should render the default 'Step Title' when title is not defined to wizard step\", async () => {\n    const steps = [\n      <WmWizardstep {...wizardStepPropsObject} key={0} index={0} name=\"step1\">\n        <Text>Content of Step 1</Text>\n      </WmWizardstep>,\n      <WmWizardstep {...wizardStepPropsObject} key={1} index={1} name=\"step2\">\n        <Text>Content of Step 2</Text>\n      </WmWizardstep>,\n      <WmWizardstep {...wizardStepPropsObject} key={2} index={2} name=\"step3\">\n        <Text>Content of Step 3</Text>\n      </WmWizardstep>,\n    ];\n    renderComponent({ children: steps });\n    await waitFor(() => {\n      expect(screen.getByText('Step Title')).toBeTruthy();\n    });\n  });\n\n  it('should not render prev button when currentStep is less than 0', async () => {\n    const ref = createRef();\n    renderComponent({ ref, defaultstep: 'step3' });\n    await timer(300);\n\n    fireEvent.press(screen.getByText(defaultProps.previousbtnlabel));\n    await waitFor(() => {\n      expect(screen.getByText('Step 2')).toBeTruthy();\n    });\n    fireEvent.press(screen.getByText(defaultProps.previousbtnlabel));\n    await waitFor(() => {\n      expect(screen.getByText('Step 1')).toBeTruthy();\n    });\n    expect(screen.queryByText(defaultProps.previousbtnlabel)).toBeFalsy();\n  });\n\n  it('should not render next button when current step exceeds the the steps length', async () => {\n    const ref = createRef();\n    renderComponent({ ref, defaultstep: 'step1' });\n    await timer(300);\n\n    fireEvent.press(screen.getByText(defaultProps.nextbtnlabel));\n    await waitFor(() => {\n      expect(screen.getByText('Step 2')).toBeTruthy();\n    });\n    fireEvent.press(screen.getByText(defaultProps.nextbtnlabel));\n    await waitFor(() => {\n      expect(screen.getByText('Step 3')).toBeTruthy();\n    });\n    expect(screen.queryByText(defaultProps.nextbtnlabel)).toBeFalsy();\n  });\n\n  it('should not update current step if invokeEventCallback returns false when next button is pressed', async () => {\n    const invokeNextCBSpy = jest.spyOn(WmWizardstep.prototype, 'invokeNextCB');\n    invokeNextCBSpy.mockReturnValue(false);\n    renderComponent({ defaultstep: 'step1' });\n    await timer(300);\n    const setActiveSpy = jest.spyOn(WmWizardstep.prototype, 'setActive');\n    fireEvent.press(screen.getByText(defaultProps.nextbtnlabel));\n    await waitFor(() => {\n      expect(invokeNextCBSpy).toHaveBeenCalled();\n      expect(setActiveSpy).not.toHaveBeenCalled();\n    });\n  });\n\n  it('should not update current step if invokeEventCallback returns false when previous button is pressed', async () => {\n    const invokePrevCBSpy = jest.spyOn(WmWizardstep.prototype, 'invokePrevCB');\n    invokePrevCBSpy.mockReturnValue(false);\n    renderComponent({ defaultstep: 'step2' });\n    await timer(300);\n    fireEvent.press(screen.getByText(defaultProps.previousbtnlabel));\n    await waitFor(() => {\n      expect(invokePrevCBSpy).toHaveBeenCalled();\n    });\n  });\n\n  it('should not invoke onSkip callback if current step blocks it', async () => {\n    const steps = [\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={0}\n        index={0}\n        title=\"Step 1\"\n        name=\"step1\"\n        enableskip={true}\n      >\n        <Text>Content of Step 1</Text>\n      </WmWizardstep>,\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={1}\n        index={1}\n        title=\"Step 2\"\n        name=\"step2\"\n        enableskip={true}\n      >\n        <Text>Content of Step 2</Text>\n      </WmWizardstep>,\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={2}\n        index={2}\n        title=\"Step 3\"\n        name=\"step3\"\n        enableskip={true}\n      >\n        <Text>Content of Step 3</Text>\n      </WmWizardstep>,\n    ];\n\n    const invokeNextCBSpy = jest.spyOn(WmWizardstep.prototype, 'invokeNextCB');\n    invokeNextCBSpy.mockReturnValue(false);\n    renderComponent({ children: steps });\n    await timer(300);\n    fireEvent.press(screen.getByText('Next'));\n    const invokeSkipCBSpy = jest.spyOn(WmWizardstep.prototype, 'invokeSkipCB');\n    await waitFor(() => {\n      expect(invokeNextCBSpy).toHaveBeenCalled();\n    });\n  });\n\n  it('should have connector of second last step having width 50% when last connector show prop is false', async () => {\n    const steps = [\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={0}\n        index={0}\n        title=\"Step 1\"\n        name=\"step1\"\n        enableskip={true}\n      >\n        <Text>Content of Step 1</Text>\n      </WmWizardstep>,\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={1}\n        index={1}\n        title=\"Step 2\"\n        name=\"step2\"\n        enableskip={true}\n      >\n        <Text>Content of Step 2</Text>\n      </WmWizardstep>,\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={2}\n        index={2}\n        title=\"Step 3\"\n        name=\"step3\"\n        enableskip={true}\n      >\n      <Text>Content of Step 3</Text>\n      </WmWizardstep>,\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={3}\n        index={3}\n        title=\"Step 4\"\n        name=\"step4\"\n        enableskip={true}\n      >\n      <Text>Content of Step 4</Text>\n      </WmWizardstep>,\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={4}\n        index={4}\n        title=\"Step 5\"\n        name=\"step5\"\n        enableskip={true}\n        show={false}\n      >\n      <Text>Content of Step 5</Text>\n      </WmWizardstep>,\n    ];\n\n    const stepConnectorWidthMock = jest.spyOn(WmWizard.prototype, 'stepConnectorWidth');\n    renderComponent({ children: steps });\n\n    await waitFor(() => {\n      expect(stepConnectorWidthMock).toHaveNthReturnedWith(1,'50%') // 1st step\n      expect(stepConnectorWidthMock).toHaveNthReturnedWith(4,'50%') // Second last step\n      expect(stepConnectorWidthMock).toHaveNthReturnedWith(5,'50%') // Last step\n    })\n  });\n\n  test('stepConnectorWidth should return 50% and 100%, when steps are first or last and steps in between respectively ', async () => {\n    const steps = [\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={0}\n        index={0}\n        title=\"Step 1\"\n        name=\"step1\"\n        enableskip={true}\n      >\n        <Text>Content of Step 1</Text>\n      </WmWizardstep>,\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={1}\n        index={1}\n        title=\"Step 2\"\n        name=\"step2\"\n        enableskip={true}\n      >\n        <Text>Content of Step 2</Text>\n      </WmWizardstep>,\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={2}\n        index={2}\n        title=\"Step 3\"\n        name=\"step3\"\n        enableskip={true}\n      >\n      <Text>Content of Step 3</Text>\n      </WmWizardstep>,\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={3}\n        index={3}\n        title=\"Step 4\"\n        name=\"step4\"\n        enableskip={true}\n      >\n      <Text>Content of Step 4</Text>\n      </WmWizardstep>,\n      <WmWizardstep\n        {...wizardStepPropsObject}\n        key={4}\n        index={4}\n        title=\"Step 5\"\n        name=\"step5\"\n        enableskip={true}\n        show={true}\n      >\n      <Text>Content of Step 5</Text>\n      </WmWizardstep>,\n    ];\n    \n    const customRef = createRef<WmWizard>();\n    const stepConnectorWidthMock = jest.spyOn(WmWizard.prototype, 'stepConnectorWidth');\n    renderComponent({ children: steps, ref: customRef });\n\n    await timer();\n\n\n    await waitFor(() => {\n      expect(stepConnectorWidthMock).toHaveNthReturnedWith(1,'50%') \n      expect(stepConnectorWidthMock).toHaveNthReturnedWith(2,'100%')\n      expect(stepConnectorWidthMock).toHaveNthReturnedWith(3,'100%')\n      expect(stepConnectorWidthMock).toHaveNthReturnedWith(4,'100%')\n      expect(stepConnectorWidthMock).toHaveNthReturnedWith(5,'50%')\n    })\n  })\n\n  test('render skeleton if showskeleton is true and showskeletonchildren is false', async () => {\n    const renderSkeletonSpy = jest.spyOn(WmWizard.prototype, 'renderSkeleton');\n\n    const tree = renderComponent({\n      showskeleton: true,\n      showskeletonchildren: false,\n    });\n    expect(screen).toMatchSnapshot();\n\n    expect(renderSkeletonSpy).toHaveBeenCalled();\n    const viewElement = tree.toJSON()[1];\n    expect(viewElement.props.style.backgroundColor).toBe('#eeeeee');\n    expect(viewElement.children[0].props.style).toContainEqual({\n      opacity: 0,\n    });\n    renderSkeletonSpy.mockRestore();\n  });\n\n  xit('render skeleton if showskeleton is true and showskeletonchildren is true', async () => {\n    const renderSkeletonSpy = jest.spyOn(WmWizard.prototype, 'renderSkeleton');\n\n    const tree = renderComponent({\n      showskeleton: true,\n      showskeletonchildren: true,\n    });\n    expect(screen).toMatchSnapshot();\n\n    expect(renderSkeletonSpy).toHaveBeenCalled();\n    const viewElement = tree.root;\n    expect(viewElement.props.style.backgroundColor).toBe('#eeeeee');\n    expect(viewElement.props.children[0].props.style).toContainEqual({\n      opacity: 0,\n    });\n    renderSkeletonSpy.mockRestore();\n  });\n});\n", "wavemaker-rn-runtime/test/components/container/linearlayout.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport WmLinearlayout from '@wavemaker/app-rn-runtime/components/container/linearlayout/linearlayout.component';\nimport WmLinearlayoutProps from '@wavemaker/app-rn-runtime/components/container/linearlayout/linearlayout.props';\nimport { screen, render } from '@testing-library/react-native';\nimport { View, Text } from 'react-native';\n\ndescribe('Linearlayout component tests', () => {\n  const defaultProps: WmLinearlayoutProps = {\n    direction: 'row',\n    horizontalalign: 'left',\n    verticalalign: 'top',\n    spacing: 0,\n  };\n\n  const ALIGNMENT_MAP = {\n    top: 'flex-start',\n    left: 'flex-start',\n    center: 'center',\n    right: 'flex-end',\n    bottom: 'flex-end',\n  } as any;\n\n  const getChildren = (n: number = 3) => {\n    const children = Array.from({ length: n }).map((_, index) => {\n      return (\n        <Text key={index} testID={`child-${index + 1}`}>\n          {`Sample Text ${index + 1}`}\n        </Text>\n      );\n    });\n    return children;\n  };\n\n  const renderComponent = (props = {}) => {\n    return render(<WmLinearlayout {...defaultProps} {...props} />);\n  };\n\n  it('renders correctly with default props', () => {\n    const tree = renderComponent();\n    expect(tree).toBeTruthy();\n    expect(tree.root.props.style).toBeTruthy();\n    expect(screen).toMatchSnapshot();\n  });\n\n  it('should render children properly', () => {\n    const children = <View key=\"1\" testID=\"child-1\" />;\n    const { getByTestId } = renderComponent({ children });\n    expect(screen).toMatchSnapshot();\n    expect(getByTestId('child-1')).toBeTruthy();\n  });\n\n  it('should render multiple children properly', () => {\n    const children = [0, 1, 2, 3].map((item, index) => {\n      return (\n        <Text testID={`child-${index + 1}`}>{`Sample Text ${index + 1}`}</Text>\n      );\n    });\n    const { getByTestId, getByText } = renderComponent({ children });\n    children.map((item, index) => {\n      expect(getByTestId(`child-${index + 1}`)).toBeTruthy();\n      expect(getByText(`Sample Text ${index + 1}`)).toBeTruthy();\n    });\n  });\n\n  it('should render the items in a horizontal row', () => {\n    const children = getChildren();\n    const tree: any = renderComponent({ children });\n    expect(tree.root.props.style.flexDirection).toBe('row');\n    children.map((item, index) => {\n      expect(tree.root.children[index + 1].props.children).toBe(\n        `Sample Text ${index + 1}`\n      );\n    });\n  });\n\n  it('should render the items in a vertical column', () => {\n    const children = getChildren();\n    const tree: any = renderComponent({ children, direction: 'column' });\n    expect(tree.root.props.style.flexDirection).toBe('column');\n    children.map((item, index) => {\n      expect(tree.getByText(`Sample Text ${index + 1}`)).toBeTruthy();\n    });\n  });\n\n  it('should render the items in a reversed horizontal row', () => {\n    const children = getChildren();\n    const tree = renderComponent({ children, direction: 'row-reverse' });\n    expect(tree.root.props.style.flexDirection).toBe('row-reverse');\n    children.map((item, index) => {\n      expect(tree.getByText(`Sample Text ${index + 1}`)).toBeTruthy();\n    });\n  });\n\n  it('should render the items in a reversed vertical column', () => {\n    const children = getChildren();\n    const tree = renderComponent({ children, direction: 'column-reverse' });\n    expect(tree.root.props.style.flexDirection).toBe('column-reverse');\n    children.map((item, index) => {\n      expect(tree.getByText(`Sample Text ${index + 1}`)).toBeTruthy();\n    });\n  });\n\n  it('should render the items in a horizontal row with horizontal align left,vertical align top', () => {\n    const children = getChildren();\n    const tree = renderComponent({\n      children,\n      direction: 'row',\n      horizontalalign: 'left',\n      verticalalign: 'top',\n    });\n    expect(tree.root.props.style.flexDirection).toBe('row');\n    expect(tree.root.props.style.justifyContent).toBe('flex-start');\n    expect(tree.root.props.style.alignItems).toBe('flex-start');\n  });\n\n  it('should render the items in a horizontal row with horizontal align left,vertical align top', () => {\n    const children = getChildren();\n    const directions: WmLinearlayoutProps['direction'][] = [\n      'row',\n      'row-reverse',\n      'column',\n      'column-reverse',\n    ];\n    const horizontalAlignments: WmLinearlayoutProps['horizontalalign'][] = [\n      'left',\n      'center',\n      'right',\n    ];\n    const verticalAlignments: WmLinearlayoutProps['verticalalign'][] = [\n      'top',\n      'center',\n      'bottom',\n    ];\n\n    directions.forEach((direction) => {\n      horizontalAlignments.forEach((horizontalalign) => {\n        verticalAlignments.forEach((verticalalign) => {\n          const tree = renderComponent({\n            children,\n            direction: direction,\n            horizontalalign: horizontalalign,\n            verticalalign: verticalalign,\n            spacing: 0,\n          });\n\n          expect(tree.root.props.style.flexDirection).toBe(direction);\n          const isHorizontal = direction.startsWith('row');\n          if (isHorizontal) {\n            const justifyContent = ALIGNMENT_MAP[horizontalalign];\n            const alignItems = ALIGNMENT_MAP[verticalalign];\n            expect(tree.root.props.style.justifyContent).toBe(justifyContent);\n            expect(tree.root.props.style.alignItems).toBe(alignItems);\n          } else {\n            const justifyContent = ALIGNMENT_MAP[verticalalign];\n            const alignItems = ALIGNMENT_MAP[horizontalalign];\n            expect(tree.root.props.style.justifyContent).toBe(justifyContent);\n            expect(tree.root.props.style.alignItems).toBe(alignItems);\n          }\n        });\n      });\n    });\n  });\n\n  test('render skeleton if showskeleton is true and showskeletonchildren is false', async () => {\n    const children = getChildren();\n    const renderSkeletonSpy = jest.spyOn(\n      WmLinearlayout.prototype,\n      'renderSkeleton'\n    );\n\n    const tree = renderComponent({\n      children,\n      showskeleton: true,\n      showskeletonchildren: false,\n    });\n\n    expect(renderSkeletonSpy).toHaveBeenCalled();\n    const viewElement = tree.root;\n    expect(viewElement.props.style.backgroundColor).toBe('#eeeeee');\n    expect(viewElement.props.children[0].props.style).toContainEqual({\n      opacity: 0,\n    });\n    renderSkeletonSpy.mockRestore();\n  });\n\n  xit('render skeleton if showskeleton is true and showskeletonchildren is true', async () => {\n    const children = getChildren();\n    const renderSkeletonSpy = jest.spyOn(\n      WmLinearlayout.prototype,\n      'renderSkeleton'\n    );\n\n    const tree = renderComponent({\n      children,\n      showskeleton: true,\n      showskeletonchildren: true,\n    });\n\n    expect(renderSkeletonSpy).toHaveBeenCalled();\n    const viewElement = tree.root;\n    expect(viewElement.props.style.backgroundColor).toBe('#eeeeee');\n    expect(viewElement.props.children[0].props.style).toContainEqual({\n      opacity: 0,\n    });\n    renderSkeletonSpy.mockRestore();\n  });\n});\n", "wavemaker-rn-runtime/test/components/container/tabs.component.spec.tsx": "import React, { createRef, ReactNode, useRef } from 'react';\nimport { ScrollView, Text, TouchableOpacity, View } from 'react-native';\nimport {\n  render,\n  fireEvent,\n  cleanup,\n  screen,\n} from '@testing-library/react-native';\nimport WmTabs from '@wavemaker/app-rn-runtime/components/container/tabs/tabs.component';\nimport WmTabpane from '@wavemaker/app-rn-runtime/components/container/tabs/tabpane/tabpane.component';\nimport WmTabheader from '@wavemaker/app-rn-runtime/components/container/tabs/tabheader/tabheader.component';\n\nconst getBasicTabs = () => {\n  const tabs = createRef<WmTabs>();\n  const tab1 = createRef<WmTabpane>();\n  const tab2 = createRef<WmTabpane>();\n  const tab3 = createRef<WmTabpane>();\n  return {\n    tree: render(\n      <WmTabs name=\"test_tabs\" ref={tabs}>\n        <WmTabpane name=\"tab1\" title=\"Red\" ref={tab1}></WmTabpane>\n        <WmTabpane name=\"tab2\" title=\"Green\" ref={tab2}></WmTabpane>\n        <WmTabpane name=\"tab3\" title=\"Blue\" ref={tab3}></WmTabpane>\n      </WmTabs>\n    ),\n    ref: {\n      tabs,\n      tab1,\n      tab2,\n      tab3,\n    },\n  };\n};\n\nconst timer = (time = 100) =>\n  new Promise((resolve: any, reject) => {\n    setTimeout(() => resolve(), time);\n  });\n\ndescribe('Test Tabs component', () => {\n  test('should render the Tabs component', () => {\n    const {\n      tree,\n      ref: { tabs },\n    } = getBasicTabs();\n    expect(tree).not.toBeNull();\n    expect(tree).toBeDefined();\n    expect(tree).toMatchSnapshot();\n    expect(tabs.current).not.toBeNull();\n  });\n\n  test('should select the first tab pane by default', () => {\n    const {\n      ref: { tabs, tab1 },\n    } = getBasicTabs();\n    expect(tab1.current).not.toBeNull();\n    expect(tabs.current?.selectedTabPane === tab1.current?.proxy).toBeTruthy();\n  });\n\n  test('should select the tab pane based on header pressed', async () => {\n    const {\n      tree,\n      ref: { tabs, tab1, tab3 },\n    } = getBasicTabs();\n    expect(tab1.current).not.toBeNull();\n    expect(tabs.current?.selectedTabPane === tab1.current?.proxy).toBeTruthy();\n    const header3 = tree.getByText('Blue');\n    fireEvent(header3, 'press');\n    await timer(1000);\n    expect(tab3.current).not.toBeNull();\n    expect(tabs.current?.selectedTabPane === tab3.current?.proxy).toBeTruthy();\n  });\n\n  test('should check the goTo method', async () => {\n    const {\n      tree,\n      ref: { tabs, tab1, tab3 },\n    } = getBasicTabs();\n    expect(tab1.current).not.toBeNull();\n    expect(tabs.current?.selectedTabPane === tab1.current?.proxy).toBeTruthy();\n    tabs.current?.goToTab(2);\n    await timer(1000);\n    expect(tab3.current).not.toBeNull();\n    expect(tabs.current?.selectedTabPane === tab3.current?.proxy).toBeTruthy();\n    tabs.current?.goToTab(-1);\n    expect(tabs.current?.selectedTabPane === tab3.current?.proxy).toBeTruthy();\n    tabs.current?.goToTab(4);\n    expect(tabs.current?.selectedTabPane === tab3.current?.proxy).toBeTruthy();\n    tabs.current?.goToTab(0);\n    await timer(1000);\n    expect(tabs.current?.selectedTabPane === tab1.current?.proxy).toBeTruthy();\n  });\n\n  test('should select the tab pane with select method', async () => {\n    const {\n      tree,\n      ref: { tabs, tab1, tab3 },\n    } = getBasicTabs();\n    expect(tab1.current).not.toBeNull();\n    expect(tabs.current?.selectedTabPane === tab1.current?.proxy).toBeTruthy();\n    expect(tab3.current).not.toBeNull();\n    (tab3.current?.proxy as any).select();\n    await timer(1000);\n    expect(tabs.current?.selectedTabPane === tab3.current?.proxy).toBeTruthy();\n  });\n\n  test('should render the tabs when content is from partial', async () => {\n    const tab2 = createRef<WmTabpane>();\n    const onLoadMock = jest.fn();\n\n    const tree = render(\n      <WmTabs name=\"test_tabs\">\n        <WmTabpane name=\"tab1\" title=\"Red\"></WmTabpane>\n        <WmTabpane\n          name=\"tab2\"\n          title=\"Green\"\n          ref={tab2}\n          onLoad={onLoadMock}\n          renderPartial={(props, onLoad) => {\n            onLoad();\n            return <Text>TEST_COMPONENT</Text>;\n          }}\n        ></WmTabpane>\n      </WmTabs>\n    );\n    timer(1000);\n    expect(tree.getByText('TEST_COMPONENT')).toBeTruthy();\n    expect(onLoadMock).toHaveBeenCalled();\n  });\n\n  test('should render skeleton loader when showskeleton is \"true\"', () => {\n    const tree = render(\n      <WmTabs name=\"test_tabs\" showskeleton={true}>\n        <WmTabpane name=\"tab1\" title=\"Red\"></WmTabpane>\n        <WmTabpane\n          name=\"tab2\"\n          title=\"Green\"\n          renderPartial={() => {\n            return <Text>TEST_COMPONENT</Text>;\n          }}\n        ></WmTabpane>\n      </WmTabs>\n    );\n    expect(tree).toMatchSnapshot();\n    expect(screen.queryByText('Red')).toBeNull();\n    expect(screen.queryByText('Green')).toBeNull();\n  });\n\n  test('handles show property correctly', async () => {\n    const ref = createRef();\n    const tree = render(\n      <WmTabs name=\"test_Popover\" show={true} ref={ref}>\n        <WmTabpane name=\"tab1\" title=\"Red\"></WmTabpane>\n        <WmTabpane\n          name=\"tab2\"\n          title=\"Green\"\n          renderPartial={() => {\n            return <Text>TEST_COMPONENT</Text>;\n          }}\n        ></WmTabpane>\n      </WmTabs>\n    );\n\n    expect(tree.toJSON()[1].props.style.width).not.toBe(0);\n    expect(tree.toJSON()[1].props.style.height).not.toBe(0);\n\n    ref.current.proxy.show = false;\n\n    await timer(300);\n\n    expect(tree.toJSON()[1].props.style.width).toBe(0);\n    expect(tree.toJSON()[1].props.style.height).toBe(0);\n  });\n\n  it('should handle tablayout change event', () => {\n    const ref = createRef();\n    const tree = render(\n      <WmTabs name=\"test_Popover\" ref={ref}>\n        <WmTabpane name=\"tab1\" title=\"Red\"></WmTabpane>\n        <WmTabpane\n          name=\"tab2\"\n          title=\"Green\"\n          renderPartial={() => {\n            return <Text>TEST_COMPONENT</Text>;\n          }}\n        ></WmTabpane>\n      </WmTabs>\n    );\n    const nativeEvent = {\n      layout: {\n        width: 100,\n        height: 100,\n      },\n    };\n\n    const viewEle = tree.UNSAFE_getAllByType(View)[2];\n    fireEvent(viewEle, 'layout', {\n      nativeEvent: nativeEvent,\n    });\n\n    expect(ref.current.proxy.tabLayout.toString()).toBe(nativeEvent.toString());\n  });\n\n  it('should set tab pane heights when layout change event is triggered', () => {\n    const ref = createRef();\n    const tree = render(\n      <WmTabs name=\"test_Popover\" ref={ref}>\n        <WmTabpane name=\"tab1\" title=\"Red\"></WmTabpane>\n        <WmTabpane\n          name=\"tab2\"\n          title=\"Green\"\n          renderPartial={() => {\n            return <Text>TEST_COMPONENT</Text>;\n          }}\n        ></WmTabpane>\n      </WmTabs>\n    );\n    const nativeEvent = {\n      layout: {\n        width: 100,\n        height: 100,\n      },\n    };\n    const viewEle = tree.UNSAFE_getAllByType(WmTabpane)[0].parent;\n    fireEvent(viewEle, 'layout', {\n      nativeEvent: nativeEvent,\n    });\n\n    expect(ref.current.proxy.tabPaneHeights.toString()).toBe(\n      nativeEvent.layout.height.toString()\n    );\n  });\n\n  it('should handle tabheader layout change events', () => {\n    const ref = createRef();\n    const tree = render(<WmTabheader name=\"test_Popover\" ref={ref} data={[\n      {title: 'tab1', icon: 'fa fa-edit', key: 'tab1'},\n      {title: 'tab2', icon: 'fa fa-edit', key: 'tab2'},\n      {title: 'tab3', icon: 'fa fa-edit', key: 'tab3'},\n    ]}/>);\n    const nativeEvent = {\n      layout: {\n        width: 100,\n        height: 100,\n      },\n    };\n\n    ref.current.proxy.setHeaderPanelPositon({ nativeEvent: nativeEvent });\n    ref.current.proxy.setHeaderPositon(1, { nativeEvent: nativeEvent });\n\n    expect(ref.current.proxy.headerPanelLayout).toMatchObject(\n      nativeEvent.layout\n    );\n\n    expect(ref.current.proxy.headersLayout[1]).toMatchObject(\n      nativeEvent.layout\n    );\n  });\n\n  it('should disable scroll when shouldScroll prop is false', () => {\n    const ref = createRef();\n    const tree = render(<WmTabheader name=\"test_Popover\" shouldScroll={false} ref={ref} data={[\n      {title: 'tab1', icon: 'fa fa-edit', key: 'tab1'},\n      {title: 'tab2', icon: 'fa fa-edit', key: 'tab2'},\n      {title: 'tab3', icon: 'fa fa-edit', key: 'tab3'},\n    ]}/>);\n    const nativeEvent = {\n      layout: {\n        width: 100,\n        height: 100,\n      },\n    };\n\n    ref.current.proxy.setHeaderPanelPositon({ nativeEvent: nativeEvent });\n    ref.current.proxy.setHeaderPositon(1, { nativeEvent: nativeEvent });\n\n    const scrollComponent = tree.UNSAFE_getByType(ScrollView);\n\n    expect(ref.current.proxy.headerPanelLayout).toMatchObject(\n      nativeEvent.layout\n    );\n\n    expect(ref.current.proxy.headersLayout[1]).toMatchObject(\n      nativeEvent.layout\n    );\n\n    expect(scrollComponent.props.scrollEnabled).toBe(false)\n  });\n\n  // test('should navigate to next and previous', async () => {\n  //   const {tree, ref: {tabs, tab1, tab2, tab3}} = getBasicTabs();\n  //   expect(tabs.current?.selectedTabPane === tab1.current?.proxy).toBeTruthy();\n  //   tabs.current?.next();\n  //   await timer(1000);\n  //   expect(tabs.current?.selectedTabPane === tab2.current?.proxy).toBeTruthy();\n  //   tabs.current?.next();\n  //   await timer(1000);\n  //   expect(tabs.current?.selectedTabPane === tab3.current?.proxy).toBeTruthy();\n  //   tabs.current?.prev();\n  //   await timer(1000);\n  //   expect(tabs.current?.selectedTabPane === tab2.current?.proxy).toBeTruthy();\n  // });\n});\n", "wavemaker-rn-runtime/test/components/container/layoutgrid.component.spec.tsx": "import React from 'react';\nimport { Text, View } from 'react-native';\nimport { render } from '@testing-library/react-native';\nimport { BackgroundComponent } from '@wavemaker/app-rn-runtime/styles/background.component';\nimport WmLayoutgrid from '@wavemaker/app-rn-runtime/components/container/layoutgrid/layoutgrid.component';\nimport WmLayoutgridProps from '@wavemaker/app-rn-runtime/components/container/layoutgrid/layoutgrid.props';\n\nconst renderComponent = (props?: WmLayoutgridProps | any) => {\n  return render(\n    <WmLayoutgrid id=\"layoutgrid\" {...props}>\n      {props?.children}\n    </WmLayoutgrid>\n  );\n};\n\nconst ChildComponent = () => (\n  <View>\n    <Text>Child Component</Text>\n  </View>\n);\n\ndescribe('Test Layoutgrid component', () => {\n  test('renders layout grid properly', () => {\n    const tree = renderComponent({children: null});\n\n    expect(tree.getByTestId('layoutgrid')).toBeTruthy();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders root styles', () => {\n    const tree = renderComponent();\n    const rootEle = tree.root;\n    expect(rootEle.props.style.flexDirection).toBe('column');\n    expect(rootEle.props.style.width).toBe('100%');\n  });\n\n  it('renders background component', () => {\n    const tree = renderComponent();\n    const viewEle = tree.UNSAFE_queryByType(BackgroundComponent);\n    expect(viewEle).not.toBeNull();\n    expect(viewEle).toBeDefined();\n  });\n\n  it('should render a skeleton with given width and height', () => {\n    const tree = renderComponent({\n      showskeleton: true,\n      skeletonheight: '100',\n      skeletonwidth: '50',\n    });\n\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders children correctly', () => {\n    const props = {\n      children: <ChildComponent />\n    }\n    const tree = renderComponent(props);\n\n    expect(tree.getByText('Child Component')).toBeTruthy();\n    expect(tree).toMatchSnapshot();\n  });\n});\n", "wavemaker-rn-runtime/test/components/container/tile.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport {\n  render,\n  fireEvent,\n  waitFor,\n  screen,\n} from '@testing-library/react-native';\nimport WmButton from '@wavemaker/app-rn-runtime/components/basic/button/button.component';\nimport WmTile from '@wavemaker/app-rn-runtime/components/container/tile/tile.component';\n\ndescribe('Test Tile component', () => {\n  it('should render correctly with default props', () => {\n    const props = {\n      animation: 'fadeIn',\n      children: <></>,\n    };\n    render(<WmTile {...props} />);\n    expect(screen.getByTestId('animatableView')).toBeTruthy();\n    expect(screen).toMatchSnapshot();\n  });\n\n  it('should have width and height to be 0 when show is false', () => {\n    const props = {\n      animation: 'fadeIn',\n      children: <></>,\n      show: false,\n    };\n    render(<WmTile {...props} />);\n    expect(screen.getByTestId('animatableView').props.style.width).toBe(0);\n    expect(screen.getByTestId('animatableView').props.style.height).toBe(0);\n  });\n\n  it('should render width and height', () => {\n    const props = {\n      animation: 'fadeIn',\n      children: <></>,\n    };\n    const width = 50;\n    const height = 70;\n    render(\n      <WmTile\n        {...props}\n        styles={{\n          root: {\n            width: width,\n            height: height,\n          },\n        }}\n      />\n    );\n\n    expect(screen).toMatchSnapshot();\n    const viewEle = screen.getByTestId('animatableView');\n    expect(viewEle.props.style.width).toBe(width);\n    expect(viewEle.props.style.height).toBe(height);\n  });\n\n  it('renders children correctly', () => {\n    const props = {\n      animation: '',\n      children: <></>,\n    };\n    const { getByText } = render(\n      <WmTile {...props}>\n        <WmButton caption=\"Button1\" />\n        <WmButton caption=\"Button2\" />\n      </WmTile>\n    );\n\n    expect(getByText('Button1')).toBeTruthy();\n    expect(getByText('Button2')).toBeTruthy();\n  });\n\n  it('should handle animation and delay props', () => {\n    const props = {\n      animation: 'fadeIn',\n      animationdelay: 500,\n      children: <></>,\n    };\n    render(<WmTile {...props} />);\n\n    const animatedView = screen.getByTestId('animatableView');\n    expect(animatedView).toBeTruthy();\n    expect(animatedView.props.animation).toBe(props.animation);\n    expect(animatedView.props.delay).toBe(props.animationdelay);\n  });\n\n  it('should trigger onTap callback with WmLabel instance as one of the arguments', async () => {\n    const onTapMock = jest.fn();\n    render(<WmTile onTap={onTapMock} animation=\"fadeIn\" children={<></>} />);\n\n    fireEvent(screen.getByTestId('animatableView'), 'press');\n\n    await waitFor(() => {\n      expect(onTapMock).toHaveBeenCalled();\n      const callArg = onTapMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmTile);\n    });\n  });\n\n  it('should trigger onDoubleTap callback with WmLabel instance as one of the arguments', async () => {\n    const onDoubleTapMock = jest.fn();\n    render(\n      <WmTile onDoubletap={onDoubleTapMock} animation=\"\" children={<></>} />\n    );\n\n    fireEvent(screen.getByTestId('non_animatableView'), 'press');\n    fireEvent(screen.getByTestId('non_animatableView'), 'press');\n\n    await waitFor(() => {\n      expect(onDoubleTapMock).toHaveBeenCalled();\n      const callArg = onDoubleTapMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmTile);\n    });\n  });\n\n  it('should trigger onLongTap callback with WmLabel instance as one of the arguments', async () => {\n    const onLongTapMock = jest.fn();\n    render(\n      <WmTile onLongtap={onLongTapMock} animation=\"fadeIn\" children={<></>} />\n    );\n\n    fireEvent(screen.getByTestId('animatableView'), 'longPress');\n\n    await waitFor(() => {\n      expect(onLongTapMock).toHaveBeenCalled();\n      const callArg = onLongTapMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmTile);\n    });\n  });\n\n  xit('should trigger onTouchStart callback with WmLabel instance as one of the arguments', async () => {\n    // const onTapMock = jest.fn();\n    const onTouchStartMock = jest.fn();\n    render(\n      <WmTile\n        // onTap={onTapMock}\n        onTouchstart={onTouchStartMock}\n        animation=\"\"\n        children={<></>}\n      />\n    );\n\n    fireEvent(screen.getByTestId('non_animatableView'), 'press');\n\n    await waitFor(() => {\n      expect(onTouchStartMock).toHaveBeenCalled();\n      const callArg = onTouchStartMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmTile);\n    });\n  });\n\n  xit('should trigger onTouchEnd callback with WmLabel instance as one of the arguments', async () => {\n    // const onTapMock = jest.fn();\n    const onTouchEndMock = jest.fn();\n    render(\n      <WmTile\n        // onTap={onTapMock}\n        onTouchend={onTouchEndMock}\n        animation=\"fadeIn\"\n        children={<></>}\n      />\n    );\n\n    fireEvent(screen.getByTestId('animatableView'), 'pressOut');\n\n    await waitFor(() => {\n      expect(onTouchEndMock).toHaveBeenCalled();\n      const callArg = onTouchEndMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmTile);\n    });\n  });\n});\n", "wavemaker-rn-runtime/test/components/container/panel.component.spec.tsx": "import React from 'react';\nimport { Platform, Text } from 'react-native';\nimport { fireEvent, render, waitFor } from '@testing-library/react-native';\nimport WmPanel from '@wavemaker/app-rn-runtime/components/container/panel/panel.component';\nimport WmPanelProps from '@wavemaker/app-rn-runtime/components/container/panel/panel.props';\n\nconst fireEventLayoutFun = (component: any) => {\n  return fireEvent(component.root, 'layout', {\n    nativeEvent: {\n      layout: {\n        x: 100,\n        y: 100,\n        px: 100,\n        py: 100,\n        width: 200,\n        height: 200,\n      },\n    },\n  });\n};\n\nconst renderComponent = (props?: Partial<WmPanelProps> | any) => {\n  const defaultProps = {\n    id: 'panel',\n    name: 'panel',\n    title: 'Panel Title',\n    subheading: 'Panel Subheading',\n    collapsible: true,\n    expanded: true,\n    animation: '',\n    iconclass: '',\n    badgetype: 'default',\n    badgevalue: '99+',\n    children: <Text>Panel Content</Text>,\n    show: true,\n  };\n\n  return render(\n    <WmPanel {...defaultProps} {...props}>\n      {props?.children || defaultProps?.children}\n    </WmPanel>\n  );\n};\n\ndescribe('Test Panel component', () => {\n  test('renders panel properly', () => {\n    const tree = renderComponent();\n\n    expect(tree.getByTestId('panel')).toBeTruthy();\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('renders children components', () => {\n    const tree = renderComponent();\n\n    expect(tree.getByText('Panel Content')).toBeTruthy();\n  });\n\n  test('renders the panel title and subheading properly', () => {\n    const tree = renderComponent();\n\n    const title = tree.getByText('Panel Title');\n    expect(title).toBeTruthy();\n\n    const subheading = tree.getByText('Panel Subheading');\n    expect(subheading).toBeTruthy();\n  });\n\n  test('handles collapse functionality', async () => {\n    const onCollapse = jest.fn();\n    const props = {\n      collapsible: true,\n      expanded: true,\n      onCollapse,\n    };\n    const tree = renderComponent(props);\n    const header = tree.getByTestId('panel_header');\n\n    fireEvent.press(header);\n    expect(onCollapse).toHaveBeenCalled();\n    expect(tree.getByText('chevron-up')).toBeTruthy();\n  });\n\n  test('handles expand functionality', async () => {\n    const onExpand = jest.fn();\n    const props = {\n      collapsible: true,\n      expanded: false,\n      onExpand,\n    };\n    const tree = renderComponent(props);\n    const header = tree.getByTestId('panel_header');\n\n    fireEvent.press(header);\n    expect(onExpand).toHaveBeenCalled();\n    expect(tree.getByText('chevron-down')).toBeTruthy();\n  });\n\n  it('does not toggle expanded state, when not collapsible', () => {\n    const onExpand = jest.fn();\n    const onCollapse = jest.fn();\n    const tree = renderComponent({ collapsible: false });\n\n    fireEvent.press(tree.getByTestId('panel_header'));\n    expect(onExpand).not.toHaveBeenCalled();\n    expect(onCollapse).not.toHaveBeenCalled();\n  });\n\n  it('should invoke onLoad callback when panel content is loaded', async () => {\n    const onLoadMock = jest.fn();\n\n    const tree = renderComponent({\n      onLoad: onLoadMock,\n      renderPartial: (props: any, onLoad: any) => {\n        onLoad();\n      },\n    });\n\n    fireEventLayoutFun(tree);\n    await waitFor(() => {\n      expect(onLoadMock).toHaveBeenCalled();\n    });\n  });\n\n  test('displays the badge correctly', () => {\n    const tree = renderComponent();\n    const badge = tree.getByTestId('panel_badge');\n    expect(badge).toBeTruthy();\n    expect(badge.props.children).toBe('99+');\n  });\n\n  test('displays the icon correctly', () => {\n    const tree = renderComponent({\n      iconclass: 'wi wi-edit',\n    });\n\n    expect(tree.getByText('edit')).toBeTruthy();\n  });\n\n  it('collapsible pane works properly', () => {\n    Platform.OS = 'ios';\n\n    const tree = renderComponent({\n      styles: {\n        header: {\n          display: 'block',\n        },\n      },\n      children: <Text>Collapsible Pane Content</Text>,\n    });\n\n    expect(tree.getByText('Collapsible Pane Content')).toBeTruthy();\n  });\n\n  it('should render a skeleton with given width and height', () => {\n    const tree = renderComponent({\n      showskeleton: true,\n      skeletonheight: '100',\n      skeletonwidth: '50',\n    });\n\n    expect(tree).toMatchSnapshot();\n  });\n});\n", "wavemaker-rn-runtime/test/components/container/layoutgrid/gridcolumn.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport { Text, TouchableOpacity } from 'react-native';\nimport { shallow } from 'enzyme';\nimport renderer from 'react-test-renderer';\nimport WmGridcolumn from '@wavemaker/app-rn-runtime/components/container/layoutgrid/gridcolumn/gridcolumn.component';\n\ndescribe.skip('Test Gridcolumn component', () => {\n  test('Check validity of sample component', () => {\n    const tree = renderer\n      .create(<WmGridcolumn name=\"test_Gridcolumn\" />)\n      .toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n});\n", "wavemaker-rn-runtime/test/components/container/layoutgrid/gridrow.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport { Text, TouchableOpacity } from 'react-native';\nimport { shallow } from 'enzyme';\nimport renderer from 'react-test-renderer';\nimport WmGridrow from '@wavemaker/app-rn-runtime/components/container/layoutgrid/gridrow/gridrow.component';\n\ndescribe('Test Gridrow component', () => {\n  test('Check validity of sample component', () => {\n    const tree = renderer.create(<WmGridrow name=\"test_Gridrow\" />).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n});\n", "wavemaker-rn-runtime/test/components/container/panel/panel-content.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport { Text, TouchableOpacity } from 'react-native';\nimport { shallow } from 'enzyme';\nimport renderer from 'react-test-renderer';\nimport WmPanelContent from '@wavemaker/app-rn-runtime/components/container/panel/panel-content/panel-content.component';\n\ndescribe('Test PanelContent component', () => {\n    test('Check validity of sample component', () => {\n      const tree = renderer.create(<WmPanelContent name=\"test_PanelContent\"/>).toJSON();\n      expect(tree).toMatchSnapshot();\n    });\n});", "wavemaker-rn-runtime/test/components/container/panel/panel-footer.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport { Text, TouchableOpacity } from 'react-native';\nimport { shallow } from 'enzyme';\nimport renderer from 'react-test-renderer';\nimport WmPanelFooter from '@wavemaker/app-rn-runtime/components/container/panel/panel-footer/panel-footer.component';\n\ndescribe('Test PanelFooter component', () => {\n    test('Check validity of sample component', () => {\n      const tree = renderer.create(<WmPanelFooter name=\"test_PanelFooter\"/>).toJSON();\n      expect(tree).toMatchSnapshot();\n    });\n});", "wavemaker-rn-runtime/test/components/container/accordion/accordion.component.spec.tsx": "import React, { createRef } from 'react';\nimport {\n  render,\n  fireEvent,\n  waitFor,\n  screen,\n  act,\n  cleanup,\n} from '@testing-library/react-native';\nimport WmAccordion from '@wavemaker/app-rn-runtime/components/container/accordion/accordion.component';\nimport WmAccordionpane from '@wavemaker/app-rn-runtime/components/container/accordion/accordionpane/accordionpane.component';\nimport WmLabel from '@wavemaker/app-rn-runtime/components/basic/label/label.component';\nimport WmAccordionProps from '../../../../src/components/container/accordion/accordion.props';\nimport { Platform } from 'react-native';\n\nconst defaultProps = {\n  animation: 'fadeInDown',\n  children: null,\n  defaultpaneindex: 0,\n  closeothers: true,\n  name: 'accordion1',\n} as WmAccordionProps;\n\nconst timer = (time = 100) =>\n  new Promise((resolve: any, reject) => {\n    setTimeout(() => resolve(), time);\n  });\n\nconst generateAccordionPane = (\n  items: number = 1,\n  props: any = null,\n  renderPartial: any = () => null,\n  partialComponent: boolean = false\n) => {\n  const arr: any = [];\n  for (let i = 1; i <= items; i++) {\n    arr.push(\n      <WmAccordionpane\n        memoize=\"false\"\n        name={`accordionpane${i}`}\n        title={`Title${i}`}\n        subheading={`subtitle${i}`}\n        badgevalue={`badge${i}`}\n        iconclass={`wm-sl-l sl-apple`}\n        badgetype=\"danger\"\n        key={`Title${i}`}\n        renderPartial={() => renderPartial()}\n        {...props}\n      >\n        {!partialComponent && (\n          <WmLabel\n            name={`label${i}`}\n            caption={`test caption${i} in accordion pane`}\n          ></WmLabel>\n        )}\n      </WmAccordionpane>\n    );\n  }\n  return arr;\n};\n\nconst childrensLength = 3;\nconst CompWithChildrens = {\n  children: generateAccordionPane(childrensLength),\n} as WmAccordionProps;\n\nconst renderPartial = (props: any, onLoad: any) => {\n  return (\n    <WmLabel name={'PartialLabel'} caption={`Partial label caption`}></WmLabel>\n  );\n};\n\nconst CompWithPartial = {\n  children: generateAccordionPane(\n    1,\n    { onLoad: jest.fn() },\n    renderPartial,\n    true\n  ),\n} as WmAccordionProps;\n\nconst getAccordionPanes = () => {\n  return Array.from(CompWithChildrens.children);\n};\n\nconst getTitles = () => {\n  return Array.from(CompWithChildrens.children).map(\n    (pane: any) => pane.props.title\n  );\n};\n\nconst getSubHeading = () => {\n  return Array.from(CompWithChildrens.children).map(\n    (pane: any) => pane.props.subheading\n  );\n};\n\nconst getBadgeValues = () => {\n  return Array.from(CompWithChildrens.children).map(\n    (pane: any) => pane.props.badgevalue\n  );\n};\n\nconst getIconClass = () => {\n  return Array.from(CompWithChildrens.children).map((pane: any) => {\n    const match = pane.props.iconclass\n      ?.split(' ')[1]\n      .replace(/^.*?-(.*)$/, '$1');\n    return match;\n  });\n};\n\nconst renderComponent = (props = {}) =>\n  render(<WmAccordion {...defaultProps} {...props} />);\n\nafterEach(cleanup);\n\ndescribe('WmAccordion Component', () => {\n  test('check for render wmaccordion correctly with default props', async () => {\n    const tree = renderComponent();\n    expect(tree).toBeDefined();\n    expect(tree).not.toBeNull();\n    expect(tree).toMatchSnapshot();\n  });\n\n  xit('check for accordionpane getting except as an valid array', () => {\n    // sending children default value of []\n    expect(renderComponent({ children: [] })).toBeDefined();\n  });\n\n  xit('check for title, subheading rendered properly', () => {\n    const { getAllByText } = renderComponent(CompWithChildrens);\n\n    const panes_header_titles = getAllByText(/^Title\\d{1,2}$/);\n    expect(panes_header_titles.length).toBe(getTitles().length);\n    const titles = panes_header_titles.map((title) => title.props.children);\n    titles.map((t: string, i: number) => {\n      expect(t).toBe(getTitles()[i]);\n    });\n\n    const panes_header_subheading = getAllByText(/^subtitle\\d{1,2}$/);\n    expect(panes_header_subheading.length).toBe(getSubHeading().length);\n    const sub_headings = panes_header_subheading.map(\n      (sub_heading) => sub_heading.props.children\n    );\n    sub_headings.map((s: string, i: number) => {\n      expect(s).toBe(getSubHeading()[i]);\n    });\n  });\n\n  xit('check for titleIcon rendered properly', () => {\n    const { getAllByTestId, getByText } = renderComponent(CompWithChildrens);\n    const accodionpane_icons = getAllByTestId(\n      /^accordion\\d_titleIcon\\d+_icon$/\n    );\n    const icons = accodionpane_icons.map((icon) => icon.props.children);\n    icons.map((ic: string, i: number) => {\n      if (getIconClass()) expect(icons[i]).toBe(getIconClass()[i]);\n    });\n  });\n\n  test('check for badge rendered properly with badgevalue', () => {\n    const badgeArr = ['success', 'primary', 'info', 'warning', 'danger'];\n\n    badgeArr.map((item, index) => {\n      const CompWithBadge = {\n        children: generateAccordionPane(1, { badgevalue: item }),\n      };\n      const tree = renderComponent(CompWithBadge);\n      const badges_ids = tree.getAllByTestId(/^accordion\\d_badge\\d$/);\n      const badges = badges_ids.map((b) => b.props.children);\n      expect(badges[0]).toBe(badgeArr[index]);\n    });\n\n    const tree = renderComponent(CompWithChildrens);\n    const badges_comp = tree.getAllByText(/^badge\\d{1,2}$/);\n    expect(badges_comp.length).toBe(getBadgeValues().length);\n    const badge_values = badges_comp.map((i) => i.props.children);\n    badge_values.map((b: string, i: number) => {\n      expect(b).toBe(getBadgeValues()[i]);\n    });\n  });\n\n  xit('should handle current item expanded correctly', async () => {\n    // Simulating as web preview\n    Platform.OS = 'web';\n    const ref = createRef();\n    const activeHeaderColor = '#4263eb'; // coming from theme primaryColor\n\n    const { getByTestId, getByText } = renderComponent({\n      ...CompWithChildrens,\n      ref,\n    });\n    const currentItemIndex = childrensLength - 2;\n    fireEvent.press(getByText(`Title${currentItemIndex + 1}`));\n\n    // todo\n    // first item it is expanded by default and not collapsing on other item expansion, need fix\n    for (let i = 0; i < getAccordionPanes().length; i++) {\n      await waitFor(() => {\n        // check for header backgroundStyles applied properly\n        const accordionHeader = getByTestId(`accordion1_header${i}`);\n        const renderedHeaderStyles = accordionHeader.props.style[0][0];\n        const expectedHeaderStyles = { backgroundColor: activeHeaderColor };\n        if (i == currentItemIndex)\n          expect(renderedHeaderStyles).toContainEqual(\n            expect.objectContaining(expectedHeaderStyles)\n          );\n        else\n          expect(renderedHeaderStyles).not.toContainEqual(\n            expect.objectContaining(expectedHeaderStyles)\n          );\n\n        // check for accordionpane children displaying properly\n        const contentLabel = getByTestId(\n          `accordionpane${i + 1}_content_label${i + 1}`\n        );\n        const styleObj =\n          i == currentItemIndex ? {} : { maxHeight: 0, overflow: 'hidden' };\n        expect(contentLabel.props).toHaveProperty('style', styleObj);\n      });\n    }\n  });\n\n  xit('check for title, subheading styles applied properly', async () => {\n    Platform.OS = 'web';\n    const ref = createRef();\n    const activeHeaderTitleColor = '#ffffff'; // coming from theme accordionActiveHeaderTextColor\n    const expectedTitleStyles = { color: activeHeaderTitleColor };\n    const expectedSubHeadingStyles = { color: activeHeaderTitleColor };\n\n    renderComponent({ ...CompWithChildrens, ref });\n    const currentItemIndex = childrensLength - 2;\n    await waitFor(() => {\n      fireEvent.press(screen.getByText(`Title${currentItemIndex + 1}`));\n    });\n\n    // todo\n    // first item it is expanded by default and not collapsing on other item expansion, need fix\n    for (let i = 0; i < getAccordionPanes().length; i++) {\n      // check for title text color applied properly\n      const title = screen.getByText(`Title${i + 1}`);\n      const renderedTitleStyles = title.props.style;\n\n      // check for subheader text color applied properly\n      const subHeading = screen.getByText(`subtitle${i + 1}`);\n      const renderedSubHeadingStyles = subHeading.props.style;\n\n      await waitFor(() => {\n        if (i == currentItemIndex) {\n          expect(renderedTitleStyles).toContainEqual(\n            expect.objectContaining(expectedTitleStyles)\n          );\n          expect(renderedSubHeadingStyles).toContainEqual(\n            expect.objectContaining(expectedSubHeadingStyles)\n          );\n        } else {\n          expect(renderedTitleStyles).not.toContainEqual(\n            expect.objectContaining(expectedTitleStyles)\n          );\n          expect(renderedSubHeadingStyles).not.toContainEqual(\n            expect.objectContaining(expectedSubHeadingStyles)\n          );\n        }\n      });\n    }\n  });\n\n  xit('check for expand method', async () => {\n    //  Simulating as web preview\n    Platform.OS = 'web';\n    const ref = createRef();\n    renderComponent({ ...CompWithChildrens, ref });\n\n    ref.current.expand(`accordionpane2`);\n\n    timer(1000);\n    const contentLabel = screen.getByTestId(`accordionpane2_content_label2`);\n    await waitFor(() => {\n      expect(contentLabel.props.style).toEqual({});\n    });\n  });\n\n  xit('check for collapse method', async () => {\n    //  Simulating as web preview\n    Platform.OS = 'web';\n    const ref = createRef();\n    renderComponent({ ...CompWithChildrens, ref });\n\n    ref.current.collapse(`accordionpane2`);\n\n    timer(1000);\n    const contentLabel = screen.getByTestId(`accordionpane2_content_label2`);\n    await waitFor(() => {\n      expect(contentLabel.props.style).toEqual({\n        maxHeight: 0,\n        overflow: 'hidden',\n      });\n    });\n  });\n\n  test('check for onChange in accordion', async () => {\n    const onChangeMock = jest.fn();\n    const tree = renderComponent({\n      ...CompWithChildrens,\n      onChange: onChangeMock,\n    });\n\n    fireEvent.press(screen.getByText(`Title2`));\n\n    await waitFor(() => {\n      expect(onChangeMock).toHaveBeenCalled();\n    });\n  });\n\n  test('check for onExpand and onCollpase in accordionpane', async () => {\n    const onExpandMock = jest.fn();\n    const onCollapseMock = jest.fn();\n    const onChangeMock = jest.fn();\n\n    const CompWithOnExpandCollpaseFn = {\n      children: generateAccordionPane(childrensLength, {\n        onExpand: onExpandMock,\n        onCollapse: onCollapseMock,\n      }),\n    };\n    // Simulating as web preview and expanding accordionpane\n    Platform.OS = 'web';\n    const ref = createRef();\n\n    const { getByText } = renderComponent({\n      ...CompWithOnExpandCollpaseFn,\n      ref,\n      onChange: onChangeMock,\n    });\n    const currentItemIndex = childrensLength - 2;\n    fireEvent.press(getByText(`Title${currentItemIndex + 1}`));\n    await timer(1000);\n    expect(onExpandMock).toHaveBeenCalled();\n    expect(onChangeMock).toHaveBeenCalled();\n\n    fireEvent.press(getByText(`Title${currentItemIndex + 1}`));\n    await timer(1000);\n    expect(onCollapseMock).toHaveBeenCalled();\n    expect(onChangeMock).toHaveBeenCalled();\n  });\n\n  test('render skeleton if showskeleton is true and showskeletonchildren is true', async () => {\n    const renderSkeletonMock = jest.spyOn(\n      WmAccordion.prototype,\n      'renderSkeleton'\n    );\n\n    const tree = renderComponent({\n      ...CompWithChildrens,\n      showskeleton: true,\n      showskeletonchildren: true,\n    });\n    expect(screen).toMatchSnapshot();\n\n    expect(renderSkeletonMock).toHaveBeenCalled();\n    const viewElement = tree.root;\n    expect(viewElement.props.style.backgroundColor).toBe('transparent');\n    expect(viewElement.props.style.borderColor).toBe('#eeeeee');\n    renderSkeletonMock.mockRestore();\n  });\n\n  test('render skeleton if showskeleton is true and showskeletonchildren is false', async () => {\n    const renderSkeletonMock = jest.spyOn(\n      WmAccordion.prototype,\n      'renderSkeleton'\n    );\n\n    const tree = renderComponent({\n      ...CompWithChildrens,\n      showskeleton: true,\n      showskeletonchildren: false,\n    });\n    expect(screen).toMatchSnapshot();\n\n    expect(renderSkeletonMock).toHaveBeenCalled();\n    const viewElement = tree.root.props.children[0];\n    expect(viewElement.props.style).toContainEqual({ opacity: 0 });\n    renderSkeletonMock.mockRestore();\n  });\n\n  xit('check for partial inside accorionpane', async () => {\n    const onLoadMock = jest.fn();\n    const tree = renderComponent(CompWithPartial);\n    expect(tree.getByText('Partial label caption')).toBeTruthy();\n\n    // todo fix\n    // check for partial onLoad event\n    await waitFor(() => {\n      expect(onLoadMock).toHaveBeenCalled();\n    });\n  });\n});\n", "wavemaker-rn-runtime/test/components/container/accordion/accordionpane/accordionpane.component.spec.tsx": "import React, { createRef } from 'react';\nimport { render, waitFor, screen } from '@testing-library/react-native';\nimport WmAccordionpane from '@wavemaker/app-rn-runtime/components/container/accordion/accordionpane/accordionpane.component';\nimport WmAccordion from '@wavemaker/app-rn-runtime/components/container/accordion/accordion.component';\nimport WmAccordionProps from '@wavemaker/app-rn-runtime/components/container/accordion/accordion.props';\nimport WmLabel from '@wavemaker/app-rn-runtime/components/basic/label/label.component';\nimport { Platform } from 'react-native';\n\nconst defaultProps = {\n  animation: 'fadeInDown',\n  children: null,\n  defaultpaneindex: 0,\n  closeothers: true,\n  name: 'accordion1',\n} as WmAccordionProps;\n\nconst timer = (time = 100) =>\n  new Promise((resolve: any, reject) => {\n    setTimeout(() => resolve(), time);\n  });\n\nconst generateAccordionPane = (\n  items: number = 1,\n  props: any = null,\n  renderPartial: any = () => null,\n  partialComponent: boolean = false\n) => {\n  const arr: any = [];\n  for (let i = 1; i <= items; i++) {\n    arr.push(\n      <WmAccordionpane\n        memoize=\"false\"\n        name={`accordionpane${i}`}\n        title={`Title${i}`}\n        subheading={`subtitle${i}`}\n        badgevalue={`badge${i}`}\n        iconclass={`wm-sl-l sl-apple`}\n        badgetype=\"danger\"\n        key={`Title${i}`}\n        renderPartial={() => renderPartial()}\n        {...props}\n      >\n        {!partialComponent && (\n          <WmLabel\n            name={`label${i}`}\n            caption={`test caption${i} in accordion pane`}\n          ></WmLabel>\n        )}\n      </WmAccordionpane>\n    );\n  }\n  return arr;\n};\n\nconst CompWithChildrens = {\n  children: generateAccordionPane(2),\n} as WmAccordionProps;\n\nconst renderComponent = (props = {}) =>\n  render(<WmAccordion {...defaultProps} {...props} />);\n\ndescribe('Test Accordionpane component', () => {\n  test('check for render wmaccordionpane correctly with default props', () => {\n    const tree = renderComponent();\n    expect(tree).toBeDefined();\n    expect(tree).not.toBeNull();\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('check for isCollapsed method', () => {\n    const ref = createRef();\n    render(\n      <WmAccordion>\n        <WmAccordionpane ref={ref}>\n          <WmLabel caption=\"test\"></WmLabel>\n        </WmAccordionpane>\n      </WmAccordion>\n    );\n\n    ref.current?.setState({ collapsed: true });\n    expect(ref.current?.isCollapsed()).toBe(true);\n\n    ref.current?.setState({ collapsed: false });\n    expect(ref.current?.isCollapsed()).toBe(false);\n  });\n\n  xit('check for expand method', async () => {\n    Platform.OS = 'web';\n    const ref = createRef();\n    const CompChildrensWithRef = {\n      children: generateAccordionPane(2, { ref: ref }),\n    } as WmAccordionProps;\n\n    renderComponent(CompChildrensWithRef);\n    ref.current.expand(`accordionpane2`);\n\n    timer(1000);\n    const contentLabel = screen.getByTestId(`accordionpane2_content_label2`);\n    await waitFor(() => {\n      expect(contentLabel.props.style).toEqual({});\n    });\n  });\n\n  xit('check for collapse method', async () => {\n    //  Simulating as web preview\n    Platform.OS = 'web';\n    const ref = createRef();\n    const CompChildrensWithRef = {\n      children: generateAccordionPane(3, { ref: ref }),\n    } as WmAccordionProps;\n\n    renderComponent(CompChildrensWithRef);\n    ref.current.collapse(`accordionpane2`);\n\n    timer(1000);\n    const contentLabel = screen.getByTestId(`accordionpane2_content_label2`);\n    await waitFor(() => {\n      expect(contentLabel.props.style).toEqual({\n        maxHeight: 0,\n        overflow: 'hidden',\n      });\n    });\n  });\n\n  test('check for partial load', () => {\n    // renderComponent(CompWithChildrens)\n    const ref = createRef();\n    render(\n      <WmAccordion>\n        <WmAccordionpane ref={ref}>\n          <WmLabel caption=\"test\"></WmLabel>\n        </WmAccordionpane>\n      </WmAccordion>\n    );\n\n    ref.current.onPartialLoad();\n  });\n});\n", "wavemaker-rn-runtime/test/components/container/wizard/wizardstep.component.spec.tsx": "// import React, { ReactNode } from 'react';\n// import { Text, TouchableOpacity } from 'react-native';\n// import { shallow } from 'enzyme';\n// import renderer from 'react-test-renderer';\n// import WmWizardstep from '@wavemaker/app-rn-runtime/components/container/wizard/wizardstep/wizardstep.component';\n\n// describe('Test Wizardstep component', () => {\n//     test('Check validity of sample component', () => {\n//       const tree = renderer.create(<WmWizardstep name=\"test_Wizardstep\"/>).toJSON();\n//       expect(tree).toMatchSnapshot();\n//     });\n// });\n", "wavemaker-rn-runtime/test/components/container/linearlayout/linearlayoutitem.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport { Text, TouchableOpacity } from 'react-native';\nimport { screen, render } from '@testing-library/react-native';\nimport WmLinearlayout from '@wavemaker/app-rn-runtime/components/container/linearlayout/linearlayout.component';\nimport WmLinearlayoutProps from '@wavemaker/app-rn-runtime/components/container/linearlayout/linearlayout.props';\nimport WmLinearlayoutitem from '@wavemaker/app-rn-runtime/components/container/linearlayout/linearlayoutitem/linearlayoutitem.component';\nimport { Platform } from 'react-native';\nconst defaultProps: WmLinearlayoutProps = {\n  direction: 'row',\n  horizontalalign: 'left',\n  verticalalign: 'top',\n  spacing: 0,\n};\n\nconst renderComponent = (props = {}) => {\n  return render(<WmLinearlayout {...defaultProps} {...props} />);\n};\n\nconst getLinearLayoutItem = (props?: any) => {\n  const defaultLinearLayoutItemProps = {\n    children: [<Text key={1}>Item 1</Text>, <Text key={2}>Item 2</Text>],\n    flexgrow: 0,\n    flexshrink: 0,\n  };\n  return <WmLinearlayoutitem {...defaultLinearLayoutItemProps} {...props} />;\n};\n\ndescribe('Linear layout item tests', () => {\n  it('should render linearlayoutitem without crashing', () => {\n    const children = getLinearLayoutItem();\n    const tree = renderComponent({ children });\n    expect(tree).toBeTruthy();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('should render linearlayoutitem chidren', () => {\n    const children = getLinearLayoutItem();\n    const tree = renderComponent({ children });\n    expect(tree.getByText('Item 1')).toBeTruthy();\n    expect(tree.getByText('Item 2')).toBeTruthy();\n  });\n\n  it('should apply flexGrow correctly', () => {\n    const children = getLinearLayoutItem({\n      flexgrow: 1,\n      flexshrink: undefined,\n    });\n    const tree = renderComponent({ children });\n    const view: any = tree.toJSON();\n    const flexGrow = view.children[0].props.style.flexGrow;\n    expect(flexGrow).toBe(1);\n  });\n\n  it('should apply flexShrink correctly', () => {\n    const children = getLinearLayoutItem({\n      flexshrink: 1,\n    });\n    const tree = renderComponent({ children });\n    const view: any = tree.toJSON();\n    const flexShrink = view.children[0].props.style.flexShrink;\n    expect(flexShrink).toBe(1);\n  });\n\n  it(\"flexBasis should be 'auto' when Platform.OS is web\", () => {\n    Platform.OS = 'web';\n    let children = getLinearLayoutItem();\n    const tree = renderComponent({ children });\n    const view: any = tree.toJSON();\n    const flexBasis = view.children[0].props.style.flexBasis;\n    expect(flexBasis).toBe('auto');\n  });\n\n  it(\"flexBasis should be '0' when props.flexgrow is 1 and direction is row or row-reverse and Platform.OS is ios/android\", () => {\n    Platform.OS = 'ios';\n    let children1 = getLinearLayoutItem({ flexgrow: 1 });\n    const tree1 = renderComponent({ children: children1 });\n    const view: any = tree1.toJSON();\n    const flexBasis = view.children[0].props.style.flexBasis;\n    expect(flexBasis).toBe(0);\n\n    Platform.OS = 'android';\n    const children2 = getLinearLayoutItem({ flexgrow: 1 });\n    const tree2 = renderComponent({\n      children: children2,\n      direction: 'row-reverse',\n    });\n    const view1: any = tree2.toJSON();\n    const flexBasis1 = view1.children[0].props.style.flexBasis;\n    expect(flexBasis1).toBe(0);\n  });\n});\n", "wavemaker-rn-runtime/test/components/prefab/prefab-container.component.spec.tsx": "import React from 'react';\nimport { Text } from 'react-native';\nimport { render, screen } from '@testing-library/react-native';\n\nimport WmPrefabContainer from '@wavemaker/app-rn-runtime/components/prefab/prefab-container.component';\nimport { AssetProvider } from '@wavemaker/app-rn-runtime/core/asset.provider';\n\nconst timer = (time = 200) => new Promise((resolve: any, reject) => {setTimeout(()=>resolve(), time)})\n\nconst renderComponent = (props = {}) => {\n    return render(\n      <AssetProvider value={(path) => path}>\n        <WmPrefabContainer name={'wm-prefab'} children={[<Text>Children</Text>]} {...props}/>\n      </AssetProvider>\n    )\n}\n\njest.mock('@wavemaker/app-rn-runtime/core/imageSizeEstimator', () => ({\n  getSize: jest.fn((uri, callback) => {\n    callback(100, 200); // mock image dimensions\n  }),\n}));\n\ndescribe('Test prefab container', () => {\n  test('should render component', () => {\n    renderComponent();\n    expect(screen).toMatchSnapshot();\n  });\n\n  test('should render children component', () => {\n    renderComponent();\n    expect(screen.getByText('Children')).toBeTruthy();\n    expect(screen).toMatchSnapshot();\n  });\n\n  test('should apply styles', () => {\n    renderComponent({\n        styles: {\n            root: {\n                backGroundColor: 'red',\n                height: 100\n            }\n        }\n    });\n\n    expect(screen.toJSON()?.props.style).toMatchObject({\n        backGroundColor: 'red',\n        height: 100\n    })\n    expect(screen).toMatchSnapshot();\n  });\n\n  test('should render background component, when background image is set', async () => {\n    renderComponent({\n      styles: {\n        root: {\n          backgroundImage: 'linear-gradient(45deg, #4c669f, #3b5998)',\n          backgroundSize: '100% 100%',\n        }\n      }\n    });\n\n    await timer();\n    expect(screen.getByTestId('wm-expo-linear-gradient')).toBeTruthy();\n    expect(screen).toMatchSnapshot();\n  })\n});\n", "wavemaker-rn-runtime/test/components/dialogs/dialog.component.spec.tsx": "import React, { createRef } from 'react';\nimport { Text, View } from 'react-native';\nimport {\n  act,\n  cleanup,\n  fireEvent,\n  render,\n  waitFor,\n} from '@testing-library/react-native';\nimport WmDialog from '@wavemaker/app-rn-runtime/components/dialogs/dialog/dialog.component';\nimport AppModalService from '@wavemaker/app-rn-runtime/runtime/services/app-modal.service';\nimport { AssetProvider } from '@wavemaker/app-rn-runtime/core/asset.provider';\nimport { ModalProvider } from '@wavemaker/app-rn-runtime/core/modal.service';\n\nconst renderComponent = (props: any = {}) => {\n  const defaultProps = {\n    id: 'test-dialog',\n    show: true,\n    title: 'Test Title',\n    modal: true,\n    closable: false,\n    showheader: true,\n  };\n  const loadAsset = (path) => path;\n\n  AppModalService.modalsOpened = [];\n\n  return render(\n    <ModalProvider value={AppModalService}>\n      <AssetProvider value={loadAsset}>\n        <WmDialog {...defaultProps} {...props} />\n      </AssetProvider>\n    </ModalProvider>\n  );\n};\n\nconst ChildrenComponent = () => (\n  <View>\n    <Text>Children Component</Text>\n  </View>\n);\n\ndescribe('Test Dialog component', () => {\n  afterEach(() => {\n    cleanup();\n    jest.clearAllMocks();\n  });\n\n  //The render tree will always be null\n  //The dom is assigned to AppModalService.\n  test('renders correctly with default props', () => {\n    renderComponent();\n    const renderOptions = AppModalService.modalsOpened[0];\n\n    expect(\n      renderOptions.content.props.children.props.children.props.testID\n    ).toBeTruthy();\n    expect(\n      renderOptions.content.props.children.props.children.props.testID\n    ).toBe('wm-dialog');\n  });\n\n  test('should render header component when showheader is passed as true ', () => {\n    renderComponent({ showheader: true });\n    const renderOptions = AppModalService.modalsOpened[0];\n    const parentContainer = renderOptions.content.props.children.props.children;\n    const headerComponent = parentContainer.props.children[1];\n\n    expect(headerComponent.props.testID).toBeTruthy();\n    expect(headerComponent.props.testID).toBe('wm-dialog-header');\n  });\n\n  test('should render header icon when iconclass is given in props', () => {\n    renderComponent({ iconclass: 'fa fa-info' });\n\n    const renderOptions = AppModalService.modalsOpened[0];\n    const parentContainer = renderOptions.content.props.children.props.children;\n    const headerComponent = parentContainer.props.children[1];\n    const iconComponent = headerComponent.props?.children[0]?.props?.children;\n\n    expect(headerComponent.props.testID).toBeTruthy();\n    expect(headerComponent.props.testID).toBe('wm-dialog-header');\n    expect(iconComponent).toBeTruthy();\n    expect(iconComponent.props.id).toBe('test-dialog_icon');\n    expect(iconComponent.props.caption).toBe('Test Title');\n  });\n\n  test('should renders the close button when closable is true', () => {\n    renderComponent({ closable: true });\n    const renderOptions = AppModalService.modalsOpened[0];\n    const parentContainer = renderOptions.content.props.children.props.children;\n    const headerComponent = parentContainer.props.children[1];\n\n    expect(headerComponent.props.testID).toBeTruthy();\n    expect(headerComponent.props.testID).toBe('wm-dialog-header');\n\n    const closeButtonComponent = headerComponent.props?.children[1];\n\n    expect(closeButtonComponent).toBeTruthy();\n    expect(closeButtonComponent.props.id).toBe('test-dialog_closebtn');\n  });\n\n  test('should not render the close button when closable is false', () => {\n    renderComponent({ closable: false });\n    const renderOptions = AppModalService.modalsOpened[0];\n    const parentContainer = renderOptions.content.props.children.props.children;\n    const headerComponent = parentContainer.props.children[1];\n\n    expect(headerComponent.props.testID).toBeTruthy();\n    expect(headerComponent.props.testID).toBe('wm-dialog-header');\n\n    const closeButtonComponent = headerComponent.props?.children[1];\n\n    expect(closeButtonComponent).toBeFalsy();\n  });\n\n  xit('should not render header icon when iconclass is not given in props or is falsy', () => {\n    renderComponent({ iconclass: null });\n    const renderOptions = AppModalService.modalsOpened[0];\n    const parentContainer = renderOptions.content.props.children.props.children;\n    const headerComponent = parentContainer.props.children[1];\n\n    expect(headerComponent.props.testID).toBeTruthy();\n    expect(headerComponent.props.testID).toBe('wm-dialog-header');\n\n    const iconComponent = headerComponent.props?.children[0]?.props?.children;\n\n    expect(iconComponent).toBeFalsy();\n  });\n\n  test('should not render header component when showheader is passed as false ', () => {\n    renderComponent({ showheader: false });\n    const renderOptions = AppModalService.modalsOpened[0];\n    const parentContainer = renderOptions.content.props.children.props.children;\n    const headerComponent = parentContainer.props.children[1];\n\n    expect(headerComponent).toBeFalsy();\n  });\n\n  test('should call invokeEventCallback with onOpened when component is being rendered', async () => {\n    const customRef = createRef<WmDialog>();\n    const eventCallBackMock = jest.spyOn(\n      WmDialog.prototype,\n      'invokeEventCallback'\n    );\n    renderComponent({ ref: customRef });\n\n    await waitFor(() => {\n      expect(eventCallBackMock).toHaveBeenCalled();\n      expect(eventCallBackMock).toHaveBeenCalledWith('onOpened', [\n        null,\n        customRef.current,\n      ]);\n    });\n  });\n\n  test('should call invokeEventCallback with onOpened when open method is called', async () => {\n    const customRef = createRef<WmDialog>();\n    const eventCallBackMock = jest.spyOn(\n      WmDialog.prototype,\n      'invokeEventCallback'\n    );\n    renderComponent({ ref: customRef });\n\n    act(() => {\n      customRef.current.open();\n    });\n\n    await waitFor(() => {\n      expect(eventCallBackMock).toHaveBeenCalled();\n      expect(eventCallBackMock).toHaveBeenCalledWith('onOpened', [\n        null,\n        customRef.current,\n      ]);\n    });\n  });\n\n  test('should call invokeEventCallback with onOpened when show state is false and open method is called', async () => {\n    const customRef = createRef<WmDialog>();\n    const eventCallBackMock = jest.spyOn(\n      WmDialog.prototype,\n      'invokeEventCallback'\n    );\n    const updateStateMock = jest.spyOn(WmDialog.prototype, 'updateState');\n    renderComponent({ ref: customRef });\n\n    act(() => {\n      customRef.current.state.props.show = false;\n    });\n\n    act(() => {\n      customRef.current.open();\n    });\n\n    await waitFor(() => {\n      expect(updateStateMock).toHaveBeenCalledWith({ props: { show: true } });\n      expect(eventCallBackMock).toHaveBeenCalled();\n      expect(eventCallBackMock).toHaveBeenCalledWith('onOpened', [\n        null,\n        customRef.current,\n      ]);\n    });\n  });\n\n  test('should call invokeEventCallback with onClose when close method is called', async () => {\n    const customRef = createRef<WmDialog>();\n    const eventCallBackMock = jest.spyOn(\n      WmDialog.prototype,\n      'invokeEventCallback'\n    );\n    const updateStateMock = jest.spyOn(WmDialog.prototype, 'updateState');\n    renderComponent({ ref: customRef });\n\n    act(() => {\n      customRef.current.close();\n    });\n\n    await waitFor(() => {\n      expect(updateStateMock).toHaveBeenCalled();\n      expect(updateStateMock).toHaveBeenCalledWith(\n        {\n          props: { show: false },\n        },\n        expect.any(Function)\n      );\n      expect(eventCallBackMock).toHaveBeenCalled();\n      expect(eventCallBackMock).toHaveBeenCalledWith('onClose', [\n        null,\n        customRef.current,\n      ]);\n    });\n  });\n\n  test('should call invokeEventCallback with onClose when close button is pressed', async () => {\n    const customRef = createRef<WmDialog>();\n    const eventCallBackMock = jest.spyOn(\n      WmDialog.prototype,\n      'invokeEventCallback'\n    );\n    const updateStateMock = jest.spyOn(WmDialog.prototype, 'updateState');\n\n    renderComponent({ ref: customRef, closable: true });\n    const renderOptions = AppModalService.modalsOpened[0];\n    const Component = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const { getByText } = render(<Component />);\n    fireEvent(getByText('close'), 'press');\n\n    await waitFor(() => {\n      expect(updateStateMock).toHaveBeenCalled();\n      expect(updateStateMock).toHaveBeenCalledWith(\n        {\n          props: { show: false },\n        },\n        expect.any(Function)\n      );\n      expect(eventCallBackMock).toHaveBeenCalled();\n      expect(eventCallBackMock).toHaveBeenCalledWith('onClose', [\n        null,\n        customRef.current,\n      ]);\n    });\n  });\n\n  test('should renders children inside the dialog', () => {\n    renderComponent({\n      iconclass: 'fa fa-info',\n      children: <ChildrenComponent />,\n    });\n    const renderOptions = AppModalService.modalsOpened[0];\n    const Component = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const tree = render(<Component />);\n\n    expect(tree.getByText('Children Component')).toBeDefined();\n  });\n});\n", "wavemaker-rn-runtime/test/components/dialogs/dialogcontent.component.spec.tsx": "import React from 'react';\nimport { Text } from 'react-native';\nimport { fireEvent, render } from '@testing-library/react-native';\nimport WmDialogcontent from '@wavemaker/app-rn-runtime/components/dialogs/dialogcontent/dialogcontent.component';\n\ndescribe('Test Dialogcontent component', () => {\n  test('should render component', () => {\n    const tree = render(<WmDialogcontent name=\"test_Dialogcontent\" />);\n\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render component with children', () => {\n    const tree = render(\n      <WmDialogcontent name=\"test_Dialogcontent\">\n        <Text>Test Children component</Text>\n      </WmDialogcontent>\n    );\n\n    expect(tree.getByText('Test Children component')).toBeDefined();\n    expect(tree).toMatchSnapshot();\n  });\n\n  xit('should render component with custom style', () => {\n    const tree = render(\n      <WmDialogcontent\n        name=\"test_Dialogcontent\"\n        styles={{\n          backgroundColor: '#040404',\n          maxHeight: 400,\n        }}\n      >\n        <Text>Test Children component</Text>\n      </WmDialogcontent>\n    );\n\n    const containerStyleArray = tree.toJSON().props.contentContainerStyle;\n    const containerStyle = {};\n    containerStyleArray.forEach((item) => {\n      if (!item) return;\n      Object.keys(item).forEach((key) => {\n        containerStyle[key] = item[key];\n      });\n    });\n\n    expect(containerStyle).toMatchObject({\n      backgroundColor: '#040404',\n      maxHeight: 400,\n    });\n    expect(tree.toJSON().props.style).toMatchObject({ maxHeight: 400 });\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should not show component when show is false', () => {\n    const tree = render(\n      <WmDialogcontent name=\"test_Dialogcontent\" show={false}>\n        <Text>Test Children component</Text>\n      </WmDialogcontent>\n    );\n    const containerStyleArray = tree.toJSON().props.contentContainerStyle;\n    const containerStyle = {};\n    containerStyleArray.forEach((item) => {\n      if (!item) return;\n      Object.keys(item).forEach((key) => {\n        containerStyle[key] = item[key];\n      });\n    });\n\n    expect(containerStyle).toMatchObject({ height: 0, width: 0 });\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should call notify method when component is scrolled', () => {\n    const notifyMock = jest.spyOn(WmDialogcontent.prototype, 'notify');\n    const tree = render(\n      <WmDialogcontent name=\"test_Dialogcontent\" show={false}>\n        <Text>Test Children component</Text>\n      </WmDialogcontent>\n    );\n\n    fireEvent(tree.root, 'scroll');\n\n    expect(notifyMock).toHaveBeenCalled();\n    expect(notifyMock).toHaveBeenCalledWith(\n      'scroll',\n      expect.arrayContaining([])\n    );\n  });\n});\n", "wavemaker-rn-runtime/test/components/dialogs/alertdialog.component.spec.tsx": "import React from 'react';\nimport {\n  cleanup,\n  fireEvent,\n  render,\n  waitFor,\n} from '@testing-library/react-native';\nimport WmAlertdialog from '@wavemaker/app-rn-runtime/components/dialogs/alertdialog/alertdialog.component';\nimport WmDialog from '@wavemaker/app-rn-runtime/components/dialogs/dialog/dialog.component';\nimport AppModalService from '@wavemaker/app-rn-runtime/runtime/services/app-modal.service';\nimport { AssetProvider } from '@wavemaker/app-rn-runtime/core/asset.provider';\nimport { ModalProvider } from '@wavemaker/app-rn-runtime/core/modal.service';\n\nconst defaultProps = {\n  id: 'alert',\n  title: 'Alert',\n  oktext: 'Ok',\n  modal: true,\n  closable: true,\n  onOpened: jest.fn(),\n};\n\nconst renderComponent = async (props = {}) => {\n  const loadAsset = (path) => path;\n  AppModalService.modalsOpened = [];\n\n  const tree = render(\n    <ModalProvider value={AppModalService}>\n      <AssetProvider value={loadAsset}>\n        <WmAlertdialog {...defaultProps} {...props} />\n      </AssetProvider>\n    </ModalProvider>\n  );\n\n  const instance = tree.UNSAFE_getByType(WmAlertdialog).instance;\n  instance.open();\n  await timer();\n\n  return tree;\n};\n\nconst timer = (time = 100) =>\n  new Promise((resolve: any, reject) => {\n    setTimeout(() => resolve(), time);\n  });\n\nconst Component = ({ children }) => <>{children}</>;\n\ndescribe('Alertdialog component', () => {\n  afterEach(() => {\n    cleanup();\n  });\n\n  test('should render WmAlertdialog with default props', async () => {\n    await renderComponent({ message: 'test alert message' });\n    const renderOptions = AppModalService.modalsOpened[0];\n    const subTree = render(<Component children={renderOptions.content} />);\n\n    expect(subTree.getByTestId('wm-dialog')).toBeDefined();\n    expect(subTree.getByTestId('wm-dialog-header')).toBeDefined();\n    expect(subTree.getByText('test alert message')).toBeDefined();\n    expect(subTree.getByText('warning')).toBeDefined(); // default icon class: wi wi-warning\n  });\n\n  test('should render custom ok button text', async () => {\n    await renderComponent({ oktext: 'test ok button' });\n    const renderOptions = AppModalService.modalsOpened[0];\n    const subTree = render(<Component children={renderOptions.content} />);\n\n    expect(subTree.getByText('test ok button')).toBeDefined();\n  });\n\n  test('should render custom title', async () => {\n    await renderComponent({ title: 'test title' });\n    const renderOptions = AppModalService.modalsOpened[0];\n    const subTree = render(<Component children={renderOptions.content} />);\n\n    expect(subTree.getByText('test title')).toBeDefined();\n  });\n\n  test('should render with custom icon', async () => {\n    await renderComponent({ iconclass: 'wi wi-test_help' });\n    const renderOptions = AppModalService.modalsOpened[0];\n    const subTree = render(<Component children={renderOptions.content} />);\n\n    expect(subTree.getByText('test_help')).toBeDefined();\n  });\n\n  test('should call onOpened when the dialog is opened', async () => {\n    await renderComponent();\n    await timer(600);\n\n    expect(defaultProps.onOpened).toHaveBeenCalled();\n  });\n\n  test('should be closable when closable prop is true', async () => {\n    await renderComponent({ closable: true });\n    const renderOptions = AppModalService.modalsOpened[0];\n    const subTree = render(<Component children={renderOptions.content} />);\n\n    expect(subTree.getByText('close')).toBeDefined();\n  });\n\n  xit('should render custom styles', async () => {\n    const customStyles = {\n      dialog: {\n        root: {\n          backgroundColor: 'blue',\n        },\n      },\n      okButton: {\n        backgroundColor: 'green',\n      },\n      message: {\n        color: 'purple',\n      },\n    };\n    await renderComponent({ styles: { customStyles } });\n    const renderOptions = AppModalService.modalsOpened[0];\n    const { getByTestId, getByText } = render(\n      <Component children={renderOptions.content} />\n    );\n\n    expect(getByTestId('wm-dialog').props.style).toMatchObject({\n      backgroundColor: 'blue',\n    });\n    expect(getByText('Ok').props.style).toMatchObject({\n      backgroundColor: 'green',\n    });\n    expect(getByText('This is an alert message!').props.style).toMatchObject({\n      color: 'purple',\n    });\n  });\n\n  test('should render with animation if animation prop is provided', async () => {\n    await renderComponent({ animation: 'fadeIn' });\n    const renderOptions = AppModalService.modalsOpened[0];\n\n    expect(renderOptions.animation).toBe('fadeIn');\n  });\n\n  test('should have modal property set as per prop value', async () => {\n    await renderComponent({ modal: false });\n    const renderOptions = AppModalService.modalsOpened[0];\n\n    expect(renderOptions.isModal).toBe(false);\n  });\n\n  test('should render icon using URL if iconurl prop is provided', async () => {\n    const iconurlProps = {\n      iconurl: 'https://example.com/icon.png',\n      iconwidth: 20,\n      iconheight: 30,\n    };\n    await renderComponent({ ...iconurlProps });\n    const renderOptions = AppModalService.modalsOpened[0];\n    const subTree = render(<Component children={renderOptions.content} />);\n\n    expect(subTree.getByTestId('alert_dialog_icon_icon')).toBeTruthy();\n    expect(\n      subTree.getByTestId('alert_dialog_icon_icon').props.source\n    ).toMatchObject({ uri: 'https://example.com/icon.png' });\n    expect(\n      subTree.getByTestId('alert_dialog_icon_icon').props.style\n    ).toMatchObject({\n      height: 30,\n      width: 20,\n    });\n  });\n\n  test('should set the default message if not provided', async () => {\n    await renderComponent();\n    const renderOptions = AppModalService.modalsOpened[0];\n    const { getByText } = render(\n      <Component children={renderOptions.content} />\n    );\n\n    expect(getByText('I am an alert box!')).toBeDefined();\n  });\n\n  test('should close the dialog when close button is pressed', async () => {\n    await renderComponent({ closable: true });\n    const renderOptions = AppModalService.modalsOpened[0];\n    const { getByText } = render(\n      <Component children={renderOptions.content} />\n    );\n\n    expect(getByText('close')).toBeDefined();\n    fireEvent(getByText('close'), 'press');\n\n    await timer(500); // there is a timer in AppModalService\n\n    expect(AppModalService.modalsOpened[0]).toBeUndefined();\n  });\n\n  test('should close dialog when ok button is pressed', async () => {\n    const alertInvokeEventCallbackMock = jest.spyOn(\n      WmAlertdialog.prototype,\n      'invokeEventCallback'\n    );\n    const dialogInvokeEventCallbackMock = jest.spyOn(\n      WmDialog.prototype,\n      'invokeEventCallback'\n    );\n    await renderComponent();\n    const renderOptions = AppModalService.modalsOpened[0];\n    const { getByText } = render(\n      <Component children={renderOptions.content} />\n    );\n\n    fireEvent(getByText('Ok'), 'press');\n    await timer(500);\n\n    expect(alertInvokeEventCallbackMock).toHaveBeenCalledWith(\n      'onOk',\n      expect.arrayContaining([null])\n    );\n    expect(dialogInvokeEventCallbackMock).toHaveBeenCalledWith(\n      'onClose',\n      expect.arrayContaining([null])\n    );\n    expect(AppModalService.modalsOpened[0]).toBeUndefined();\n  });\n\n  test('should open and close the dialog using open and close methods', async () => {\n    const { UNSAFE_getByType } = render(\n      <ModalProvider value={AppModalService}>\n        <AssetProvider value={(path) => path}>\n          <WmAlertdialog {...defaultProps} />\n        </AssetProvider>\n      </ModalProvider>\n    );\n    const instance = UNSAFE_getByType(WmAlertdialog).instance;\n    instance.open();\n    await timer();\n\n    const subTree = render(\n      <Component children={AppModalService.modalsOpened[0].content} />\n    );\n\n    expect(AppModalService.modalsOpened[0]).toBeDefined();\n    expect(subTree.getByTestId('wm-dialog')).toBeDefined();\n\n    instance.close();\n    await timer();\n    expect(AppModalService.modalsOpened[0]).toBeUndefined();\n  });\n\n  // TODO: update and use below test case when alerttype is being used in the alert dialog component.\n  // test('should render alert message with correct style based on alerttype', () => {\n  //   const { getByText } = renderComponent({alerttype: 'error'})\n\n  //   expect(getByText('This is an alert message!').props.styles).toEqual({\n  //     text: {\n  //       color: '#ff0000', // Assuming the error text color\n  //       // additional styles for error type\n  //     },\n  //   });\n\n  //   const { getByText: getByTextInfo } = renderComponent({alerttype: 'information'})\n  //   expect(getByTextInfo('This is an alert message!').props.styles).toEqual({\n  //     text: {\n  //       color: '#0000ff', // Assuming the info text color\n  //       // additional styles for info type\n  //     },\n  //   });\n\n  //   const { getByText: getByTextWarning } = renderComponent({alerttype: 'warning'})\n  //   expect(getByTextWarning('This is an alert message!').props.styles).toEqual({\n  //     text: {\n  //       color: '#ffcc00', // Assuming the warning text color\n  //       // additional styles for warning type\n  //     },\n  //   });\n\n  //   const { getByText: getByTextSuccess } = renderComponent({alerttype: 'success'})\n  //   expect(getByTextSuccess('This is an alert message!').props.styles).toEqual({\n  //     text: {\n  //       color: '#00ff00', // Assuming the success text color\n  //       // additional styles for success type\n  //     },\n  //   });\n  // });\n});\n", "wavemaker-rn-runtime/test/components/dialogs/dialogactions.component.spec.tsx": "import React from 'react';\nimport { Text } from 'react-native';\nimport { render } from '@testing-library/react-native';\nimport WmDialogactions from '@wavemaker/app-rn-runtime/components/dialogs/dialogactions/dialogactions.component';\n\ndescribe('Dialogactions component', () => {\n  test('should render component', () => {\n    const tree = render(<WmDialogactions name=\"test_Dialogactions\" />);\n\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render component with children', () => {\n    const tree = render(\n      <WmDialogactions name=\"test_Dialogactions\">\n        <Text>Test children component</Text>\n      </WmDialogactions>\n    );\n\n    expect(tree.getByText('Test children component')).toBeDefined();\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should render component with custom style', () => {\n    const tree = render(\n      <WmDialogactions\n        name=\"test_Dialogactions\"\n        styles={{\n          root: {\n            borderColor: '#404040',\n          },\n        }}\n      >\n        <Text>Test children component</Text>\n      </WmDialogactions>\n    );\n\n    expect(tree.getByText('Test children component')).toBeDefined();\n    expect(tree.toJSON().props.style).toMatchObject({ borderColor: '#404040' });\n    expect(tree).toMatchSnapshot();\n  });\n\n  test('should not show component when show is false', () => {\n    const tree = render(\n      <WmDialogactions name=\"test_Dialogactions\" show={false}>\n        <Text>Test children component</Text>\n      </WmDialogactions>\n    );\n\n    expect(tree.toJSON().props.style).toMatchObject({ height: 0, width: 0 });\n    expect(tree).toMatchSnapshot();\n  });\n});\n", "wavemaker-rn-runtime/test/components/dialogs/confirmdialog.component.spec.tsx": "import React from 'react';\nimport { fireEvent, render, waitFor } from '@testing-library/react-native';\nimport WmConfirmdialog from '@wavemaker/app-rn-runtime/components/dialogs/confirmdialog/confirmdialog.component';\nimport WmDialog from '@wavemaker/app-rn-runtime/components/dialogs/dialog/dialog.component';\nimport AppModalService from '@wavemaker/app-rn-runtime/runtime/services/app-modal.service';\nimport { AssetProvider } from '@wavemaker/app-rn-runtime/core/asset.provider';\nimport { ModalProvider } from '@wavemaker/app-rn-runtime/core/modal.service';\n\nconst defaultProps = {\n  id: 'confirm',\n  title: 'Delete Item',\n  oktext: 'Yes',\n  canceltext: 'No',\n  modal: true,\n  closable: true,\n  show: true,\n  animation: 'fade',\n  onOpened: jest.fn(),\n};\n\nconst renderComponent = (props = {}) => {\n  const loadAsset = (path) => path;\n  AppModalService.modalsOpened = [];\n\n  return render(\n    <ModalProvider value={AppModalService}>\n      <AssetProvider value={loadAsset}>\n        <WmConfirmdialog {...defaultProps} {...props} />\n      </AssetProvider>\n    </ModalProvider>\n  );\n};\n\nconst timer = (time = 100) =>\n  new Promise((resolve: any, reject) => {\n    setTimeout(() => resolve(), time);\n  });\n\ndescribe('Test Confirmdialog component', () => {\n  //The render tree will always be null\n  //The dom is assigned to AppModalService.\n  test('should render WmConfirmdialog with default props', async () => {\n    const { UNSAFE_getByType } = renderComponent();\n    const instance = UNSAFE_getByType(WmConfirmdialog).instance;\n    instance.open();\n    await timer();\n\n    const renderOptions = AppModalService.modalsOpened[0];\n\n    await waitFor(() => {\n      expect(renderOptions).toBeTruthy();\n      expect(\n        renderOptions.content.props.children.props.children.props.testID\n      ).toBeTruthy();\n      expect(\n        renderOptions.content.props.children.props.children.props.testID\n      ).toBe('wm-dialog');\n    });\n  });\n\n  test('should call onOk when OK button is pressed', async () => {\n    // invokeEventCallback\n    const invokeEventCallbackMock = jest.spyOn(\n      WmConfirmdialog.prototype,\n      'invokeEventCallback'\n    );\n    const dialogCloseMock = jest.spyOn(WmDialog.prototype, 'close');\n    const { UNSAFE_getByType } = renderComponent();\n    const instance = UNSAFE_getByType(WmConfirmdialog).instance;\n    instance.open();\n    await timer();\n    const renderOptions = AppModalService.modalsOpened[0];\n\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const subTree = render(<Content />);\n    fireEvent.press(subTree.getByText('Yes'));\n\n    await waitFor(() => {\n      expect(renderOptions).toBeTruthy();\n      expect(\n        renderOptions.content.props.children.props.children.props.testID\n      ).toBeTruthy();\n      expect(\n        renderOptions.content.props.children.props.children.props.testID\n      ).toBe('wm-dialog');\n      expect(dialogCloseMock).toHaveBeenCalled();\n      expect(invokeEventCallbackMock).toHaveBeenCalled();\n      expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n        'onOk',\n        expect.arrayContaining([null])\n      );\n    });\n  });\n\n  test('should call onCancel when Cancel button is pressed', async () => {\n    const invokeEventCallbackMock = jest.spyOn(\n      WmConfirmdialog.prototype,\n      'invokeEventCallback'\n    );\n    const dialogCloseMock = jest.spyOn(WmDialog.prototype, 'close');\n    const { UNSAFE_getByType } = renderComponent();\n    const instance = UNSAFE_getByType(WmConfirmdialog).instance;\n    instance.open();\n    await timer();\n    const renderOptions = AppModalService.modalsOpened[0];\n\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const subTree = render(<Content />);\n    fireEvent.press(subTree.getByText('No'));\n\n    await waitFor(() => {\n      expect(renderOptions).toBeTruthy();\n      expect(\n        renderOptions.content.props.children.props.children.props.testID\n      ).toBeTruthy();\n      expect(\n        renderOptions.content.props.children.props.children.props.testID\n      ).toBe('wm-dialog');\n      expect(dialogCloseMock).toHaveBeenCalled();\n      expect(invokeEventCallbackMock).toHaveBeenCalled();\n      expect(invokeEventCallbackMock).toHaveBeenCalledWith(\n        'onCancel',\n        expect.arrayContaining([null])\n      );\n    });\n  });\n\n  test('should render with custom icon', async () => {\n    const { UNSAFE_getByType } = renderComponent({\n      iconclass: 'wm-sl-l sl-check',\n    });\n    const instance = UNSAFE_getByType(WmConfirmdialog).instance;\n    instance.open();\n    await timer();\n    const renderOptions = AppModalService.modalsOpened[0];\n\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const subTree = render(<Content />);\n\n    await waitFor(() => {\n      expect(renderOptions).toBeTruthy();\n      expect(\n        renderOptions.content.props.children.props.children.props.testID\n      ).toBeTruthy();\n      expect(\n        renderOptions.content.props.children.props.children.props.testID\n      ).toBe('wm-dialog');\n      expect(subTree.getByText('check')).toBeTruthy();\n    });\n  });\n\n  test('should call onOpened when the dialog is opened', async () => {\n    const { UNSAFE_getByType } = renderComponent();\n    const instance = UNSAFE_getByType(WmConfirmdialog).instance;\n    instance.open();\n    // there is a setTimeout of 500ms in AppModalService showLastModal\n    await timer(600);\n\n    expect(defaultProps.onOpened).toHaveBeenCalled();\n  });\n\n  xit('should render custom styles', async () => {\n    const customStyles = {\n      dialog: {\n        root: {\n          backgroundColor: 'blue',\n        },\n      },\n      okButton: {\n        backgroundColor: 'green',\n      },\n      cancelButton: {\n        backgroundColor: 'red',\n      },\n      message: {\n        color: 'purple',\n      },\n    };\n    const { UNSAFE_getByType } = renderComponent({ styles: customStyles });\n    const instance = UNSAFE_getByType(WmConfirmdialog).instance;\n    instance.open();\n    await timer();\n    const renderOptions = AppModalService.modalsOpened[0];\n\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const { getByTestId, getByText } = render(<Content />);\n\n    expect(getByTestId('wm-dialog').props.style).toMatchObject({\n      backgroundColor: 'blue',\n    });\n    expect(getByText('Yes').props.style).toMatchObject({\n      backgroundColor: 'green',\n    });\n    expect(getByText('No').props.style).toMatchObject({\n      backgroundColor: 'red',\n    });\n    expect(\n      getByText('Are you sure you want to delete this item?').props.style\n    ).toMatchObject({ color: 'purple' });\n  });\n\n  test('should render with animation if animation prop is provided', async () => {\n    const { UNSAFE_getByType } = renderComponent({ animation: 'bounce' });\n    const instance = UNSAFE_getByType(WmConfirmdialog).instance;\n    instance.open();\n    await timer();\n    const renderOptions = AppModalService.modalsOpened[0];\n\n    expect(renderOptions.animation).toBe('bounce');\n  });\n\n  test('should have modal property set as per prop value', async () => {\n    const { UNSAFE_getByType } = renderComponent({ modal: false });\n    const instance = UNSAFE_getByType(WmConfirmdialog).instance;\n    instance.open();\n    await timer();\n    const renderOptions = AppModalService.modalsOpened[0];\n\n    expect(renderOptions.isModal).toBe(false);\n  });\n\n  test('should render icon using URL if iconurl prop is provided', async () => {\n    const { UNSAFE_getByType } = renderComponent({\n      iconurl: 'https://example.com/icon.png',\n      iconwidth: 20,\n      iconheight: 30,\n    });\n    const instance = UNSAFE_getByType(WmConfirmdialog).instance;\n    instance.open();\n    await timer();\n    const renderOptions = AppModalService.modalsOpened[0];\n\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const subTree = render(<Content />);\n\n    await waitFor(() => {\n      expect(subTree.getByTestId('confirm_dialog_icon_icon')).toBeTruthy();\n      expect(\n        subTree.getByTestId('confirm_dialog_icon_icon').props.source\n      ).toMatchObject({ uri: 'https://example.com/icon.png' });\n      expect(\n        subTree.getByTestId('confirm_dialog_icon_icon').props.style\n      ).toMatchObject({\n        height: 30,\n        width: 20,\n      });\n    });\n  });\n\n  test('should set the default message if not provided', async () => {\n    const { UNSAFE_getByType } = renderComponent();\n    const instance = UNSAFE_getByType(WmConfirmdialog).instance;\n    instance.open();\n    await timer();\n    const renderOptions = AppModalService.modalsOpened[0];\n\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const { getByText } = render(<Content />);\n\n    expect(getByText('I am confirm box!')).toBeTruthy();\n  });\n\n  test('should render message when provided', async () => {\n    const { UNSAFE_getByType } = renderComponent({ message: 'test message' });\n    const instance = UNSAFE_getByType(WmConfirmdialog).instance;\n    instance.open();\n    await timer();\n    const renderOptions = AppModalService.modalsOpened[0];\n\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const { getByText } = render(<Content />);\n\n    expect(getByText('test message')).toBeTruthy();\n  });\n\n  test('should open and close the dialog using open and close methods', async () => {\n    const component = renderComponent();\n    const instance = component.UNSAFE_getByType(WmConfirmdialog).instance;\n\n    instance.open();\n    await timer();\n    const renderOptions = AppModalService.modalsOpened[0];\n\n    const Content = () => {\n      return <>{renderOptions.content}</>;\n    };\n    const tree = render(<Content />);\n\n    expect(tree.getByTestId('wm-dialog')).toBeTruthy();\n\n    instance.close();\n    await timer();\n\n    expect(AppModalService.modalsOpened[0]).toBeUndefined();\n  });\n});\n", "wavemaker-rn-runtime/test/components/device/camera.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport { Text, TouchableOpacity } from 'react-native';\nimport { shallow } from 'enzyme';\nimport renderer from 'react-test-renderer';\nimport WmCamera from '@wavemaker/app-rn-runtime/components/device/camera/camera.component';\n\ndescribe('Test Camera component', () => {\n    test('Check validity of sample component', () => {\n      const tree = renderer.create(<WmCamera name=\"test_Camera\"/>).toJSON();\n      expect(tree).toMatchSnapshot();\n    });\n});\n", "wavemaker-rn-runtime/test/components/device/barcodescanner.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport { Text, TouchableOpacity } from 'react-native';\nimport { shallow } from 'enzyme';\nimport renderer from 'react-test-renderer';\nimport WmBarcodescanner from '@wavemaker/app-rn-runtime/components/device/barcodescanner/barcodescanner.component';\n\ndescribe('Test Barcodescanner component', () => {\n  // test('Check validity of sample component', () => {\n  //   const tree = renderer.create(<WmBarcodescanner name=\"test_Barcodescanner\"/>).toJSON();\n  //   expect(tree).toMatchSnapshot();\n  // });\n});\n", "wavemaker-rn-runtime/test/components/data/list.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport { Text, TouchableOpacity } from 'react-native';\nimport { shallow } from 'enzyme';\nimport WmList from '@wavemaker/app-rn-runtime/components/data/list/list.component';\nimport WmListProps from '@wavemaker/app-rn-runtime/components/data/list/list.props';\nimport { render } from '@testing-library/react-native';\ndescribe('Test List component', () => {\n  interface ListItem {\n    id: number;\n    name: string;\n    category?: string;\n  }\n\n  const mockData: ListItem[] = [\n    { id: 1, name: 'Item 1' },\n    { id: 2, name: 'Item 2' },\n    { id: 3, name: 'Item 3' }\n  ];\n\n  //test id\n  const testID = \"testList_flat_list\"\n\n  const createProps = (overrides?: Partial<WmListProps>): WmListProps => {\n    const baseProps = new WmListProps();\n    return {\n      ...baseProps,\n      name: 'testList',\n      direction: 'horizontal',\n      dataset: mockData,\n      renderItem: (item: ListItem): JSX.Element => <div>{item.name}</div>,\n      ...overrides\n    };\n  };\n  test('Check validity of sample component', () => {\n    const props = createProps();\n    const tree = render(<WmList {...props} />).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n  test('should show horizontal scrollbar by default', () => {\n    const props = createProps();\n    const { getByTestId } = render(<WmList {...props} />);\n    const flatList = getByTestId(testID);\n    expect(flatList.props.showsHorizontalScrollIndicator).toBe(true);\n  });\n\n  test('should hide horizontal scrollbar when hidehorizontalscrollbar is true', () => {\n    const props = createProps({ hidehorizontalscrollbar: true });\n    const { getByTestId } = render(<WmList {...props} />);\n    const flatList = getByTestId(testID);\n    expect(flatList.props.showsHorizontalScrollIndicator).toBe(false);\n  });\n\n  test('should show horizontal scrollbar when hidehorizontalscrollbar is false', () => {\n    const props = createProps({ hidehorizontalscrollbar: false });\n    const { getByTestId } = render(<WmList {...props} />);\n    const flatList = getByTestId(testID);\n    expect(flatList.props.showsHorizontalScrollIndicator).toBe(true);\n  });\n\n  test('should not affect vertical list scrollbar', () => {\n    const props = createProps({\n      direction: 'vertical',\n      hidehorizontalscrollbar: true\n    });\n\n    const { getByTestId } = render(<WmList {...props} />);\n    const flatList = getByTestId(testID);\n\n    expect(flatList.props.showsHorizontalScrollIndicator).toBeUndefined();\n  });\n});", "wavemaker-rn-runtime/test/components/data/form.component.spec.tsx": "import React from 'react';\nimport { View } from 'react-native'\nimport { render, fireEvent, waitFor } from '@testing-library/react-native';\nimport WmForm from '@wavemaker/app-rn-runtime/components/data/form/form.component';\nimport WMCard from '@wavemaker/app-rn-runtime/components/data/card/card.component';\nimport { ToastConsumer, ToastService, ToastProvider } from '@wavemaker/app-rn-runtime/core/toast.service';\n\n\njest.mock('@wavemaker/app-rn-runtime/core/utils', () => {\n  return {\n    ...jest.requireActual('@wavemaker/app-rn-runtime/core/utils'),\n    isDataSetWidget: jest.fn(() => {\n      return true;\n    }),\n  }\n})\n\nconst mockShowToast = jest.fn();\nconst mockToaster = {\n  showToast: mockShowToast\n}\n\nclass SampleToastProvider extends React.Component<React.ComponentProps<any>> {\n  constructor(props) {\n    super(props);\n  }\n  render(): React.ReactNode {\n    return <ToastProvider value={{...mockToaster}}>\n       {this.props.children}\n    </ToastProvider>\n  }\n}\n\ndescribe('WmForm', () => {\n\n  const defaultProps = {\n    title: 'Form Title',\n    subheading: 'Form Subheading',\n    iconclass: 'wm-icon-class'\n  };\n\n  it('renders WmForm component', () => {\n    const { getByText } = render(<SampleToastProvider>\n      <WmForm {...defaultProps} />\n      </SampleToastProvider>);\n    expect(getByText('Form Title')).toBeTruthy();\n    expect(getByText('Form Subheading')).toBeTruthy();\n  });\n\n  it('componentDidMount sets parent form reference', () => {\n    const tree = render(\n      <WmForm name=\"parentForm\">\n        <WMCard>\n          <WmForm {...defaultProps} parentForm=\"parentForm\" />\n        </WMCard>\n      </WmForm>\n    );\n\n    const allForms = tree.UNSAFE_getAllByType(WmForm)\n    const childForm = allForms[1];\n\n    expect(childForm.instance.parentFormRef).not.toBeNull()\n  });\n\n  it('should have width and height to be 0 when show is false', () => {\n    const props = {\n      ...defaultProps,\n      title: 'some_title_new',\n      iconclass: 'some-icon-class',\n      show: false,\n    }\n    const tree = render(<WmForm {...props} name=\"form\"/>)\n    const viewEle = tree.UNSAFE_getAllByType(View)[0].instance\n    expect(viewEle.props.style.width).toBe(0);\n    expect(viewEle.props.style.height).toBe(0);\n  })\n\n  it('onPropertyChange applyFormData gets called when the prop is changed', () => {\n    // Arrange\n    const tree = render(<WmForm {...defaultProps}/>)\n    const instance = tree.UNSAFE_getAllByType(WmForm)[0].instance;\n    const mockApplyFormData = jest.fn();\n    instance.applyFormData = mockApplyFormData;\n\n    // Act\n    instance.onPropertyChange('formdata', 'some new value', 'some old value');\n\n    // Assert\n    expect(mockApplyFormData).toHaveBeenCalled()\n  })\n\n  it('onPropertyChange should change the updated mode with respect to the passed defaultmode', () => {\n    // Arrange\n    const props = {\n      ...defaultProps,\n      defaultmode: 'Edit'\n    }\n    const tree = render(<WmForm {...props}/>)\n    const instance = tree.UNSAFE_getAllByType(WmForm)[0].instance;\n    const mockUpdateState = jest.fn()\n    instance.updateState = mockUpdateState;\n\n    // Act\n    instance.onPropertyChange('defaultmode', 'Edit', 'some old value');\n\n    // Assert\n    expect(mockUpdateState).toHaveBeenCalledWith({\"isUpdateMode\": true})\n\n    // Act\n    instance.onPropertyChange('defaultmode', 'Non Edit', 'some old value');\n\n    // Assert\n    expect(mockUpdateState).toHaveBeenCalledWith({\"isUpdateMode\": false})\n  })\n\n\n  it('onPropertyChange should update all the form fields when dataset is changed', () => {\n    // Arrange\n    const props = {\n      ...defaultProps,\n      defaultmode: 'Edit'\n    }\n    const tree = render(<WmForm {...props}/>)\n    const instance = tree.UNSAFE_getAllByType(WmForm)[0].instance;\n    const mockFormFields = ['form field 1', 'form field 2', 'form field 3', 'form field 4'];\n    instance.formFields = mockFormFields;\n    const mockUpdateFieldOnDataSourceChange = jest.fn()\n    instance._updateFieldOnDataSourceChange = mockUpdateFieldOnDataSourceChange;\n    // Act\n    instance.onPropertyChange('dataset', 'some new dataset', 'some old dataset');\n\n    // Assert\n    expect(mockUpdateFieldOnDataSourceChange).toHaveBeenCalledTimes(mockFormFields.length);\n  })\n\n  it('onPropertyChange generates form fields when metadata is updated', () => {\n    // Arrange\n    const props = {\n      ...defaultProps,\n      defaultmode: 'Edit'\n    }\n    const tree = render(<WmForm {...props}/>)\n    const instance = tree.UNSAFE_getAllByType(WmForm)[0].instance;\n    const mockGenerateFormFields = jest.fn()\n    instance.generateFormFields = mockGenerateFormFields;\n    // Act\n    instance.onPropertyChange('metadata', 'some new dataset', 'some old dataset');\n\n    // Assert\n    expect(mockGenerateFormFields).toHaveBeenCalled()\n  })\n\n\n  it('setReadonlyFields calls setReadOnlyState', () => {\n    const tree = render(<WmForm {...defaultProps}/>);\n    const instance = tree.UNSAFE_getByType(WmForm).instance;\n    instance.state.isUpdateMode = \"mock updated mode\"\n    const mockSetReadOnlyStateFunc = jest.fn()\n    const mockFormFields = [\n      {\n        setReadOnlyState: mockSetReadOnlyStateFunc\n      },\n      {\n        setReadOnlyState: mockSetReadOnlyStateFunc\n      }\n    ]\n    instance.formFields = mockFormFields;\n    instance.setReadonlyFields()\n    expect(mockSetReadOnlyStateFunc).toHaveBeenCalledTimes(2)\n    expect(mockSetReadOnlyStateFunc).toHaveBeenCalledWith('mock updated mode')\n  }) \n\n  it('setReadonlyState updates readonly state correctly',  () => {\n    jest.useFakeTimers();\n    const tree = render(<WmForm {...defaultProps}/>);\n    const instance = tree.UNSAFE_getByType(WmForm).instance;\n    instance.showActions = jest.fn();\n    instance.setReadonlyFields = jest.fn()\n\n    const mockUpdateMode = 'sample updateMode';\n    instance.setReadonlyState(mockUpdateMode)\n\n    jest.advanceTimersByTime(100)\n\n\n    expect(instance.showActions).toHaveBeenCalled()\n    expect(instance.setReadonlyFields).toHaveBeenCalled()\n\n  })\n  \n  it('form actions - edit, new, cancel', () => {\n    const tree = render(<WmForm {...defaultProps}/>);\n    const instance = tree.UNSAFE_getByType(WmForm).instance;\n\n    const mockSetReadOnlyState = jest.fn()\n    instance.setReadonlyState = mockSetReadOnlyState;\n    instance.edit();\n    instance.new();\n    instance.cancel();\n    expect(mockSetReadOnlyState).toHaveBeenCalledTimes(3)\n\n  })\n\n  it('registerFormFields registers form fields and sets readonly fields', () => {\n    const {  UNSAFE_getByType } = render(<WmForm {...defaultProps} parentForm=\"parentForm\" />);\n    const instance = UNSAFE_getByType(WmForm).instance;\n    const formFields = [{ props: { name: 'testField' }, setReadOnlyState: jest.fn(), updateState: jest.fn() }];\n    const formWidgets = {};\n\n    const mockSetReadonlyFields = jest.fn()\n\n    const mockSetApplyFormData = jest.fn()\n    const mockApplyDefaultValue = jest.fn();\n\n    instance.setReadonlyFields = mockSetReadonlyFields;\n    instance.applyFormData = mockSetApplyFormData;\n    instance.applyDefaultValue = mockApplyDefaultValue;\n\n    instance.registerFormFields(formFields, formWidgets);\n    expect(instance.formFields).toEqual(formFields);\n    expect(instance.formWidgets).toEqual(formWidgets);\n    expect(instance.formfields.testField).toEqual(formFields[0]);\n    expect(instance.setReadonlyFields).toHaveBeenCalled();\n  });\n\n  it('showActions updates all action button states', () => {\n    const mockButtonUpdateStates = jest.fn();\n    const mockButtonsArray = [{\n      updateState: mockButtonUpdateStates,\n      updateMode: 'some updaye mode'\n    }]\n    const tree = render(<WmForm {...defaultProps}/>)\n    const instance = tree.UNSAFE_getByType(WmForm).instance;\n    instance.buttonArray = mockButtonsArray;\n    instance.showActions()\n    expect(mockButtonUpdateStates).toHaveBeenCalledWith({\n      props: {\n        \"show\": false\n      }\n    })\n  })\n\n  it('registerFormActions adds form actions', () => {\n    const tree = render(<WmForm {...defaultProps}/>);\n    const instance = tree.UNSAFE_getByType(WmForm).instance;\n    const mockActions = [{}, {}, {}]\n    const mockShowActions = jest.fn();\n    instance.showActions = mockShowActions;\n\n    instance.registerFormActions(mockActions)\n\n    expect(instance.buttonArray).toEqual(mockActions)\n    expect(mockShowActions).toHaveBeenCalled()\n  })\n\n  it('revert later', async () => {\n    const mockRelatedData = jest.fn()\n    const props = {\n      relatedData: mockRelatedData\n    }\n    const tree = render(<WmForm {...props}/>);\n    const instance = tree.UNSAFE_getAllByType(WmForm)[0].instance;\n    const mockFieldProps = {\n      'isDataSetBound': false,\n      widget: 'some widget',\n      isRelated: true\n    }\n    const mockFormFields = [{\n      state: {\n        props: mockFieldProps\n      },\n      props: mockFieldProps,\n      updateState: jest.fn()\n    }]\n    instance.formFields = mockFormFields\n    instance.onPropertyChange('dataset', 'some new value', 'some old value')\n    \n    await waitFor(() => {\n      expect(mockRelatedData).toHaveBeenCalled()\n    })\n  })\n\n  it('applyFormData doesnt update formdata of formfields when props form data not exists', () => {\n    const mockFormFieldUpdateState = jest.fn();\n    const formFields = [\n      {\n        updateState: mockFormFieldUpdateState\n      }\n    ]\n    const instance = render(<WmForm {...defaultProps}/>).UNSAFE_getByType(WmForm).instance;\n    instance.state.props.formdata = null;\n    instance.parentFormRef = null;\n\n    instance.formFields = formFields;\n    instance.applyFormData()\n\n    expect(mockFormFieldUpdateState).not.toHaveBeenCalled()\n\n  })\n\n  it('applyFormData updates formdata of formfields when props form data exists', async () => {\n    const mockFormFieldUpdateState = jest.fn();\n    const formFields = [\n      {\n        'formKey': 'key', \n        updateState: mockFormFieldUpdateState\n      }\n    ]\n    const instance = render(<WmForm {...defaultProps}/>).UNSAFE_getByType(WmForm).instance;\n    instance.state.props = {\n      \"formdata\": {\n        \"key\": \"some form field data\"\n      }\n    }\n    instance.parentFormRef = null;\n    instance.formFields = formFields;\n    instance.applyFormData()\n\n    expect(mockFormFieldUpdateState).toHaveBeenCalledWith({\"props\": {\"datavalue\": 'some form field data'}})\n  })\n\n  it('applyFormData updates formdata of formfields when prop formdata exists and formdata is an array', () => {\n    const mockFormFieldUpdateState = jest.fn();\n    const formFields = [\n      {\n        'formKey': 'key', \n        updateState: mockFormFieldUpdateState\n      }\n    ]\n    const instance = render(<WmForm {...defaultProps}/>).UNSAFE_getByType(WmForm).instance;\n    const mockFormData = [{\n      \"key\": \"some form field data\"\n    }]\n    instance.state.props = {\n      \"formdata\": mockFormData\n    }\n    instance.parentFormRef = null;\n    instance.formFields = formFields;\n    instance.applyFormData()\n\n    expect(mockFormFieldUpdateState).toHaveBeenCalledWith({\"props\": { \"datavalue\": mockFormData[0]['key']}})\n\n  })\n\n  it('applyDefaultValue updates formfield default value if formfield passed', () => {\n    const instance = render(<WmForm {...defaultProps}/>).UNSAFE_getByType(WmForm).instance;\n    const mockUpdateFormFieldDefaultValue = jest.fn();\n    instance.updateFormFieldDefaultValue = mockUpdateFormFieldDefaultValue;\n    instance.applyDefaultValue('some form field');\n    expect(mockUpdateFormFieldDefaultValue).toHaveBeenCalledWith('some form field')\n  })\n\n  it('applyDefaultValue updates existing form fields default value if formfield not passed', () => {\n    const instance = render(<WmForm {...defaultProps}/>).UNSAFE_getByType(WmForm).instance;\n    instance.formFields = [\n      {}, {}, {}\n    ]\n    const mockUpdateFormFieldDefaultValue = jest.fn();\n    instance.updateFormFieldDefaultValue = mockUpdateFormFieldDefaultValue;\n    instance.applyDefaultValue(null);\n    expect(mockUpdateFormFieldDefaultValue).toHaveBeenCalledTimes(instance.formFields.length)\n  })\n\n  it('formreset resets all default values of existing form fields', () => {\n    const mockFFUpdateState = jest.fn((paramOne, paramTwo) => paramTwo());\n    const formFields = [\n      {\n         state: { props: {} },\n        updateState: mockFFUpdateState,\n        props: {formKey: 'keyOne'} \n      }, {\n        state: { props: {} },\n        updateState: mockFFUpdateState,\n        formKey: 'keyTwo',\n        props: {formKey: 'keyTwo'} \n      }, {\n        state: { props: {} },\n        updateState: mockFFUpdateState,\n        formKey: 'keyThree',\n        props: {formKey: 'keyThree'} \n      }\n    ]\n\n    const instance = render(<WmForm {...defaultProps}/>).UNSAFE_getByType(WmForm).instance;\n    instance.formFields = formFields;\n    const mockReset = jest.fn()\n    instance.formWidgets = [{\n      reset: mockReset,\n      updateState: jest.fn()\n    }, {\n      reset: mockReset,\n      updateState: jest.fn()\n    }, {\n      reset: mockReset,\n      updateState: jest.fn()\n    }]\n    instance.formreset()\n    expect(mockFFUpdateState).toHaveBeenCalledTimes(formFields.length)\n    expect(mockReset).toHaveBeenCalled()\n  })\n\n  it('submit should call _debouncedSubmitForm when it is executed', () => {\n    //_debouncedSubmitForm\n    const instance = render(<WmForm {...defaultProps}/>).UNSAFE_getByType(WmForm).instance;\n    const mockDebouncedSubmitForm = jest.fn()\n    instance._debouncedSubmitForm = mockDebouncedSubmitForm\n    instance.submit()\n    expect(mockDebouncedSubmitForm).toHaveBeenCalled()\n  })\n\n  it('form submit should not invoke any callback when validation fails ', () => {\n    \n    const { UNSAFE_getByType } = render(<WmForm {...defaultProps} />);\n    const instance = UNSAFE_getByType(WmForm).instance;\n    instance.validateFieldsOnSubmit = jest.fn(() => false);\n    instance.invokeEventCallback = jest.fn(() => true);\n    instance.handleSubmit();\n    \n    expect(instance.invokeEventCallback).not.toHaveBeenCalled()\n  });\n\n  it('form submit should invoke onBeforesubmit callback if it is provided', () => {\n    \n    const onBeforesubmitMock = jest.fn()\n    const props = {\n      ...defaultProps,\n      onBeforesubmit: onBeforesubmitMock\n    }\n    const { UNSAFE_getByType } = render(<WmForm {...props} />);\n    const instance = UNSAFE_getByType(WmForm).instance;\n    instance.validateFieldsOnSubmit = jest.fn(() => true);\n    instance.handleSubmit();\n    \n    expect(onBeforesubmitMock).toHaveBeenCalled()\n  });\n\n\n  it('form submit should invoke formSubmit from props and resultCB if it is provided and formSubmit is succeeded', () => {\n    \n    const mockFormSubmit = jest.fn((data, cb, failure) => cb(data));\n    const props = {\n      ...defaultProps,\n      formSubmit: mockFormSubmit\n    }\n    const { UNSAFE_getByType } = render(<WmForm {...props} />);\n    const instance = UNSAFE_getByType(WmForm).instance;\n    instance.validateFieldsOnSubmit = jest.fn(() => true);\n    instance.onResultCb = jest.fn()\n    instance.handleSubmit();\n    \n    expect(mockFormSubmit).toHaveBeenCalled();\n    expect(instance.onResultCb).toHaveBeenCalled();\n  });\n\n  it('form submit should invoke formSubmit from props and resultCB with error if it is provided and formSubmit is failed', () => {\n    \n    const mockFormSubmit = jest.fn((data, cb, failure) => failure('some error'));\n    const props = {\n      ...defaultProps,\n      formSubmit: mockFormSubmit\n    }\n    const { UNSAFE_getByType } = render(<WmForm {...props} />);\n    const instance = UNSAFE_getByType(WmForm).instance;\n    instance.validateFieldsOnSubmit = jest.fn(() => true);\n    instance.onResultCb = jest.fn()\n    instance.handleSubmit();\n    \n    expect(instance.props.formSubmit).toHaveBeenCalled();\n    expect(mockFormSubmit).toHaveBeenCalled();\n    expect(instance.onResultCb).toHaveBeenCalledWith('some error', '');\n  });\n\n  it('form submit should invoke onsubmit callback when onSubmit is not provided as prop', () => {\n    \n    const mockSubmit = jest.fn()\n    const props = {\n      ...defaultProps,\n      onSubmit: mockSubmit\n    }\n    const { UNSAFE_getByType } = render(<WmForm {...props} />);\n    const instance = UNSAFE_getByType(WmForm).instance;\n    instance.validateFieldsOnSubmit = jest.fn(() => true);\n    instance.handleSubmit();\n    \n    expect(mockSubmit).toHaveBeenCalled();\n  });\n\n  it('onMsgClose updates showInlinesMessage', async () => {\n    const { instance } = render(<WmForm {...defaultProps}/>).UNSAFE_getAllByProps(WmForm)[0]\n\n    instance.onMsgClose();\n\n    await waitFor(() => {\n      expect(instance.state.showInlineMsg).toBeFalsy()\n    })\n  })\n\n  it('toggleMessage updates the type and message when messagelayout is Inline', async () => {\n    const props = {\n      ...defaultProps,\n      messagelayout: 'Inline'\n    }\n    const mockType = 'some type';\n    const mockMessage = 'some message';\n\n    const { instance } = render(<WmForm {...props}/>).UNSAFE_getAllByType(WmForm)[0]\n\n    instance.toggleMessage(mockType, mockMessage)\n\n    await waitFor(() => {\n      expect(instance.state.type).toEqual(mockType)\n      expect(instance.state.message).toEqual(mockMessage)\n      expect(instance.state.showInlineMsg).toBeTruthy()\n    })\n  })\n\n  it('toggleMessage calls showToast when messagelayout is non Inline', () => {\n    const props = {\n      ...defaultProps,\n      messagelayout: 'non-Inline'\n    }\n    const mockType = 'some type';\n    const mockMessage = 'some message';\n\n    const { instance } = render(<WmForm {...props}/>).UNSAFE_getAllByType(WmForm)[0]\n\n    instance.toaster = {\n      showToast: jest.fn(() => {})\n    }\n    instance.toggleMessage(mockType, mockMessage)\n    expect(instance.toaster.showToast).toHaveBeenCalled()\n  })\n\n  it('updateDataOutput updateState with formdata output with valid key provided', async () => {\n    const tree = render(<WmForm name='parent'>\n      <WmForm {...defaultProps} parentForm=\"parent\"/>\n    </WmForm>)\n    const instance = tree.UNSAFE_getAllByType(WmForm)[1].instance;\n    //instance.formdataoutput = {};\n\n    const instanceParent = tree.UNSAFE_getAllByType(WmForm)[0].instance;\n    instanceParent.updateDataOutput = jest.fn();\n\n    const key = \"somekey\"\n    const value = \"somevalue\"\n\n    instance.updateDataOutput(key, value);\n\n    await waitFor(() => {\n      expect(instance.formdataoutput).toEqual({\n        \"somekey\": \"somevalue\",\n      })\n      expect(instanceParent.updateDataOutput).toHaveBeenCalled()\n    })\n  })\n\n  it('onResultCb should invoke callback with respective params', () => {\n    const { instance } = render(<WmForm {...defaultProps}/>).UNSAFE_getAllByType(WmForm)[0]\n    const mockInvokeEventCallback = jest.fn();\n    const mockToggleMessage = jest.fn()\n\n    instance.invokeEventCallback = mockInvokeEventCallback;\n    instance.toggleMessage = mockToggleMessage;\n\n    let mockResponse = {\"key\": \"value\"};\n    let mockStatus = true;\n\n    instance.onResultCb(mockResponse, mockStatus)\n\n    expect(mockInvokeEventCallback).toHaveBeenCalled()\n    expect(mockToggleMessage).toHaveBeenCalledWith(\"success\", \"Data posted successfully\")\n    mockInvokeEventCallback.mockClear();\n\n    mockResponse = {\"key\": \"value\"};\n    mockStatus = false;\n\n    instance.onResultCb(mockResponse, mockStatus)\n\n    expect(mockInvokeEventCallback).toHaveBeenCalled()\n    expect(mockToggleMessage).toHaveBeenCalledWith(\"success\", \"Data posted successfully\")\n\n  })\n\n  it('generateFormFields should return if form field data is empty', () => {\n    //['fieldOne', 'fieldTwo', 'fieldThree']\n    const mockMetadata = {\n      data: []\n    }\n    const props = {\n      ...defaultProps,\n      metadata: mockMetadata\n    }\n    const { instance } = render(<WmForm {...props}/>).UNSAFE_getAllByType(WmForm)[0]\n\n    instance.invokeEventCallback = jest.fn()\n\n    instance.generateFormFields()\n\n    expect(instance.invokeEventCallback).not.toHaveBeenCalled()\n  })\n\n  it('generateFormFields updates dynamicForm when metadata is available', () => {\n    const mockDynamicFormData = ['field 1', 'field 2']\n    const mockGenerateComponent =  jest.fn(() => mockDynamicFormData);\n    const mockMetadata = {\n      data: ['fieldOne', 'fieldTwo', 'fieldThree'],\n    }\n    const props = {\n      ...defaultProps,\n      metadata: mockMetadata,\n      generateComponent: mockGenerateComponent,\n      onBeforerender: jest.fn()\n    }\n    const { instance } = render(<WmForm {...props}/>).UNSAFE_getAllByType(WmForm)[0]\n\n    instance.invokeEventCallback = jest.fn(() => true)\n\n    instance.generateFormFields()\n\n    expect(instance.invokeEventCallback).toHaveBeenCalled()\n  })\n\n  it('setPrimaryKey updates primary key of form field', () => {\n    const { instance } = render(<WmForm {...defaultProps}/>).UNSAFE_getAllByType(WmForm)[0];\n\n    instance.setPrimaryKey('someKey')\n\n    expect(instance.primaryKey).toEqual(['someKey']) \n  })\n\n  it('dataoutput returns formdataoutput', () => {\n    const { instance } = render(<WmForm {...defaultProps}/>).UNSAFE_getAllByType(WmForm)[0];\n\n    instance.formdataoutput = 'some data output'\n\n    expect(instance.dataoutput).toEqual('some data output') \n  })\n\n\n\n});", "wavemaker-rn-runtime/test/components/data/card.component.spec.tsx": "import React from 'react';\nimport { Text, TouchableOpacity, View } from 'react-native';\nimport { shallow } from 'enzyme';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react-native';\nimport WmCard from '@wavemaker/app-rn-runtime/components/data/card/card.component';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport { Tappable } from '@wavemaker/app-rn-runtime/core/tappable.component';\nimport WMPicture from '@wavemaker/app-rn-runtime/components/basic/picture/picture.component';\nimport WMLabel from '@wavemaker/app-rn-runtime/components/basic/label/label.component'\nimport WmMenu from '@wavemaker/app-rn-runtime/components/navigation/menu/menu.component'\n\ndescribe('Test Card component', () => {\n\n   let defaultProps;\n\n  beforeEach(() => {\n    defaultProps = {\n      title: 'Card title',\n      subheading: 'Card Subheading',\n      actions: 'some-actions',\n    } \n  })\n\n   it('renders correctly with default props', () => {\n\n    const props = {\n      ...defaultProps,\n      iconclass: 'fa fa-edit',\n      iconposition: 'left'\n    }\n\n    const tree = render(<WmCard {...props}/>)\n    expect(tree).toMatchSnapshot()\n    expect(tree.getByText('Card title')).toBeTruthy()\n    expect(tree.getByText('Card Subheading')).toBeTruthy()\n    expect(tree.getByText('edit')).toBeTruthy()\n   })\n\n   it('renders picture source when picturesource is provided', () => {\n    const props = {\n      ...defaultProps,\n      picturesource: 'some-source'\n    }\n\n    render(<WmCard {...props}/>)\n    expect(screen.UNSAFE_getAllByType(WMPicture).length).toBe(1)\n   })\n\n   it('renders children correctly', () => {\n    const { getByText } = render(\n      <WmCard>\n        <WMLabel caption=\"Child Component\"/>\n      </WmCard>\n    )\n    expect(getByText('Child Component')).toBeTruthy()\n   })\n\n   it('should have width and height to be 0 when show is false', () => {\n    const props = {\n      ...defaultProps,\n      show: false\n    }\n\n    const { UNSAFE_getAllByType } = render(\n      <WmCard {...props}/>\n    );\n    const viewEle = UNSAFE_getAllByType(View)[0].instance\n    expect(viewEle.props.style.width).toBe(0);\n    expect(viewEle.props.style.height).toBe(0);\n  });\n\n\n\n   it('should trigger onTap callback with WMCard as WMCard as one of the arguments', async () => {\n    const onTapMock = jest.fn();\n\n    const tree = render(<WmCard {...defaultProps} onTap={onTapMock}/>)\n\n    fireEvent(tree.UNSAFE_queryAllByType(Tappable)[1], 'press')\n\n    await waitFor(() => {\n      expect(onTapMock).toHaveBeenCalled()\n      const callArg = onTapMock.mock.calls[0][1]\n      expect(callArg).toBeInstanceOf(WmCard)\n    })\n   })\n\n   it('should trigger onDoubleTap callback with WMCard as one of the arguments', async () => {\n\n    const onDoubleTapMock = jest.fn();\n\n    const props = {\n      ...defaultProps,\n      onDoubletap: onDoubleTapMock\n    }\n\n    const tree = render(<WmCard {...props}/>)\n    fireEvent(tree.UNSAFE_getAllByType(Tappable)[1], 'press')\n    fireEvent(tree.UNSAFE_getAllByType(Tappable)[1], 'press')\n\n    await waitFor(() => {\n      expect(onDoubleTapMock).toHaveBeenCalled();\n      const callArg = onDoubleTapMock.mock.calls[0][1];\n      expect(callArg).toBeInstanceOf(WmCard)\n    })\n   })\n\n   it('should trigger onLongPress callback with WMCard as one of the argument', async () => {\n    const onLongTapMock = jest.fn();\n\n    const props = {\n      ...defaultProps,\n      onLongtap: onLongTapMock\n    }\n\n    const tree = render(<WmCard {...props}/>);\n    fireEvent(tree.UNSAFE_getAllByType(Tappable)[1], 'longPress');\n    await waitFor(() => {\n      expect(onLongTapMock).toHaveBeenCalled();\n      const callArg = onLongTapMock.mock.calls[0][1]\n      expect(callArg).toBeInstanceOf(WmCard)\n    })\n   })\n   \n   //TODO: Sunil Press in and out are not gettin called.\n  \n  //  it('should trigger onTouchStart callback', async () => {\n  //   // const onTapMock = jest.fn();\n  //   const onTouchStartMock = jest.fn();\n  //   const tree = render(\n  //     <WmCard\n  //       // onTap={onTapMock}\n  //       onTouchstart={onTouchStartMock}\n  //     />\n  //   );\n\n  //   fireEvent(tree.UNSAFE_getAllByType(Tappable)[[0]], 'press');\n\n  //   await waitFor(() => {\n  //     expect(onTouchStartMock).toHaveBeenCalled();\n  //     const callArg = onTouchStartMock.mock.calls[0][1];\n  //   });\n  // });\n\n   \n  // it('should trigger onTouchend callback with WMCard as one of the argument', async () => {\n  //   const onTouchEndMock = jest.fn();\n  //   const props = {\n  //     ...defaultProps,\n  //   }\n\n  //   const tree = render(<WmCard {...props} onLongtap={onTouchEndMock}/>);\n  //   fireEvent(tree.UNSAFE_getAllByType(Tappable)[1], 'longPress');\n  //   await waitFor(() => {\n  //     expect(onTouchEndMock).toHaveBeenCalled();\n  //   })\n  // })\n\n  \n\n});", "wavemaker-rn-runtime/test/components/data/form/form-field.component.spec.tsx": "import React from 'react';\nimport {\n  render,\n  screen,\n  fireEvent,\n  waitFor,\n} from '@testing-library/react-native';\nimport WmFormField, {\n  WmFormFieldState,\n} from '@wavemaker/app-rn-runtime/components/data/form/form-field/form-field.component';\nimport WmFormFieldProps from '@wavemaker/app-rn-runtime/components/data/form/form-field/form-field.props';\nimport { Text, View } from 'react-native';\nimport { cloneDeep } from 'lodash';\nimport { PERFORMANCE_LOGGER } from '@wavemaker/app-rn-runtime/core/logger';\nimport WmLabel from '@wavemaker/app-rn-runtime/components/basic/label/label.component';\nimport WmText from '@wavemaker/app-rn-runtime/components/input/text/text.component';\n\ndescribe('WmFormField Component', () => {\n  let defaultProps: WmFormFieldProps;\n\n  const commonFields = {\n    name: 'widgetName',\n    formfieldname: 'formfieldName',\n    formfield: true,\n    memoize: false,\n    required: false,\n    regexp: '',\n    validationmessage: '',\n    datavalue: '',\n    disabled: false,\n    readonly: false,\n    className: 'form-input form-widgetType form-widgetName-input',\n    conditionalclass: \"fragment.getFormFieldStyles($formField, 'commonField')\",\n    placeholder: 'placeholderValue',\n    displayname: 'Username',\n    onFocus: jest.fn(),\n    onBlur: jest.fn(),\n    onTap: jest.fn(),\n  };\n\n  const createFormMock = () => ({\n    registerFormFields: jest.fn(),\n    formWidgets: { testKey: {} },\n    formFields: {},\n    updateDataOutput: jest.fn(),\n  });\n\n  const setupInstance = (props = {}) => {\n    const { UNSAFE_getByType } = render(\n      <WmFormField {...{ ...defaultProps, ...props }} />\n    );\n    return UNSAFE_getByType(WmFormField).instance;\n  };\n\n  beforeEach(() => {\n    defaultProps = {\n      ...commonFields,\n      children: null,\n      formRef: null,\n      generator: '',\n      onChange: jest.fn(),\n      renderFormFields: ({ defaultProps }) => <></>,\n      isRelated: null,\n      widget: null,\n      onFieldChange: jest.fn(),\n      formKey: '',\n      dataset: null,\n      displayfield: '',\n      datafield: '',\n      isDataSetBound: false,\n      onValidate: jest.fn(),\n      formScope: jest.fn(),\n      maskchar: '',\n      displayformat: '',\n      defaultvalue: undefined,\n      primaryKey: false,\n    };\n  });\n\n  test('should call componentDidMount and register form fields', () => {\n    const componentDidMountSpy = jest.spyOn(\n      WmFormField.prototype,\n      'componentDidMount'\n    );\n    const formMock = createFormMock();\n\n    render(\n      <WmFormField\n        {...defaultProps}\n        formScope={() => formMock}\n        formKey=\"testKey\"\n      />\n    );\n\n    expect(componentDidMountSpy).toHaveBeenCalled();\n    const instance = componentDidMountSpy.mock.instances[0] as any;\n    expect(instance.formwidget).toBe(formMock.formWidgets['testKey']);\n    expect(formMock.registerFormFields).toHaveBeenCalledWith(\n      formMock.formFields,\n      formMock.formWidgets\n    );\n\n    componentDidMountSpy.mockRestore();\n  });\n\n  test('should call notifyChanges when field value changes', () => {\n    const instance = setupInstance();\n    instance.form = createFormMock();\n    instance.notifyChanges = jest.fn();\n\n    const newValue = 'new value';\n    const oldValue = 'old value';\n\n    instance.onFieldChangeEvt('fieldName', newValue, oldValue, false);\n\n    expect(instance.notifyChanges).toHaveBeenCalled();\n  });\n\n  test('should update state with new datavalue', () => {\n    const instance = setupInstance();\n    instance.form = createFormMock();\n    instance.updateState = jest.fn();\n\n    const newValue = 'new value';\n    const oldValue = 'old value';\n\n    instance.onFieldChangeEvt('fieldName', newValue, oldValue, false);\n\n    expect(instance.updateState).toHaveBeenCalledWith(\n      { props: { datavalue: newValue } },\n      expect.any(Function)\n    );\n  });\n\n  test('should invoke event callback with correct arguments', async () => {\n    const instance = setupInstance();\n    instance.form = createFormMock();\n    instance.invokeEventCallback = jest.fn();\n    instance.validateFormField = jest.fn();\n\n    const newValue = 'new value';\n    const oldValue = 'old value';\n\n    instance.onFieldChangeEvt('fieldName', newValue, oldValue, false);\n\n    await waitFor(() => {\n      expect(instance.invokeEventCallback).toHaveBeenCalled();\n      const callbackArgs = instance.invokeEventCallback.mock.calls[0];\n      expect(callbackArgs[0]).toBe('onChange');\n      expect(callbackArgs[1][0]).toBeUndefined();\n      expect(callbackArgs[1][1]).toBe(instance);\n      expect(callbackArgs[1][2]).toBe(newValue);\n      expect(callbackArgs[1][3]).toBe(oldValue);\n      expect(instance.validateFormField).toHaveBeenCalled();\n    });\n  });\n\n  test('should not call invokeEventCallback if isDefault is true', async () => {\n    const instance = setupInstance();\n    instance.form = createFormMock();\n    instance.notifyChanges = jest.fn();\n    instance.updateState = jest.fn((_, callback) => callback());\n    instance.invokeEventCallback = jest.fn();\n    instance.validateFormField = jest.fn();\n\n    const newValue = 'new value';\n    const oldValue = 'old value';\n\n    instance.onFieldChangeEvt('fieldName', newValue, oldValue, true);\n\n    expect(instance.notifyChanges).toHaveBeenCalled();\n    expect(instance.updateState).toHaveBeenCalledWith(\n      { props: { datavalue: newValue } },\n      expect.any(Function)\n    );\n    await waitFor(() => {\n      expect(instance.invokeEventCallback).not.toHaveBeenCalled();\n      expect(instance.validateFormField).toHaveBeenCalled();\n    });\n  });\n\n  test('should call updateDataOutput with formkey empty if this.form is true', async () => {\n    const instance = setupInstance();\n    instance.form = createFormMock();\n\n    const newValue = 'new value';\n    const oldValue = 'old value';\n\n    instance.onFieldChangeEvt('fieldName', newValue, oldValue, true);\n    expect(instance.form.updateDataOutput).toHaveBeenCalledWith('', newValue); // Ensure formKey is set correctly\n  });\n\n  test('should call updateDataOutput with formkey not empty if this.form is true', async () => {\n    const instance = setupInstance({ formKey: 'testkey' }); // Pass formKey as part of props\n    instance.form = createFormMock();\n\n    const newValue = 'new value';\n    const oldValue = 'old value';\n\n    instance.onFieldChangeEvt('fieldName', newValue, oldValue, true);\n    expect(instance.form.updateDataOutput).toHaveBeenCalledWith(\n      'testkey',\n      newValue\n    ); // Expecting formKey to be 'testkey'\n  });\n\n  test('observeOn should register observers', () => {\n    const instance = setupInstance();\n    const mockField = { proxy: { name: 'field1' }, notifyForFields: [] };\n    instance.form = { formFields: [mockField] };\n    instance.observeOn(['field1']);\n    expect(mockField.notifyForFields.length).toBe(1);\n    expect(mockField.notifyForFields[0]).toBe(instance);\n  });\n\n  test('notifyChanges should notify observed fields', async () => {\n    const instance = setupInstance();\n    const mockField = {\n      formwidget: { validate: jest.fn() },\n      validateFormField: jest.fn(),\n    };\n    instance.notifyForFields = [mockField];\n    instance.notifyChanges();\n    expect(mockField.formwidget.validate).toHaveBeenCalled();\n    await waitFor(() => {\n      expect(mockField.validateFormField).toHaveBeenCalled();\n    });\n  });\n\n  test('should call the function and store the promise object in arr', () => {\n    const mockPromise = Promise.resolve('mocked value');\n\n    // Create a mock function that returns the mockPromise\n    const mockFunction = jest.fn().mockReturnValue(mockPromise);\n\n    const instance = setupInstance();\n\n    // Set up a mock for formwidget to ensure proxy is defined\n    instance.formwidget = {\n      proxy: {},\n      ...createFormMock().formWidgets['testKey'],\n    }; // Add proxy to formwidget\n\n    // Create a new mock function and bind it to the proxy\n    const boundMockFunction = function () {\n      return mockFunction.apply(this, arguments);\n    }.bind(instance.formwidget.proxy);\n\n    // Set the prototype to ensure it's recognized as a function\n    Object.setPrototypeOf(boundMockFunction, Function.prototype);\n\n    const validators = [boundMockFunction]; // Array with the bound function\n\n    // Call getPromiseList and store the result\n    const result = instance.getPromiseList(validators);\n\n    // Ensure the original mockFunction was called with correct arguments\n    expect(mockFunction).toHaveBeenCalledWith(\n      instance.formwidget.proxy,\n      instance.form\n    );\n\n    // Ensure the promise is in the result\n    expect(result).toContain(mockPromise);\n  });\n\n  test('should directly add promise to arr', () => {\n    const mockPromise = Promise.resolve('direct promise');\n\n    const instance = setupInstance();\n    instance.formwidget = {\n      proxy: {},\n      ...createFormMock().formWidgets['testKey'],\n    }; // Add proxy to formwidget\n    const validators = [mockPromise]; // Array with one promise\n\n    const result = instance.getPromiseList(validators);\n\n    expect(result).toContain(mockPromise); // Ensure the promise is in the result\n  });\n\n  describe('setAsyncValidators', () => {\n    // Mock setup for the component instance\n    const setupInstanceWithAsyncValidators = (validators) => {\n      const instance = setupInstance(); // Assuming setupInstance creates a component instance\n      instance.setInvalidState = jest.fn(); // Mocking setInvalidState\n      instance.getPromiseList = jest.fn(() => validators); // Mock getPromiseList to return validators\n      instance.setAsyncValidators(validators);\n      return instance;\n    };\n\n    test('should set async validation function successfully', () => {\n      const instance = setupInstanceWithAsyncValidators([]);\n\n      // Check that _asyncValidatorFn is set to a function\n      expect(typeof instance._asyncValidatorFn).toBe('function');\n    });\n\n    test('should handle validation success', async () => {\n      const instance = setupInstanceWithAsyncValidators([Promise.resolve()]);\n\n      // Call the async validator function\n      const result = await instance._asyncValidatorFn();\n\n      // Expect the validation to succeed (result should be null)\n      expect(result).toBeNull();\n\n      // Ensure no invalid state was set\n      expect(instance.setInvalidState).not.toHaveBeenCalled();\n    });\n\n    test('should handle validation failure with errorMessage', async () => {\n      const mockError = { errorMessage: 'Test validation error' };\n      const instance = setupInstanceWithAsyncValidators([\n        Promise.reject(mockError),\n      ]);\n\n      // Call the async validator function\n      const result = await instance._asyncValidatorFn();\n\n      // Expect setInvalidState to be called with the correct validation message\n      expect(instance.setInvalidState).toHaveBeenCalledWith(\n        'Test validation error'\n      );\n\n      // Expect the result to be the error object\n      expect(result).toEqual(mockError);\n    });\n\n    test('should handle validation failure without errorMessage property', async () => {\n      const mockError = { fieldError: 'Field validation failed' };\n      const instance = setupInstanceWithAsyncValidators([\n        Promise.reject(mockError),\n      ]);\n\n      // Call the async validator function\n      const result = await instance._asyncValidatorFn();\n\n      // Expect setInvalidState to be called with the first key's value as the validation message\n      expect(instance.setInvalidState).toHaveBeenCalledWith(\n        'Field validation failed'\n      );\n\n      // Expect the result to be the error object\n      expect(result).toEqual(mockError);\n    });\n\n    test('should call setInvalidState with correct validation message on failure', async () => {\n      const mockError = { fieldError: 'Another validation error' };\n      const instance = setupInstanceWithAsyncValidators([\n        Promise.reject(mockError),\n      ]);\n\n      // Call the async validator function\n      await instance._asyncValidatorFn();\n\n      // Check that setInvalidState was called with the correct validation message\n      expect(instance.setInvalidState).toHaveBeenCalledWith(\n        'Another validation error'\n      );\n    });\n  });\n\n  describe('setValidators', () => {\n    const setupInstanceWithSyncValidators = (validators) => {\n      const instance = setupInstance(); // Assuming setupInstance creates a component instance\n      instance.formwidget = { proxy: {}, updateState: jest.fn() }; // Mock formwidget and updateState\n      instance.defaultValidatorMessages = {}; // Mock defaultValidatorMessages\n      instance.setValidators(validators); // Call setValidators with provided validators\n      return instance;\n    };\n\n    test('should handle custom function validators and bind them to formwidget proxy', () => {\n      // Create a mock validator function and ensure it's an instance of Function\n      const mockValidator = jest.fn();\n      Object.setPrototypeOf(mockValidator, Function.prototype);\n\n      const instance = setupInstanceWithSyncValidators([mockValidator]);\n\n      // Ensure the validator is bound to formwidget.proxy and added to _syncValidators\n      expect(instance._syncValidators.length).toBe(1);\n      expect(instance._syncValidators[0]).toBeInstanceOf(Function);\n\n      // Call the bound function to verify the correct binding\n      instance._syncValidators[0]();\n      expect(mockValidator).toHaveBeenCalledWith(\n        instance.formwidget.proxy,\n        instance.form\n      );\n    });\n\n    test('should handle built-in validators like required and update state', () => {\n      const instance = setupInstanceWithSyncValidators([\n        { type: 'required', validator: true, errorMessage: 'Required field' },\n      ]);\n\n      // Ensure defaultValidatorMessages is updated with the errorMessage\n      expect(instance.defaultValidatorMessages['required']).toBe(\n        'Required field'\n      );\n\n      // Check that updateState was called for the built-in validator\n      expect(instance.formwidget.updateState).toHaveBeenCalledWith({\n        props: { required: true },\n      });\n    });\n\n    test('should update state for multiple validators including custom and built-in', () => {\n      const mockValidator = jest.fn();\n      Object.setPrototypeOf(mockValidator, Function.prototype);\n\n      const instance = setupInstanceWithSyncValidators([\n        { type: 'required', validator: true, errorMessage: 'Required field' },\n        mockValidator,\n      ]);\n\n      // Ensure defaultValidatorMessages is updated with the errorMessage for required\n      expect(instance.defaultValidatorMessages['required']).toBe(\n        'Required field'\n      );\n\n      // Check that updateState was called for the built-in validator\n      expect(instance.formwidget.updateState).toHaveBeenCalledWith({\n        props: { required: true },\n      });\n\n      // Ensure the custom validator is bound and pushed to _syncValidators\n      expect(instance._syncValidators.length).toBe(1);\n      expect(instance._syncValidators[0]).toBeInstanceOf(Function);\n    });\n\n    test('should bind multiple custom validators to formwidget proxy', () => {\n      const mockValidator1 = jest.fn();\n      const mockValidator2 = jest.fn();\n      Object.setPrototypeOf(mockValidator1, Function.prototype);\n      Object.setPrototypeOf(mockValidator2, Function.prototype);\n\n      const instance = setupInstanceWithSyncValidators([\n        mockValidator1,\n        mockValidator2,\n      ]);\n\n      // Ensure both custom validators are bound and pushed to _syncValidators\n      expect(instance._syncValidators.length).toBe(2);\n\n      // Call each bound function to verify the correct binding\n      instance._syncValidators[0]();\n      instance._syncValidators[1]();\n\n      expect(mockValidator1).toHaveBeenCalledWith(\n        instance.formwidget.proxy,\n        instance.form\n      );\n      expect(mockValidator2).toHaveBeenCalledWith(\n        instance.formwidget.proxy,\n        instance.form\n      );\n    });\n\n    xit('should handle validators with no type gracefully', () => {\n      const validators = [\n        { validator: true, errorMessage: 'Custom validation message' },\n      ];\n\n      const instance = setupInstanceWithSyncValidators(validators);\n\n      // Since the validator has no type, no defaultValidatorMessages should be set\n      expect(Object.keys(instance.defaultValidatorMessages).length).toBe(0);\n\n      // No built-in state update should be called, only custom validators should be added to _syncValidators\n      expect(instance._syncValidators.length).toBe(0);\n      expect(instance.formwidget.updateState).not.toHaveBeenCalled();\n    });\n  });\n\n  test('setReadOnlyState should update readonly state', () => {\n    const instance = setupInstance();\n    instance.formwidget = { updateState: jest.fn() };\n    instance.setReadOnlyState(false);\n    expect(instance.formwidget.updateState).toHaveBeenCalledWith({\n      props: { readonly: true },\n    });\n  });\n\n  describe('updateFormWidgetDataset', () => {\n    let instance: any;\n    let mockUpdateState: jest.Mock;\n\n    beforeEach(() => {\n      instance = setupInstance(); // Assuming setupInstance creates a component instance\n      mockUpdateState = jest.fn();\n      instance.formwidget = {\n        updateState: mockUpdateState,\n        state: {\n          props: {\n            displayfield: 'existingDisplayField',\n          },\n        },\n      };\n    });\n\n    test('should update formwidget state with given dataset and display field', () => {\n      const response = { data: ['item1', 'item2', 'item3'] };\n      const displayField = 'newDisplayField';\n\n      instance.updateFormWidgetDataset(response, displayField);\n\n      // Check if the updateState was called with the correct props\n      expect(mockUpdateState).toHaveBeenCalledWith({\n        props: {\n          dataset: response.data,\n          datafield: 'All Fields',\n          displayfield: instance.formwidget.state.props.displayfield, // Adjust this to use the existing value\n        },\n      } as WmFormFieldState);\n    });\n\n    test('should use existing displayfield from formwidget if available', () => {\n      const response = { data: ['item1', 'item2', 'item3'] };\n      const existingDisplayField = 'existingDisplayField';\n\n      instance.updateFormWidgetDataset(response, 'newDisplayField');\n\n      expect(mockUpdateState).toHaveBeenCalledWith({\n        props: {\n          dataset: response.data,\n          datafield: 'All Fields',\n          displayfield: existingDisplayField,\n        },\n      } as WmFormFieldState);\n    });\n\n    test('should call updateState with correct props when displayfield is undefined', () => {\n      instance.formwidget.state.props.displayfield = undefined; // Clear existing displayfield\n\n      const response = { data: ['item1', 'item2', 'item3'] };\n      const displayField = 'newDisplayField';\n\n      instance.updateFormWidgetDataset(response, displayField);\n\n      expect(mockUpdateState).toHaveBeenCalledWith({\n        props: {\n          dataset: response.data,\n          datafield: 'All Fields',\n          displayfield: displayField,\n        },\n      } as WmFormFieldState);\n    });\n\n    test('should not modify formwidget state if response data is empty', () => {\n      const response = { data: [] };\n      const displayField = 'newDisplayField';\n\n      instance.updateFormWidgetDataset(response, displayField);\n\n      expect(mockUpdateState).toHaveBeenCalledWith({\n        props: {\n          dataset: response.data,\n          datafield: 'All Fields',\n          displayfield: instance.formwidget.state.props.displayfield,\n        },\n      } as WmFormFieldState);\n    });\n  });\n\n  describe('setInvalidState', () => {\n    let instance: any;\n    let mockUpdateState: jest.Mock;\n\n    beforeEach(() => {\n      instance = setupInstance(); // Assume setupInstance creates the component instance\n      mockUpdateState = jest.fn();\n      instance.updateState = mockUpdateState; // Mocking updateState\n      instance.formwidget = { updateState: jest.fn() }; // Mocking formwidget's updateState\n    });\n\n    test('should set the state to invalid with the provided message', () => {\n      const message = 'Invalid input';\n\n      // Call the setInvalidState method\n      instance.setInvalidState(message);\n\n      // Check that the instance's updateState was called with correct parameters\n      expect(mockUpdateState).toHaveBeenCalledWith({\n        isValid: false,\n        props: {\n          validationmessage: message,\n        },\n      } as WmFormFieldState);\n\n      // Check that the formwidget's updateState was also called with correct parameters\n      expect(instance.formwidget.updateState).toHaveBeenCalledWith({\n        isValid: false,\n        props: {\n          validationmessage: message,\n        },\n      } as WmFormFieldState);\n    });\n\n    test('should set the state to invalid with an empty message', () => {\n      const message = '';\n\n      // Call the setInvalidState method\n      instance.setInvalidState(message);\n\n      // Check that the instance's updateState was called with correct parameters\n      expect(mockUpdateState).toHaveBeenCalledWith({\n        isValid: false,\n        props: {\n          validationmessage: message,\n        },\n      } as WmFormFieldState);\n\n      // Check that the formwidget's updateState was also called with correct parameters\n      expect(instance.formwidget.updateState).toHaveBeenCalledWith({\n        isValid: false,\n        props: {\n          validationmessage: message,\n        },\n      } as WmFormFieldState);\n    });\n\n    xit('should handle non-string messages gracefully', () => {\n      const message = 12345; // Non-string message\n\n      // Call the setInvalidState method\n      instance.setInvalidState(message);\n\n      // Check that the instance's updateState was called with correct parameters\n      expect(mockUpdateState).toHaveBeenCalledWith({\n        isValid: false,\n        props: {\n          validationmessage: String(message), // Ensure it converts to string\n        },\n      } as WmFormFieldState);\n\n      // Check that the formwidget's updateState was also called with correct parameters\n      expect(instance.formwidget.updateState).toHaveBeenCalledWith({\n        isValid: false,\n        props: {\n          validationmessage: String(message), // Ensure it converts to string\n        },\n      } as WmFormFieldState);\n    });\n  });\n\n  describe('onPropertyChange', () => {\n    let instance: any;\n    let mockApplyDefaultValue: jest.Mock;\n    let mockSetPrimaryKey: jest.Mock;\n\n    beforeEach(() => {\n      instance = setupInstance(); // Assume setupInstance creates the component instance\n      instance.form = {\n        applyDefaultValue: jest.fn(), // Mocking form's applyDefaultValue\n        setPrimaryKey: jest.fn(), // Mocking form's setPrimaryKey\n      };\n      mockApplyDefaultValue = instance.form.applyDefaultValue;\n      mockSetPrimaryKey = instance.form.setPrimaryKey;\n      jest.spyOn(PERFORMANCE_LOGGER, 'debug').mockClear(); // Spy on the PERFORMANCE_LOGGER\n    });\n\n    afterEach(() => {\n      jest.clearAllMocks(); // Clear mocks after each test\n    });\n\n    test('should log a change in datavalue', () => {\n      const name = 'datavalue';\n      const oldValue = 'oldValue';\n      const newValue = 'newValue';\n\n      instance.onPropertyChange(name, newValue, oldValue);\n\n      expect(PERFORMANCE_LOGGER.debug).toHaveBeenCalledWith(\n        `form field ${instance.props.name} changed from ${oldValue} to ${newValue}`\n      );\n    });\n\n    test('should not log if datavalue has not changed', () => {\n      const name = 'datavalue';\n      const value = 'sameValue';\n\n      instance.onPropertyChange(name, value, value);\n\n      expect(PERFORMANCE_LOGGER.debug).not.toHaveBeenCalled();\n    });\n\n    test('should apply default value if defaultvalue changes', () => {\n      const name = 'defaultvalue';\n      const oldValue = 'oldDefault';\n      const newValue = 'newDefault';\n\n      instance.onPropertyChange(name, newValue, oldValue);\n\n      expect(mockApplyDefaultValue).toHaveBeenCalledWith(instance);\n    });\n\n    test('should not apply default value if defaultvalue has not changed', () => {\n      const name = 'defaultvalue';\n      const value = 'sameDefault';\n\n      instance.onPropertyChange(name, value, value);\n\n      expect(mockApplyDefaultValue).not.toHaveBeenCalled();\n    });\n\n    test('should set primary key when primary-key is set to true', () => {\n      const name = 'primary-key';\n      const newValue = true;\n\n      instance.onPropertyChange(name, newValue, null);\n\n      expect(mockSetPrimaryKey).toHaveBeenCalledWith(instance.props.name);\n    });\n\n    test('should not set primary key when primary-key is false', () => {\n      const name = 'primary-key';\n      const newValue = false;\n\n      instance.onPropertyChange(name, newValue, true);\n\n      expect(mockSetPrimaryKey).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('validateFormField', () => {\n    let instance: any;\n    let mockUpdateState: jest.Mock;\n    let mockSetInvalidState: jest.Mock;\n\n    beforeEach(() => {\n      instance = setupInstance(); // Assume setupInstance creates the component instance\n      mockUpdateState = jest.fn();\n      instance.updateState = mockUpdateState; // Mocking updateState\n      mockSetInvalidState = jest.fn();\n      instance.setInvalidState = mockSetInvalidState; // Mocking setInvalidState\n      instance.formwidget = {\n        state: {\n          isValid: true,\n          errorType: null,\n        },\n        proxy: {},\n      };\n      instance._syncValidators = [];\n      instance._asyncValidatorFn = jest.fn();\n    });\n\n    afterEach(() => {\n      jest.clearAllMocks(); // Clear mocks after each test\n    });\n\n    test('should set isValid to false and update validation message if formwidget is invalid', () => {\n      instance.formwidget.state.isValid = false;\n      instance.defaultValidatorMessages = { required: 'Field is required' };\n      instance.formwidget.state.errorType = 'required';\n\n      instance.validateFormField();\n\n      // First call should set the validation message\n      expect(mockUpdateState).toHaveBeenCalledWith({\n        props: {\n          validationmessage: 'Field is required',\n        },\n      } as WmFormFieldState);\n\n      // Second call should set isValid to false\n      expect(mockUpdateState).toHaveBeenCalledWith({\n        isValid: false,\n      } as WmFormFieldState);\n\n      // Check that updateState was called twice\n      expect(mockUpdateState).toHaveBeenCalledTimes(2);\n    });\n\n    test('should call setInvalidState with correct message from sync validators', () => {\n      instance.formwidget.state.isValid = false;\n      instance.defaultValidatorMessages = { required: 'Field is required' };\n      instance.formwidget.state.errorType = 'required';\n\n      // Mock a synchronous validator that returns an error message\n      instance._syncValidators.push(() => ({\n        errorMessage: 'Sync validation error',\n      }));\n\n      instance.validateFormField();\n\n      expect(mockSetInvalidState).toHaveBeenCalledWith('Sync validation error');\n    });\n\n    test('should not update validation message if no errorType is found', () => {\n      instance.formwidget.state.isValid = false;\n      instance.formwidget.state.errorType = 'unknown';\n\n      instance.validateFormField();\n\n      expect(mockUpdateState).toHaveBeenCalledWith({\n        isValid: false,\n      } as WmFormFieldState);\n    });\n\n    test('should set isValid to true if formwidget is valid', () => {\n      instance.formwidget.state.isValid = true;\n\n      instance.validateFormField();\n\n      expect(mockUpdateState).toHaveBeenCalledWith({\n        isValid: true,\n      } as WmFormFieldState);\n    });\n\n    test('should call async validator function if it exists', async () => {\n      instance.formwidget.state.isValid = false;\n      instance._asyncValidatorFn = jest.fn().mockResolvedValue(null); // Mock async function\n\n      await instance.validateFormField();\n\n      expect(instance._asyncValidatorFn).toHaveBeenCalled();\n    });\n\n    test('should handle validation messages returned from functions', () => {\n      instance.formwidget.state.isValid = false;\n      instance.defaultValidatorMessages = {\n        required: (proxy: any, form: any) =>\n          `Field is required (from function)`,\n      };\n      instance.formwidget.state.errorType = 'required';\n\n      instance.validateFormField();\n\n      // First call should set the validation message\n      expect(mockUpdateState).toHaveBeenCalledWith({\n        props: {\n          validationmessage: 'Field is required (from function)',\n        },\n      } as WmFormFieldState);\n\n      // Second call should set isValid to false\n      expect(mockUpdateState).toHaveBeenCalledWith({\n        isValid: false,\n      } as WmFormFieldState);\n\n      // Check that updateState was called twice\n      expect(mockUpdateState).toHaveBeenCalledTimes(2);\n    });\n\n    test('should call setInvalidState with message from async validator if validation fails', async () => {\n      instance.formwidget.state.isValid = false;\n\n      // Mock _asyncValidatorFn to reject with an error object containing an errorMessage\n      instance._asyncValidatorFn = jest.fn().mockImplementation(() => {\n        return Promise.resolve().then(() => {\n          // Simulate the async validation error\n          const error = { errorMessage: 'Async validation error' };\n          instance.setInvalidState(error.errorMessage);\n          return error;\n        });\n      });\n      await instance.validateFormField();\n\n      expect(mockSetInvalidState).toHaveBeenCalledWith(\n        'Async validation error'\n      );\n    });\n\n    test('should call validation message function with correct arguments', () => {\n      instance.formwidget.state.isValid = false;\n      instance.formwidget.proxy = { name: 'testField' }; // Mock proxy\n      instance.form = {}; // Ensure form is defined\n      instance.defaultValidatorMessages = {\n        required: (proxy: any, form: any) => `Field ${proxy.name} is required`,\n      };\n      instance.formwidget.state.errorType = 'required';\n\n      // Mock synchronous validator that returns an object with errorMessage as a function\n      instance._syncValidators.push(() => ({\n        errorMessage: (proxy: any, form: any) =>\n          `Field ${proxy.name} is required`,\n      }));\n\n      instance.validateFormField();\n\n      expect(mockSetInvalidState).toHaveBeenCalledWith(\n        'Field testField is required'\n      );\n    });\n  });\n\n  describe('WmFormField renderWidget', () => {\n    const children = [\n      <WmLabel key={'label'} {...commonFields} />,\n      <WmText\n        autofocus={false}\n        autocomplete={false}\n        autotrim={false}\n        hastwowaybinding={false}\n        maxchars={0}\n        type={''}\n        updateon={''}\n        maskchar={''}\n        displayformat={''}\n        key={'text'}\n        {...commonFields}\n      />,\n    ];\n    const childrenWithoutLabel = [\n      <WmText\n        autofocus={false}\n        autocomplete={false}\n        autotrim={false}\n        hastwowaybinding={false}\n        maxchars={0}\n        type={''}\n        updateon={''}\n        maskchar={''}\n        displayformat={''}\n        key={'text'}\n        {...commonFields}\n      />,\n    ];\n    beforeEach(() => {\n      defaultProps = {\n        ...commonFields,\n        children: children,\n        formRef: null,\n        generator: '',\n        onChange: jest.fn(),\n        renderFormFields: jest.fn(() => ({\n          props: {\n            children, // Use the defined children\n          },\n        })),\n        isRelated: null,\n        widget: null,\n        onFieldChange: jest.fn(),\n        formKey: '',\n        dataset: null,\n        displayfield: '',\n        datafield: '',\n        isDataSetBound: false,\n        onValidate: jest.fn(),\n        formScope: jest.fn(),\n        maskchar: '',\n        displayformat: '',\n        defaultvalue: undefined,\n        primaryKey: false,\n      };\n    });\n\n    test('renderWidget should render children with updated props when valid', () => {\n      const { getByText, getByPlaceholderText } = render(\n        <WmFormField {...defaultProps} />\n      );\n      expect(getByText('Label')).toBeTruthy(); // Check WmLabel is rendered\n      expect(getByPlaceholderText('placeholderValue')).toBeTruthy(); // Check placeholder for WmText\n    });\n\n    test('renderWidget should render without WmLabel', () => {\n      const propsWithoutLabel = {\n        ...defaultProps,\n        renderFormFields: jest.fn(() => ({\n          props: {\n            children: childrenWithoutLabel,\n          },\n        })),\n      };\n\n      const { getByPlaceholderText } = render(\n        <WmFormField {...propsWithoutLabel} />\n      );\n      expect(getByPlaceholderText('placeholderValue')).toBeTruthy(); // Check placeholder for WmText\n      expect(screen.queryByText('Label')).toBeNull(); // Ensure WmLabel is not rendered\n    });\n\n    test('renderWidget should render error message when isValid is false', () => {\n      // Set up the initial props with a validation message\n      const props = {\n        ...defaultProps,\n        validationmessage: 'This field is required',\n      };\n\n      // Render the component with the initial props\n      const { rerender, getByTestId, queryByTestId } = render(\n        <WmFormField {...props} />\n      );\n\n      // Initially, isValid is assumed to be true (you can set it directly in props if needed)\n      // Check that the error message is not rendered\n      expect(queryByTestId('widgetName_error_msg')).toBeNull(); // Ensure no error message is rendered initially\n\n      // Now, update the instance state to set isValid to false\n      // Assuming you have access to the instance\n      const instance = setupInstance(props); // Function to get the instance\n      instance.setState({ isValid: false }); // Set isValid to false\n\n      // Rerender the component to reflect the new state\n      rerender(<WmFormField {...props} />);\n\n      // Now check if the error message is rendered\n      expect(screen.getByTestId('widgetName_error_msg')).toBeTruthy(); // Check if the error message is rendered\n      expect(screen.getByTestId('widgetName_error_msg')).toHaveTextContent(\n        'This field is required'\n      ); // Ensure the correct message is shown\n    });\n\n    test('renderWidget should not render error message when isValid is true', () => {\n      const props = {\n        ...defaultProps,\n        validationmessage: 'This field is required',\n      };\n      // Set the instance state to valid\n      render(<WmFormField {...props} />);\n      expect(screen.queryByText('This field is required')).toBeNull(); // Ensure no error message is rendered\n    });\n\n    test('renderWidget should render correctly when no children are present', () => {\n      // Set up the props with no children\n      const props = {\n        ...defaultProps,\n        renderFormFields: jest.fn(() => ({\n          props: {\n            children: [], // No children\n          },\n        })),\n      };\n\n      // Render the component\n      const { UNSAFE_root } = render(<WmFormField {...props} />);\n\n      // Ensure the root is truthy\n      expect(UNSAFE_root).toBeTruthy(); // Ensure it renders correctly without crashing\n\n      // Check that there are no children rendered\n      expect(screen.queryByTestId('widgetName_caption')).toBeNull(); // Check that WmLabel is not rendered\n      expect(screen.queryByTestId('widgetName_i')).toBeNull(); // Check that WmText is not rendered\n\n      // Additionally, you may want to check that the error message is not rendered\n      expect(screen.queryByTestId('widgetName_error_msg')).toBeNull(); // Ensure no error message is rendered\n    });\n\n    test('renderWidget should pass placeholder prop to children when provided', () => {\n      const propsWithPlaceholder = {\n        ...defaultProps,\n        placeholder: 'Enter your text here',\n        renderFormFields: jest.fn(() => ({\n          props: {\n            children: childrenWithoutLabel,\n          },\n        })),\n      };\n\n      const { getByPlaceholderText } = render(\n        <WmFormField {...propsWithPlaceholder} />\n      );\n\n      expect(getByPlaceholderText('Enter your text here')).toBeTruthy(); // Check placeholder is correctly passed\n    });\n\n    xit('renderWidget should not set placeholder prop when it is nil', () => {\n      const propsWithoutPlaceholder = {\n        ...defaultProps,\n        placeholder: null, // Placeholder is nil\n        renderFormFields: jest.fn(() => ({\n          props: {\n            children: [<WmText key={'text'} />],\n          },\n        })),\n      };\n\n      const { getByTestId } = render(\n        <WmFormField {...propsWithoutPlaceholder} />\n      );\n\n      // Check if WmText is rendered\n      const wmText = getByTestId('widgetName_i'); // Assuming this is the testID for WmText\n\n      // Ensure the placeholder prop is not set\n      expect(wmText.props.placeholder).toBeUndefined(); // Check that placeholder is not set\n    });\n  });\n});\n", "wavemaker-rn-runtime/test/components/data/form/form-footer.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport { Text, TouchableOpacity } from 'react-native';\nimport { shallow } from 'enzyme';\nimport renderer from 'react-test-renderer';\nimport WmFormFooter from '@wavemaker/app-rn-runtime/components/data/form/form-footer/form-footer.component';\n\ndescribe('Test FormFooter component', () => {\n    test('Check validity of sample component', () => {\n      const tree = renderer.create(<WmFormFooter name=\"test_FormFooter\"/>).toJSON();\n      expect(tree).toMatchSnapshot();\n    });\n});", "wavemaker-rn-runtime/test/components/data/form/form-body.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport { Text, TouchableOpacity } from 'react-native';\nimport { shallow } from 'enzyme';\nimport renderer from 'react-test-renderer';\nimport WmFormBody from '@wavemaker/app-rn-runtime/components/data/form/form-body/form-body.component';\n\ndescribe('Test FormBody component', () => {\n    test('Check validity of sample component', () => {\n      const tree = renderer.create(<WmFormBody name=\"test_FormBody\"/>).toJSON();\n      expect(tree).toMatchSnapshot();\n    });\n});", "wavemaker-rn-runtime/test/components/data/card/card-footer.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport { Text, TouchableOpacity } from 'react-native';\nimport { shallow } from 'enzyme';\nimport renderer from 'react-test-renderer';\nimport WmCardFooter from '@wavemaker/app-rn-runtime/components/data/card/card-footer/card-footer.component';\n\ndescribe('Test CardFooter component', () => {\n    test('Check validity of sample component', () => {\n      const tree = renderer.create(<WmCardFooter name=\"test_CardFooter\"/>).toJSON();\n      expect(tree).toMatchSnapshot();\n    });\n});", "wavemaker-rn-runtime/test/components/data/card/card-content.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport { Text, TouchableOpacity } from 'react-native';\nimport { shallow } from 'enzyme';\nimport renderer from 'react-test-renderer';\nimport WmCardContent from '@wavemaker/app-rn-runtime/components/data/card/card-content/card-content.component';\n\ndescribe('Test CardContent component', () => {\n    test('Check validity of sample component', () => {\n      const tree = renderer.create(<WmCardContent name=\"test_CardContent\"/>).toJSON();\n      expect(tree).toMatchSnapshot();\n    });\n});", "wavemaker-rn-runtime/test/components/data/list/list-action-template.component.spec.tsx": "import React from 'react';\nimport renderer from 'react-test-renderer';\nimport WmListActionTemplate from '@wavemaker/app-rn-runtime/components/data/list/list-action-template/list-action-template.component';\ndescribe('Test ListActionTemplate component', () => {\n    test('Check validity of sample component', () => {\n      const tree = renderer.create(<WmListActionTemplate name=\"test_ListActionTemplate\"/>).toJSON();\n      expect(tree).toMatchSnapshot();\n    });\n});", "wavemaker-rn-runtime/test/components/data/list/list-template.component.spec.tsx": "import React, { ReactNode } from 'react';\nimport { Text, TouchableOpacity } from 'react-native';\nimport { shallow } from 'enzyme';\nimport renderer from 'react-test-renderer';\nimport WmListTemplate from '@wavemaker/app-rn-runtime/components/data/list/list-template/list-template.component';\n\ndescribe('Test ListTemplate component', () => {\n  test.skip('Check validity of sample component', () => {\n    const tree = renderer\n      .create(<WmListTemplate name=\"test_ListTemplate\" />)\n      .toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n});\n", "wavemaker-rn-runtime/test/components/data/liveform/liveform.component.spec.tsx": "import React, { Children, createRef } from 'react';\nimport { render, fireEvent, waitFor,screen } from '@testing-library/react-native';\nimport WmLiveForm from '@wavemaker/app-rn-runtime/components/data/liveform/liveform.component';\nimport WmFormAction from '@wavemaker/app-rn-runtime/components/data/form/form-action/form-action.component';\nimport WmFormBody from '@wavemaker/app-rn-runtime/components/data/form/form-body/form-body.component';\nimport WmFormFooter from '@wavemaker/app-rn-runtime/components/data/form/form-footer/form-footer.component';\nimport WmGridcolumn from '@wavemaker/app-rn-runtime/components/container/layoutgrid/gridcolumn/gridcolumn.component';\nimport WmGridrow from '@wavemaker/app-rn-runtime/components/container/layoutgrid/gridrow/gridrow.component';\nimport WmLabel from '@wavemaker/app-rn-runtime/components/basic/label/label.component';\nimport WmFormField from '@wavemaker/app-rn-runtime/components/data/form/form-field/form-field.component';\n\nconst mockProps = {\n  onBeforeservicecall: jest.fn(),\n  formSubmit: jest.fn(),\n  formSuccess: jest.fn(),\n  onSuccess: jest.fn(),\n  onError: jest.fn(),\n  children: null\n};\n\nconst mockFormField = ()=> <WmFormField\n    name=\"firstname\"\n    displayname=\"Firstname\"\n    show={true}\n    generator=\"assigned\"\n    type=\"string\"\n    readonly={false}\n    required={false}\n    widget=\"text\"\n    maxchars={255}\n    inputtype=\"text\"\n    formRef=\"EmployeeLiveForm1\"\n    primaryKey={false}\n    isRelated=\"undefined\"              \n    formKey=\"firstname\"\n    renderFormFields={()=><WmLabel caption='firstname'></WmLabel>}\n  ></WmFormField>\n\n\nconst mockResetAction = (ref)=> <WmFormAction\n    show={true}\n    iconclass=\"wi wi-refresh\"\n    title=\"Reset\"\n    action={()=>ref.formreset()}\n    shortcutkey=\"\"\n    disabled={false}\n    widget-type=\"button\"\n    formKey=\"EmployeeLiveForm1\"\n    name=\"EmployeeLiveForm1_button_formAction\"\n    displayName=\"Reset\"\n    updateMode={true}\n    btnClass=\"btn-default\"\n    classname=\"form-reset btn-default\"\n    formAction={()=>ref.formreset()}>\n  </WmFormAction>\n\nconst mockSaveAction = (ref)=> <WmFormAction\n    show={true}\n    iconclass=\"wi wi-done\"\n    title=\"Save\"\n    action={()=>ref.submit()}\n    shortcutkey=\"\"\n    disabled={false}\n    widget-type=\"button\"\n    formKey=\"EmployeeLiveForm1\"\n    name=\"EmployeeLiveForm1_submit_formAction\"\n    displayName=\"Save\"\n    updateMode={true}\n    btnClass=\"btn-primary\"\n    classname=\"form-save btn-success\"\n    formAction={()=>ref.submit()}\n ></WmFormAction>\n\nconst mockCancelAction = (ref)=><WmFormAction\n    show={true}\n    iconclass=\"wi wi-cancel\"\n    title=\"Cancel\"\n    action={()=>ref.cancel()}\n    shortcutkey=\"\"\n    disabled={false}\n    widget-type=\"button\"\n    formKey=\"EmployeeLiveForm1\"\n    name=\"EmployeeLiveForm1_button_formAction\"\n    displayName=\"Cancel\"\n    updateMode={true}\n    btnClass=\"btn-default\"\n    classname=\"form-cancel btn-default\"\n    formAction={()=>ref.cancel()}\n  ></WmFormAction>\n\nconst mockDeleteAction = (ref)=><WmFormAction\n    show={true}\n    iconclass=\"wi wi-trash\"\n    title=\"Delete\"\n    action={()=>ref.delete()}\n    shortcutkey=\"\"\n    disabled={false}\n    widget-type=\"button\"\n    formKey=\"EmployeeLiveForm1\"\n    name=\"EmployeeLiveForm1_button_formAction\"\n    displayName=\"Delete\"\n    updateMode={false}\n    btnClass=\"btn-default\"\n    classname=\"form-delete btn-danger\"\n    formAction={()=>ref.delete()}>\n  </WmFormAction>\n\nconst mockEditAction = (ref)=><WmFormAction\n    show={true}\n    iconclass=\"wi wi-pencil\"\n    title=\"Edit\"\n    action={()=>ref.edit()}\n    shortcutkey=\"\"\n    disabled={false}\n    widget-type=\"button\"\n    formKey=\"EmployeeLiveForm1\"\n    name=\"EmployeeLiveForm1_button_formAction\"\n    displayName=\"Edit\"\n    updateMode={false}\n    btnClass=\"btn-default\"\n    classname=\"form-update btn-info\"\n    formAction={()=>ref.edit()}>\n  </WmFormAction>\n\nconst mockNewAction = (ref)=><WmFormAction\n    show={true}\n    iconclass=\"wi wi-plus\"\n    title=\"New\"\n    action={()=>ref.new()}\n    shortcutkey=\"\"\n    disabled={false}\n    widget-type=\"button\"\n    formKey=\"EmployeeLiveForm1\"\n    name=\"EmployeeLiveForm1_button_formAction\"\n    displayName=\"New\"\n    updateMode={false}\n    btnClass=\"btn-default\"\n    classname=\"form-new btn-success\"\n    formAction={()=>ref.new()}>\n  </WmFormAction> \n\nconst renderComponent = (props = {}, ref={}) => \n  render(\n    <WmLiveForm\n        errormessage=\"\"\n        title=\"Employee Info\"\n        iconclass=\"wi wi-edit\"\n        formlayout=\"inline\"\n        defaultmode=\"Edit\"\n        captionalign=\"left\"\n        captionposition=\"top\"\n        name=\"EmployeeLiveForm1\"\n        ref={ref}\n        {...props}\n      >\n        <WmFormBody name=\"wm_form_body_e9ahh092j0\">\n            <WmGridrow name=\"gridrow2\" >\n              <WmGridcolumn\n                columnwidth={12}\n                name=\"gridcolumn2\"\n                xscolumnwidth={12}\n                >\n                {mockFormField()}\n              </WmGridcolumn>\n            </WmGridrow>\n        </WmFormBody>\n        <WmFormFooter name=\"wm_form_footer_i4ichf160a\">\n          {mockResetAction(ref)}\n          {mockCancelAction(ref)}\n          {mockSaveAction(ref)}\n          {mockDeleteAction(ref)}\n          {mockEditAction(ref)}\n          {mockNewAction(ref)}\n        </WmFormFooter>\n      </WmLiveForm>\n  )\n  \ndescribe('WmLiveFrom Component', ()=>{\n  const Live_Operations = {\n    INSERT : 'insert',\n    UPDATE : 'update',\n    DELETE : 'delete',\n    READ : 'read'\n  }\n  const ref: any = createRef()\n\n  test('check for render wmliveform correctly', ()=>{\n    const comp = renderComponent({}, null)\n    expect(comp).toBeDefined()\n    expect(comp).not.toBeNull();\n    expect(comp).toMatchSnapshot();\n  })\n\n  test('should return INSERT if no primary key is set', () => {\n    renderComponent({...mockProps}, ref)\n    const result = ref.current.findOperationType();\n    expect(result).toBe(Live_Operations.INSERT);\n    \n  });\n\n  test('should return UPDATE if there is a single primary key with value', () => {\n    renderComponent(mockProps, ref)\n    ref.current.primaryKey = ['id']\n    ref.current.setState({\n      props: {\n        formdata: { id: 123 } \n      }\n    });\n    const result = ref.current.findOperationType();\n    expect(result).toBe(Live_Operations.UPDATE);\n  });\n\n  test('should return INSERT if the primary key is set but form data has no primary key value', () => {\n    renderComponent(mockProps, ref)\n    ref.current.primaryKey = ['id']\n    ref.current.setState({\n      props: {\n        formdata: { id: null } \n      }\n    });\n\n    const result = ref.current.findOperationType();\n    expect(result).toBe(Live_Operations.INSERT);\n  });\n\n  test('should return UPDATE if there are multiple primary keys with at least one value', () => {\n    renderComponent(mockProps, ref)\n    ref.current.primaryKey =['id', 'otherId']\n    ref.current.setState({\n      props: {\n        formdata: { id: 123, otherId: null}\n      }\n    });\n\n    const result = ref.current.findOperationType();\n    expect(result).toBe(Live_Operations.UPDATE);\n  });\n\n  test('should return UPDATE if the primary key array is empty but form data has some value', () => {\n    renderComponent(mockProps,ref)\n    ref.current.primaryKey = [];\n    ref.current.setState({\n      props: {\n        formdata: { name: 'user1' }\n      }\n    });\n\n    const result = ref.current.findOperationType();\n    expect(result).toBe(Live_Operations.UPDATE);\n  });\n\n  test('should return INSERT if primary key is empty and form data is also empty', () => {\n    renderComponent(mockProps, ref)\n    ref.current.primaryKey = [];\n    ref.current.setState({\n      props: {\n        formdata: {}\n      }\n    });\n\n    const result = ref.current.findOperationType();\n    expect(result).toBe(Live_Operations.INSERT);\n  });\n\n  test('should return UPDATE if multiple primary keys with values in form data', () => {\n    renderComponent(mockProps, ref)\n    ref.current.primaryKey = ['id', 'otherId'];\n    ref.current.setState({\n      props: {\n        formdata: { id: 1, secondaryId: 2 }\n      }\n    });\n\n    const result = ref.current.findOperationType();\n    expect(result).toBe(Live_Operations.UPDATE);\n  });\n\n\n  test('check for handleSubmit with form err validations', async() => {\n    const findOperationTypeMock = jest.spyOn(WmLiveForm.prototype, 'findOperationType').mockReturnValue('insert');\n    const validateFieldsMock = jest.spyOn(WmLiveForm.prototype, 'validateFieldsOnSubmit').mockReturnValue(false);\n    const eventMock = { preventDefault: jest.fn() };\n\n    renderComponent(mockProps, ref)\n\n    ref.current.handleSubmit(eventMock)\n\n    expect(findOperationTypeMock).toHaveBeenCalled();\n    expect(validateFieldsMock).toHaveBeenCalled();\n    expect(ref.current.handleSubmit(eventMock)).toBe(false)\n  })\n\n  test('check for handleSubmit with no form validation', async() => {\n    const findOperationTypeMock = jest.spyOn(WmLiveForm.prototype, 'findOperationType').mockReturnValue('insert');\n    const validateFieldsMock = jest.spyOn(WmLiveForm.prototype, 'validateFieldsOnSubmit').mockReturnValue(true);\n    const eventMock = { preventDefault: jest.fn() };\n    const formSubmitMock = jest.fn();\n    const onBeforeServiceCallMock = jest.fn();\n\n    const props = {\n      formSubmit: formSubmitMock,\n      onBeforeservicecall: onBeforeServiceCallMock,\n    };\n\n    const tree = renderComponent({...mockProps, ...props}, ref)\n    expect(tree).toMatchSnapshot()\n\n    ref.current.handleSubmit(eventMock)\n\n    expect(findOperationTypeMock).toHaveBeenCalled();\n    expect(validateFieldsMock).toHaveBeenCalled();\n    expect(onBeforeServiceCallMock).toHaveBeenCalled();\n    expect(formSubmitMock).toHaveBeenCalled();\n\n  })\n\n  test('should call formSubmit with correct arguments and handle success and error callbacks', () => {\n    const eventMock = { preventDefault: jest.fn() };\n    const formSubmitMock = jest.fn((input, operationType, onSuccess, onError) => {\n      onSuccess({ data: 'mock success data' });\n      onError({ error: 'mock error data' });\n    });\n  \n    const onBeforeServiceCallMock = jest.fn();\n    const onResultCbMock = jest.spyOn(WmLiveForm.prototype, 'onResultCb');\n    const invokeEventCallbackMock = jest.fn();\n    const toggleMessageMock = jest.fn();\n\n    const operationTypeMock = 'insert';\n    const props = {\n      formSubmit: formSubmitMock,\n      onBeforeservicecall: onBeforeServiceCallMock,\n    };\n  \n    renderComponent({...mockProps, ...props}, ref)\n    expect(ref.current).not.toBeNull()\n\n    ref.current.formdataoutput = { field1: 'value1', field2: 'value2' };\n    ref.current.handleSubmit(eventMock);\n  \n    expect(eventMock.preventDefault).toHaveBeenCalled();\n    // Check if formSubmit is called with correct arguments\n    expect(formSubmitMock).toHaveBeenCalledWith(\n      { inputFields: ref.current.formdataoutput },\n      'insert',\n      expect.any(Function), \n      expect.any(Function)  \n    );\n  \n    // Check if success callback was called correctly\n    expect(onResultCbMock).toHaveBeenCalledWith({ data: 'mock success data' }, 'success', operationTypeMock);\n  \n    // Check if error callback was called correctly\n    expect(onResultCbMock).toHaveBeenCalledWith({ error: 'mock error data' }, '', operationTypeMock);\n  \n    // Cleanup mocks after test\n    onResultCbMock.mockRestore();\n\n    const toggleMessageMockProps = {\n      formSuccess: jest.fn(), \n      onSuccess: null, \n      onError: null\n    };\n\n    renderComponent({...mockProps, ...toggleMessageMockProps}, ref)\n\n    ref.current.invokeEventCallback = invokeEventCallbackMock;\n    ref.current.toggleMessage = toggleMessageMock;\n\n    const success_response = { data: 'mock success data' };\n    const err_response = 'An error occured. Please try again!';\n\n    const success_status = 'success';\n    const err_status = '';\n    const operationType = 'insert';\n\n    ref.current.onResultCb(success_response, success_status, operationType);\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith('onSuccess', [null, operationType, success_response]);\n    expect(toggleMessageMock).toHaveBeenCalledWith('success', 'Data posted successfully');\n\n    ref.current.onResultCb(err_response, err_status, operationType);\n    expect(invokeEventCallbackMock).toHaveBeenCalledWith('onError', [null, operationType, err_response]);\n    expect(toggleMessageMock).toHaveBeenCalledWith('error', 'An error occured. Please try again!');\n\n  });\n  \n});\n\n", "wavemaker-rn-runtime/typings/fonts.d.ts": "declare module '*.woff';\ndeclare module '*.woff2';\ndeclare module '*.ttf';\ndeclare module '*.eot';", "wavemaker-rn-runtime/scripts/wavicon-generator.js": "const fs = require('fs-extra');\nconst handlebars = require('handlebars');\n\nconst WAVICON_STYLESHEET = '../../wavemaker-studio-frontend/wavemaker-app-runtime-angularjs/components/wavicon/css/wavicon.css';\nconst WAVICON_TTF = '../../wavemaker-studio-frontend/wavemaker-app-runtime-angularjs/components/wavicon/fonts/wavicon.ttf';\nconst WM_SL_L_STYLESHEET = '../../wavemaker-studio-frontend/wavemaker-app-runtime-angularjs/styles/wm-streamline-icon/light/css/wm-streamline-light-icon.css';\nconst WM_SL_L_TTF = '../../wavemaker-studio-frontend/wavemaker-app-runtime-angularjs/styles/wm-streamline-icon/light/fonts/wm-streamline-light-icon.ttf';\nconst WM_SL_R_STYLESHEET = '../../wavemaker-studio-frontend/wavemaker-app-runtime-angularjs/styles/wm-streamline-icon/regular/css/wm-streamline-regular-icon.css';\nconst WM_SL_R_TTF = '../../wavemaker-studio-frontend/wavemaker-app-runtime-angularjs/styles/wm-streamline-icon/regular/fonts/wm-streamline-regular-icon.ttf';\nconst TEMPLATE = handlebars.compile(`\n/*******************************************************\n * Don't make any changes.\n * This is a generated file.\n * See wavicon.generator.js\n ********************************************************/\n\nimport font from './{{iconSetName}}.ttf';\nimport createIconSet from '@expo/vector-icons/build/createIconSet';\n\nexport const glyphMap: any = {{{iconset}}};\n\nexport default createIconSet(glyphMap, '{{iconSetName}}', font);\n`);\n\n\nfunction generate(iconSetName, styleSheet, iconSetPrefix, fontFile) {\n    const text = fs.readFileSync(styleSheet, 'utf-8');\n    const fontFolder = `src/components/basic/icon/${iconSetName}`;\n    const obj = JSON.parse('{' +  text.substring(text.indexOf(iconSetPrefix))\n            .replace(new RegExp(iconSetPrefix, 'g'), ',\"')\n            .replace(/:before(\\s)*\\{\\s*content/g,'\"')\n            .replace(/;\\s*}\\s*/g, '')\n            .replace(',', '')\n            .replace(/\\\\f/g,'\\\\uF') + '}');\n    fs.mkdirpSync(fontFolder);\n    fs.writeFileSync(`${fontFolder}/${iconSetName}.component.tsx`, TEMPLATE({\n        iconset: JSON.stringify(obj, null, 4),\n        iconSetName: iconSetName\n    }));\n    fs.copyFileSync(fontFile, `${fontFolder}/${iconSetName}.ttf`,);\n    console.log(`generated ${iconSetName}`);\n}\n\ngenerate('wavicon', WAVICON_STYLESHEET, '.wi-', WAVICON_TTF);\ngenerate('streamline-light-icon', WM_SL_L_STYLESHEET, '.wm-sl-l.sl-', WM_SL_L_TTF);\ngenerate('streamline-regular-icon', WM_SL_R_STYLESHEET, '.wm-sl-r.sl-', WM_SL_R_TTF);", "wavemaker-rn-runtime/scripts/bootstrap.js": "const path = require('path');\nconst child_process = require('child_process');\n\nconst root = path.resolve(__dirname, '..');\nconst args = process.argv.slice(2);\nconst options = {\n  cwd: process.cwd(),\n  env: process.env,\n  stdio: 'inherit',\n  encoding: 'utf-8',\n};\n\nlet result;\n\nif (process.cwd() !== root || args.length) {\n  // We're not in the root of the project, or additional arguments were passed\n  // In this case, forward the command to `yarn`\n  result = child_process.spawnSync('yarn', args, options);\n} else {\n  // If `yarn` is run without arguments, perform bootstrap\n  result = child_process.spawnSync('yarn', ['bootstrap'], options);\n}\n\nprocess.exitCode = result.status;\n", "wavemaker-rn-runtime/scripts/build.js": "const fs = require('fs-extra');\nconst projectDir = '.';\nconst yargs = require('yargs');\nconst { hideBin } = require('yargs/helpers');\nconst tar = require('tar');\nconst execa = require('execa');\nconst path = require(\"path\");\n\nasync function createPackageLock(path) {\n  await execa('npm', ['install', '--package-lock-only'], {\n    'cwd': path\n  });\n  const expoPackageJSON = fs.readJSONSync(`${path}/package-lock.json`);\n  Object.values(expoPackageJSON.packages || {}).map(v => {\n    delete v.resolved;\n  });\n  fs.writeJSONSync(`${path}/package-lock.json`, expoPackageJSON, {\n    spaces: 4\n  });\n  fs.writeJSONSync(`${path}/npm-shrinkwrap.json`, expoPackageJSON, {\n    spaces: 4\n  });\n}\n\nasync function updatePackageVersion(packagePath, key, version) {\n    let content = fs.readFileSync(packagePath, 'utf8');\n    content = content.replace(new RegExp(`\"${key}\"\\\\s*:\\\\s*\"[^\"]*\"`), `\"${key}\": \"${version}\"`);\n    fs.writeFileSync(packagePath, content);\n}\n\nasync function postBuild(runtimeVersion) {\n    fs.copySync(`${projectDir}/lib/module`, `${projectDir}/dist/module`);\n    fs.copySync(`${projectDir}/package.json`, `${projectDir}/dist/module/package.json`);\n    const packageData = fs.readJSONSync(`${projectDir}/package.json`, {\n        encoding: \"utf8\"\n    });\n    packageData.main = 'index';\n    packageData.module = 'index';\n    //there is this dependency already present in the dependencies. why again in devDependencies?\n    // packageData['devDependencies']['@wavemaker/variables'] = runtimeVersion;\n    packageData.exports = {\n      \"./\": \"./\"\n    };\n    delete packageData['files'];\n    fs.writeFileSync(`${projectDir}/dist/module/package.json`, JSON.stringify(packageData, null, 2))\n    await updatePackageVersion(`${projectDir}/dist/module/package.json`, 'version', runtimeVersion);\n    console.log('Post Build successful!!!');\n}\n\nasync function prepareNpmPackages(runtimeVersion) {\n  let tarballName = `wavemaker-app-rn-runtime-${runtimeVersion}.tgz`\n  fs.copySync(`${projectDir}/dist/module`, `${projectDir}/dist/npm-packages/package`, {\n    filter: p => !p.startsWith('/node_modules/')\n  });\n  // generate package lock\n  await createPackageLock(`${projectDir}/dist/npm-packages/package`);\n  await execa('tar', ['-czf', `dist/npm-packages/${tarballName}`, '-C', 'dist/npm-packages', 'package'], {\n    'cwd': `${projectDir}`\n  });\n  let tarballPath = path.join(__dirname, `../dist/npm-packages/${tarballName}`)\n  const {stdout} = await execa('node', ['../process-npm-package-stats.js', `--path=${tarballPath}`, '--packageName=@wavemaker/app-rn-runtime', `--publishVersion=${runtimeVersion}`]);\n  console.log(stdout);\n}\n\nasync function pushToLocalRepo() {\n    fs.writeFileSync(`${projectDir}/dist/new-build`, '' + Date.now);\n    await execa('yalc', ['publish' , '--no-sig', '--push'], {\n        'cwd': `${projectDir}/dist/module`\n    });\n}\n\nyargs(hideBin(process.argv)).command('post-build',\n    'to run post processing after project build',\n    (yargs) => {\n        yargs.option('runtimeVersion', {\n            describe: 'version number',\n            type: 'string',\n            default: '1.0.0-dev'\n        }).option('production', {\n            describe: 'to perform a production build',\n            type: 'boolean',\n            default: false\n        });\n    }, (argv) => {\n        postBuild(argv.runtimeVersion).then(() => {\n            if (argv.production) {\n                return prepareNpmPackages(argv.runtimeVersion);\n            } else {\n                return pushToLocalRepo();\n            }\n        });\n    }).showHelpOnFail().argv;\n", "wavemaker-rn-runtime/scripts/widget.js": "const fs = require('fs-extra');\nconst yargs = require('yargs');\nconst { hideBin } = require('yargs/helpers');\nconst handlebars = require('handlebars');\nconst { capitalize, camelCase } = require('lodash');\nconst projectDir = '.';\n\nconst loadTemplate = (templatePath) => {\n    const template = fs.readFileSync(__dirname + '/' + templatePath, 'utf8');\n    return handlebars.compile(template);\n};\n\nconst WIDGET_COMPONENT_TEMPLATE = loadTemplate('./widget-template/widget.component.tsx.hbs');\nconst WIDGET_PROPS_TEMPLATE = loadTemplate('./widget-template/widget.props.ts.hbs');\nconst WIDGET_STYLES_TEMPLATE = loadTemplate('./widget-template/widget.styles.ts.hbs');\nconst WIDGET_STYLE_DEF_TEMPLATE = loadTemplate('./widget-template/widget.styledef.ts.hbs');\nconst WIDGET_TRANSFORMER_TEMPLATE = loadTemplate('./widget-template/widget.transformer.ts.hbs');\nconst WIDGET_SPEC_TEMPLATE = loadTemplate('./widget-template/widget.component.spec.tsx.hbs');\n\nfunction writeFile(path, content) {\n    const parent = path.substring(0, path.lastIndexOf('/'));\n    if (!fs.existsSync(parent)) {\n        fs.mkdirSync(parent, {recursive : true});\n    }\n    fs.writeFileSync(path, content);\n};\n\nfunction writeStyleDefinition(componentName, group) {\n    const styledefProviderPath = `${__dirname}/../../wavemaker-rn-codegen/src/theme/components/style-definition.provider.ts`;\n    const cComponentName = capitalize(camelCase(componentName));\n    const styledefProvider = fs.readFileSync(styledefProviderPath, 'utf-8')\n        .replace('//ADD_STYLE_IMPORT', \n            `import ${cComponentName}StyleDef from './${group}/${componentName}.styledef';\\n//ADD_STYLE_IMPORT`)\n        .replace('//ADD_STYLE_DEF', \n            `['${group}', ${cComponentName}StyleDef.getStyleDefs()],\\n//ADD_STYLE_DEF`);\n    const def = WIDGET_STYLE_DEF_TEMPLATE({\n        name: componentName,\n        baseStylePath: group.split('/').map((s, i) => '../').join('')\n    });\n    writeFile(`${__dirname}/../../wavemaker-rn-codegen/src/theme/components/${group}/${componentName}.styledef.ts`, def);\n    writeFile(styledefProviderPath, styledefProvider);\n    return styledefProvider;\n}\n\nyargs(hideBin(process.argv)).command('generate',\n    'generates a wavemaker widget',\n    (yargs) => {\n        yargs.option('name', {\n            'describe': 'name of the widget',\n            'requiresArg': true\n        });\n        yargs.positional('group', {\n            'describe': 'group to which this widget belongs',\n            'requiresArg': true\n        });\n    }, (argv) => {\n        var cName = argv.name.replace(/-([a-z])/g, g => g[1].toUpperCase());\n        cName = cName[0].toUpperCase() + cName.slice(1);\n        var info = {\n            widget: {\n                name: {\n                    camelcase: cName,\n                    hyphenated: argv.name\n                },\n                group: argv.group\n            }\n        };\n        var folder = `${__dirname}/../src/components/${argv.group}/${argv.name}`;\n        var specFolder = `${__dirname}/../test/components/${argv.group}`;\n        var codegen = `${__dirname}/../../wavemaker-rn-codegen/src/transpile/components/${argv.group}`;\n        var registerFile = `${__dirname}/../../wavemaker-rn-codegen/src/transpile/components/transform-register.ts`;\n        writeFile(`${folder}/${argv.name}.component.tsx`, WIDGET_COMPONENT_TEMPLATE(info));\n        writeFile(`${folder}/${argv.name}.props.ts`,WIDGET_PROPS_TEMPLATE(info));\n        writeFile(`${folder}/${argv.name}.styles.ts`,WIDGET_STYLES_TEMPLATE(info));\n        writeFile(`${codegen}/${argv.name}.transformer.ts`,WIDGET_TRANSFORMER_TEMPLATE(info));\n        writeFile(`${specFolder}/${argv.name}.component.spec.tsx`,WIDGET_SPEC_TEMPLATE(info));\n        var content = fs.readFileSync(registerFile, 'utf-8')\n            .replace('//#IMPORT_STATEMENT', \n                `import ${info.widget.name.camelcase}Transformer from './${info.widget.group}/${info.widget.name.hyphenated}.transformer';\\n//#IMPORT_STATEMENT`)\n            .replace('//#REGISTER_COMPONENT', \n                `registerTransformer('wm-${info.widget.name.hyphenated}', ${info.widget.name.camelcase}Transformer);\\n\\t//#REGISTER_COMPONENT`);\n        writeFile(registerFile, content);\n        writeStyleDefinition(argv.name, argv.group);\n    }).showHelpOnFail().argv;", "wavemaker-rn-runtime/scripts/combineCoverageHtmlCSS.js": "const fs = require('fs');\nconst path = require('path');\n\nconst htmlPath = 'dist/reports/coverage/lcov-report/index.html';\nconst css1Path = 'dist/reports/coverage/lcov-report/base.css';\nconst css2Path = 'dist/reports/coverage/lcov-report/prettify.css';\n\ntry {\n    // Read HTML file\n    const htmlContent = fs.readFileSync(htmlPath, 'utf-8');\n\n    // Read CSS files\n    const css1Content = fs.readFileSync(css1Path, 'utf-8');\n    const css2Content = fs.readFileSync(css2Path, 'utf-8');\n\n    // Combine CSS content\n    const combinedCss = `<style>${css1Content}\\n${css2Content}</style>`;\n\n    // Insert combined CSS into HTML\n    const finalHtmlContent = htmlContent.replace(/<\\/head>/, `${combinedCss}\\n</head>`);\n\n    // Write the combined HTML to a new file\n    const outputPath = path.join('dist/reports/coverage/lcov-report', 'coverage-report.html');\n    fs.writeFileSync(outputPath, finalHtmlContent, 'utf-8');\n\n    console.log('HTML and CSS combined successfully!');\n} catch (error) {\n    console.error('An error occurred while combining HTML and CSS:');\n    console.error(error.message);\n    \n    if (error.code === 'ENOENT') {\n        console.error('File not found. Please check the file paths and try again.');\n    } else if (error.code === 'EACCES') {\n        console.error('Permission denied. Please check your file permissions.');\n    } else {\n        console.error('Unexpected error:', error);\n    }\n}\n", "wavemaker-rn-runtime/src/index.ts": "export * from '@wavemaker/app-rn-runtime/actions/index';", "wavemaker-rn-runtime/src/core/fixed-view.component.tsx": "\nimport React from \"react\";\nimport { View, ViewStyle, Animated } from \"react-native\";\nimport { Theme, ThemeProvider } from \"../styles/theme\";\n\nconst FixedViewContext = React.createContext<FixedViewContainer>(null as any);\n\nexport interface FixedViewProps {\n    style?: ViewStyle,\n    show?: boolean;\n    theme: Theme;\n    usememo?: boolean;\n    children?: any;\n    animated?: boolean;\n}\n\nexport class FixedView extends React.Component<FixedViewProps> {\n    static defaultProps = {\n        show: true, \n        animated: false\n    };\n    static counter = Date.now();\n    container: FixedViewContainer = null as any;\n    cachedComponent: React.ReactNode;\n    id = FixedView.counter++;\n\n    constructor(props: FixedViewProps) {\n        super(props);\n    }\n\n    componentWillUnmount() {\n        this.container.remove(this);\n    }\n\n    render() {\n        const WrapperView = this.props.animated ? Animated.View : View\n        this.cachedComponent = (this.props.usememo === true && this.cachedComponent ) || (<FixedViewContext.Consumer>\n            {(container) => {\n                this.container = container;\n                if (this.props.show) {\n                    container.add(this, (\n                        <ThemeProvider value={this.props.theme} key={this.id}>\n                            <WrapperView style={[\n                                {position: 'absolute'},\n                                this.props.style]}>\n                                {this.props.children}\n                            </WrapperView>\n                        </ThemeProvider>\n                    ));\n                } else {\n                    container.remove(this);\n                }\n                return <></>;\n            }}\n        </FixedViewContext.Consumer>);\n        return this.cachedComponent;\n    }\n}\n\nexport class FixedViewContainer extends React.Component {\n    children: Map<FixedView, React.ReactNode> = new Map();\n    id = 0;\n\n    add(c: FixedView, n : React.ReactNode) {\n        this.children.set(c, n);\n        setTimeout(() => this.setState({id: ++this.id}));\n    }\n\n    remove(c: FixedView) {\n        this.children.delete(c);\n        setTimeout(() => this.setState({id: ++this.id}));\n    }\n\n    render() {\n        return (\n            <FixedViewContext.Provider value={this}>\n                {(this.props as any).children}\n                {Array.from(this.children.values())}\n            </FixedViewContext.Provider>\n        ) ;\n    }\n};", "wavemaker-rn-runtime/src/core/toast.service.ts": "import React from 'react';\n\nexport interface ToastOptions {\n    elevationIndex: number;\n    content?: React.ReactNode;\n    onClick?: () => void;\n    onClose?: () => void;\n    text: string;\n    type: 'success' | 'warning' | 'error' | 'info' | 'loading';\n    placement: string;\n    duration?: number;\n    name: string;\n    styles: any;\n    hideOnClick?: boolean;\n    showclosebutton?: boolean;\n    closeiconclass?: string;\n    closeToast?: () => void;\n}\n\nexport interface ToastService {\n    showToast: (options: ToastOptions) => void;\n    hideToast: (options: ToastOptions) => void;\n}\n\nconst ToastContext = React.createContext<ToastService>(null as any);\n\nexport const ToastProvider = ToastContext.Provider;\nexport const ToastConsumer = ToastContext.Consumer;\n", "wavemaker-rn-runtime/src/core/navigation.service.ts": "import React from 'react';\n\nexport default interface NavigationService {\n    goToPage: (pageName: string, params: any) => Promise<void>;\n    goBack: (pageName: string, params: any) => Promise<void>;\n    openUrl: (url: string, params?: any) => Promise<void>;\n}\n\nconst NavigationContext = React.createContext<NavigationService>(null as any);\n\nexport const NavigationServiceProvider = NavigationContext.Provider;\nexport const NavigationServiceConsumer = NavigationContext.Consumer;", "wavemaker-rn-runtime/src/core/if.component.tsx": "import React from 'react';\nimport { StyleSheet, View, ViewStyle } from 'react-native';\n\nexport enum HideMode {\n    DONOT_ADD_TO_DOM = 0,\n    ADD_TO_DOM = 1\n}\n\nconst styles = StyleSheet.create({\n    hidden: {\n        width: 0,\n        height: 0,\n        transform: [{ scale: 0 }] \n    },\n    visible: {}\n});\n\nexport const WmIf = ({condition = true, hideMode = 0, style, children} : {\n    condition: boolean,\n    hideMode: HideMode,\n    style: ViewStyle,\n    children: any}) => {\n    if (hideMode === HideMode.ADD_TO_DOM) {\n        React.Children.map\n        return (<View style={[condition? styles.visible: styles.hidden, style]}>{children}</View>);\n    } else if (condition) {\n        return children;\n    } else {\n        return null;\n    }\n};", "wavemaker-rn-runtime/src/core/sticky-container.component.tsx": "\nimport React, { Component } from \"react\";\nimport { ViewStyle, Animated, Easing, View, Platform} from \"react-native\";\nimport { SafeAreaInsetsContext } from \"react-native-safe-area-context\";\nimport { Theme, ThemeProvider } from \"@wavemaker/app-rn-runtime/styles/theme\";\nimport { BaseComponent } from \"./base.component\";\nimport injector from '@wavemaker/app-rn-runtime/core/injector';\nimport AppConfig from '@wavemaker/app-rn-runtime/core/AppConfig';\n\nconst StickyViewContext = React.createContext<StickyViewContainer>(null as any);\n\nexport interface StickyViewProps {\n    style?: ViewStyle,\n    theme: Theme;\n    children?: any;\n    slide?: boolean;\n    component: BaseComponent<any, any, any>;\n    onVisibilityChange?: (visible: boolean) => void;\n}\n\nexport class StickyViewState {\n    isStickyVisible = false;\n}\n\nexport class StickyView extends Component<StickyViewProps, StickyViewState, any> {\n    static defaultProps = {\n        slide: false\n    };\n    static counter = Date.now();\n    container?: StickyViewContainer = null as any;\n    cachedComponent: React.ReactNode;\n    id = StickyView.counter++;\n    destroyScrollListner: Function = null as any;\n    insets: any = null;\n    refScrollPosition = 0;\n    lastScrollDirection = 1;\n    appConfig = injector.get<AppConfig>('APP_CONFIG');\n    scrolled: boolean = false;\n\n    constructor(props: StickyViewProps) {\n        super(props);\n        this.state = new StickyViewState();\n        this.listenScrollEvent();\n    }\n\n    componentWillUnmount() {\n        this.container?.remove(this);\n        this.destroyScrollListner && this.destroyScrollListner();\n    }\n\n    listenScrollEvent(): void {\n        this.destroyScrollListner && this.destroyScrollListner();\n        const component = this.props.component;\n        let yPosition: number;\n        this.destroyScrollListner = component.subscribe('scroll', (e: any) => {\n            const height = component.getLayout()?.height;\n            const topInsetsInYposition = Platform.OS == 'ios' ? this.insets?.top || 0 : 0;\n            yPosition = (yPosition || yPosition == 0) ? yPosition : component?.getLayout()?.py - topInsetsInYposition;\n            const scrollPosition = e.nativeEvent.contentOffset.y;\n            let isStickyVisible = false ;\n\n            const {containerHeight = 0, hiddenHeight = 0} = this.container || {}\n            const containerHeightVal = Math.abs(containerHeight + hiddenHeight) ;\n            if(!this.scrolled) this.scrolled = true;\n            \n            if (e.scrollDirection) {\n                if (this.lastScrollDirection !== e.scrollDirection) {\n                    this.refScrollPosition = scrollPosition;\n                }\n                this.lastScrollDirection = e.scrollDirection;\n            }\n\n            // based on scrollDirection checking for stickyVisibility\n            if(e.scrollDirection <= 0){\n                isStickyVisible = scrollPosition > 10 // scroll threshold value of 10\n                    && ((scrollPosition + containerHeightVal + this.appConfig.pageScrollTopThreshold ) >= (yPosition + height));\n            } else {\n                isStickyVisible =  ((scrollPosition +  this.appConfig.pageScrollTopThreshold) >= \n                    (yPosition + (this.props.slide ? height: 0)));\n            }\n\n            if (this.state.isStickyVisible !== isStickyVisible) {\n                this.setState({ \n                    isStickyVisible : isStickyVisible\n                }, () => {\n                    if (isStickyVisible && this.props.slide) {\n                        this.container?.slideBy(-1 * height);\n                    } else {\n                        this.container?.slideBy(this.refScrollPosition - scrollPosition);\n                    }\n                })\n            } else {\n                this.container?.slideBy(this.refScrollPosition - scrollPosition);\n            }\n        })\n    }\n\n    render() {\n        return (\n            <>\n                <SafeAreaInsetsContext.Consumer>\n                    {(insets = { top: 0, bottom: 0, left: 0, right: 0 }) => {\n                    this.insets = insets;\n                    return <StickyViewContext.Consumer>\n                        {(container) => {\n                            this.container = container;\n                            if(!this.scrolled) return <></>\n                            if (this.state.isStickyVisible && this.container) {\n                                if(!this.container?.children?.has(this)){\n                                    this.container.add(this, (\n                                        <ThemeProvider value={this.props.theme} key={this.id}>\n                                            <View style={[this.props.style]}>\n                                                {this.props.children}\n                                            </View>\n                                        </ThemeProvider>\n                                    ));\n                                }\n                            } else {\n                                this.container?.remove(this);\n                            }\n                            return <></>;\n                        }}\n                    </StickyViewContext.Consumer>}}\n                </SafeAreaInsetsContext.Consumer>\n                <View style={{opacity: this.state.isStickyVisible ? 0 : 1}}>\n                    {this.props.children}\n                </View>\n            </>\n        );\n    }\n}\n\nexport class StickyViewContainer extends React.Component {\n    public children: Map<StickyView, React.ReactNode> = new Map();\n    private id = 0;\n    public translateY: Animated.Value = new Animated.Value(0);\n    public topSlideHeight = 0;\n    public hiddenHeight: number = 0;\n    public containerHeight: number = 0;\n    private appConfig = injector.get<AppConfig>('APP_CONFIG');\n\n    add(c: StickyView, n : React.ReactNode) {\n        const h = Math.max(c.props.component.getLayout()?.height || 0, 0);\n        this.containerHeight += h;\n        this.topSlideHeight += (c.props.slide ? h : 0);\n        this.children.set(c, n);\n        setTimeout(() => this.setState({id: ++this.id}));\n    }\n\n    remove(c: StickyView) {\n        const h = Math.max(c.props.component.getLayout()?.height || 0, 0);\n        this.containerHeight -=  h;\n        this.topSlideHeight -= (c.props.slide ? h : 0);\n        this.containerHeight = Math.max(this.containerHeight, 0);\n        this.topSlideHeight = Math.max(this.topSlideHeight, 0);\n        this.children.delete(c);\n        setTimeout(() => this.setState({id: ++this.id}));\n    }\n\n    public slideBy(value: number) {\n        this.hiddenHeight = Math.max(\n            Math.min(0, (this.translateY as any)._value + value), \n            -1 * this.topSlideHeight);\n        \n        this.translateY.setValue(this.hiddenHeight);\n    }\n\n    render() {\n        return (\n            <StickyViewContext.Provider value={this}>\n                {(this.props as any).children}\n                <Animated.View style={{\n                    position: 'absolute', top: this.appConfig.pageScrollTopThreshold || 0, width: '100%',\n                    transform: [{ translateY: this.translateY }]\n                }}>\n                {Array.from(this.children.values())}\n                </Animated.View>\n            </StickyViewContext.Provider>\n        );\n    }\n};", "wavemaker-rn-runtime/src/core/event-notifier.ts": "let i = 1;\nexport default class EventNotifier {\n    public static ROOT = new EventNotifier();\n    public name = '';\n    public id = i++;\n    private listeners = {} as any;\n    private parent: EventNotifier = EventNotifier.ROOT;\n    private children: EventNotifier[] = [];\n\n    setParent(parent: EventNotifier) {\n        if (parent !== this.parent) {\n            this.removeFromParent();\n            this.parent = parent;\n            this.parent.children.push(this);\n        }\n    }\n\n    public notify(event: string, args: any[], emitToParent = false) {\n        let propagate = true;\n        if (this.listeners[event]) {\n            propagate = !this.listeners[event].find((l: Function) => {\n                try {\n                    return (l && l.apply(null, args)) === false;\n                } catch(e) {\n                    console.error(e);\n                }\n                return true;\n            });\n        }\n        if (propagate) {\n            if (emitToParent) {\n                this.parent?.notify(event, args, true);\n            } else {\n                this.children.forEach((c) => {\n                    c.notify(event, args);\n                });\n            }\n        }\n    }\n\n    public subscribe(event: string, fn: Function) {\n        this.listeners[event] = this.listeners[event] || [];\n        this.listeners[event].push(fn);\n        return () => {\n            const eventListeners = this.listeners[event];\n            const i = eventListeners.findIndex((fni: Function) => fni === fn);\n            eventListeners.splice(i, 1);\n        };\n    }\n\n    private removeFromParent() {\n        if (this.parent) {\n            const i = this.parent.children.indexOf(this) || -1;\n            if (i >= 0) {\n                this.parent.children.splice(i, 1);\n            }\n            this.parent = null as any;\n        }\n    }\n\n    public destroy() {\n        this.removeFromParent();\n    }\n}", "wavemaker-rn-runtime/src/core/asset.provider.ts": "import React from 'react';\n\nconst AssetContext = React.createContext<(path: string) => number | string>(null as any);\n\nexport const AssetProvider = AssetContext.Provider;\nexport const AssetConsumer = AssetContext.Consumer;", "wavemaker-rn-runtime/src/core/accessibility.ts": "import { AccessibilityInfo } from 'react-native';\nimport { isAndroid, isWebPreviewMode, removeUndefinedKeys } from './utils';\n\nlet _isScreenReaderEnabled = false;\n\nAccessibilityInfo.addEventListener(\n  'screenReaderChanged',\n  flag => {\n    _isScreenReaderEnabled = flag;\n  },\n);\n\nexport const isScreenReaderEnabled = () => _isScreenReaderEnabled;\n\nasync function getScreenReaderStatus() {\n  _isScreenReaderEnabled = (!isWebPreviewMode() && await AccessibilityInfo.isScreenReaderEnabled());\n}\n\ngetScreenReaderStatus();\n\nexport enum AccessibilityWidgetType {\n  BUTTON = 'button',\n  PICTURE = 'picture',\n  TEXT = 'text',\n  NUMBER = 'number',\n  TEXTAREA = 'textarea',\n  SELECT = 'select',\n  CHIPS = 'chips',\n  CURRENCY = 'currency',\n  RADIOSET = 'radioset',\n  CHECKBOX = 'checkbox',\n  TOGGLE = 'toggle',\n  SWITCH = 'switch',\n  DATE = 'date',\n  VIDEO = 'video',\n  PROGRESSBAR = 'progressbar',\n  PROGRESSCIRCLE = 'progresscircle',\n  LABEL = 'label',\n  ANCHOR = 'anchor',\n  MESSAGE = 'message',\n  SEARCH = 'search',\n  ICON = 'icon',\n  NAV = 'nav',\n  POVOVER = 'popover',\n  WEBVIEW = 'webview',\n  LINECHART = 'linechart',\n  SLIDER = 'slider',\n};\n\n  \nexport type AccessibilityPropsType = {\n  accessible?: boolean;\n  accessibilityLabel?: string;\n  accessibilityLabelledBy?: string;\n  accessibilityHint?: string;\n  accessibilityRole?: 'button' | 'link' | 'header' | 'search' | 'image' | 'imagebutton' | 'none' | 'summary' | 'text' | 'progressbar' | 'grid' | 'alert';\n  accessibilityState?: {\n    disabled?: boolean;\n    selected?: boolean;\n    checked?: boolean;\n    expanded?: boolean;\n  };\n  accessibilityValue?: {\n    min?: number;\n    max?: number;\n    now?: number;\n    text?: string;\n  };\n  accessibilityActions?: Array<{\n    name: string;\n    label?: string;\n  }>;\n  accessibilityLiveRegion?: 'none' | 'polite' | 'assertive';\n  accessibilityLanguage?: any;\n  accessibilityElementsHidden?: boolean;\n  accessibilityViewIsModal?: boolean;\n};\n  \n\nexport const getAccessibilityProps = (widgetType: AccessibilityWidgetType, accessibilityProps: AccessibilityPropsType | any) => {\n  let props: AccessibilityPropsType = {accessible: true};\n  if (!_isScreenReaderEnabled || isWebPreviewMode()) {\n    return {};\n  }\n  switch (widgetType) {\n    case AccessibilityWidgetType.BUTTON:\n    case AccessibilityWidgetType.TEXT:\n    case AccessibilityWidgetType.NUMBER:\n    case AccessibilityWidgetType.TEXTAREA:\n    case AccessibilityWidgetType.SELECT:\n    case AccessibilityWidgetType.CURRENCY:\n    case AccessibilityWidgetType.TOGGLE:\n    case AccessibilityWidgetType.DATE:\n    case AccessibilityWidgetType.LABEL:\n    case AccessibilityWidgetType.ANCHOR:\n    case AccessibilityWidgetType.MESSAGE:    \n    case AccessibilityWidgetType.SEARCH: \n    case AccessibilityWidgetType.PICTURE: \n    case AccessibilityWidgetType.ICON:\n    case AccessibilityWidgetType.NAV:\n    case AccessibilityWidgetType.POVOVER:\n    case AccessibilityWidgetType.WEBVIEW:\n    case AccessibilityWidgetType.LINECHART:\n    case AccessibilityWidgetType.SLIDER:\n    case AccessibilityWidgetType.VIDEO: {\n      props.accessibilityLabel = accessibilityProps.accessibilitylabel || accessibilityProps.caption?.toString();\n      props.accessibilityHint = accessibilityProps.hint;\n      props.accessibilityRole = accessibilityProps.accessibilityrole;\n\n      if (\n        widgetType === AccessibilityWidgetType.BUTTON ||\n        widgetType === AccessibilityWidgetType.TEXT ||\n        widgetType === AccessibilityWidgetType.NUMBER ||\n        widgetType === AccessibilityWidgetType.TEXTAREA ||\n        widgetType === AccessibilityWidgetType.SELECT ||\n        widgetType === AccessibilityWidgetType.TOGGLE ||\n        widgetType === AccessibilityWidgetType.DATE\n      ) {\n        props.accessibilityState = { disabled: accessibilityProps.disabled };\n      }\n      if (\n        (widgetType === AccessibilityWidgetType.TEXT ||\n          widgetType === AccessibilityWidgetType.NUMBER ||\n          widgetType === AccessibilityWidgetType.TEXTAREA ||\n          widgetType === AccessibilityWidgetType.SELECT ||\n          widgetType === AccessibilityWidgetType.CURRENCY ||\n          widgetType === AccessibilityWidgetType.TOGGLE) &&\n        isAndroid()\n      ) {\n        props.accessibilityLabelledBy =\n          accessibilityProps.accessibilitylabelledby;\n      }\n      if (\n        widgetType === AccessibilityWidgetType.NUMBER ||\n        widgetType === AccessibilityWidgetType.CURRENCY\n      ) {\n        props.accessibilityValue = {\n          min: accessibilityProps.minvalue,\n          max: accessibilityProps.maxvalue,\n        };\n      }\n      if (widgetType === AccessibilityWidgetType.SELECT) {\n        props.accessibilityState = {\n          ...props.accessibilityState,\n          expanded: accessibilityProps.expanded,\n        };\n      }\n      if (widgetType === AccessibilityWidgetType.TOGGLE) {\n        props.accessibilityState = {\n          ...props.accessibilityState,\n          selected: accessibilityProps.selected,\n        };\n      }\n      break;\n    }\n\n    case AccessibilityWidgetType.CHIPS: {\n      props.accessibilityLabel = accessibilityProps.accessibilitylabel || accessibilityProps.caption?.toString();\n      props.accessibilityHint = accessibilityProps.hint;\n      props.accessibilityState = {\n        disabled: accessibilityProps.disabled,\n        selected: accessibilityProps.selected,\n      };\n      break;\n    }\n\n    case AccessibilityWidgetType.RADIOSET: {\n      props.accessibilityState = {\n        disabled: accessibilityProps.readonly || accessibilityProps.disabled,\n        selected: accessibilityProps.selected,\n      };\n      break;\n    }\n\n    case AccessibilityWidgetType.CHECKBOX: {\n      props.accessibilityLabel = accessibilityProps.accessibilitylabel || accessibilityProps.caption?.toString();\n      props.accessibilityHint = accessibilityProps.hint;\n      props.accessibilityState = {\n        disabled: accessibilityProps.readonly ||  accessibilityProps.disabled,\n        checked: accessibilityProps.checked,\n      };\n      break;\n    }\n\n    case AccessibilityWidgetType.SWITCH: {\n      props.accessibilityLabel = accessibilityProps.accessibilitylabel || accessibilityProps.caption?.toString();\n      props.accessibilityHint = accessibilityProps.hint;\n      props.accessibilityState = {\n        disabled: accessibilityProps.disabled,\n        selected: accessibilityProps.selected,\n      };\n      break;\n    }\n    case AccessibilityWidgetType.PROGRESSBAR:\n    case AccessibilityWidgetType.PROGRESSCIRCLE: {\n      props.accessibilityLabel = accessibilityProps.accessibilitylabel || accessibilityProps.caption?.toString();\n      props.accessibilityRole = accessibilityProps.accessibilityrole;\n      break;\n    }\n    default:\n      break;\n  }\n\n  const finalProps = removeUndefinedKeys(props);\n  // console.log('finalProps', finalProps)\n\n  return finalProps;\n}", "wavemaker-rn-runtime/src/core/modal.service.ts": "import React from 'react';\n\nexport interface ModalOptions {\n    elevationIndex: number;\n    name?: string;\n    content: React.ReactNode;\n    modalStyle?: any;\n    contentStyle?: any;\n    centered?: boolean,\n    onClose?: () => void;\n    onOpen?: () => void;\n    isModal?: boolean;\n    animation: string;\n    animationdelay: number;\n}\n\nexport interface ModalService {\n    refresh: () => void;\n    showModal: (options: ModalOptions) => void;\n    hideModal: (options: ModalOptions) => void;\n}\n\nconst ModalContext = React.createContext<ModalService>(null as any);\n\nexport const ModalProvider = ModalContext.Provider;\nexport const ModalConsumer = ModalContext.Consumer;\n", "wavemaker-rn-runtime/src/core/partial.service.ts": "import React from 'react';\n\nexport default interface PartialService {\n    get: (partialName: string) => any;\n}\n\nconst PartialContext = React.createContext<PartialService>(null as any);\n\nexport const PartialProvider = PartialContext.Provider;\nexport const PartialConsumer = PartialContext.Consumer;", "wavemaker-rn-runtime/src/core/currency-constants.ts": "export const CURRENCY_INFO: any = {\n  'USD': {\n    'symbol': '$',\n    'name': 'US Dollar',\n    'symbol_native': '$',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'USD',\n    'name_plural': 'US dollars'\n  },\n  'CAD': {\n    'symbol': 'CA$',\n    'name': 'Canadian Dollar',\n    'symbol_native': '$',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'CAD',\n    'name_plural': 'Canadian dollars'\n  },\n  'EUR': {\n    'symbol': '\u20ac',\n    'name': 'Euro',\n    'symbol_native': '\u20ac',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'EUR',\n    'name_plural': 'euros'\n  },\n  'AED': {\n    'symbol': 'AED',\n    'name': 'United Arab Emirates Dirham',\n    'symbol_native': '\u062f.\u0625.\u200f',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'AED',\n    'name_plural': 'UAE dirhams'\n  },\n  'AFN': {\n    'symbol': 'Af',\n    'name': 'Afghan Afghani',\n    'symbol_native': '\u060b',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'AFN',\n    'name_plural': 'Afghan Afghanis'\n  },\n  'ALL': {\n    'symbol': 'ALL',\n    'name': 'Albanian Lek',\n    'symbol_native': 'Lek',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'ALL',\n    'name_plural': 'Albanian lek\u00eb'\n  },\n  'AMD': {\n    'symbol': 'AMD',\n    'name': 'Armenian Dram',\n    'symbol_native': '\u0564\u0580.',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'AMD',\n    'name_plural': 'Armenian drams'\n  },\n  'ARS': {\n    'symbol': 'AR$',\n    'name': 'Argentine Peso',\n    'symbol_native': '$',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'ARS',\n    'name_plural': 'Argentine pesos'\n  },\n  'AUD': {\n    'symbol': 'AU$',\n    'name': 'Australian Dollar',\n    'symbol_native': '$',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'AUD',\n    'name_plural': 'Australian dollars'\n  },\n  'AZN': {\n    'symbol': 'man.',\n    'name': 'Azerbaijani Manat',\n    'symbol_native': '\u043c\u0430\u043d.',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'AZN',\n    'name_plural': 'Azerbaijani manats'\n  },\n  'BAM': {\n    'symbol': 'KM',\n    'name': 'Bosnia-Herzegovina Convertible Mark',\n    'symbol_native': 'KM',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'BAM',\n    'name_plural': 'Bosnia-Herzegovina convertible marks'\n  },\n  'BDT': {\n    'symbol': 'Tk',\n    'name': 'Bangladeshi Taka',\n    'symbol_native': '\u09f3',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'BDT',\n    'name_plural': 'Bangladeshi takas'\n  },\n  'BGN': {\n    'symbol': 'BGN',\n    'name': 'Bulgarian Lev',\n    'symbol_native': '\u043b\u0432.',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'BGN',\n    'name_plural': 'Bulgarian leva'\n  },\n  'BHD': {\n    'symbol': 'BD',\n    'name': 'Bahraini Dinar',\n    'symbol_native': '\u062f.\u0628.\u200f',\n    'decimal_digits': 3,\n    'rounding': 0,\n    'code': 'BHD',\n    'name_plural': 'Bahraini dinars'\n  },\n  'BIF': {\n    'symbol': 'FBu',\n    'name': 'Burundian Franc',\n    'symbol_native': 'FBu',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'BIF',\n    'name_plural': 'Burundian francs'\n  },\n  'BND': {\n    'symbol': 'BN$',\n    'name': 'Brunei Dollar',\n    'symbol_native': '$',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'BND',\n    'name_plural': 'Brunei dollars'\n  },\n  'BOB': {\n    'symbol': 'Bs',\n    'name': 'Bolivian Boliviano',\n    'symbol_native': 'Bs',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'BOB',\n    'name_plural': 'Bolivian bolivianos'\n  },\n  'BRL': {\n    'symbol': 'R$',\n    'name': 'Brazilian Real',\n    'symbol_native': 'R$',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'BRL',\n    'name_plural': 'Brazilian reals'\n  },\n  'BWP': {\n    'symbol': 'BWP',\n    'name': 'Botswanan Pula',\n    'symbol_native': 'P',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'BWP',\n    'name_plural': 'Botswanan pulas'\n  },\n  'BYR': {\n    'symbol': 'BYR',\n    'name': 'Belarusian Ruble',\n    'symbol_native': 'BYR',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'BYR',\n    'name_plural': 'Belarusian rubles'\n  },\n  'BZD': {\n    'symbol': 'BZ$',\n    'name': 'Belize Dollar',\n    'symbol_native': '$',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'BZD',\n    'name_plural': 'Belize dollars'\n  },\n  'CDF': {\n    'symbol': 'CDF',\n    'name': 'Congolese Franc',\n    'symbol_native': 'FrCD',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'CDF',\n    'name_plural': 'Congolese francs'\n  },\n  'CHF': {\n    'symbol': 'CHF',\n    'name': 'Swiss Franc',\n    'symbol_native': 'CHF',\n    'decimal_digits': 2,\n    'rounding': 0.05,\n    'code': 'CHF',\n    'name_plural': 'Swiss francs'\n  },\n  'CLP': {\n    'symbol': 'CL$',\n    'name': 'Chilean Peso',\n    'symbol_native': '$',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'CLP',\n    'name_plural': 'Chilean pesos'\n  },\n  'CNY': {\n    'symbol': 'CN\u00a5',\n    'name': 'Chinese Yuan',\n    'symbol_native': 'CN\u00a5',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'CNY',\n    'name_plural': 'Chinese yuan'\n  },\n  'COP': {\n    'symbol': 'CO$',\n    'name': 'Colombian Peso',\n    'symbol_native': '$',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'COP',\n    'name_plural': 'Colombian pesos'\n  },\n  'CRC': {\n    'symbol': '\u20a1',\n    'name': 'Costa Rican Col\u00f3n',\n    'symbol_native': '\u20a1',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'CRC',\n    'name_plural': 'Costa Rican col\u00f3ns'\n  },\n  'CVE': {\n    'symbol': 'CV$',\n    'name': 'Cape Verdean Escudo',\n    'symbol_native': 'CV$',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'CVE',\n    'name_plural': 'Cape Verdean escudos'\n  },\n  'CZK': {\n    'symbol': 'K\u010d',\n    'name': 'Czech Republic Koruna',\n    'symbol_native': 'K\u010d',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'CZK',\n    'name_plural': 'Czech Republic korunas'\n  },\n  'DJF': {\n    'symbol': 'Fdj',\n    'name': 'Djiboutian Franc',\n    'symbol_native': 'Fdj',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'DJF',\n    'name_plural': 'Djiboutian francs'\n  },\n  'DKK': {\n    'symbol': 'Dkr',\n    'name': 'Danish Krone',\n    'symbol_native': 'kr',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'DKK',\n    'name_plural': 'Danish kroner'\n  },\n  'DOP': {\n    'symbol': 'RD$',\n    'name': 'Dominican Peso',\n    'symbol_native': 'RD$',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'DOP',\n    'name_plural': 'Dominican pesos'\n  },\n  'DZD': {\n    'symbol': 'DA',\n    'name': 'Algerian Dinar',\n    'symbol_native': '\u062f.\u062c.\u200f',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'DZD',\n    'name_plural': 'Algerian dinars'\n  },\n  'EEK': {\n    'symbol': 'Ekr',\n    'name': 'Estonian Kroon',\n    'symbol_native': 'kr',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'EEK',\n    'name_plural': 'Estonian kroons'\n  },\n  'EGP': {\n    'symbol': 'EGP',\n    'name': 'Egyptian Pound',\n    'symbol_native': '\u062c.\u0645.\u200f',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'EGP',\n    'name_plural': 'Egyptian pounds'\n  },\n  'ERN': {\n    'symbol': 'Nfk',\n    'name': 'Eritrean Nakfa',\n    'symbol_native': 'Nfk',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'ERN',\n    'name_plural': 'Eritrean nakfas'\n  },\n  'ETB': {\n    'symbol': 'Br',\n    'name': 'Ethiopian Birr',\n    'symbol_native': 'Br',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'ETB',\n    'name_plural': 'Ethiopian birrs'\n  },\n  'GBP': {\n    'symbol': '\u00a3',\n    'name': 'British Pound Sterling',\n    'symbol_native': '\u00a3',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'GBP',\n    'name_plural': 'British pounds sterling'\n  },\n  'GEL': {\n    'symbol': 'GEL',\n    'name': 'Georgian Lari',\n    'symbol_native': 'GEL',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'GEL',\n    'name_plural': 'Georgian laris'\n  },\n  'GHS': {\n    'symbol': 'GH\u20b5',\n    'name': 'Ghanaian Cedi',\n    'symbol_native': 'GH\u20b5',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'GHS',\n    'name_plural': 'Ghanaian cedis'\n  },\n  'GNF': {\n    'symbol': 'FG',\n    'name': 'Guinean Franc',\n    'symbol_native': 'FG',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'GNF',\n    'name_plural': 'Guinean francs'\n  },\n  'GTQ': {\n    'symbol': 'GTQ',\n    'name': 'Guatemalan Quetzal',\n    'symbol_native': 'Q',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'GTQ',\n    'name_plural': 'Guatemalan quetzals'\n  },\n  'HKD': {\n    'symbol': 'HK$',\n    'name': 'Hong Kong Dollar',\n    'symbol_native': '$',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'HKD',\n    'name_plural': 'Hong Kong dollars'\n  },\n  'HNL': {\n    'symbol': 'HNL',\n    'name': 'Honduran Lempira',\n    'symbol_native': 'L',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'HNL',\n    'name_plural': 'Honduran lempiras'\n  },\n  'HRK': {\n    'symbol': 'kn',\n    'name': 'Croatian Kuna',\n    'symbol_native': 'kn',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'HRK',\n    'name_plural': 'Croatian kunas'\n  },\n  'HUF': {\n    'symbol': 'Ft',\n    'name': 'Hungarian Forint',\n    'symbol_native': 'Ft',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'HUF',\n    'name_plural': 'Hungarian forints'\n  },\n  'IDR': {\n    'symbol': 'Rp',\n    'name': 'Indonesian Rupiah',\n    'symbol_native': 'Rp',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'IDR',\n    'name_plural': 'Indonesian rupiahs'\n  },\n  'ILS': {\n    'symbol': '\u20aa',\n    'name': 'Israeli New Sheqel',\n    'symbol_native': '\u20aa',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'ILS',\n    'name_plural': 'Israeli new sheqels'\n  },\n  'INR': {\n    'symbol': '\u20b9',\n    'name': 'Indian Rupee',\n    'symbol_native': '\u099f\u0995\u09be',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'INR',\n    'name_plural': 'Indian rupees'\n  },\n  'IQD': {\n    'symbol': 'IQD',\n    'name': 'Iraqi Dinar',\n    'symbol_native': '\u062f.\u0639.\u200f',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'IQD',\n    'name_plural': 'Iraqi dinars'\n  },\n  'IRR': {\n    'symbol': 'IRR',\n    'name': 'Iranian Rial',\n    'symbol_native': '\ufdfc',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'IRR',\n    'name_plural': 'Iranian rials'\n  },\n  'ISK': {\n    'symbol': 'Ikr',\n    'name': 'Icelandic Kr\u00f3na',\n    'symbol_native': 'kr',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'ISK',\n    'name_plural': 'Icelandic kr\u00f3nur'\n  },\n  'JMD': {\n    'symbol': 'J$',\n    'name': 'Jamaican Dollar',\n    'symbol_native': '$',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'JMD',\n    'name_plural': 'Jamaican dollars'\n  },\n  'JOD': {\n    'symbol': 'JD',\n    'name': 'Jordanian Dinar',\n    'symbol_native': '\u062f.\u0623.\u200f',\n    'decimal_digits': 3,\n    'rounding': 0,\n    'code': 'JOD',\n    'name_plural': 'Jordanian dinars'\n  },\n  'JPY': {\n    'symbol': '\u00a5',\n    'name': 'Japanese Yen',\n    'symbol_native': '\uffe5',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'JPY',\n    'name_plural': 'Japanese yen'\n  },\n  'KES': {\n    'symbol': 'Ksh',\n    'name': 'Kenyan Shilling',\n    'symbol_native': 'Ksh',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'KES',\n    'name_plural': 'Kenyan shillings'\n  },\n  'KHR': {\n    'symbol': 'KHR',\n    'name': 'Cambodian Riel',\n    'symbol_native': '\u17db',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'KHR',\n    'name_plural': 'Cambodian riels'\n  },\n  'KMF': {\n    'symbol': 'CF',\n    'name': 'Comorian Franc',\n    'symbol_native': 'FC',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'KMF',\n    'name_plural': 'Comorian francs'\n  },\n  'KRW': {\n    'symbol': '\u20a9',\n    'name': 'South Korean Won',\n    'symbol_native': '\u20a9',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'KRW',\n    'name_plural': 'South Korean won'\n  },\n  'KWD': {\n    'symbol': 'KD',\n    'name': 'Kuwaiti Dinar',\n    'symbol_native': '\u062f.\u0643.\u200f',\n    'decimal_digits': 3,\n    'rounding': 0,\n    'code': 'KWD',\n    'name_plural': 'Kuwaiti dinars'\n  },\n  'KZT': {\n    'symbol': 'KZT',\n    'name': 'Kazakhstani Tenge',\n    'symbol_native': '\u0442\u04a3\u0433.',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'KZT',\n    'name_plural': 'Kazakhstani tenges'\n  },\n  'LBP': {\n    'symbol': 'LB\u00a3',\n    'name': 'Lebanese Pound',\n    'symbol_native': '\u0644.\u0644.\u200f',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'LBP',\n    'name_plural': 'Lebanese pounds'\n  },\n  'LKR': {\n    'symbol': 'SLRs',\n    'name': 'Sri Lankan Rupee',\n    'symbol_native': 'SL Re',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'LKR',\n    'name_plural': 'Sri Lankan rupees'\n  },\n  'LTL': {\n    'symbol': 'Lt',\n    'name': 'Lithuanian Litas',\n    'symbol_native': 'Lt',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'LTL',\n    'name_plural': 'Lithuanian litai'\n  },\n  'LVL': {\n    'symbol': 'Ls',\n    'name': 'Latvian Lats',\n    'symbol_native': 'Ls',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'LVL',\n    'name_plural': 'Latvian lati'\n  },\n  'LYD': {\n    'symbol': 'LD',\n    'name': 'Libyan Dinar',\n    'symbol_native': '\u062f.\u0644.\u200f',\n    'decimal_digits': 3,\n    'rounding': 0,\n    'code': 'LYD',\n    'name_plural': 'Libyan dinars'\n  },\n  'MAD': {\n    'symbol': 'MAD',\n    'name': 'Moroccan Dirham',\n    'symbol_native': '\u062f.\u0645.\u200f',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'MAD',\n    'name_plural': 'Moroccan dirhams'\n  },\n  'MDL': {\n    'symbol': 'MDL',\n    'name': 'Moldovan Leu',\n    'symbol_native': 'MDL',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'MDL',\n    'name_plural': 'Moldovan lei'\n  },\n  'MGA': {\n    'symbol': 'MGA',\n    'name': 'Malagasy Ariary',\n    'symbol_native': 'MGA',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'MGA',\n    'name_plural': 'Malagasy Ariaries'\n  },\n  'MKD': {\n    'symbol': 'MKD',\n    'name': 'Macedonian Denar',\n    'symbol_native': 'MKD',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'MKD',\n    'name_plural': 'Macedonian denari'\n  },\n  'MMK': {\n    'symbol': 'MMK',\n    'name': 'Myanma Kyat',\n    'symbol_native': 'K',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'MMK',\n    'name_plural': 'Myanma kyats'\n  },\n  'MOP': {\n    'symbol': 'MOP$',\n    'name': 'Macanese Pataca',\n    'symbol_native': 'MOP$',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'MOP',\n    'name_plural': 'Macanese patacas'\n  },\n  'MUR': {\n    'symbol': 'MURs',\n    'name': 'Mauritian Rupee',\n    'symbol_native': 'MURs',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'MUR',\n    'name_plural': 'Mauritian rupees'\n  },\n  'MXN': {\n    'symbol': 'MX$',\n    'name': 'Mexican Peso',\n    'symbol_native': '$',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'MXN',\n    'name_plural': 'Mexican pesos'\n  },\n  'MYR': {\n    'symbol': 'RM',\n    'name': 'Malaysian Ringgit',\n    'symbol_native': 'RM',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'MYR',\n    'name_plural': 'Malaysian ringgits'\n  },\n  'MZN': {\n    'symbol': 'MTn',\n    'name': 'Mozambican Metical',\n    'symbol_native': 'MTn',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'MZN',\n    'name_plural': 'Mozambican meticals'\n  },\n  'NAD': {\n    'symbol': 'N$',\n    'name': 'Namibian Dollar',\n    'symbol_native': 'N$',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'NAD',\n    'name_plural': 'Namibian dollars'\n  },\n  'NGN': {\n    'symbol': '\u20a6',\n    'name': 'Nigerian Naira',\n    'symbol_native': '\u20a6',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'NGN',\n    'name_plural': 'Nigerian nairas'\n  },\n  'NIO': {\n    'symbol': 'C$',\n    'name': 'Nicaraguan C\u00f3rdoba',\n    'symbol_native': 'C$',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'NIO',\n    'name_plural': 'Nicaraguan c\u00f3rdobas'\n  },\n  'NOK': {\n    'symbol': 'Nkr',\n    'name': 'Norwegian Krone',\n    'symbol_native': 'kr',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'NOK',\n    'name_plural': 'Norwegian kroner'\n  },\n  'NPR': {\n    'symbol': 'NPRs',\n    'name': 'Nepalese Rupee',\n    'symbol_native': '\u0928\u0947\u0930\u0942',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'NPR',\n    'name_plural': 'Nepalese rupees'\n  },\n  'NZD': {\n    'symbol': 'NZ$',\n    'name': 'New Zealand Dollar',\n    'symbol_native': '$',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'NZD',\n    'name_plural': 'New Zealand dollars'\n  },\n  'OMR': {\n    'symbol': 'OMR',\n    'name': 'Omani Rial',\n    'symbol_native': '\u0631.\u0639.\u200f',\n    'decimal_digits': 3,\n    'rounding': 0,\n    'code': 'OMR',\n    'name_plural': 'Omani rials'\n  },\n  'PAB': {\n    'symbol': 'B/.',\n    'name': 'Panamanian Balboa',\n    'symbol_native': 'B/.',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'PAB',\n    'name_plural': 'Panamanian balboas'\n  },\n  'PEN': {\n    'symbol': 'S/.',\n    'name': 'Peruvian Nuevo Sol',\n    'symbol_native': 'S/.',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'PEN',\n    'name_plural': 'Peruvian nuevos soles'\n  },\n  'PHP': {\n    'symbol': '\u20b1',\n    'name': 'Philippine Peso',\n    'symbol_native': '\u20b1',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'PHP',\n    'name_plural': 'Philippine pesos'\n  },\n  'PKR': {\n    'symbol': 'PKRs',\n    'name': 'Pakistani Rupee',\n    'symbol_native': '\u20a8',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'PKR',\n    'name_plural': 'Pakistani rupees'\n  },\n  'PLN': {\n    'symbol': 'z\u0142',\n    'name': 'Polish Zloty',\n    'symbol_native': 'z\u0142',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'PLN',\n    'name_plural': 'Polish zlotys'\n  },\n  'PYG': {\n    'symbol': '\u20b2',\n    'name': 'Paraguayan Guarani',\n    'symbol_native': '\u20b2',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'PYG',\n    'name_plural': 'Paraguayan guaranis'\n  },\n  'QAR': {\n    'symbol': 'QR',\n    'name': 'Qatari Rial',\n    'symbol_native': '\u0631.\u0642.\u200f',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'QAR',\n    'name_plural': 'Qatari rials'\n  },\n  'RON': {\n    'symbol': 'RON',\n    'name': 'Romanian Leu',\n    'symbol_native': 'RON',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'RON',\n    'name_plural': 'Romanian lei'\n  },\n  'RSD': {\n    'symbol': 'din.',\n    'name': 'Serbian Dinar',\n    'symbol_native': '\u0434\u0438\u043d.',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'RSD',\n    'name_plural': 'Serbian dinars'\n  },\n  'RUB': {\n    'symbol': 'RUB',\n    'name': 'Russian Ruble',\n    'symbol_native': '\u0440\u0443\u0431.',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'RUB',\n    'name_plural': 'Russian rubles'\n  },\n  'RWF': {\n    'symbol': 'RWF',\n    'name': 'Rwandan Franc',\n    'symbol_native': 'FR',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'RWF',\n    'name_plural': 'Rwandan francs'\n  },\n  'SAR': {\n    'symbol': 'SR',\n    'name': 'Saudi Riyal',\n    'symbol_native': '\u0631.\u0633.\u200f',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'SAR',\n    'name_plural': 'Saudi riyals'\n  },\n  'SDG': {\n    'symbol': 'SDG',\n    'name': 'Sudanese Pound',\n    'symbol_native': 'SDG',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'SDG',\n    'name_plural': 'Sudanese pounds'\n  },\n  'SEK': {\n    'symbol': 'Skr',\n    'name': 'Swedish Krona',\n    'symbol_native': 'kr',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'SEK',\n    'name_plural': 'Swedish kronor'\n  },\n  'SGD': {\n    'symbol': 'S$',\n    'name': 'Singapore Dollar',\n    'symbol_native': '$',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'SGD',\n    'name_plural': 'Singapore dollars'\n  },\n  'SOS': {\n    'symbol': 'Ssh',\n    'name': 'Somali Shilling',\n    'symbol_native': 'Ssh',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'SOS',\n    'name_plural': 'Somali shillings'\n  },\n  'SYP': {\n    'symbol': 'SY\u00a3',\n    'name': 'Syrian Pound',\n    'symbol_native': '\u0644.\u0633.\u200f',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'SYP',\n    'name_plural': 'Syrian pounds'\n  },\n  'THB': {\n    'symbol': '\u0e3f',\n    'name': 'Thai Baht',\n    'symbol_native': '\u0e3f',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'THB',\n    'name_plural': 'Thai baht'\n  },\n  'TND': {\n    'symbol': 'DT',\n    'name': 'Tunisian Dinar',\n    'symbol_native': '\u062f.\u062a.\u200f',\n    'decimal_digits': 3,\n    'rounding': 0,\n    'code': 'TND',\n    'name_plural': 'Tunisian dinars'\n  },\n  'TOP': {\n    'symbol': 'T$',\n    'name': 'Tongan Pa\u02bbanga',\n    'symbol_native': 'T$',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'TOP',\n    'name_plural': 'Tongan pa\u02bbanga'\n  },\n  'TRY': {\n    'symbol': 'TL',\n    'name': 'Turkish Lira',\n    'symbol_native': 'TL',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'TRY',\n    'name_plural': 'Turkish Lira'\n  },\n  'TTD': {\n    'symbol': 'TT$',\n    'name': 'Trinidad and Tobago Dollar',\n    'symbol_native': '$',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'TTD',\n    'name_plural': 'Trinidad and Tobago dollars'\n  },\n  'TWD': {\n    'symbol': 'NT$',\n    'name': 'New Taiwan Dollar',\n    'symbol_native': 'NT$',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'TWD',\n    'name_plural': 'New Taiwan dollars'\n  },\n  'TZS': {\n    'symbol': 'TSh',\n    'name': 'Tanzanian Shilling',\n    'symbol_native': 'TSh',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'TZS',\n    'name_plural': 'Tanzanian shillings'\n  },\n  'UAH': {\n    'symbol': '\u20b4',\n    'name': 'Ukrainian Hryvnia',\n    'symbol_native': '\u20b4',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'UAH',\n    'name_plural': 'Ukrainian hryvnias'\n  },\n  'UGX': {\n    'symbol': 'USh',\n    'name': 'Ugandan Shilling',\n    'symbol_native': 'USh',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'UGX',\n    'name_plural': 'Ugandan shillings'\n  },\n  'UYU': {\n    'symbol': '$U',\n    'name': 'Uruguayan Peso',\n    'symbol_native': '$',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'UYU',\n    'name_plural': 'Uruguayan pesos'\n  },\n  'UZS': {\n    'symbol': 'UZS',\n    'name': 'Uzbekistan Som',\n    'symbol_native': 'UZS',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'UZS',\n    'name_plural': 'Uzbekistan som'\n  },\n  'VEF': {\n    'symbol': 'Bs.F.',\n    'name': 'Venezuelan Bol\u00edvar',\n    'symbol_native': 'Bs.F.',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'VEF',\n    'name_plural': 'Venezuelan bol\u00edvars'\n  },\n  'VND': {\n    'symbol': '\u20ab',\n    'name': 'Vietnamese Dong',\n    'symbol_native': '\u20ab',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'VND',\n    'name_plural': 'Vietnamese dong'\n  },\n  'XAF': {\n    'symbol': 'FCFA',\n    'name': 'CFA Franc BEAC',\n    'symbol_native': 'FCFA',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'XAF',\n    'name_plural': 'CFA francs BEAC'\n  },\n  'XOF': {\n    'symbol': 'CFA',\n    'name': 'CFA Franc BCEAO',\n    'symbol_native': 'CFA',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'XOF',\n    'name_plural': 'CFA francs BCEAO'\n  },\n  'YER': {\n    'symbol': 'YR',\n    'name': 'Yemeni Rial',\n    'symbol_native': '\u0631.\u064a.\u200f',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'YER',\n    'name_plural': 'Yemeni rials'\n  },\n  'ZAR': {\n    'symbol': 'R',\n    'name': 'South African Rand',\n    'symbol_native': 'R',\n    'decimal_digits': 2,\n    'rounding': 0,\n    'code': 'ZAR',\n    'name_plural': 'South African rand'\n  },\n  'ZMK': {\n    'symbol': 'ZK',\n    'name': 'Zambian Kwacha',\n    'symbol_native': 'ZK',\n    'decimal_digits': 0,\n    'rounding': 0,\n    'code': 'ZMK',\n    'name_plural': 'Zambian kwachas'\n  }\n};\n", "wavemaker-rn-runtime/src/core/wm-component-tree.ts": "import { BaseComponent } from \"./base.component\";\n\nlet id = 0;\n\nexport class WmComponentNode {\n    type?: string;\n    private _classnameMap: Map<string, boolean> = new Map();\n    private id = ++id;\n    private _classnameVal = '';\n    parent?: WmComponentNode;\n    readonly children: WmComponentNode[] = [];\n    instance?: BaseComponent<any, any, any>;\n    \n\n    public constructor(args: {\n        type?: string,\n        classname?: string,\n        children?: WmComponentNode[],\n        instance?: BaseComponent<any, any, any>\n    }) {\n        this.type = args.type;\n        this.instance = args.instance;\n        args.children?.forEach(c => this.add(c));\n    }\n\n    private refresh(only?: (node: WmComponentNode) => boolean) {\n        if (!only || only(this)) {\n            this.instance?.refresh();\n        }\n        if (only) {\n            this.children?.forEach((c) => {\n                c?.refresh(only);\n            });\n        }\n    }\n\n    get classname() {\n        return this._classnameVal;\n    }\n\n    hasClass(name: string) {\n        return this._classnameMap.has(name);\n    }\n\n    add(node: WmComponentNode) {\n        if (node.parent !== this) {\n            node.parent?.remove(this);\n            this.children.push(node);\n            node.parent = this;\n            node.refresh();\n        }\n    }\n\n    remove(node: WmComponentNode) {\n        const i = this.children.findIndex((n) => n === node);\n        if (i >= 0) {\n            this.children.splice(i, 1);\n            node.parent = undefined;\n            this.children?.forEach((c) => {\n                c.refresh();\n            });\n        }\n    }\n}", "wavemaker-rn-runtime/src/core/testid.provider.ts": "import React from 'react';\n\nconst TextIdPrefixContext = React.createContext<string | undefined>(null as any);\n\nexport const TestIdPrefixProvider = TextIdPrefixContext.Provider;\nexport const TextIdPrefixConsumer = TextIdPrefixContext.Consumer;", "wavemaker-rn-runtime/src/core/utils.ts": "import { Platform } from 'react-native';\nimport moment from \"moment\";\nimport * as FileSystem from \"expo-file-system\";\nimport { isFunction, includes, isUndefined, isNull, orderBy, groupBy, toLower, get, forEach, sortBy, cloneDeep, keys, values, isArray, isString, isNumber } from 'lodash';\nimport * as mime from 'react-native-mime-types';\nimport ThemeVariables from '../styles/theme.variables';\n\ndeclare const window: any;\nconst GROUP_BY_OPTIONS = {\n  ALPHABET: 'alphabet',\n  WORD: 'word',\n  OTHERS: 'Others'\n};\nconst TIME_ROLLUP_OPTIONS = {\n  HOUR: 'hour',\n  DAY: 'day',\n  WEEK: 'week',\n  MONTH: 'month',\n  YEAR: 'year'\n};\n\ntype LayoutData = {\n  [index: string]: {\n    [index: string]: {\n      x: number,\n      y: number\n    }\n  }\n}\n\nconst AppLayoutPosition: { currentPage: string, data: LayoutData } = {\n  currentPage: 'Main',\n  data: {}\n}\n\nconst _deepCopy = (o1: any, ...o2: any) => {\n  o2.forEach((o: any) => {\n    if (o) {\n      Object.keys(o).forEach(k => {\n        const v = o[k];\n        if (v && !isString(v) && !isArray(v) && typeof v === 'object') {\n          o1[k] = _deepCopy(o1[k] || {}, o[k]);\n        } else {\n          o1[k] = _deepCopy(v);\n        }\n      });\n    }\n  });\n  return o1;\n};\n\nexport const deepCopy = (...objects: any) => _deepCopy({}, ...objects);\n\nexport const toBoolean = (val: any) => {\n  return val === true\n    || val === 'true'\n    || !(val === false\n      || val === null\n      || val === undefined\n      || val === '');\n};\n\nexport const toNumber = (val: any) => {\n  try {\n    return parseFloat(val) || 0;\n  } catch (e) {\n    return 0;\n  }\n};\n\n/**\n * this method encodes the url and returns the encoded string\n */\nexport const encodeUrl = (url: string): string => {\n  let splits = url.split('#');\n  const hash = splits[1];\n  splits = splits[0].split('?');\n  let params = '';\n  if (splits.length > 1) {\n    params = splits[1].split('&')\n      .map(p => p.split('='))\n      .map(p => p[0] + '=' + encodeURIComponent(p[1]))\n      .join('&');\n  }\n  return encodeURI(splits[0]) + (params ? '?' + params : '') + (hash ? '#' + hash : '');\n};\n\nexport const isWebPreviewMode = () => Platform.OS === 'web';\n\nexport const isDevMode = () => isWebPreviewMode() || __DEV__;\n\nexport const widgetsWithUndefinedValue = ['checkbox', 'toggle'];\n\nexport const isAndroid = () => (Platform.OS === 'android' || (Platform.OS === 'web' && /android/i.test(window.navigator.userAgent)));\n\nexport const isIos = () => (Platform.OS === 'ios' || (Platform.OS === 'web' && /iPhone|iPad/i.test(window.navigator.userAgent)));\n\nconst getGroupKey = (fieldDef: any, groupby: string, widgetScope: any, innerItem?: any) => isFunction(groupby) ? groupby.apply(widgetScope.proxy, [innerItem ? fieldDef[innerItem] : fieldDef]) : get(innerItem ? fieldDef[innerItem] : fieldDef, groupby);\n\n/**\n * This method prepares the grouped data.\n *\n * @param fieldDefs array of objects i.e. dataset\n * @param groupby string groupby\n * @param match string match\n * @param orderby string orderby\n * @param dateFormat string date format\n */\nexport const getGroupedData = (fieldDefs: any, groupby: string, match: string, orderby: string, dateFormat: string, widgetScope: any, innerItem?: any) => {\n\n  // handling case-in-sensitive scenario\n  // ordering the data based on groupby field. If there is innerItem then apply orderby using the innerItem's containing the groupby field.\n  fieldDefs = orderBy(fieldDefs, fieldDef => {\n    const groupKey = getGroupKey(fieldDef, groupby, widgetScope, innerItem);\n    if (groupKey) {\n      return toLower(groupKey);\n    }\n    return '';\n  });\n\n  // extract the grouped data based on the field obtained from 'groupDataByField'.\n  const groupedLiData = groupBy(fieldDefs, function (fieldDef) {\n    let concatStr = getGroupKey(fieldDef, groupby, widgetScope, innerItem);\n    // by default set the undefined groupKey as 'others'\n    if (isUndefined(concatStr) || isNull(concatStr) || concatStr.toString().trim() === '') {\n      return GROUP_BY_OPTIONS.OTHERS;\n    }\n    // if match prop is alphabetic ,get the starting alphabet of the word as key.\n    if (match === GROUP_BY_OPTIONS.ALPHABET) {\n      concatStr = concatStr.substr(0, 1);\n    }\n\n    // if match contains the time options then get the concatStr using 'getTimeRolledUpString'\n    if (includes(values(TIME_ROLLUP_OPTIONS), match)) {\n      dateFormat = dateFormat && dateFormat.replace(/d/g, 'D');\n      dateFormat = dateFormat && dateFormat.replace(/y/g, 'Y');\n      concatStr = moment(concatStr).format(dateFormat);\n    }\n\n    return concatStr;\n  });\n\n  return getSortedGroupedData(groupedLiData, groupby, orderby, innerItem);\n};\n\n/**\n * function to get the ordered dataset based on the given orderby\n */\nexport const getOrderedDataset = (dataSet: any, orderby: string, innerItem?: any) => {\n  if (!orderBy) {\n    return cloneDeep(dataSet);\n  }\n\n  // The order by only works when the dataset contains list of objects.\n  const items = orderby && orderby.split(','),\n    fields: any = [],\n    directions: any = [];\n  items && items.forEach(obj => {\n    const item = obj.split(':');\n    fields.push(innerItem ? innerItem + '.' + item[0] : item[0]);\n    directions.push(item[1]);\n  });\n  return orderBy(dataSet, fields, directions);\n};\n\n\n/**\n * This method returns sorted data based to groupkey.\n * Returns a array of objects, each object containing key which is groupKey and data is the sorted data which is sorted by groupby field in the data.\n *\n * @param groupedLiData, grouped data object with key as the groupKey and its value as the array of objects grouped under the groupKey.\n * @param groupBy, string groupby property\n * @returns {any[]}\n */\nexport const getSortedGroupedData = (groupedLiData: any, groupBy: string, orderby: string, innerItem?: any) => {\n  const _groupedData: any = [];\n  forEach(keys(groupedLiData), (groupkey, index) => {\n    const liData = getOrderedDataset(groupedLiData[groupkey], orderby, innerItem);\n    _groupedData.push({\n      key: groupkey,\n      data: sortBy(liData, data => {\n        data._groupIndex = index;\n        return get(data, groupBy) || get(data[innerItem], groupBy);\n      })\n    });\n  });\n  return _groupedData;\n};\n\nexport const isDefined = (v: any) => typeof v !== 'undefined';\n\n// try to convert the chekedvalue and unchecked values to boolean/number\nexport const unStringify = (val: any, defaultVal?: boolean) => {\n  if (val === null) {\n    return defaultVal;\n  }\n\n  if (val === true || val === 'true') {\n    return true;\n  }\n\n  if (val === false || val === 'false') {\n    return false;\n  }\n\n  const number = parseInt(val, 10);\n  if (!isNaN(number)) {\n    return number;\n  }\n  return val;\n};\n\n/**\n * This function invokes the given the function (fn) until the function successfully executes or the maximum number\n * of retries is reached or onBeforeRetry returns false.\n *\n * @param fn - a function that is needs to be invoked. The function can also return a promise as well.\n * @param interval - minimum time gap between successive retries. This argument should be greater or equal to 0.\n * @param maxRetries - maximum number of retries. This argument should be greater than 0. For all other values,\n * maxRetries is infinity.\n * @param onBeforeRetry - a callback function that will be invoked before re-invoking again. This function can\n * return false or a promise that is resolved to false to stop further retry attempts.\n * @returns {*} a promise that is resolved when fn is success (or) maximum retry attempts reached\n * (or) onBeforeRetry returned false.\n */\nexport const retryIfFails = (fn: Function, interval: number, maxRetries: number, onBeforeRetry = () => Promise.resolve(false)) => {\n  let retryCount = 0;\n  const tryFn = () => {\n    retryCount++;\n    if (isFunction(fn)) {\n      return fn();\n    }\n  };\n  maxRetries = (isNumber(maxRetries) && maxRetries > 0 ? maxRetries : 0);\n  interval = (isNumber(interval) && interval > 0 ? interval : 0);\n  return new Promise((resolve, reject) => {\n    const errorFn = function () {\n      const errArgs = arguments;\n      setTimeout(() => {\n        Promise.resolve().then(() => onBeforeRetry()).then(function (retry) {\n          if (retry !== false && (!maxRetries || retryCount <= maxRetries)) {\n            Promise.resolve().then(() => tryFn()).then(resolve, errorFn);\n          } else {\n            reject(errArgs);\n          }\n        }, () => reject(errArgs));\n      }, interval);\n    };\n    Promise.resolve().then(() => tryFn()).then(resolve, errorFn);\n  });\n};\n\n/**\n * Promise of a defer created using this function, has abort function that will reject the defer when called.\n * @returns {*} angular defer object\n */\nexport const getAbortableDefer = () => {\n  const _defer: any = {\n    promise: null,\n    reject: null,\n    resolve: null,\n    onAbort: () => { },\n    isAborted: false\n  };\n  _defer.promise = new Promise((resolve, reject) => {\n    _defer.resolve = resolve;\n    _defer.reject = reject;\n  });\n  _defer.promise.abort = () => {\n    _defer.onAbort && _defer.onAbort();\n    _defer.reject('aborted');\n    _defer.isAborted = true;\n  };\n  return _defer;\n};\n\nexport const validateField = (props: any, value: any) => {\n  let requiredCheck = true, regexCheck = true;\n  if (props.required) {\n    if (isArray(value)) {\n      requiredCheck = value.length === 0 ? false : true\n    } else {\n      requiredCheck = !value ? false : true\n    }\n    if (!requiredCheck) {\n      return {\n        errorType: 'required',\n        isValid: false\n      }\n    }\n  }\n  if (value && props.regexp) {\n    const condition = new RegExp(\"^\" + props.regexp + \"$\", 'g');\n    regexCheck = condition.test(value);\n    if (!regexCheck) {\n      return {\n        errorType: 'regexp',\n        isValid: false\n      }\n    }\n  }\n  if (value && props.maxchars && value.length > props.maxchars) {\n    return {\n      errorType: 'maxchars',\n      isValid: false\n    }\n\n  }\n  if (value && props.mindate && new Date(props.datavalue) < moment(props.mindate).startOf('day').toDate()) {\n    return {\n      errorType: 'mindate',\n      isValid: false\n    }\n  }\n  if (value && props.maxdate && new Date(props.datavalue) > moment(props.maxdate).endOf('day').toDate()) {\n    return {\n      errorType: 'maxdate',\n      isValid: false\n    }\n  }\n\n  return {\n    isValid: true\n  }\n};\n\nexport const countDecimalDigits = (number: number | string) => {\n  if (!number) return 0;\n\n  // * convert the number to a string\n  const numberString = number.toString();\n\n  // * regular expression to match and count the decimal digits\n  const decimalMatch = numberString.match(/\\.(\\d+)/);\n\n  if (decimalMatch) {\n    const decimalDigits = decimalMatch[1];\n    return decimalDigits.length;\n  } else {\n    return 0; // * no decimal digits found\n  }\n}\n\nexport const formatCompactNumber = (number: number) => {\n  const isNegative = number < 0;\n  number = isNegative ? number * -1 : number;\n  let formattedNumber = number + '';\n  if (number >= 1000 && number < 1_000_000) {\n    formattedNumber = (number / 1000).toFixed(1).replace(/\\.0$/, \"\") + \"K\";\n  } else if (number >= 1_000_000 && number < 1_000_000_000) {\n    formattedNumber = (number / 1_000_000).toFixed(1).replace(/\\.0$/, \"\") + \"M\";\n  } else if (number >= 1_000_000_000 && number < 1_000_000_000_000) {\n    formattedNumber = (number / 1_000_000_000).toFixed(1).replace(/\\.0$/, \"\") + \"B\";\n  } else if (number >= 1_000_000_000_000 && number < 1_000_000_000_000_000) {\n    formattedNumber = (number / 1_000_000_000_000).toFixed(1).replace(/\\.0$/, \"\") + \"T\";\n  }\n  return (isNegative ? '-' : '') + formattedNumber;\n}\n\nexport const toBase64 = function (path: string) {\n  return FileSystem.readAsStringAsync(path, { encoding: 'base64' });\n};\n\nconst DATASET_WIDGETS = new Set(['select', 'checkboxset', 'radioset', 'switch', 'autocomplete', 'chips', 'typeahead', 'rating']);\nexport const isDataSetWidget = (widget: any) => {\n  return DATASET_WIDGETS.has(widget);\n};\nexport const isFullPathUrl = (url: string) => {\n  return isString(url) &&\n    (url.startsWith('data:')\n      || url.startsWith('http:')\n      || url.startsWith('https:')\n      || url.startsWith('file:'));\n};\n\nexport function removeUndefinedKeys(obj: any) {\n  for (const key in obj) {\n    if (obj[key] === undefined) {\n      delete obj[key];\n    } else if (typeof obj[key] === 'object') {\n      // * if the value is an object, recursively call the function\n      removeUndefinedKeys(obj[key]);\n    }\n  }\n\n  return obj;\n}\n// * get total number of days in a month of a year\nexport function getDaysInMonth(month: number, year: number) {\n  return new Date(year, month, 0).getDate();\n}\n\nexport const getDates = (\n  startDate: number,\n  endDate: number,\n  month = 0, // zero-based\n  year = new Date().getFullYear(),\n) => {\n  const daysInMonth = getDaysInMonth(month, year);\n  const dates = Array.from({ length: daysInMonth }, (v, i) => i + 1);\n\n  const datesInRange = dates.filter(date => date >= startDate && date <= endDate);\n\n  return datesInRange;\n};\n\nexport const monthNames = [\n  'January',\n  'February',\n  'March',\n  'April',\n  'May',\n  'June',\n  'July',\n  'August',\n  'September',\n  'October',\n  'November',\n  'December',\n];\n\nexport const getMonths = (startMonth: number, endMonth: number) => {\n  const months = monthNames.map(name => name.substring(0, 3));\n  const monthRange = months.filter((_, index) => index >= startMonth && index <= endMonth);\n\n  return monthRange;\n};\n\nexport const getMonthIndex = (monthName: string, shortName: boolean = true) => {\n  const months = shortName ? monthNames.map(name => name.substring(0, 3)) : monthNames;\n  const monthNumber = months.findIndex((name) => name === monthName);\n\n  return monthNumber;\n}\n\nexport const getYearRange = (\n  startYear: number = 1950,\n  endYear: number = 2060,\n) => {\n  const years = [];\n  for (let year = startYear; year <= endYear; ++year) {\n    years.push(year);\n  }\n\n  return years;\n};\n\nexport const getDateObject = (date: number, month: number, year: number) => {\n  // * month is zero-based\n  return new Date(year, month, date);\n};\n\nexport const getHours = () => {\n  const hours = [];\n  for (let hour = 1; hour <= 12; ++hour) {\n    const paddedHour = String(hour).padStart(2, '0');\n    hours.push(paddedHour);\n  }\n\n  return hours;\n}\n\nexport const get24Hours = () => {\n  const hours = [];\n  for (let hour = 0; hour <= 23; ++hour) {\n    const paddedHour = String(hour).padStart(2, '0');\n    hours.push(paddedHour);\n  }\n\n  return hours;\n}\n\nexport const getMinutes = () => {\n  const minutes = [];\n  for (let minute = 0; minute <= 59; ++minute) {\n    const paddedMinute = String(minute).padStart(2, '0');\n    minutes.push(paddedMinute);\n  }\n\n  return minutes;\n}\n\nexport const getTimeIndicators = () => {\n  return ['AM', 'PM'];\n}\n\nexport const getDateTimeObject = (date: number, month: number, year: number, hour: number, minute: number) => {\n  // * month is zero-based\n  return new Date(year, month, date, hour, minute);\n};\n\nexport const getProgressBarGradientStartEnd = (angle: string) => {\n  const angleLowerCase = angle?.toLowerCase();\n  let start = { x: 0, y: 1 };\n  let end = { x: 1, y: 1 };\n\n  if (angle === '0deg' || angleLowerCase === 'to top') {\n    end.x = 0;\n    end.y = 0;\n  } else if (angle === '90deg' || angleLowerCase === 'to right') {\n    start.x = 0;\n  } else if (angle === '180deg' || angleLowerCase === 'to bottom') {\n    start.y = 0;\n    end.x = 0;\n    end.y = 1;\n  } else if (angle === '270deg' || angleLowerCase === 'to left') {\n    start.x = 1;\n    end.x = 0;\n  } else {\n    // other angle\n  }\n\n  return {start, end}\n}\n\nexport const parseProgressBarLinearGradient = (gradient: string) => {\n  let angle = '', color1 = '', color2 = '';\n  const linearGradientRegex = /linear-gradient\\(([^,]+),\\s*([^,]+),\\s*([^)]+)\\)/;\n  const hasLinearGradient = linearGradientRegex.test(gradient);\n\n  const matches = gradient?.match(linearGradientRegex);\n  angle = matches?.[1] || '90deg';\n  const {start, end} = getProgressBarGradientStartEnd(angle)\n  color1 = matches?.[2] || ThemeVariables.INSTANCE.primaryColor;\n  color2 = matches?.[3] || ThemeVariables.INSTANCE.primaryColor;\n\n  return {hasLinearGradient, color1, color2, start, end};\n}\n\n\n\nexport const extractGradientDirection = (gradientString: string): string => {\n  // Check if the gradient string contains a direction or angle\n  const directionMatch = gradientString.match(/linear-gradient\\s*\\(\\s*((?:to\\s+(?:top|bottom|left|right)(?:\\s+(?:left|right))?|[0-9]+(?:deg|grad|rad|turn)))/i);\n  \n  // Return the direction if found, otherwise return default '90deg'\n  return directionMatch ? directionMatch[1] : '90deg';\n};\n\nexport const getGradientStartEnd = (direction: string) => {\n  const directionLowerCase = direction?.toLowerCase();\n  \n  // Default values (to right / 90deg)\n  let start = { x: 0, y: 0 };\n  let end = { x: 1, y: 0 };\n  \n  // Handle standard named directions and common angles first\n  if (direction === '0deg' || directionLowerCase === 'to top') {\n    start = { x: 0, y: 1 };\n    end = { x: 0, y: 0 };\n  } else if (direction === '90deg' || directionLowerCase === 'to right') {\n    start = { x: 0, y: 0 };\n    end = { x: 1, y: 0 };\n  } else if (direction === '180deg' || directionLowerCase === 'to bottom') {\n    start = { x: 0, y: 0 };\n    end = { x: 0, y: 1 };\n  } else if (direction === '270deg' || directionLowerCase === 'to left') {\n    start = { x: 1, y: 0 };\n    end = { x: 0, y: 0 };\n  } else if (direction === '45deg' || directionLowerCase === 'to top right') {\n    start = { x: 0, y: 1 };\n    end = { x: 1, y: 0 };\n  } else if (direction === '135deg' || directionLowerCase === 'to bottom right') {\n    start = { x: 0, y: 0 };\n    end = { x: 1, y: 1 };\n  } else if (direction === '225deg' || directionLowerCase === 'to bottom left') {\n    start = { x: 1, y: 0 };\n    end = { x: 0, y: 1 };\n  } else if (direction === '315deg' || directionLowerCase === 'to top left') {\n    start = { x: 1, y: 1 };\n    end = { x: 0, y: 0 };\n  } else if (direction.match(/\\d+(?:deg|grad|rad|turn)$/)) {\n    // Handle custom angles\n    let angleInDegrees = 0;\n    \n    if (direction.endsWith('deg')) {\n      angleInDegrees = parseFloat(direction);\n    } else if (direction.endsWith('grad')) {\n      // 1 grad = 0.9 degrees\n      angleInDegrees = parseFloat(direction) * 0.9;\n    } else if (direction.endsWith('rad')) {\n      // 1 rad = 180/\u03c0 degrees\n      angleInDegrees = parseFloat(direction) * (180 / Math.PI);\n    } else if (direction.endsWith('turn')) {\n      // 1 turn = 360 degrees\n      angleInDegrees = parseFloat(direction) * 360;\n    }\n    \n    // Normalize angle to [0, 360)\n    angleInDegrees = ((angleInDegrees % 360) + 360) % 360;\n    \n    // Convert angle to radians for calculations\n    // Note: CSS angles follow the polar coordinate system where 0deg points up (north)\n    // and increases clockwise. We adjust by adding 270 to match this convention.\n    const adjustedAngle = ((angleInDegrees + 270) % 360) * (Math.PI / 180);\n    \n    // Calculate end point on a unit circle\n    const endX = Math.cos(adjustedAngle);\n    const endY = Math.sin(adjustedAngle);\n    \n    // Normalize to ensure the vector length is correct and fits in our coordinate system\n    const vectorLength = Math.sqrt(endX * endX + endY * endY);\n    \n    // Set start at center point (0.5, 0.5) and calculate end point\n    start = { \n      x: 0.5 - (endX / vectorLength) * 0.5,\n      y: 0.5 - (endY / vectorLength) * 0.5\n    };\n    \n    end = { \n      x: 0.5 + (endX / vectorLength) * 0.5, \n      y: 0.5 + (endY / vectorLength) * 0.5 \n    };\n  }\n  \n  return { start, end };\n};\n\nexport const getGradientColorStops = (gradientString: string): number[] => {\n  // Check if input is valid\n  if (!gradientString) return [];\n  \n  // Extract the content inside linear-gradient()\n  const match = gradientString.match(/linear-gradient\\s*\\((.*)\\)/);\n  if (!match) return [];\n  \n  const content = match[1];\n  \n  // Remove angle/direction part if present\n  const withoutDirection = content.replace(/^(to\\s+\\w+(?:\\s+\\w+)?|[0-9]+(?:deg|grad|rad|turn))\\s*,\\s*/, '');\n  \n  // Split by commas that are not inside parentheses\n  let depth = 0;\n  let currentSegment = '';\n  const segments = [];\n  \n  for (let i = 0; i < withoutDirection.length; i++) {\n    const char = withoutDirection[i];\n    \n    if (char === '(') depth++;\n    else if (char === ')') depth--;\n    else if (char === ',' && depth === 0) {\n      segments.push(currentSegment.trim());\n      currentSegment = '';\n      continue;\n    }\n    \n    currentSegment += char;\n  }\n  \n  // Don't forget the last segment\n  if (currentSegment.trim()) {\n    segments.push(currentSegment.trim());\n  }\n  \n  // Check if any segments have percentages\n  const hasPercentages = segments.some(segment => {\n    return segment.match(/^(?:rgba?\\([^)]+\\)|hsla?\\([^)]+\\)|#[0-9a-fA-F]{3,8}|\\w+)\\s+\\d+(?:\\.\\d+)?%$/);\n  });\n  \n  // If no percentages are defined, return an empty array\n  if (!hasPercentages) return [];\n  \n  // Parse each segment into color and position\n  const colorStops = segments.map((segment, index) => {\n    // Match color and optional percentage position\n    const match = segment.match(/^(?:rgba?\\([^)]+\\)|hsla?\\([^)]+\\)|#[0-9a-fA-F]{3,8}|\\w+)(?:\\s+(\\d+(?:\\.\\d+)?)%)?$/);\n    \n    if (match && match[1]) {\n      // If percentage is present, convert to decimal (0-1)\n      const percentage = parseFloat(match[1]);\n      return Math.max(0, Math.min(percentage / 100, 1)); // Clamp between 0 and 1\n    } else {\n      // If no percentage, calculate based on position\n      return segments.length > 1 ? index / (segments.length - 1) : 0;\n    }\n  });\n  \n  //expo linear gradient location props ascendng order validation\n  for (let i = 0; i < colorStops.length - 1; i++) {\n    if (colorStops[i] < colorStops[i - 1]) {\n      return []; // Invalid: not in ascending order return empty array\n    }\n  }\n  return colorStops;\n};\n\nexport const getGradientColors = (gradientString: string): string[] => {\n  // Check if input is valid\n  if (!gradientString) return [];\n  \n  // Extract the content inside linear-gradient()\n  const match = gradientString.match(/linear-gradient\\s*\\((.*)\\)/);\n  if (!match) return [];\n  \n  const content = match[1];\n  \n  // Remove angle/direction part if present\n  const withoutDirection = content.replace(/^(to\\s+\\w+(?:\\s+\\w+)?|[0-9]+(?:deg|grad|rad|turn))\\s*,\\s*/, '');\n  \n  // Split by commas that are not inside parentheses\n  let depth = 0;\n  let currentSegment = '';\n  const segments = [];\n  \n  for (let i = 0; i < withoutDirection.length; i++) {\n    const char = withoutDirection[i];\n    \n    if (char === '(') depth++;\n    else if (char === ')') depth--;\n    else if (char === ',' && depth === 0) {\n      segments.push(currentSegment.trim());\n      currentSegment = '';\n      continue;\n    }\n    \n    currentSegment += char;\n  }\n  \n  // Don't forget the last segment\n  if (currentSegment.trim()) {\n    segments.push(currentSegment.trim());\n  }\n  \n  // Extract just the color part from each segment\n  return segments.map(segment => {\n    const match = segment.match(/^((?:rgba?\\([^)]+\\)|hsla?\\([^)]+\\)|#[0-9a-fA-F]{3,8}|\\w+))/);\n    return match ? match[1] : segment;\n  });\n};\n\n\n\nexport const parseLinearGradient = (gradient: string)   => {\n  // Check if this is a valid linear gradient\n  const hasLinearGradient = /linear-gradient\\s*\\(/i.test(gradient);\n  \n  if (!hasLinearGradient || !gradient)  return{\n    hasLinearGradient: false,\n    color1: '',\n    color2: '',\n    start: { x: 0, y: 0 },\n    end: { x: 1, y: 0 },\n    gradientColors: [],\n    colorStops: []\n  }\n  \n  // Extract direction/angle\n  const direction = extractGradientDirection(gradient);\n  \n  // Get start and end points\n  const { start, end } = getGradientStartEnd(direction);\n  \n  // Get colors\n  let gradientColors = getGradientColors(gradient);\n  \n  // Get color stops in the format [[0, 0.5], [0.5, 1]]\n  const colorStops = getGradientColorStops(gradient);\n  \n  // For backward compatibility, extract color1 and color2\n  const color1 = gradientColors.length > 0 ? gradientColors[0] : ThemeVariables?.INSTANCE?.primaryColor || '#000000';\n  const color2 = gradientColors.length > 1 ? gradientColors[gradientColors.length - 1] : color1;\n\n  const defaultColor = ThemeVariables?.INSTANCE?.primaryColor\n\n  gradientColors = gradientColors.length >= 2 ? gradientColors : [defaultColor,defaultColor]\n \n  return { \n    hasLinearGradient, \n    color1, \n    color2, \n    start, \n    end, \n    gradientColors,\n    colorStops,\n  };\n};\n\nexport const validateInputOnDevice = (value: string, type: 'number' | 'currency') => {\n  const isCurrencyField = type === 'currency';\n  let isValidText = true;\n  let validText = value;\n\n  // * no alphabets except E, may contain E only once\n  if (/[a-df-zA-DF-Z]/.test(value) || !/^[^eE]*[eE]?[^eE]*$/.test(value)) {\n    isValidText = false;\n    validText = validText.replace(/[a-df-zA-DF-Z]/g, '');\n    validText = validText.replace(/([eE])\\1+/g, 'e');\n  }\n\n  // * currency only: check for negative number\n  if (isCurrencyField && (Number(value) < 0 || /-/g.test(value))) {\n    isValidText = false;\n    validText = validText.replace(/-/g, '');\n  }\n\n  // * number only: not more than one minus and doesn't end with minus (-)\n  if (!isCurrencyField && (Number(value.match(/-/g)?.length) > 1) || /\\w-/.test(value)) {\n    isValidText = false;\n    validText = validText.replace(/-/g, '');\n    validText = validText.replace(/\\w-/g, '');\n  }\n\n  // * check for more than one decimal point\n  if (/^\\d*\\.\\d*\\..*$/.test(value)) {\n    isValidText = false;\n    validText = validText.replace(/\\.(?=\\.*\\.)/g, '');\n  }\n\n  // * check for spaces and comma\n  if (/[\\s,]/.test(value)) {\n    isValidText = false;\n    validText = validText.replace(/[\\s,]/, '');\n  }\n\n  return { isValidText, validText };\n}\n\nexport const isDateFormatAsPerPattern = (\n  datePattern?: string,\n  dateString?: string | Date\n) => {\n  try {\n    // * format dateString as per datePattern\n    const date = moment(dateString, datePattern, true);\n\n    // * check date is valid and matches the format\n    return date.isValid() && typeof dateString === 'string' && dateString?.toUpperCase() === date.format(datePattern)?.toUpperCase();\n  } catch (error) {\n    // * if not able to parse date string\n    return false;\n  }\n};\n\nexport const getMimeType = (extensions?: string) => {\n  if (!extensions) return '*/*';\n  let hasInvalidExtension = false;\n  let wildCards = ['image/*', 'audio/*', 'video/*'];\n  let extensionList = extensions.split(' ');\n  let mimeType = extensionList\n    .map((extension: string) => {\n      let type = mime.lookup(extension);\n      let isWildCardExtension = wildCards.includes(extension);\n      // * invalid extension, also not in wildcards\n      hasInvalidExtension = !type && !isWildCardExtension;\n      return type ? type : isWildCardExtension ? extension : '';\n    })\n    .filter((type) => type);\n\n  if (hasInvalidExtension) return '*/*';\n  return mimeType;\n};\n\nexport function getNumberOfEmptyObjects(noOfItems: number) {\n  return Array.from({ length: noOfItems }, () => ({}));\n}\n\nexport const setPosition = (data: { [index: string]: {x: number, y: number} }): void => {\n  Object.keys(data).forEach((key: string):void => {\n    if(AppLayoutPosition?.data?.[AppLayoutPosition?.currentPage]){\n      AppLayoutPosition.data[AppLayoutPosition.currentPage][key] = data[key]\n    }\n  })\n}\n\nexport const getPosition = (key: string): { x: number, y: number } => {\n  return AppLayoutPosition.data[AppLayoutPosition.currentPage][key];\n}\n\nexport const setCurrentPageInAppLayout = (pageName: string): void => {\n  AppLayoutPosition.currentPage = pageName;\n  AppLayoutPosition.data[pageName] = {};\n}\n", "wavemaker-rn-runtime/src/core/props.provider.ts": "import { assign, isNil } from \"lodash-es\";\nimport { BaseProps } from \"./base.component\";\n\nexport class PropsProvider<T extends BaseProps> {\n    private oldProps: any = {};\n    private overriddenProps: any = {};\n    private propsProxy: T;\n    private isDirty = false;\n    private propertyNames = {} as any;\n\n    constructor(private defaultProps: T, private initprops: T, private onChange = (name: string, $new: any, $old: any) => {}) {\n        this.initprops = this.initprops || {};\n        Object.keys(defaultProps).forEach(k => this.propertyNames[k] = true);\n        Object.keys(initprops).forEach(k => this.propertyNames[k] = true);\n        //@ts-ignore\n        this.propsProxy = (new Proxy({}, {\n            get: (target, prop, receiver): any => {\n                const propName = prop.toString();\n                let value = (this.defaultProps as any)[propName];\n                if (this.overriddenProps.hasOwnProperty(propName)) {\n                    value = this.overriddenProps[propName];\n                } else if (this.oldProps.hasOwnProperty(propName)) {\n                    value = this.oldProps[propName];\n                }\n                return value;\n            },\n            set: (target: any, prop, value: any): any => {\n                const propName = prop.toString();\n                if (!this.has(propName)) {\n                    return true;\n                }\n                this.isDirty = this.isDirty || this.overriddenProps[propName] !== value;\n                this.overriddenProps[propName] = value;\n                if (this.oldProps[propName] !== value) {\n                    const oldValue = this.oldProps[propName];\n                    this.onChange(propName, value, oldValue);\n                    this.oldProps[propName] = value;\n                }\n                return true;\n            }\n        }));\n    }\n\n    setDefault(propName: string, value: any) {\n        (this.defaultProps as any)[propName] = value;\n    }\n    overrideProp(propName: string, value: any) {\n        (this.overriddenProps as any)[propName] = value;\n        this.isDirty = true;\n    }\n\n    check(nextProps?: T) {\n        if (!nextProps) {\n            nextProps = assign({}, this.defaultProps, this.initprops);\n        }\n        const result = Object.keys(nextProps).reduce((b, k) => {\n            let flag = false;\n            //@ts-ignore\n            const value = nextProps[k];\n            const oldValue = this.oldProps[k];\n            if (isNil(this.overriddenProps[k])\n                && (!this.oldProps.hasOwnProperty(k)\n                    || this.oldProps[k] !== value)) {\n                this.oldProps[k] = value;\n                this.onChange(k, value, oldValue);\n                flag = true;\n            }\n            return b || flag;\n        }, false) || this.isDirty;\n\n      this.isDirty = false;\n      return result;\n    }\n\n    // sets the property. But, value gets overriden when the original prop changes.\n    set(name: string, value: any) {\n        const oldValue = this.oldProps[name];\n        if(oldValue !== value) {\n            this.oldProps[name] = value;\n            this.onChange(name, value, oldValue);\n        }\n    }\n\n    has(propName: string) {\n        return !!this.propertyNames[propName];\n    }\n\n    get() {\n        return this.propsProxy;\n    }\n}\n", "wavemaker-rn-runtime/src/core/viewport.ts": "import { Dimensions } from \"react-native\";\nimport EventNotifier from \"./event-notifier\";\n\n\nexport const SCREEN_ORIENTATION = {\n    LANDSCAPE: 'LANDSCAPE',\n    PORTRAIT: 'PORTRAIT'\n};\n\nexport const EVENTS = {\n    ORIENTATION_CHANGE: 'orientationChange',\n    SIZE_CHANGE: 'sizeChange'\n};\n\nexport class ViewPort extends EventNotifier {\n    public width: number;\n    public height: number;\n    public orientation: string;\n    public isMobileType = true;\n\n    constructor() {\n        super();\n        const dim = Dimensions.get('window');\n        this.width = dim.width;\n        this.height = dim.height;\n        this.orientation = this.width > this.height ? SCREEN_ORIENTATION.LANDSCAPE: SCREEN_ORIENTATION.PORTRAIT;\n        Dimensions.addEventListener('change', () => {\n            const dim = Dimensions.get('window');\n            const orientation = dim.width > dim.height ? SCREEN_ORIENTATION.LANDSCAPE: SCREEN_ORIENTATION.PORTRAIT;\n            this.notify(EVENTS.SIZE_CHANGE, [\n                {width: dim.width, height: dim.height}, \n                {width: this.width, height: this.height}\n            ]);\n            this.width = dim.width;\n            this.height = dim.height;\n            if (this.orientation != orientation) {\n                this.notify(EVENTS.ORIENTATION_CHANGE, [orientation, this.orientation]);\n                this.orientation = orientation;\n            }\n        });\n    }\n}\n\nexport default new ViewPort();", "wavemaker-rn-runtime/src/core/display.manager.ts": "import React from 'react';\n\nexport interface DisplayOptions {\n  content: React.ReactNode;\n  onDestroy?: () => any;\n}\n\nexport interface DisplayManager {\n  show: (options: DisplayOptions) => any;\n  destroy: () => any;\n}\n\nconst DisplayContext = React.createContext<DisplayManager>(null as any);\n\nexport const DisplayProvider = DisplayContext.Provider;\nexport const DisplayConsumer = DisplayContext.Consumer;\n", "wavemaker-rn-runtime/src/core/tappable.component.tsx": "import { BaseComponent } from \"@wavemaker/app-rn-runtime/core/base.component\";\nimport React from \"react\";\nimport { GestureResponderEvent, Platform, View, TouchableOpacity } from \"react-native\";\nimport { get } from \"lodash\";\nimport injector from \"./injector\";\nimport { TouchableRipple } from \"react-native-paper\";\nimport ThemeVariables from \"../styles/theme.variables\";\nimport { isDefined } from \"./utils\";\n\nexport const TappableContext = React.createContext<Tappable>(null as any);\nimport { UIPreferencesConsumer, UI_PREFERENCES } from \"./ui-preferences.context\";\n\nexport const ParentTappableContext = React.createContext<Tappable>(null as any);\ninterface TappableProps {\n    testID?: string;\n    children?: any\n    styles?: any;\n    target?: BaseComponent<any, any, any>;\n    onTap?: (e: any) => void;\n    onLongTap?: (e: any) => void; \n    onDoubleTap?: (e: any) => void;\n    onTouchStart? : (e: any) => void;\n    onTouchEnd? : (e: any) => void;\n    rippleColor?: string;\n    accessibilityProps?: any;\n    disableTouchEffect?:boolean;\n    onLayout?: any;\n}\n\nexport class SyntheticEvent {\n    // as the event is being used in onPress, onPressOut and onLongTap the TapEvent is renamed to SyntheticEvent\n    propagationEnabled = true;\n   \n    constructor() {\n\n    }\n\n    stopPropagation() {\n        this.propagationEnabled = false;\n    }\n}\n\nexport class Tappable extends React.Component<TappableProps, any> {\n    private lastPress = 0;\n    private lastTap = 0;\n    private lastDoubleTap = 0;\n    private isLongTap = false;\n    private parent:Tappable = null as any;\n   \n    constructor(props: any) {\n        super(props);\n    }\n\n    async triggerTap(e = new SyntheticEvent()) {\n        if (!e.propagationEnabled) {\n            return;\n        }\n        const target = this.props.target;\n        if (this.props.onTap) {\n            await this.props.onTap(e);\n        } else {\n            await target?.invokeEventCallback('onTap', [e, target]);\n        }\n        this.parent?.triggerTap(e);\n    }\n\n    onPress(e: SyntheticEvent): void {   \n        this.lastPress = Date.now();\n        const target = this.props.target;\n        this.props.onTouchStart && this.props.onTouchStart(e);\n        this.props.target?.invokeEventCallback('onTouchstart', [e, this.props.target]);\n        const currentTime = Date.now();\n        const tapDelta = currentTime - this.lastTap;\n        if (this.isLongTap) {\n            this.isLongTap = false;\n            return;\n        }\n        if (e.propagationEnabled) {\n            injector.FOCUSED_ELEMENT.get()?.blur();\n            if(this.lastDoubleTap !== this.lastTap \n                && tapDelta < 500) {\n                this.props.onDoubleTap && this.props.onDoubleTap(e);\n                setTimeout(() => {\n                    target?.invokeEventCallback('onDoubletap', [e, target]);\n                }, 200);\n                this.lastDoubleTap = currentTime;\n            }\n            setTimeout(() => {\n                if (!e.propagationEnabled) {\n                    return;\n                }\n                if (this.props.onTap) {\n                    this.props.onTap(e);\n                } else {\n                    target?.invokeEventCallback('onTap', [e, target]);\n                }\n                this.parent?.onPress(e);\n            }, 200);\n            this.lastTap = currentTime;\n        }\n    }\n\n    onLongTap(e: SyntheticEvent): void {\n        if(!e.propagationEnabled){\n            return;\n        }\n        this.props.onLongTap && this.props.onLongTap(e);\n        setTimeout(() => {\n            this.props.target?.invokeEventCallback('onLongtap', [e, this.props.target]);\n            this.parent?.onPressOut(e);\n        }, 200);\n        this.isLongTap = true;\n    }\n    \n    onPressOut(e: SyntheticEvent): void {\n        if(!e.propagationEnabled){\n            return;\n        } \n        this.props.onTouchEnd && this.props.onTouchEnd(e);\n        setTimeout(() => {\n            this.props.target?.invokeEventCallback('onTouchend', [e, this.props.target]);\n            this.parent?.onPressOut(e);\n        }, 200);\n        this.isLongTap = false;\n    }\n    private setParent(parent: Tappable) {\n        if (parent && this.parent !== parent)  {\n            this.parent = parent;\n        }\n    }\n\n    render() {\n        const target = this.props.target;\n        const commonProps = {\n            ...(Platform.OS === 'android' || Platform.OS === 'web') ? {\n                accessibilityLabel: this.props.testID,\n                testID: this.props.testID\n            }: {\n                // accessible: false,\n                testID: this.props.testID\n            },\n            ...this.props.accessibilityProps,\n            disabled:get(target?.proxy, 'disabled'),\n            style:this.props.styles,\n            onPress:(e?: GestureResponderEvent) => {\n                if ((e?.target as any)?.tagName === 'INPUT') {\n                    return;\n                }\n                this.onPress(new SyntheticEvent())\n            },\n            onLongPress:(e?: GestureResponderEvent) => this.onLongTap(new SyntheticEvent()),\n            onPressOut:(e?: GestureResponderEvent) => this.onPressOut(new SyntheticEvent())\n        };\n        if (target?.props.onTap \n            || target?.props.onLongtap \n            || target?.props.onDoubletap \n            || this.props.onTap \n            || this.props.onLongTap \n            || this.props.onDoubleTap) {\n            return (\n            <UIPreferencesConsumer>\n                {(preferences: UI_PREFERENCES) => {\n                    return preferences.enableRipple != false ? (\n                        <ParentTappableContext.Consumer>{(parent) => {\n                            this.setParent(parent);\n                            return(\n                                <ParentTappableContext.Provider value={this}>\n                                    <TouchableRipple \n                                        rippleColor={this.props.disableTouchEffect ? \"transparent\" : this.props.rippleColor} \n                                        borderless={true} \n                                        {...commonProps}\n                                        onLayout={this.props.onLayout}\n                                    >\n                                        <>{this.props.children}</>\n                                    </TouchableRipple>\n                                </ParentTappableContext.Provider>\n                            )\n                        }}</ParentTappableContext.Consumer>): (\n                        //default value is 0.2\n                        <TouchableOpacity \n                            activeOpacity={this.props.disableTouchEffect ? 1 : 0.2} \n                            onLayout={this.props.onLayout}\n                            {...commonProps}\n                        >\n                            <>{this.props.children}</>\n                        </TouchableOpacity>);\n                }}\n            </UIPreferencesConsumer>\n            );\n        }\n        return (\n            <View \n                style={this.props.styles}\n                onLayout={this.props.onLayout}\n            >\n                {this.props.children}\n            </View>);\n    }\n}\n", "wavemaker-rn-runtime/src/core/ui-preferences.context.ts": "import React from \"react\";\n\nexport interface UI_PREFERENCES {\n    enableRipple: boolean;\n}\n  \nconst UIPreferencesContext = React.createContext<UI_PREFERENCES>({enableRipple: true});\n\nexport const UIPreferencesProvider = UIPreferencesContext.Provider;\nexport const UIPreferencesConsumer = UIPreferencesContext.Consumer;", "wavemaker-rn-runtime/src/core/injector.ts": "import { I18nService } from \"./i18n.service\";\n\nconst map = new Map<string, any>();\n\nconst get = <T>(t :string): T => {\n    return map.get(t) as T;\n};\n\nconst set = <T>(t :string, o: T) => {\n    map.set(t, o);\n};\n\nconst remove =  <T>(t :string): T => {\n    const v = map.get(t) as T;\n    v && map.delete(t);\n    return v;\n};\n\nconst getInstance = <T>(key: string) => {\n    return {\n        set: (o: T) => set(key, o),\n        get: () => get(key) as T,\n        remove: () => remove(key) as T\n    }\n};\nexport default {\n    set: set,\n    get: get,\n    remove: remove,\n    FOCUSED_ELEMENT: getInstance<any>('FOCUSED_ELEMENT'),\n    I18nService: getInstance<I18nService>('I18nService')\n};", "wavemaker-rn-runtime/src/core/base.component.tsx": "import { assign, isUndefined, isNil } from 'lodash';\nimport React, { ReactNode } from 'react';\nimport { AccessibilityInfo, LayoutChangeEvent, Platform, StyleSheet, TextStyle, View, ViewStyle, InteractionManager } from 'react-native';\nimport { AnimatableProps } from 'react-native-animatable';\nimport * as Animatable from 'react-native-animatable';\nimport ThemeVariables from '@wavemaker/app-rn-runtime/styles/theme.variables';\nimport { StyleProps, getStyleName } from '@wavemaker/app-rn-runtime/styles/style-props';\nimport { BackgroundComponent } from '@wavemaker/app-rn-runtime/styles/background.component';\nimport injector from '@wavemaker/app-rn-runtime/core/injector';\nimport { ROOT_LOGGER } from '@wavemaker/app-rn-runtime/core/logger';\nimport { deepCopy, getPosition, setPosition } from '@wavemaker/app-rn-runtime/core/utils';\nimport BASE_THEME, { NamedStyles, AllStyle, ThemeConsumer, ThemeEvent, Theme } from '../styles/theme';\nimport EventNotifier from './event-notifier';\nimport { PropsProvider } from './props.provider';\nimport { assignIn } from 'lodash-es';\nimport { HideMode } from './if.component';\nimport { AssetConsumer } from './asset.provider';\nimport { FixedView } from './fixed-view.component';\nimport { TextIdPrefixConsumer } from './testid.provider';\nimport { isScreenReaderEnabled } from './accessibility';\nimport { Tappable, TappableContext } from './tappable.component';\nimport { WmComponentNode } from './wm-component-tree';\n\nexport const WIDGET_LOGGER = ROOT_LOGGER.extend('widget');\n\nexport const ParentContext = React.createContext(null as any);\n\nexport class BaseComponentState<T extends BaseProps> {\n    public animationId?: number = 0;\n    public animatableProps?: AnimatableProps<ViewStyle> = undefined;\n    public props = {} as T;\n    public hide? = false;\n    public highlight? = false;\n}\n\nexport type BaseStyles = NamedStyles<any> & {\n    root: AllStyle,\n    text: TextStyle & {userSelect?: 'none'| 'text'}\n}\n\nexport function defineStyles<T>(styles: T): T {\n    return deepCopy({\n        text: {\n            fontFamily: ThemeVariables.INSTANCE.baseFont,\n            userSelect: 'text'\n        }\n    }, styles);\n}\n\nexport interface LifecycleListener {\n    onComponentChange?: (c: BaseComponent<any, any, any>) => void;\n    onComponentInit?: (c: BaseComponent<any, any, any>) => void;\n    onComponentDestroy?: (c: BaseComponent<any, any, any>) => void;\n}\n\ninterface Layout {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    px: number;\n    py: number;\n}\n\nexport class BaseProps extends StyleProps {\n    id?: string = null as any;\n    name?: string = null as any;\n    key?: any = null as any;\n    disabled? = false;\n    show? = true as Boolean | String | Number;\n    styles?: any = null;\n    classname?: string = null as any;\n    listener?: LifecycleListener = null as any;\n    showindevice?: ('xs'|'sm'|'md'|'lg'|'xl'|'xxl')[] = null as any;\n    showskeleton?: boolean = undefined;\n    deferload?: boolean = false;\n    showskeletonchildren?: boolean = true;\n    disabletoucheffect?:boolean = false;\n    isdefault?: boolean = false;\n}\n\nexport abstract class BaseComponent<T extends BaseProps, S extends BaseComponentState<T>, L extends BaseStyles> extends React.Component<T, S> {\n    public styles: L = null as any;\n    public hideMode = HideMode.ADD_TO_DOM;\n    private propertyProvider: PropsProvider<T>;\n    public proxy: BaseComponent<T, S, L>;\n    public _INSTANCE: BaseComponent<T, S, L>;\n    public initialized = false;\n    public cleanup = [] as Function[];\n    public theme = BASE_THEME;\n    public updateStateTimeouts= [] as NodeJS.Timeout[];\n    public parent: BaseComponent<any, any, any> = null as any;\n    public destroyed = false;\n    public _showSkeleton = false;\n    public isFixed = false;\n    public isSticky = false;\n    private notifier = new EventNotifier();\n    private parentListenerDestroyers = [] as Function[];\n    public _background = <></>;\n    private styleOverrides = {} as any;\n    public loadAsset: (path: string) => number | string = null as any;\n    private i18nService = injector.I18nService.get();\n    public testIdPrefix = '';\n    private _showView = true;\n    public closestTappable?: Tappable;   \n    public componentNode: WmComponentNode;\n    public layout: Layout = {\n        x: 0, y:0, width:0, height:0, px:0, py:0\n    };\n    public baseView: any = View;\n\n    constructor(markupProps: T, public defaultClass: string, defaultProps?: T, defaultState?: S) {\n        super(markupProps);\n        this.state = (defaultState || {} as S);\n        this.notifier.name = this.props.name || '';\n        this.componentNode = new WmComponentNode({\n            instance: this\n        });\n        this.propertyProvider = new PropsProvider<T>(\n            assign({show: true}, defaultProps),\n            assign({}, markupProps),\n            (name: string, $new: any, $old: any) => {\n                WIDGET_LOGGER.debug(() => `${this.props.name || this.constructor.name}: ${name} changed from ${$old} to ${$new}`);\n                if (this.initialized) {\n                    const styleName = getStyleName(name);\n                    if (styleName) {\n                        if ($new === undefined) {\n                            delete this.styleOverrides[styleName];\n                        } else {\n                            this.styleOverrides[styleName] = $new;\n                        }\n                    }\n                }\n                if (name === 'showskeleton' && this.initialized) {\n                    setTimeout(() => this.cleanRefresh(), 100);\n                }\n                this.onPropertyChange(name, $new, $old);\n            });\n        //@ts-ignore\n        this.state.props =this.propertyProvider.get();\n        this._INSTANCE = this;\n        //@ts-ignore\n        this._showView = !this.props.deferload;\n        this.propertyProvider.check();\n        //@ts-ignore\n        this.proxy = (new Proxy(this, {\n            get: (target, prop, receiver): any => {\n                const propName = prop.toString();\n                if (this.propertyProvider.has(propName)) {\n                    //@ts-ignore\n                    return this.state.props[propName];\n                }\n                return Reflect.get(target, prop, receiver);\n            },\n            set: (target: any, prop, value: any): any => {\n                const propName = prop.toString();\n                if (this.propertyProvider.has(propName)) {\n                    // @ts-ignore\n                    const props = {} as any;\n                    this.propertyProvider.overrideProp(propName, value);\n                    props[propName] = value;\n                    this.updateState({\n                        props: props\n                    } as S);\n                    return true;\n                } else {\n                    return Reflect.set(target, prop, value);\n                }\n            }\n        }));\n        this.cleanup.push(() => {\n            this.updateStateTimeouts.forEach(v => clearTimeout(v));\n        });\n        this.cleanup.push(this.theme.subscribe(ThemeEvent.CHANGE, () => {\n            this.forceUpdate();\n        }));\n        this.cleanup.push(AccessibilityInfo.addEventListener('screenReaderChanged',\n            () => {\n              setTimeout(() => {\n                this.forceUpdate();\n              }, 100);\n            },\n        ).remove);\n        this.cleanup.push(() => {\n            this.destroyParentListeners();\n        });\n    }\n\n    public subscribe(event: string, fn: Function) {\n        return this.notifier.subscribe(event, fn);\n    }\n\n    public notify(event: string, args: any[], emitToParent = false) {\n        return this.notifier.notify(event, args, emitToParent);\n    }\n\n    public get isRTL(){\n        return this.i18nService.isRTLLocale();\n    }\n\n    public animate(props: AnimatableProps<ViewStyle>) {\n        this.setState({\n            animationId: Date.now(),\n            animatableProps: props\n        });\n    }\n\n    setProp(propName: string, value: any) {\n        this.propertyProvider.set(propName, value);\n        this.updateState({props: {}} as S);\n    }\n\n    setPropDefault(propName: string, value: any) {\n        this.propertyProvider.setDefault(propName, value);\n    }\n    \n    onPropertyChange(name: string, $new: any, $old: any) {        \n    }\n     \n    getDefaultStyles() {\n        return this.theme.getStyle(this.defaultClass);\n    }\n\n    reset() {\n\n    }\n\n    updateState(newPartialState: S, callback?: ()=>void) {\n        if (this.destroyed) {\n            return;\n        }\n        const stateFn = (oldState: S) => {\n            const oldProps = oldState.props;\n            const newState = this.initialized ? assignIn({}, oldState, newPartialState) : assignIn(oldState, newPartialState);\n            if (newPartialState.props) {\n                Object.keys(newPartialState.props).forEach((k) => {\n                    //@ts-ignore\n                    oldProps[k] = newState.props[k];\n                });\n            newState.props = oldProps;\n            }\n            return newState;\n        };\n        const onUpdateState = () => {\n            callback && callback();\n            this.props.listener?.onComponentChange\n                && this.props.listener?.onComponentChange(this);\n        }\n        if (!this.initialized) {\n            this.state = stateFn(this.state);\n            onUpdateState();\n        } else {\n            const timeoutId = setTimeout(() => {\n                this.setState(stateFn, onUpdateState);\n                this.updateStateTimeouts.splice(this.updateStateTimeouts.indexOf(timeoutId), 1);\n            });\n            this.updateStateTimeouts.push(timeoutId);\n        }\n    }\n\n    shouldComponentUpdate(nextProps: T, nextState: S, nextContext: any) {\n        if (this.propertyProvider.check(nextProps)) {\n            return true;\n        }\n        for(let key in nextState) {\n            if(key !== 'props' && (!(key in this.state) || nextState[key] !== this.state[key])) {\n                return true;\n            }\n        }\n\n        for(let key in this.state) {\n            if(key !== 'props' && (!(key in nextState) || this.state[key] !== nextState[key])) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    componentDidMount() {\n        if (this.props.listener && this.props.listener.onComponentInit) {\n            this.props.listener.onComponentInit(this.proxy);\n        }\n        this.initialized = true;\n    }\n\n    componentWillAttach() {\n        if (this.isFixed || this.isSticky) {\n            this.setState({hide: false});\n        }\n    }\n\n    componentWillDetach() {\n        if (this.isFixed || this.isSticky) {\n            this.setState({hide: true});\n        }\n    }\n\n    componentWillUnmount() {\n        this.destroyed = true;\n        if (this.props.listener && this.props.listener.onComponentDestroy) {\n            this.props.listener.onComponentDestroy(this.proxy);\n        }\n        this.cleanup.forEach(f => f && f());\n        this.parent?.componentNode?.remove(this.componentNode);\n        this.notifier.destroy();\n        this.notifier.notify('destroy', []);\n    }\n    \n    componentDidUpdate(prevProps: Readonly<T>, prevState: Readonly<S>, snapshot?: any): void {\n        if (this.propertyProvider.check(this.props)) {\n            this.forceUpdate();\n        }\n    }\n\n    invokeEventCallback(eventName: string, args: any[]) {\n        //@ts-ignore\n        const callBack: Function = this.props[eventName];\n        args = args && args.map(a => (a === this) ? this.proxy : a)\n        if (callBack) {\n            try {\n              return callBack.apply(this.proxy, args);\n            } catch(e) {\n                console.error(e);\n            }\n        }\n    }\n\n    showView() {\n        return this.isVisible();\n    }\n\n    isVisible() {\n        const show = this.state.props.show;\n        return show !== false && show !== 'false' && show !== '0' && !isNil(show) && show !== \"\";\n    }\n\n    protected abstract renderWidget(props: T): ReactNode;\n\n    public refresh() {\n        this.forceUpdate();\n    }\n\n    public cleanRefresh() {\n        this.forceUpdate(() => this.notifier.notify('forceUpdate', []));\n    }\n    \n    public renderSkeleton (props: T): ReactNode {\n        return null;\n    }\n\n    public destroyParentListeners() {\n        this.parentListenerDestroyers.map(fn => fn());\n    }\n\n    protected setParent(parent: BaseComponent<any, any, any>) {\n        if (parent && this.parent !== parent)  {\n            this.parent = parent;\n            this.parent.componentNode.add(this.componentNode);\n            this.notifier.setParent(parent.notifier);\n            this.parentListenerDestroyers = [\n                this.parent.subscribe('forceUpdate', () => {\n                    this.forceUpdate();\n                }),\n                this.parent.subscribe('destroy', () => {\n                    this.destroyParentListeners();\n                })\n            ];\n        }\n    }\n\n    protected getName() {\n        return this.props.name;\n    }\n\n    public handleLayout(event: LayoutChangeEvent, ref: React.RefObject<View> | null = null) {\n        const key = this.getName && this.getName();\n        if(key){\n            const newLayoutPosition = {\n                [key as string]: {\n                    y: event.nativeEvent.layout.y,\n                    x: event.nativeEvent.layout.x\n                }\n            }\n            setPosition(newLayoutPosition);\n            const componentRef = ref !== null ? ref : this.baseView \n            // Layout values by measure\n            if(componentRef?.measure){\n                const updateLayout = ()=>{\n                    componentRef.measure((x = 0, y = 0, width = 0, height = 0, px = 0, py = 0) => {\n                        this.layout = { x, y, width, height, px, py }\n                    }); \n                }\n                updateLayout();\n                InteractionManager.runAfterInteractions(() => {\n                    requestAnimationFrame(updateLayout); \n                })\n            }\n        }\n    }\n    \n    copyStyles(property: string, from: any, to: any) {\n        if (!isUndefined(from[property])) {\n        to[property] = from[property];\n        }\n    }\n\n    renderFixedContainer(props: T) {\n        const style = {} as ViewStyle;\n        const rootStyle = {\n            left: 0,\n            top: 0,\n            bottom: 0,\n            right: 0,\n            width: \"100%\",\n            height: \"100%\"\n        } as ViewStyle;\n        this.copyStyles('left', this.styles.root, style);\n        this.copyStyles('top', this.styles.root, style);\n        this.copyStyles('right', this.styles.root, style);\n        this.copyStyles('bottom', this.styles.root, style);\n        this.copyStyles('width', this.styles.root, style);\n        this.copyStyles('height', this.styles.root, style);\n        this.styles = this.theme.mergeStyle(this.styles, {root: rootStyle});\n        return (<FixedView style={style} theme={this.theme}>{this.addAnimation(this.renderWidget(props))}</FixedView>);\n    }\n\n    private addAnimation(n: ReactNode) {\n        if (!this.state.animatableProps) {\n            return (\n                <>\n                    {n}\n                </>\n            )\n        }\n        return (\n            <Animatable.View \n                key={this.state.animationId} \n                {...this.state.animatableProps}\n            >\n                {n}\n            </Animatable.View>);\n    }\n    \n    private setBackground() {\n        const bgStyle = this.styles.root as any;\n        this._background = (\n            <>\n            <BackgroundComponent \n                image={bgStyle.backgroundImage}\n                position={bgStyle.backgroundPosition}\n                size={bgStyle.backgroundSize}\n                repeat={bgStyle.backgroundRepeat}\n                resizeMode={bgStyle.backgroundResizeMode}\n                style={{borderRadius: this.styles.root.borderRadius}}>\n            </BackgroundComponent>\n            {this.state.highlight ? (<View onTouchStart={() => {\n                this.setState({\n                    highlight: false\n                })\n            }} style={[{\n                borderWidth: 2,\n                overflow: 'hidden',\n                backgroundColor: '#FFFF0033', \n                borderColor: 'orange',\n                borderStyle: 'dashed',\n                zIndex: 1000,\n                borderRadius: 0,\n            }, StyleSheet.absoluteFill]}></View>) : null}\n            </>\n        );\n        delete (this.styles.root as any)['backgroundImage'];\n        delete (this.styles.root as any)['backgroundPosition'];\n        delete (this.styles.root as any)['backgroundResizeMode'];\n        delete (this.styles.root as any)['backgroundSize'];\n        delete (this.styles.root as any)['backgroundRepeat'];\n    }\n\n    public getTestId(suffix?: string) {\n        let id = this.props.id || this.props.name;\n        if (this.testIdPrefix) {\n            id = this.testIdPrefix + '_' + id;\n        }\n        if (suffix) {\n            id = id + '_' + suffix;\n        }\n        return id;\n    }\n\n    public getTestProps(suffix?: string) {\n        let id = this.getTestId(suffix);\n        if (isScreenReaderEnabled()) {\n            return {};\n        }\n        if (Platform.OS === 'android' || Platform.OS === 'web') {\n            return {\n                accessibilityLabel: id,\n                testID: id\n            };\n        }\n        return {\n            accessible: false,\n            testID: id\n        };\n    }\n\n    public getStyleClassName() {\n        return this.state.props.classname;\n    }\n\n    public getTestPropsForInput(suffix?: string) {\n        return this.getTestProps(suffix || 'i');\n    }\n\n    public getTestPropsForAction(suffix?: string) {\n        return this.getTestProps(suffix || 'a');\n    }\n\n    public getTestPropsForLabel(suffix?: string) {\n        return this.getTestProps(suffix || 'l');\n    }\n\n    public getLayoutOfWidget(name: string): {x: number, y: number} | undefined {\n        return getPosition(name)\n    }\n\n    public getLayout() {\n        return this.layout ;\n    }\n\n    public scrollToTop(){\n        this.notify('scrollToPosition', [{\n            x: 0,\n            y: 0\n        }]);\n    }\n\n    public scrollToEnd() {\n        this.notify('scrollToEnd', []);\n    }\n\n    scrollToPosition(widgetName: string) {\n        const positionY = this.getLayoutOfWidget(widgetName)?.y; // Safe access\n        this.notify('scrollToPosition', [{\n            x: 0,\n            y: positionY,\n        }]);\n    }\n\n    public hideSkeletonInPageContentWhenDisabledInPage = () => {\n       const isPageContentWidget = this.defaultClass && this.defaultClass === 'app-page-content'\n       const isCurrentParentIsContent = this.parent && this.parent.defaultClass && this.parent.defaultClass === 'app-content'\n       const showSkeletonInPageContent = this.parent.state?.props?.showskeleton === false\n    \n       if(isPageContentWidget && isCurrentParentIsContent && showSkeletonInPageContent) {\n        return false;\n       }\n       return undefined;\n    }\n \n    private getDependenciesFromContext(fn: () => ReactNode) {\n        return (\n        <TappableContext.Consumer>{(tappable) => {\n            this.closestTappable = tappable;\n            return (\n                <TextIdPrefixConsumer>\n                    {(testIdPrefix) => {\n                        this.testIdPrefix = testIdPrefix || '';\n                        return (<AssetConsumer>\n                            {(loadAsset) => {\n                            this.loadAsset = loadAsset;\n                            return (<ParentContext.Consumer>\n                                {(parent) => {\n                                    this.setParent(parent);\n                                    this._showSkeleton = this.state.props.showskeleton !== false \n                                        && (this.parent?._showSkeleton || this.state.props.showskeleton === true) && this.hideSkeletonInPageContentWhenDisabledInPage() === undefined\n                                    return (\n                                        <ParentContext.Provider value={this}>\n                                            <ThemeConsumer>\n                                                {(theme) => {                                \n                                                    this.theme = theme || BASE_THEME;\n                                                    return fn();\n                                                }}\n                                            </ThemeConsumer>\n                                        </ParentContext.Provider>);\n                                }}    \n                                </ParentContext.Consumer>);\n                            }}\n                        </AssetConsumer>);\n                    }}\n                </TextIdPrefixConsumer>)}}\n        </TappableContext.Consumer>); \n    }\n    \n    public render(): ReactNode {\n        const props = this.state.props;\n        const selectedLocale = this.i18nService.getSelectedLocale();\n        return this.getDependenciesFromContext(() => {\n            WIDGET_LOGGER.info(() => `${this.props.name || this.constructor.name} is rendering.`);\n            this._showView = this._showView || this.showView();\n            if (this.state.hide \n                || (!this.isVisible() && this.hideMode === HideMode.DONOT_ADD_TO_DOM)\n                || !this._showView) {\n                return null;\n            }\n            this.isFixed = false;\n            const classname = this.getStyleClassName();\n            this.styles =  this.theme.mergeStyle(\n                this.getDefaultStyles(),\n                {text: this.theme.getStyle('app-' + selectedLocale)},\n                {text: this.theme.getStyle(this.defaultClass + '-' + selectedLocale)},\n                props.disabled ? this.theme.getStyle(this.defaultClass + '-disabled') : null,\n                this.isRTL ? this.theme.getStyle(this.defaultClass + '-rtl') : null,\n                classname && this.theme.getStyle(classname),\n                props.showindevice && this.theme.getStyle('d-all-none ' + props.showindevice.map(d => `d-${d}-flex`).join(' ')),\n                this.theme.cleanseStyleProperties(this.props.styles),\n                this.theme.cleanseStyleProperties({\n                    root: this.styleOverrides,\n                    text: this.styleOverrides\n                }));\n            if (this.styles.root.hasOwnProperty('_background')) {\n                delete this.styles.root.backgroundColor;\n            }\n            if (!this.isVisible()) {\n                assign(this.styles, this.theme.getStyle('hidden'))\n            }\n            let eleToRender = (this._showSkeleton && this.renderSkeleton(props));\n            if (eleToRender) {\n                return eleToRender;\n            }\n            this.setBackground();\n            this.isFixed = (this.styles.root.position as any) === 'fixed';\n            if (this.isFixed) {\n                this.styles.root.position  = undefined;\n                return this.renderFixedContainer(props);\n            }\n            return this.addAnimation(this.renderWidget(this.state.props));        \n        });\n    }\n}\n", "wavemaker-rn-runtime/src/core/logger.ts": "import { keys, sortBy } from 'lodash-es';\nimport { logger } from 'react-native-logs';\nimport StorageService from './storage.service'\n\nclass LoggerCollection {\n    loggerMap = new Map<string, Logger>();\n    config = {} as any;\n    key = 'wm.log.config';\n\n    init() {\n        StorageService.getItem(this.key).then((data) => {\n            if (data) {\n                this.config = JSON.parse(data as string) || {};\n                keys(this.config).forEach((k: string) => {\n                    this.loggerMap.get(k)?.setLevel(this.config[k].level);\n                });\n            }\n        }).catch(() => {});\n    }\n\n    get(name: string) {\n        return this.loggerMap.get(name);\n    }\n\n    set(name: string, logger: Logger) {\n        this.loggerMap.set(name, logger);\n    }\n\n    setLogLevel(name?: string, level?: string) {\n        if (!level && (name && levels[name] !== undefined)) {\n            level =  name;\n            name = undefined;\n        }\n        if (level !== undefined) {\n            [...this.loggerMap.keys()]\n                .filter(k => !name || k.startsWith(name))\n                .forEach(k => {\n                    level && this.loggerMap.get(k)?.setLevel(level);\n                    if (k) {\n                        this.config[k] =  this.config[k] || {};\n                        this.config[k].level = level;\n                    } \n                });\n                StorageService.setItem(this.key, JSON.stringify(this.config))\n        }\n    }\n\n    getLogLevel(name?: string, level?: string) {\n        return name && this.config[name]?.level;\n    }\n\n    list() {\n        return sortBy([...this.loggerMap.keys()])\n    }\n}\n\nconst levels = {\n    debug: 0,\n    info: 1,\n    warn: 2,\n    error: 3\n} as any;\n\nconst loggerCollection = new LoggerCollection();\n\nconst log = logger.createLogger({\n    severity: 'debug',\n    levels: levels,\n    enabledExtensions: []\n});\n\nexport class Logger {\n\n    private ins = null as any;\n\n    constructor(private name: string, private level: string) {\n        this.ins = log.extend(this.name);\n        log.enable(this.name);\n    }\n\n    private isEnabled(level: string) {\n        return levels[level] >= levels[this.level];\n    }\n\n    private log(level: string, msg: string | Function ) {\n        if (this.isEnabled(level)) {\n            if (msg instanceof Function) {\n                msg = msg();\n            }\n            this.ins[level](msg);\n        }\n    }\n\n    extend(name: string) {\n        return getLogger(this.name + '.' + name);\n    }\n\n    setLevel(level: string) {\n        this.level = level;\n    }\n\n    debug(msg: string | Function) {\n        this.log('debug', msg);\n    }\n\n    info(msg: string | Function) {\n        this.log('info', msg);\n    }\n\n    warn(msg: string | Function) {\n        this.log('warn', msg);\n    }\n\n    error(msg: string | Function) {\n        this.log('error', msg);\n    }\n}\n\nconst getLogger = (name: string, level?: string) => {\n    let logger = loggerCollection.get(name);\n    if (!logger) {\n        logger = new Logger(name, loggerCollection.getLogLevel(name) || 'error');\n        loggerCollection.set(name, logger);\n    }\n    return logger;\n};\n\nexport const ROOT_LOGGER = getLogger('root');\nexport const PERFORMANCE_LOGGER = ROOT_LOGGER.extend('performance');\nexport const RENDER_LOGGER = PERFORMANCE_LOGGER.extend('render');\n\nexport default {\n    get: getLogger,\n    setLogLevel: (name?: string, level?: string) => loggerCollection.setLogLevel(name, level),\n    list: () => loggerCollection.list(),\n    reset: () => loggerCollection.setLogLevel('root', 'error'),\n    init: () => loggerCollection.init()\n};", "wavemaker-rn-runtime/src/core/file-extension-types.ts": "export const FileExtensionTypesMap: any = {\n  '.aac': 'audio/aac',\n  '.abw': 'application/x-abiword',\n  '.apk': 'application/vnd.android.package-archive',\n  '.avi': 'video/x-msvideo',\n  '.azw': 'application/vnd.amazon.ebook',\n  '.bin': 'application/octet-stream',\n  '.bmp': 'image/bmp',\n  '.bz': 'application/x-bzip',\n  '.bz2': 'application/x-bzip2',\n  '.csh': 'application/x-csh',\n  '.css': 'text/css',\n  '.csv': 'text/csv',\n  '.doc': 'application/msword',\n  '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n  '.eot': 'application/vnd.ms-fontobject',\n  '.epub': 'application/epub+zip',\n  '.es': 'application/ecmascript',\n  '.gif': 'image/gif',\n  '.html': 'text/html',\n  '.ico': 'image/x-icon',\n  '.ics': 'text/calendar',\n  '.jar': 'application/java-archive',\n  '.jpeg': 'image/jpeg',\n  '.jpg': 'image/jpeg',\n  '.js': 'application/javascript',\n  '.json': 'application/json',\n  '.mid': 'audio/midi',\n  '.midi': 'audio/x-midi',\n  '.mpeg': 'video/mpeg',\n  'mpkg': 'application/vnd.apple.installer+xml',\n  '.odp': 'application/vnd.oasis.opendocument.presentation',\n  '.ods': 'application/vnd.oasis.opendocument.spreadsheet',\n  '.odt': 'application/vnd.oasis.opendocument.text',\n  '.oga': 'audio/ogg',\n  '.ogv': 'video/ogg',\n  '.ogx': 'application/ogg',\n  '.otf': 'font/otf',\n  '.png': 'image/png',\n  '.pdf': 'application/pdf',\n  '.ppt': 'application/vnd.ms-powerpoint',\n  '.pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n  '.rar': 'application/x-rar-compressed',\n  '.rtf': 'application/rtf',\n  '.sh': 'application/x-sh',\n  '.svg': 'image/svg+xml',\n  '.swf': 'application/x-shockwave-flash',\n  '.tar': 'application/x-tar',\n  '.tiff': 'image/tiff',\n  '.ts': 'application/typescript',\n  '.ttf': 'font/ttf',\n  '.txt': 'text/plain',\n  '.vsd': 'application/vnd.visio',\n  '.wav': 'audio/wav',\n  '.weba': 'audio/webm',\n  '.webm': 'video/webm',\n  '.webp': 'image/webp',\n  '.woff': 'font/woff',\n  '.woff2': 'font/woff2',\n  '.xhtml': 'application/xhtml+xml',\n  '.xls': 'application/vnd.ms-excel',\n  '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n  '.xml': 'application/xml',\n  '.xul': 'application/vnd.mozilla.xul+xml',\n  '.zip': 'application/zip',\n  '.3gp': 'video/3gpp',\n  '.3g2': 'video/3gpp2',\n  '.7z': 'application/x-7z-compressed'\n};\n", "wavemaker-rn-runtime/src/core/AppConfig.ts": "export interface Drawer {\n    setContent: (c: React.ReactNode) => void;\n    getContent: () => React.ReactNode;\n    setAnimation: (animation: string) => void;\n    getAnimation: () => string;\n}\n\nexport default interface AppConfig {\n    appId: string;\n    assets: any;\n    appProperties: any;\n    appLocale: any;\n    url: string;\n    leftNavWidth: any;\n    loadApp: boolean;\n    refresh: (complete?: boolean) => void,\n    currentPage?: any;\n    pages?: any[];\n    landingPage: string;\n    partials?: any[];\n    drawer: Drawer;\n    app: any;\n    spinner: any;\n    setDrawerContent: any;\n    theme: any;\n    drawerType: any;\n    preferences:any;\n    getServiceDefinitions: any;\n    loggedInUser: any;\n    selectedLocale: string;\n    revertLayoutToExpo50: boolean,\n    diagnostics: {\n        appStartTime: number,\n        appReadyTime: number,\n        pageStartTime: number,\n        pageReadyTime: number\n    }, \n    pageScrollTopThreshold: number;\n}", "wavemaker-rn-runtime/src/core/scroll-view.component.tsx": "import React from 'react';\nimport { ScrollView as RNScrollView, ScrollViewProps as RNScrollViewProps, View } from 'react-native';\n\nexport interface ScrollViewProps extends RNScrollViewProps {\n\n}\n\nexport interface ScrollViewState {\n    scrollEnabled: boolean;\n}\n\nconst ScrollViewContext = React.createContext<ScrollView>(null as any);\n\nexport const ScrollViewProvider = ScrollViewContext.Provider;\nexport const ScrollViewConsumer = ScrollViewContext.Consumer;\n// TODO: implement scroll view that handles FlatList.\nexport class ScrollView extends React.Component<ScrollViewProps, ScrollViewState> {\n\n    public instance: ScrollView = null as any;\n\n    constructor(props: ScrollViewProps) {\n        super(props);\n        this.state = {\n            scrollEnabled: true\n        } as ScrollViewState;\n    }\n\n    enableScroll() {\n        this.setState({\n            scrollEnabled: true\n        });\n    }\n\n    disableScroll() {\n        this.setState({\n            scrollEnabled: false\n        });\n    }\n\n    isScrollEnabled() {\n        return this.state.scrollEnabled;\n    }\n\n    get contentOffset(): number {\n        return this.instance.contentOffset;\n    }\n\n    render() {\n        return (\n            <ScrollViewProvider value={this}>\n                <View onStartShouldSetResponderCapture={() => {\n                    this.setState({\n                        scrollEnabled: true\n                    });\n                    return true;\n                }}>\n                    <RNScrollView\n                        ref={scrollRef => (this.instance = scrollRef as any)}\n                        {...this.props} scrollEnabled={this.state.scrollEnabled}>\n                        {this.props.children}\n                    </RNScrollView>\n                </View>\n            </ScrollViewProvider>\n        ); \n    }\n}\n", "wavemaker-rn-runtime/src/core/security.service.ts": "import React from 'react';\n\nexport interface SecurityOptions {}\n\nexport interface SecurityService {\n    isLoggedIn: Boolean;\n    loggedInUser: any;\n    appLogin: (options: SecurityOptions, success?: any, failure?: any) => any;\n    appLogout: (options: any, success?: any, failure?: any) => any;\n    navigateToLandingPage: (data: any) => any;\n}\n\nconst SecurityContext = React.createContext<SecurityService>(null as any);\n\nexport const SecurityProvider = SecurityContext.Provider;\nexport const SecurityConsumer = SecurityContext.Consumer;\n", "wavemaker-rn-runtime/src/core/i18n.service.ts": "export interface I18nService {\n    getSelectedLocale: () => string;\n    isRTLLocale: (newLocale?: string) => any;\n    setRTL: (locale?: string) => any;\n}\n\n", "wavemaker-rn-runtime/src/core/constant.service.ts": "export class ConstantService {\n   VALIDATOR = {\n    REQUIRED: 'required',\n    MAXCHARS: 'maxchars',\n    MINVALUE: 'minvalue',\n    MAXVALUE: 'maxvalue',\n    REGEXP: 'regexp',\n    MINDATE: 'mindate',\n    MAXDATE: 'maxdate',\n    MINTIME: 'mintime',\n    MAXTIME: 'maxtime',\n    EXCLUDEDATES: 'excludedates',\n    EXCLUDEDAYS: 'excludedays'\n  };\n}\n\nexport default new ConstantService();\n", "wavemaker-rn-runtime/src/core/formatters.ts": "import { parseInt } from 'lodash';\nimport moment from 'moment';\nimport { CURRENCY_INFO, Currency } from './constants/currency-constants';\nimport { DateFormatter } from '@wavemaker/variables/src/types/date-formatter';\nimport injector from '@wavemaker/app-rn-runtime/core/injector';\n\nexport interface Formatter {\n    format: (input: any, ...params: any) => any;\n}\n\nexport class DateToStringFormatter implements DateFormatter {\n    public format(input: Date, format: string): string {\n       \n        if (!input) return '';\n\n        format = format.replaceAll('y', 'Y').replaceAll('d', 'D').replaceAll('E','d');\n        let _moment = moment(input, [\n            moment.ISO_8601,\n            \"YYYY\",\n            \"YYYY-MM\",\n            \"YYYYMMDD\",\n            \"YYYY-MM-DD\",\n            \"YYYY-MM-DDTHH\",\n            \"YYYY-MM-DDTHH:mm\",\n            \"YYYY-MM-DDTHH:mm:ss\",\n            \"YYYY-MM-DDTHH:mm:ss.SSS\",\n            \"YYYY-MM-DD HH:mm:ss\",\n            \"MM/DD/YYYY\",\n            \"MM-DD-YYYY\",\n            \"YYYY/MM/DD\",\n            \"YYYY/MM\",\n            \"D MMM YYYY\",\n            \"MMM D YYYY\",\n            \"MMMM D YYYY\",\n            \"D MMMM YYYY\",\n            \"D-MMM-YYYY\",\n            \"D/MMM/YYYY\",\n            \"YYYY-WWW\", \n            \"YYYY-WWW-E\",\n            \"YYYY-DDD\",\n            \"YYYY-DDDTHH\",\n            \"YYYY-DDDTHH:mm\",\n            \"YYYY-DDDTHH:mm:ss\",\n            \"YYYY-DDDTHH:mm:ss.SSS\",\n            \"YYYY-DDD HH:mm:ss\",\n            \"YYYY-MM-DDTHH:mm:ssZ\",\n            \"YYYY-MM-DDTHH:mm:ss+00:00\",\n            \"YYYY-MM-DDTHH:mm:ss-00:00\",\n            \"YYYY-MM-DDTHH:mm:ss.SSSZ\",\n            \"YYYY-MM-DDTHH:mm:ss.SSS+00:00\",\n            \"YYYY-MM-DDTHH:mm:ss.SSS-00:00\",\n            \"ddd, DD MMM YYYY HH:mm:ss ZZ\",\n            \"DD MMM YYYY HH:mm:ss ZZ\",\n            'x'\n        ], true);\n\n        if (format === 'timestamp')\n            return Math.floor(_moment.valueOf() / 1000).toString();\n\n        if (format === 'UTC')\n            return moment.utc(input).toString();\n\n        const defaultLanguage = (injector as any).get('APP_CONFIG')?.appProperties?.defaultLanguage || 'en';\n\n        return _moment.isValid() ? _moment.locale(defaultLanguage).format(format) : input.toString();\n    }\n}\n\nexport class PrependFormatter implements Formatter {\n\n    public format(input: any, prefix: string): string {\n        return (prefix || '') + (input !== null || input != undefined ? input : '');\n    }\n}\n\nexport class AppendFormatter implements Formatter {\n\n    public format(input: any, suffix: string): string {\n        return (input !== null || input != undefined ? input : '') + (suffix || '');\n    }\n}\n\nexport class NumberToStringFormatter implements Formatter {\n\n    public format(input: number, fractionSize: number): string {\n        const i18nService = injector.I18nService.get();\n        const selectedLocale = i18nService.getSelectedLocale();\n        let formatCurrency = new Intl.NumberFormat(selectedLocale,{\n            minimumFractionDigits: fractionSize,\n            maximumFractionDigits: fractionSize,\n        });\n        return isNaN(input) ? '': formatCurrency.format(input);\n    }\n}\n\nexport class CurrencyFormatter implements Formatter {\n\n    public format(data: number, currencySymbol: string, fracSize: number) {\n        const _currencySymbol = ((((CURRENCY_INFO as any)[currencySymbol]) || {})  as Currency).symbol || currencySymbol || '';\n        let _val = new NumberToStringFormatter().format(data, fracSize);\n        const isNegativeNumber = _val.startsWith('-');\n        if (isNegativeNumber) {\n            _val = _val.replace('-','');\n        }\n        return _val ? isNegativeNumber ? '-'+ _currencySymbol +_val :_currencySymbol + _val : '';\n    }\n}\n\nexport class TimeFromNowFormatter implements Formatter {\n    public format(timestamp: Date) {\n        return timestamp ? moment(timestamp).fromNow() : undefined;\n    }\n}\n\nexport class StringToNumberFormatter implements Formatter {\n    public format(input: string) {\n        return parseInt(input);\n    }\n}\n\nconst createFormatter = (key: string, defaultFormatter: Formatter) => {\n    return {\n        format: (input: any, ...params: any) => {\n            const output = defaultFormatter.format(input, ...params);\n            const customFormatter = formatters.get(`custom.${key}`);\n            return customFormatter ? customFormatter.format(output, ...params): output;\n        }\n    };\n};\n\nconst formatters = new Map<string, Formatter>([\n    ['numberToString', createFormatter('numberToString' , new NumberToStringFormatter())],\n    ['prefix', createFormatter('prefix', new PrependFormatter())],\n    ['suffix', createFormatter('suffix', new AppendFormatter())],\n    ['stringToNumber', createFormatter('stringToNumber',new StringToNumberFormatter())],\n    ['timeFromNow', createFormatter('timeFromNow', new TimeFromNowFormatter())],\n    ['toDate', createFormatter('toDate', new DateToStringFormatter())],\n    ['toCurrency', createFormatter('toCurrency', new CurrencyFormatter())]\n]);\n\nexport default formatters;", "wavemaker-rn-runtime/src/core/storage.service.ts": "import AsyncStorage from '@react-native-async-storage/async-storage';\n\nexport class StorageService {\n  public target = 'GLOBAL';\n\n  private getKey(key: string) {\n    return `${this.target}_${key}`;\n  }\n  \n  getItem(key: string, callback?: (error?: Error | null, result?: string | null) => void): Promise<string | null> {\n    return AsyncStorage.getItem(this.getKey(key), callback);\n  }\n  setItem(key: string, value: string, callback?: (error?: Error | null) => void): Promise<void> {\n    return AsyncStorage.setItem(this.getKey(key), value, callback);\n  }\n  removeItem(key: string, callback?: (error?: Error | null) => void): Promise<void> {\n    return AsyncStorage.removeItem(this.getKey(key), callback);\n  }\n\n  async getAll() {\n    const keys = await AsyncStorage.getAllKeys();\n    const entries = await Promise.all(keys.map(async k => {\n      const v = await AsyncStorage.getItem(k);\n      return {\n        key: k,\n        value: v\n      };\n    }));\n    const o = {} as any;\n    entries.forEach((e) => {\n      o[e.key] = e.value;\n    });\n    return o;\n  }\n}\n\nexport default new StorageService();\n", "wavemaker-rn-runtime/src/core/network.service.ts": "import axios from 'axios';\nimport { clone, isEqual, noop } from 'lodash-es';\nimport * as Network from 'expo-network';\nimport NetInfo from '@react-native-community/netinfo';\n\nimport AppConfig from './AppConfig';\nimport StorageService from './storage.service';\nimport EventNotifier from './event-notifier';\nimport { getAbortableDefer, isWebPreviewMode, retryIfFails } from './utils';\n\nexport class NetworkState {\n    isConnecting = false;\n    isConnected = true;\n    isNetworkAvailable = true;\n    isServiceAvailable = true;\n    noServiceRequired = false;\n}\n\nconst AUTO_CONNECT_KEY = 'WM.NetworkService._autoConnect',\n    IS_CONNECTED_KEY = 'WM.NetworkService.isConnected',\n    excludedList = [new RegExp('/wmProperties.js')],\n    networkState = new NetworkState();\n\n/**\n * If server is not connected and url does not match the unblock list of regular expressions,\n * then this function return true. Otherwise, return false.\n * @param url\n * @returns {boolean}\n */\nconst blockUrl = (url: string) => {\n    return !networkState.isConnected\n        && url.startsWith('http')\n        && excludedList.findIndex(regExp => regExp.test(url)) < 0;\n};\n\naxios.interceptors.request.use((request) => {\n    if (!networkState.noServiceRequired && request.url && blockUrl(request.url)) {\n        const url = request.url;\n        const urlSplits = url.split('://');\n        const pathIndex = urlSplits[1].indexOf('/');\n        urlSplits[1] = 'localhost' + (pathIndex > 0 ? urlSplits[1].substr(pathIndex) : '/');\n        request.url = urlSplits.join('://');\n    }\n    return request;\n});\n\nclass NetworkService {\n    static readonly SERVICE_NAME = 'NetworkService';\n\n    private _autoConnect = true;\n    private _lastKnownNetworkState: any;\n    private _isCheckingServer = false;\n    private appConfig: AppConfig = null as any;\n    public readonly notifier: EventNotifier = new EventNotifier();\n\n    constructor() {}\n\n    /**\n     * This method attempts to connect app to the server and returns a promise that will be resolved with\n     * a boolean value based on the operation result.\n     *\n     * @returns {object} promise\n     */\n    public connect(silent = false): Promise<boolean> {\n        this.setAutoConnect(true);\n        return this.tryToConnect(silent);\n    }\n\n    /**\n     * When the auto connect is enabled, then app is automatically connected  whenever server is available.\n     * Every time when app goes offline, auto connect is enabled. Before app coming to online, one can disable\n     * the auto connection flow using this method.\n     */\n    public disableAutoConnect = () => this.setAutoConnect(false);\n\n    /**\n     * This method disconnects the app from the server and returns a promise that will be resolved with\n     * a boolean value based on the operation result. Use connect method to reconnect.\n     *\n     * @returns {object} promise\n     */\n    public disconnect(): Promise<boolean> {\n        const p = this.tryToDisconnect();\n        this.disableAutoConnect();\n        return p;\n    }\n\n    /**\n     * If pingServer is true, then it returns a promise that will be resolved with boolean based on service availability\n     * check.If pingServer is false, returns a boolean value based on the last known service availability.\n     *\n     * @returns {boolean} if pingServer is true, then a promise is returned. Otherwise, a boolean value.\n     */\n    public isAvailable(pingServer = false): boolean | Promise<boolean> {\n        if (pingServer) {\n            return this.isServiceAvailable().then(() => {\n                this.checkForNetworkStateChange();\n                return networkState.isServiceAvailable;\n            });\n        }\n        return networkState.isServiceAvailable;\n    }\n\n    /**\n     * Returns true, if app is connected to server. Otherwise, returns false.\n     *\n     * @returns {boolean} Returns true, if app is connected to server. Otherwise, returns false.\n     */\n    public isConnected = () => {\n        this.checkForNetworkStateChange();\n        return networkState.isConnected;\n    }\n\n    /**\n     * Returns true if app is trying to connect to server. Otherwise, returns false.\n     *\n     * @returns {boolean} Returns true if app is trying to connect to server. Otherwise, returns false.\n     */\n    public isConnecting = () => networkState.isConnecting;\n\n    /**\n     * This method returns a promise that is resolved when connection is established with server.\n     *\n     * @returns {object} promise a promise that is resolved with the returned object of fn\n     */\n    public onConnect() {\n        let defer = getAbortableDefer(),\n            cancelSubscription: Function;\n        if (this.isConnected()) {\n            return Promise.resolve();\n        }\n        cancelSubscription = this.notifier.subscribe('onNetworkStateChange', () => {\n            if (this.isConnected()) {\n                defer.resolve(true);\n                cancelSubscription();\n            }\n        });\n        defer.promise.catch(function () {\n            cancelSubscription();\n        });\n        return defer.promise;\n    }\n\n    /**\n     * This is a util method. If fn cannot execute successfully and network lost connection, then the fn will\n     * be invoked when network is back. The returned can also be aborted.\n     *\n     * @param {function()} fn method to invoke.\n     * @returns {object} promise a promise that is resolved with the returned object of fn\n     */\n    public retryIfNetworkFails(fn: Function) {\n        const defer = getAbortableDefer();\n        retryIfFails(fn, 0, 0, () => {\n            let onConnectPromise: any;\n            if (!this.isConnected()) {\n                onConnectPromise = this.onConnect();\n                defer.promise.catch(function () {\n                    onConnectPromise.abort();\n                });\n                return onConnectPromise;\n            }\n            return false;\n        }).then(defer.resolve, defer.reject);\n        return defer.promise;\n    }\n\n    public async start(appConfig: AppConfig): Promise<any> {\n        this.appConfig = appConfig;\n        networkState.noServiceRequired = !appConfig.url;\n        networkState.isConnected = (await StorageService.getItem(IS_CONNECTED_KEY)) !== 'false';\n        this._autoConnect = (await StorageService.getItem(AUTO_CONNECT_KEY)) !== 'false';\n        const state = await Network.getNetworkStateAsync();\n        networkState.isNetworkAvailable = !!state.isConnected;\n        networkState.isConnected = networkState.isNetworkAvailable && networkState.isConnected;\n        !isWebPreviewMode() && NetInfo.addEventListener(state => {\n            if (state.isConnected !== networkState.isConnected) {\n                if (state.isConnected) {\n                    networkState.isNetworkAvailable = !!state.isConnected;\n                    this.tryToConnect().catch(noop);\n                } else {\n                    networkState.isNetworkAvailable = false;\n                    networkState.isServiceAvailable = false;\n                    networkState.isConnected = false;\n                    this.tryToDisconnect();\n                }\n            }\n        });\n        this.notifier.subscribe('onNetworkStateChange', (data: NetworkState) => {\n            /**\n             * If network is available and server is not available,then\n             * try to connect when server is available.\n             */\n            if (data.isNetworkAvailable && !data.isServiceAvailable && !this._isCheckingServer && !data.noServiceRequired) {\n                this._isCheckingServer = true;\n                this.checkForServiceAvailiblity().then(() => {\n                    this._isCheckingServer = false;\n                    this.connect();\n                }, () => {\n                    this._isCheckingServer = false;\n                });\n            }\n        });\n        // to set the default n/w connection values.\n        return this.tryToConnect(true).catch(noop);\n    }\n\n    public getServiceName() {\n        return NetworkService.SERVICE_NAME;\n    }\n\n    /**\n     * This function adds the given regular expression to the unblockList. Even app is in offline mode,\n     * the urls matching with the given regular expression are not blocked by NetworkService.\n     *\n     * @param {string} urlRegex regular expression\n     */\n    public unblock(urlRegex: string) {\n        excludedList.push(new RegExp(urlRegex));\n    }\n\n    public getState() {\n        return clone(networkState);\n    }\n\n    private checkForNetworkStateChange() {\n        if (!isEqual(this._lastKnownNetworkState, networkState)) {\n            this._lastKnownNetworkState = clone(networkState);\n            this.notifier.notify('onNetworkStateChange', [this._lastKnownNetworkState]);\n        }\n    }\n\n    /**\n     * Returns a promise that is resolved when server is available.\n     * @returns {*}\n     */\n    private checkForServiceAvailiblity(): Promise<void> {\n        const maxTimeout = 4500;\n        return new Promise<void>(resolve => {\n            const intervalId = setInterval(() => {\n                if (networkState.isNetworkAvailable) {\n                    this.isServiceAvailable(maxTimeout).then(available => {\n                        if (available) {\n                            clearInterval(intervalId);\n                            resolve();\n                        }\n                    });\n                }\n            }, 5000);\n        });\n    }\n\n    /**\n     * Pings server to check whether server is available. Based on ping response network state is modified.\n     * @returns {*} a promise that resolved with true, if server responds with valid status.\n     * Otherwise, the promise is resolved with false.\n     */\n    private isServiceAvailable(maxTimeout?: number): Promise<boolean> {\n        if (networkState.noServiceRequired) {\n            networkState.isServiceAvailable = false;\n            networkState.noServiceRequired = true;\n            return Promise.resolve(false);\n        }\n        return this.pingServer(maxTimeout).then(response => {\n            networkState.isServiceAvailable = response;\n            if (!networkState.isServiceAvailable) {\n                networkState.isConnecting = false;\n                networkState.isConnected = false;\n            }\n            return response;\n        });\n    }\n\n    /**\n     * Pings server\n     * @returns {*} a promise that resolved with true, if server responds with valid status.\n     * Otherwise, the promise is resolved with false.\n     * default timeout value is 1min.\n     */\n    private pingServer(maxTimeout = 60000): Promise<boolean> {\n        let baseURL = this.appConfig.url;\n        if (baseURL && !baseURL.endsWith('/')) {\n            baseURL += '/';\n        } else {\n            baseURL = baseURL || '';\n        }\n        return axios.get(baseURL + 'services/application/wmProperties.js?t=' + Date.now(), {\n            responseType: 'text',\n            timeout: maxTimeout\n        }).then((res) => res.status === 200, () => false);\n    }\n\n    private setAutoConnect(flag: boolean): void {\n        this._autoConnect = flag;\n        StorageService.setItem(AUTO_CONNECT_KEY, '' + flag);\n    }\n\n    /**\n     * Tries to connect to remote server. Network State will be changed based on the success of connection\n     * operation and emits an event notifying the network state change.\n     *\n     * @param silentMode {boolean} if true and connection is successful, then no event is emitted. Otherwise,\n     * events are emitted for network status change.\n     * @returns {*} a promise\n     */\n    private tryToConnect(silentMode = false): Promise<boolean> {\n        return new Promise<boolean>((resolve, reject) => {\n            this.isServiceAvailable(5000).then(() => {\n                if (networkState.isServiceAvailable && this._autoConnect) {\n                    networkState.isConnecting = true;\n                    if (!silentMode) {\n                        this.checkForNetworkStateChange();\n                    }\n                    setTimeout(() => {\n                        networkState.isConnecting = false;\n                        networkState.isConnected = true;\n                        StorageService.setItem(IS_CONNECTED_KEY, '' + true);\n                        if (!silentMode) {\n                            this.checkForNetworkStateChange();\n                        }\n                        resolve(true);\n                    }, silentMode ? 0 : 5000);\n                } else {\n                    networkState.isConnecting = false;\n                    networkState.isConnected = false;\n                    StorageService.setItem(IS_CONNECTED_KEY, '' + false);\n                    reject();\n                    this.checkForNetworkStateChange();\n                }\n            });\n        });\n    }\n\n    private tryToDisconnect(): Promise<boolean> {\n        networkState.isConnected = false;\n        networkState.isConnecting = false;\n        this.checkForNetworkStateChange();\n        StorageService.setItem(IS_CONNECTED_KEY, '' + networkState.isConnected);\n        return Promise.resolve(networkState.isConnected);\n    }\n}\n\nexport default new NetworkService();\n", "wavemaker-rn-runtime/src/core/imageSizeEstimator.ts": "import { remove } from \"lodash-es\";\nimport { Image } from \"react-native\";\n\ninterface Request {\n    onComplete: (width: number, height: number) => void\n    cancel : () => void\n}\n\nclass ImageSizeEstimator {\n    requestId = 1;\n  \n    requests: Map<String, Request[]> = new Map<string, Request[]>();\n\n    private createRequest(requestId: string, onComplete: (width: number, height: number) => void) {\n      const request = {} as Request;\n      request.onComplete = onComplete,\n      request.cancel = () => {\n          if (this.requests.has(requestId)) {\n            remove(this.requests.get(requestId) || [], request);\n          }\n      };\n      return request;\n    }\n\n    private getImageSize(imgSrc: string) {\n      Image.getSize(imgSrc, (width: number, height: number) => {\n        const reqs = this.requests.get(imgSrc);\n        if (reqs) {\n          reqs.map(req => {\n            req.onComplete && req.onComplete(width, height);\n          });\n          this.requests.delete(imgSrc);\n        }\n      }, () => this.requests.delete(imgSrc));\n    }\n  \n    getSize(imgSrc: string, onComplete: (width: number, height: number) => void) {\n      if (!imgSrc) {\n        setTimeout(() => onComplete(0, 0), 100);\n        return () => {};\n      }\n      const requestId = imgSrc;\n      const request = this.createRequest(requestId, onComplete);\n      if (this.requests.has(requestId)) {\n        this.requests.get(requestId)?.push(request);\n      } else {\n        const reqQueue = [] as Request[];\n        this.requests.set(requestId, reqQueue);\n        reqQueue.push(request)\n        this.getImageSize(requestId);\n      }\n      return request.cancel;\n    }\n  }\n  \nexport default new ImageSizeEstimator();", "wavemaker-rn-runtime/src/core/spinner.service.ts": "import React from 'react';\n\nexport interface DisplayOptions {\n  content?: React.ReactNode;\n  message?: string;\n  spinner?: any;\n}\n\nexport interface SpinnerService {\n  show: (options: DisplayOptions) => any;\n  hide: (options: DisplayOptions) => any;\n}\n\nconst SpinnerContext = React.createContext<SpinnerService>(null as any);\n\nexport const SpinnerProvider = SpinnerContext.Provider;\nexport const SpinnerConsumer = SpinnerContext.Consumer;\n", "wavemaker-rn-runtime/src/core/key.extractor.ts": "export class DefaultKeyExtractor {\n    store = new Map<any, string>();\n    nextKey = 1;\n  \n    getKey(o : any, create = false) {\n      let k = this.store.get(o);\n      if (!k && create) {\n        k = `key:${Date.now()}:${this.nextKey++}`;\n        this.store.set(o, k)\n      }\n      return k;\n    }\n  \n    clear() {\n      this.store = new Map();\n    }\n}", "wavemaker-rn-runtime/src/core/constants/currency-constants.ts": "export interface Currency {\n    symbol: string,\n    name: string,\n    symbol_native: number,\n    rounding: number,\n    code: string,\n    name_plural: string\n};\n\nexport const CURRENCY_INFO  = {\n    'USD': {\n        'symbol': '$',\n        'name': 'US Dollar',\n        'symbol_native': '$',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'USD',\n        'name_plural': 'US dollars'\n    },\n    'CAD': {\n        'symbol': 'CA$',\n        'name': 'Canadian Dollar',\n        'symbol_native': '$',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'CAD',\n        'name_plural': 'Canadian dollars'\n    },\n    'EUR': {\n        'symbol': '\u20ac',\n        'name': 'Euro',\n        'symbol_native': '\u20ac',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'EUR',\n        'name_plural': 'euros'\n    },\n    'AED': {\n        'symbol': 'AED',\n        'name': 'United Arab Emirates Dirham',\n        'symbol_native': '\u062f.\u0625.\u200f',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'AED',\n        'name_plural': 'UAE dirhams'\n    },\n    'AFN': {\n        'symbol': 'Af',\n        'name': 'Afghan Afghani',\n        'symbol_native': '\u060b',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'AFN',\n        'name_plural': 'Afghan Afghanis'\n    },\n    'ALL': {\n        'symbol': 'ALL',\n        'name': 'Albanian Lek',\n        'symbol_native': 'Lek',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'ALL',\n        'name_plural': 'Albanian lek\u00eb'\n    },\n    'AMD': {\n        'symbol': 'AMD',\n        'name': 'Armenian Dram',\n        'symbol_native': '\u0564\u0580.',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'AMD',\n        'name_plural': 'Armenian drams'\n    },\n    'ARS': {\n        'symbol': 'AR$',\n        'name': 'Argentine Peso',\n        'symbol_native': '$',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'ARS',\n        'name_plural': 'Argentine pesos'\n    },\n    'AUD': {\n        'symbol': 'AU$',\n        'name': 'Australian Dollar',\n        'symbol_native': '$',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'AUD',\n        'name_plural': 'Australian dollars'\n    },\n    'AZN': {\n        'symbol': 'man.',\n        'name': 'Azerbaijani Manat',\n        'symbol_native': '\u043c\u0430\u043d.',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'AZN',\n        'name_plural': 'Azerbaijani manats'\n    },\n    'BAM': {\n        'symbol': 'KM',\n        'name': 'Bosnia-Herzegovina Convertible Mark',\n        'symbol_native': 'KM',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'BAM',\n        'name_plural': 'Bosnia-Herzegovina convertible marks'\n    },\n    'BDT': {\n        'symbol': 'Tk',\n        'name': 'Bangladeshi Taka',\n        'symbol_native': '\u09f3',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'BDT',\n        'name_plural': 'Bangladeshi takas'\n    },\n    'BGN': {\n        'symbol': 'BGN',\n        'name': 'Bulgarian Lev',\n        'symbol_native': '\u043b\u0432.',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'BGN',\n        'name_plural': 'Bulgarian leva'\n    },\n    'BHD': {\n        'symbol': 'BD',\n        'name': 'Bahraini Dinar',\n        'symbol_native': '\u062f.\u0628.\u200f',\n        'decimal_digits': 3,\n        'rounding': 0,\n        'code': 'BHD',\n        'name_plural': 'Bahraini dinars'\n    },\n    'BIF': {\n        'symbol': 'FBu',\n        'name': 'Burundian Franc',\n        'symbol_native': 'FBu',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'BIF',\n        'name_plural': 'Burundian francs'\n    },\n    'BND': {\n        'symbol': 'BN$',\n        'name': 'Brunei Dollar',\n        'symbol_native': '$',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'BND',\n        'name_plural': 'Brunei dollars'\n    },\n    'BOB': {\n        'symbol': 'Bs',\n        'name': 'Bolivian Boliviano',\n        'symbol_native': 'Bs',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'BOB',\n        'name_plural': 'Bolivian bolivianos'\n    },\n    'BRL': {\n        'symbol': 'R$',\n        'name': 'Brazilian Real',\n        'symbol_native': 'R$',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'BRL',\n        'name_plural': 'Brazilian reals'\n    },\n    'BWP': {\n        'symbol': 'BWP',\n        'name': 'Botswanan Pula',\n        'symbol_native': 'P',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'BWP',\n        'name_plural': 'Botswanan pulas'\n    },\n    'BYR': {\n        'symbol': 'BYR',\n        'name': 'Belarusian Ruble',\n        'symbol_native': 'BYR',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'BYR',\n        'name_plural': 'Belarusian rubles'\n    },\n    'BZD': {\n        'symbol': 'BZ$',\n        'name': 'Belize Dollar',\n        'symbol_native': '$',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'BZD',\n        'name_plural': 'Belize dollars'\n    },\n    'CDF': {\n        'symbol': 'CDF',\n        'name': 'Congolese Franc',\n        'symbol_native': 'FrCD',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'CDF',\n        'name_plural': 'Congolese francs'\n    },\n    'CHF': {\n        'symbol': 'CHF',\n        'name': 'Swiss Franc',\n        'symbol_native': 'CHF',\n        'decimal_digits': 2,\n        'rounding': 0.05,\n        'code': 'CHF',\n        'name_plural': 'Swiss francs'\n    },\n    'CLP': {\n        'symbol': 'CL$',\n        'name': 'Chilean Peso',\n        'symbol_native': '$',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'CLP',\n        'name_plural': 'Chilean pesos'\n    },\n    'CNY': {\n        'symbol': 'CN\u00a5',\n        'name': 'Chinese Yuan',\n        'symbol_native': 'CN\u00a5',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'CNY',\n        'name_plural': 'Chinese yuan'\n    },\n    'COP': {\n        'symbol': 'CO$',\n        'name': 'Colombian Peso',\n        'symbol_native': '$',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'COP',\n        'name_plural': 'Colombian pesos'\n    },\n    'CRC': {\n        'symbol': '\u20a1',\n        'name': 'Costa Rican Col\u00f3n',\n        'symbol_native': '\u20a1',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'CRC',\n        'name_plural': 'Costa Rican col\u00f3ns'\n    },\n    'CVE': {\n        'symbol': 'CV$',\n        'name': 'Cape Verdean Escudo',\n        'symbol_native': 'CV$',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'CVE',\n        'name_plural': 'Cape Verdean escudos'\n    },\n    'CZK': {\n        'symbol': 'K\u010d',\n        'name': 'Czech Republic Koruna',\n        'symbol_native': 'K\u010d',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'CZK',\n        'name_plural': 'Czech Republic korunas'\n    },\n    'DJF': {\n        'symbol': 'Fdj',\n        'name': 'Djiboutian Franc',\n        'symbol_native': 'Fdj',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'DJF',\n        'name_plural': 'Djiboutian francs'\n    },\n    'DKK': {\n        'symbol': 'Dkr',\n        'name': 'Danish Krone',\n        'symbol_native': 'kr',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'DKK',\n        'name_plural': 'Danish kroner'\n    },\n    'DOP': {\n        'symbol': 'RD$',\n        'name': 'Dominican Peso',\n        'symbol_native': 'RD$',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'DOP',\n        'name_plural': 'Dominican pesos'\n    },\n    'DZD': {\n        'symbol': 'DA',\n        'name': 'Algerian Dinar',\n        'symbol_native': '\u062f.\u062c.\u200f',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'DZD',\n        'name_plural': 'Algerian dinars'\n    },\n    'EEK': {\n        'symbol': 'Ekr',\n        'name': 'Estonian Kroon',\n        'symbol_native': 'kr',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'EEK',\n        'name_plural': 'Estonian kroons'\n    },\n    'EGP': {\n        'symbol': 'EGP',\n        'name': 'Egyptian Pound',\n        'symbol_native': '\u062c.\u0645.\u200f',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'EGP',\n        'name_plural': 'Egyptian pounds'\n    },\n    'ERN': {\n        'symbol': 'Nfk',\n        'name': 'Eritrean Nakfa',\n        'symbol_native': 'Nfk',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'ERN',\n        'name_plural': 'Eritrean nakfas'\n    },\n    'ETB': {\n        'symbol': 'Br',\n        'name': 'Ethiopian Birr',\n        'symbol_native': 'Br',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'ETB',\n        'name_plural': 'Ethiopian birrs'\n    },\n    'GBP': {\n        'symbol': '\u00a3',\n        'name': 'British Pound Sterling',\n        'symbol_native': '\u00a3',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'GBP',\n        'name_plural': 'British pounds sterling'\n    },\n    'GEL': {\n        'symbol': 'GEL',\n        'name': 'Georgian Lari',\n        'symbol_native': 'GEL',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'GEL',\n        'name_plural': 'Georgian laris'\n    },\n    'GHS': {\n        'symbol': 'GH\u20b5',\n        'name': 'Ghanaian Cedi',\n        'symbol_native': 'GH\u20b5',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'GHS',\n        'name_plural': 'Ghanaian cedis'\n    },\n    'GNF': {\n        'symbol': 'FG',\n        'name': 'Guinean Franc',\n        'symbol_native': 'FG',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'GNF',\n        'name_plural': 'Guinean francs'\n    },\n    'GTQ': {\n        'symbol': 'GTQ',\n        'name': 'Guatemalan Quetzal',\n        'symbol_native': 'Q',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'GTQ',\n        'name_plural': 'Guatemalan quetzals'\n    },\n    'HKD': {\n        'symbol': 'HK$',\n        'name': 'Hong Kong Dollar',\n        'symbol_native': '$',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'HKD',\n        'name_plural': 'Hong Kong dollars'\n    },\n    'HNL': {\n        'symbol': 'HNL',\n        'name': 'Honduran Lempira',\n        'symbol_native': 'L',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'HNL',\n        'name_plural': 'Honduran lempiras'\n    },\n    'HRK': {\n        'symbol': 'kn',\n        'name': 'Croatian Kuna',\n        'symbol_native': 'kn',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'HRK',\n        'name_plural': 'Croatian kunas'\n    },\n    'HUF': {\n        'symbol': 'Ft',\n        'name': 'Hungarian Forint',\n        'symbol_native': 'Ft',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'HUF',\n        'name_plural': 'Hungarian forints'\n    },\n    'IDR': {\n        'symbol': 'Rp',\n        'name': 'Indonesian Rupiah',\n        'symbol_native': 'Rp',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'IDR',\n        'name_plural': 'Indonesian rupiahs'\n    },\n    'ILS': {\n        'symbol': '\u20aa',\n        'name': 'Israeli New Sheqel',\n        'symbol_native': '\u20aa',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'ILS',\n        'name_plural': 'Israeli new sheqels'\n    },\n    'INR': {\n        'symbol': '\u20b9',\n        'name': 'Indian Rupee',\n        'symbol_native': '\u099f\u0995\u09be',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'INR',\n        'name_plural': 'Indian rupees'\n    },\n    'IQD': {\n        'symbol': 'IQD',\n        'name': 'Iraqi Dinar',\n        'symbol_native': '\u062f.\u0639.\u200f',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'IQD',\n        'name_plural': 'Iraqi dinars'\n    },\n    'IRR': {\n        'symbol': 'IRR',\n        'name': 'Iranian Rial',\n        'symbol_native': '\ufdfc',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'IRR',\n        'name_plural': 'Iranian rials'\n    },\n    'ISK': {\n        'symbol': 'Ikr',\n        'name': 'Icelandic Kr\u00f3na',\n        'symbol_native': 'kr',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'ISK',\n        'name_plural': 'Icelandic kr\u00f3nur'\n    },\n    'JMD': {\n        'symbol': 'J$',\n        'name': 'Jamaican Dollar',\n        'symbol_native': '$',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'JMD',\n        'name_plural': 'Jamaican dollars'\n    },\n    'JOD': {\n        'symbol': 'JD',\n        'name': 'Jordanian Dinar',\n        'symbol_native': '\u062f.\u0623.\u200f',\n        'decimal_digits': 3,\n        'rounding': 0,\n        'code': 'JOD',\n        'name_plural': 'Jordanian dinars'\n    },\n    'JPY': {\n        'symbol': '\u00a5',\n        'name': 'Japanese Yen',\n        'symbol_native': '\uffe5',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'JPY',\n        'name_plural': 'Japanese yen'\n    },\n    'KES': {\n        'symbol': 'Ksh',\n        'name': 'Kenyan Shilling',\n        'symbol_native': 'Ksh',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'KES',\n        'name_plural': 'Kenyan shillings'\n    },\n    'KHR': {\n        'symbol': 'KHR',\n        'name': 'Cambodian Riel',\n        'symbol_native': '\u17db',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'KHR',\n        'name_plural': 'Cambodian riels'\n    },\n    'KMF': {\n        'symbol': 'CF',\n        'name': 'Comorian Franc',\n        'symbol_native': 'FC',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'KMF',\n        'name_plural': 'Comorian francs'\n    },\n    'KRW': {\n        'symbol': '\u20a9',\n        'name': 'South Korean Won',\n        'symbol_native': '\u20a9',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'KRW',\n        'name_plural': 'South Korean won'\n    },\n    'KWD': {\n        'symbol': 'KD',\n        'name': 'Kuwaiti Dinar',\n        'symbol_native': '\u062f.\u0643.\u200f',\n        'decimal_digits': 3,\n        'rounding': 0,\n        'code': 'KWD',\n        'name_plural': 'Kuwaiti dinars'\n    },\n    'KZT': {\n        'symbol': 'KZT',\n        'name': 'Kazakhstani Tenge',\n        'symbol_native': '\u0442\u04a3\u0433.',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'KZT',\n        'name_plural': 'Kazakhstani tenges'\n    },\n    'LBP': {\n        'symbol': 'LB\u00a3',\n        'name': 'Lebanese Pound',\n        'symbol_native': '\u0644.\u0644.\u200f',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'LBP',\n        'name_plural': 'Lebanese pounds'\n    },\n    'LKR': {\n        'symbol': 'SLRs',\n        'name': 'Sri Lankan Rupee',\n        'symbol_native': 'SL Re',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'LKR',\n        'name_plural': 'Sri Lankan rupees'\n    },\n    'LTL': {\n        'symbol': 'Lt',\n        'name': 'Lithuanian Litas',\n        'symbol_native': 'Lt',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'LTL',\n        'name_plural': 'Lithuanian litai'\n    },\n    'LVL': {\n        'symbol': 'Ls',\n        'name': 'Latvian Lats',\n        'symbol_native': 'Ls',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'LVL',\n        'name_plural': 'Latvian lati'\n    },\n    'LYD': {\n        'symbol': 'LD',\n        'name': 'Libyan Dinar',\n        'symbol_native': '\u062f.\u0644.\u200f',\n        'decimal_digits': 3,\n        'rounding': 0,\n        'code': 'LYD',\n        'name_plural': 'Libyan dinars'\n    },\n    'MAD': {\n        'symbol': 'MAD',\n        'name': 'Moroccan Dirham',\n        'symbol_native': '\u062f.\u0645.\u200f',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'MAD',\n        'name_plural': 'Moroccan dirhams'\n    },\n    'MDL': {\n        'symbol': 'MDL',\n        'name': 'Moldovan Leu',\n        'symbol_native': 'MDL',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'MDL',\n        'name_plural': 'Moldovan lei'\n    },\n    'MGA': {\n        'symbol': 'MGA',\n        'name': 'Malagasy Ariary',\n        'symbol_native': 'MGA',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'MGA',\n        'name_plural': 'Malagasy Ariaries'\n    },\n    'MKD': {\n        'symbol': 'MKD',\n        'name': 'Macedonian Denar',\n        'symbol_native': 'MKD',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'MKD',\n        'name_plural': 'Macedonian denari'\n    },\n    'MMK': {\n        'symbol': 'MMK',\n        'name': 'Myanma Kyat',\n        'symbol_native': 'K',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'MMK',\n        'name_plural': 'Myanma kyats'\n    },\n    'MOP': {\n        'symbol': 'MOP$',\n        'name': 'Macanese Pataca',\n        'symbol_native': 'MOP$',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'MOP',\n        'name_plural': 'Macanese patacas'\n    },\n    'MUR': {\n        'symbol': 'MURs',\n        'name': 'Mauritian Rupee',\n        'symbol_native': 'MURs',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'MUR',\n        'name_plural': 'Mauritian rupees'\n    },\n    'MXN': {\n        'symbol': 'MX$',\n        'name': 'Mexican Peso',\n        'symbol_native': '$',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'MXN',\n        'name_plural': 'Mexican pesos'\n    },\n    'MYR': {\n        'symbol': 'RM',\n        'name': 'Malaysian Ringgit',\n        'symbol_native': 'RM',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'MYR',\n        'name_plural': 'Malaysian ringgits'\n    },\n    'MZN': {\n        'symbol': 'MTn',\n        'name': 'Mozambican Metical',\n        'symbol_native': 'MTn',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'MZN',\n        'name_plural': 'Mozambican meticals'\n    },\n    'NAD': {\n        'symbol': 'N$',\n        'name': 'Namibian Dollar',\n        'symbol_native': 'N$',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'NAD',\n        'name_plural': 'Namibian dollars'\n    },\n    'NGN': {\n        'symbol': '\u20a6',\n        'name': 'Nigerian Naira',\n        'symbol_native': '\u20a6',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'NGN',\n        'name_plural': 'Nigerian nairas'\n    },\n    'NIO': {\n        'symbol': 'C$',\n        'name': 'Nicaraguan C\u00f3rdoba',\n        'symbol_native': 'C$',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'NIO',\n        'name_plural': 'Nicaraguan c\u00f3rdobas'\n    },\n    'NOK': {\n        'symbol': 'Nkr',\n        'name': 'Norwegian Krone',\n        'symbol_native': 'kr',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'NOK',\n        'name_plural': 'Norwegian kroner'\n    },\n    'NPR': {\n        'symbol': 'NPRs',\n        'name': 'Nepalese Rupee',\n        'symbol_native': '\u0928\u0947\u0930\u0942',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'NPR',\n        'name_plural': 'Nepalese rupees'\n    },\n    'NZD': {\n        'symbol': 'NZ$',\n        'name': 'New Zealand Dollar',\n        'symbol_native': '$',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'NZD',\n        'name_plural': 'New Zealand dollars'\n    },\n    'OMR': {\n        'symbol': 'OMR',\n        'name': 'Omani Rial',\n        'symbol_native': '\u0631.\u0639.\u200f',\n        'decimal_digits': 3,\n        'rounding': 0,\n        'code': 'OMR',\n        'name_plural': 'Omani rials'\n    },\n    'PAB': {\n        'symbol': 'B/.',\n        'name': 'Panamanian Balboa',\n        'symbol_native': 'B/.',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'PAB',\n        'name_plural': 'Panamanian balboas'\n    },\n    'PEN': {\n        'symbol': 'S/.',\n        'name': 'Peruvian Nuevo Sol',\n        'symbol_native': 'S/.',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'PEN',\n        'name_plural': 'Peruvian nuevos soles'\n    },\n    'PHP': {\n        'symbol': '\u20b1',\n        'name': 'Philippine Peso',\n        'symbol_native': '\u20b1',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'PHP',\n        'name_plural': 'Philippine pesos'\n    },\n    'PKR': {\n        'symbol': 'PKRs',\n        'name': 'Pakistani Rupee',\n        'symbol_native': '\u20a8',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'PKR',\n        'name_plural': 'Pakistani rupees'\n    },\n    'PLN': {\n        'symbol': 'z\u0142',\n        'name': 'Polish Zloty',\n        'symbol_native': 'z\u0142',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'PLN',\n        'name_plural': 'Polish zlotys'\n    },\n    'PYG': {\n        'symbol': '\u20b2',\n        'name': 'Paraguayan Guarani',\n        'symbol_native': '\u20b2',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'PYG',\n        'name_plural': 'Paraguayan guaranis'\n    },\n    'QAR': {\n        'symbol': 'QR',\n        'name': 'Qatari Rial',\n        'symbol_native': '\u0631.\u0642.\u200f',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'QAR',\n        'name_plural': 'Qatari rials'\n    },\n    'RON': {\n        'symbol': 'RON',\n        'name': 'Romanian Leu',\n        'symbol_native': 'RON',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'RON',\n        'name_plural': 'Romanian lei'\n    },\n    'RSD': {\n        'symbol': 'din.',\n        'name': 'Serbian Dinar',\n        'symbol_native': '\u0434\u0438\u043d.',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'RSD',\n        'name_plural': 'Serbian dinars'\n    },\n    'RUB': {\n        'symbol': 'RUB',\n        'name': 'Russian Ruble',\n        'symbol_native': '\u0440\u0443\u0431.',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'RUB',\n        'name_plural': 'Russian rubles'\n    },\n    'RWF': {\n        'symbol': 'RWF',\n        'name': 'Rwandan Franc',\n        'symbol_native': 'FR',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'RWF',\n        'name_plural': 'Rwandan francs'\n    },\n    'SAR': {\n        'symbol': 'SR',\n        'name': 'Saudi Riyal',\n        'symbol_native': '\u0631.\u0633.\u200f',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'SAR',\n        'name_plural': 'Saudi riyals'\n    },\n    'SDG': {\n        'symbol': 'SDG',\n        'name': 'Sudanese Pound',\n        'symbol_native': 'SDG',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'SDG',\n        'name_plural': 'Sudanese pounds'\n    },\n    'SEK': {\n        'symbol': 'Skr',\n        'name': 'Swedish Krona',\n        'symbol_native': 'kr',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'SEK',\n        'name_plural': 'Swedish kronor'\n    },\n    'SGD': {\n        'symbol': 'S$',\n        'name': 'Singapore Dollar',\n        'symbol_native': '$',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'SGD',\n        'name_plural': 'Singapore dollars'\n    },\n    'SOS': {\n        'symbol': 'Ssh',\n        'name': 'Somali Shilling',\n        'symbol_native': 'Ssh',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'SOS',\n        'name_plural': 'Somali shillings'\n    },\n    'SYP': {\n        'symbol': 'SY\u00a3',\n        'name': 'Syrian Pound',\n        'symbol_native': '\u0644.\u0633.\u200f',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'SYP',\n        'name_plural': 'Syrian pounds'\n    },\n    'THB': {\n        'symbol': '\u0e3f',\n        'name': 'Thai Baht',\n        'symbol_native': '\u0e3f',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'THB',\n        'name_plural': 'Thai baht'\n    },\n    'TND': {\n        'symbol': 'DT',\n        'name': 'Tunisian Dinar',\n        'symbol_native': '\u062f.\u062a.\u200f',\n        'decimal_digits': 3,\n        'rounding': 0,\n        'code': 'TND',\n        'name_plural': 'Tunisian dinars'\n    },\n    'TOP': {\n        'symbol': 'T$',\n        'name': 'Tongan Pa\u02bbanga',\n        'symbol_native': 'T$',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'TOP',\n        'name_plural': 'Tongan pa\u02bbanga'\n    },\n    'TRY': {\n        'symbol': 'TL',\n        'name': 'Turkish Lira',\n        'symbol_native': 'TL',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'TRY',\n        'name_plural': 'Turkish Lira'\n    },\n    'TTD': {\n        'symbol': 'TT$',\n        'name': 'Trinidad and Tobago Dollar',\n        'symbol_native': '$',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'TTD',\n        'name_plural': 'Trinidad and Tobago dollars'\n    },\n    'TWD': {\n        'symbol': 'NT$',\n        'name': 'New Taiwan Dollar',\n        'symbol_native': 'NT$',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'TWD',\n        'name_plural': 'New Taiwan dollars'\n    },\n    'TZS': {\n        'symbol': 'TSh',\n        'name': 'Tanzanian Shilling',\n        'symbol_native': 'TSh',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'TZS',\n        'name_plural': 'Tanzanian shillings'\n    },\n    'UAH': {\n        'symbol': '\u20b4',\n        'name': 'Ukrainian Hryvnia',\n        'symbol_native': '\u20b4',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'UAH',\n        'name_plural': 'Ukrainian hryvnias'\n    },\n    'UGX': {\n        'symbol': 'USh',\n        'name': 'Ugandan Shilling',\n        'symbol_native': 'USh',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'UGX',\n        'name_plural': 'Ugandan shillings'\n    },\n    'UYU': {\n        'symbol': '$U',\n        'name': 'Uruguayan Peso',\n        'symbol_native': '$',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'UYU',\n        'name_plural': 'Uruguayan pesos'\n    },\n    'UZS': {\n        'symbol': 'UZS',\n        'name': 'Uzbekistan Som',\n        'symbol_native': 'UZS',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'UZS',\n        'name_plural': 'Uzbekistan som'\n    },\n    'VEF': {\n        'symbol': 'Bs.F.',\n        'name': 'Venezuelan Bol\u00edvar',\n        'symbol_native': 'Bs.F.',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'VEF',\n        'name_plural': 'Venezuelan bol\u00edvars'\n    },\n    'VND': {\n        'symbol': '\u20ab',\n        'name': 'Vietnamese Dong',\n        'symbol_native': '\u20ab',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'VND',\n        'name_plural': 'Vietnamese dong'\n    },\n    'XAF': {\n        'symbol': 'FCFA',\n        'name': 'CFA Franc BEAC',\n        'symbol_native': 'FCFA',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'XAF',\n        'name_plural': 'CFA francs BEAC'\n    },\n    'XOF': {\n        'symbol': 'CFA',\n        'name': 'CFA Franc BCEAO',\n        'symbol_native': 'CFA',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'XOF',\n        'name_plural': 'CFA francs BCEAO'\n    },\n    'YER': {\n        'symbol': 'YR',\n        'name': 'Yemeni Rial',\n        'symbol_native': '\u0631.\u064a.\u200f',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'YER',\n        'name_plural': 'Yemeni rials'\n    },\n    'ZAR': {\n        'symbol': 'R',\n        'name': 'South African Rand',\n        'symbol_native': 'R',\n        'decimal_digits': 2,\n        'rounding': 0,\n        'code': 'ZAR',\n        'name_plural': 'South African rand'\n    },\n    'ZMK': {\n        'symbol': 'ZK',\n        'name': 'Zambian Kwacha',\n        'symbol_native': 'ZK',\n        'decimal_digits': 0,\n        'rounding': 0,\n        'code': 'ZMK',\n        'name_plural': 'Zambian kwachas'\n    }\n};", "wavemaker-rn-runtime/src/core/components/textinput.component.tsx": "import React, { ForwardedRef, useCallback, useEffect, useRef, useState } from 'react';\nimport { Animated, Platform, Text, TextInput, TextInputProps, TextStyle, View, ViewStyle } from 'react-native';\nimport { isArray } from 'lodash';\nimport IMask from 'imask';\nimport { FloatingLabel } from './floatinglabel.component';\n\ninterface SelectRange {\n    start: number,\n    end: number\n}\n\nconst WmCursor = React.memo((props: {\n  color: string,\n  height: number\n}) => {\n  const opacityAnimation = useRef(new Animated.Value(0.5)).current;\n  const runAnimation = useCallback(() => {\n    Animated.timing(opacityAnimation, {\n      toValue: 0.2,\n      duration: 500,\n      useNativeDriver: true\n    }).start(() => {\n      Animated.timing(opacityAnimation, {\n        toValue: 0.6,\n        duration: 500,\n        useNativeDriver: true\n      }).start(runAnimation);\n    });\n  }, []);\n  useEffect(() => {\n    runAnimation();\n  }, []);\n  return (\n    <Animated.View \n    testID=\"wm-custom-cursor\"\n    style={{\n      backgroundColor: props.color,\n      width: 2,\n      marginHorizontal: 1,\n      height: props.height,\n      opacity: opacityAnimation\n    }}></Animated.View>\n  );\n});\n\nexport const WMTextInput = React.forwardRef((props: (TextInputProps & \n  {allowContentSelection: boolean,\n    displayformat: string,\n    maskchar: string,\n    floatingLabel: string\n    floatingLabelStyle:  TextStyle & ViewStyle,\n    activeFloatingLabelStyle: TextStyle & ViewStyle,\n    customDisplayValue?: string,\n    isInputFocused: boolean,\n    autoCapitalize?: string,\n    background?: React.ReactNode,\n    handleLayout?: any,\n    style?: ViewStyle\n  }), \n    ref: ForwardedRef<TextInput>) => {\n    const [selectRange, setSelectRange] = useState<SelectRange>(null as any);\n    const [iMask, setIMask] = useState(null as any);\n    const [displayCursor, setDisplayCursor] = useState(false);\n    const value = useRef(props.value || '');\n    const [x, forceUpdate] = useState(1);\n    const [displayValue, setDisplayValue] = useState('');\n    const element = useRef(null as any);\n    // iMask initialization\n    useEffect(() => {\n      const iMask: any = props.displayformat ? new IMask.MaskedPattern({\n        mask: props.displayformat,\n        skipInvalid: true,\n        lazy: false,\n        definitions: {\n            '9': /\\d/,\n            'A': /[a-zA-Z]/,\n            'a': /[a-z]/,\n            '*': /\\w/\n        }\n      }) : null;\n      if (iMask) {\n        iMask.typedValue = value;\n        setDisplayValue(iMask.displayValue)\n        setIMask(iMask);\n      }\n    },[props.displayformat]);\n    // set default value\n    useEffect(() => {\n      const defaultValue = props.defaultValue || props.value || '';\n      if (defaultValue && !value.current) {\n        value.current = defaultValue;\n        onChangeText(defaultValue);\n      }\n    },[props.defaultValue, props.value]);\n    // set cursor position in windows\n    useEffect(() => {\n      setTimeout(() => {\n        if (Platform.OS === 'web' && (props.displayformat || props.maskchar)) {\n          element?.current?.setSelectionRange(value.current.length, value.current.length);\n        }\n      }, 100);\n    }, [value.current, props]);\n    const onSelectionChange = useCallback((e: any) => {\n        if (Platform.OS !== 'android') {\n            return;\n        }\n        const selection = e?.nativeEvent?.selection;\n        if (!props.allowContentSelection\n            && selection\n            && selection.end - selection.start > 0) {\n            setSelectRange({\n                start: value.current.length + 2,\n                end: value.current.length + 2\n            });\n        } else if (selectRange && selectRange.end > 0){\n            setSelectRange(null as any);\n        }\n    }, [props.allowContentSelection, value]);\n    // when text changes\n    const onChangeText = useCallback((text: string) => {\n      if (!(iMask || props.maskchar)) {\n        value.current = text;\n        props.onChangeText && props.onChangeText(text);\n        return;\n      }\n      let _value = value.current || '';\n      if (value.current.length - text.length > 0) {\n        _value = _value.substring(0, _value.length - (value.current.length - text.length));\n      } else if (text.length - value.current.length > 0) {\n        _value += text.slice(-1 * (text.length - value.current.length));\n      }\n      let formattedValue = _value;\n      if(props.maskchar) {\n        formattedValue = (_value.replace(/./g, props.maskchar));\n      }\n      if (iMask) {\n        iMask.typedValue = _value;\n        formattedValue = iMask.displayValue;\n      }\n      if (formattedValue !== displayValue) {\n        value.current = _value;\n        props.onChangeText && props.onChangeText(_value);\n      }\n      forceUpdate(x+ 1);\n      setDisplayValue(formattedValue);\n    }, [iMask, value, displayValue, props.onChangeText]);\n    const valueExpr = Platform.OS === 'web' ? 'value' : 'defaultValue';\n    const opts = {} as any;\n    opts[valueExpr] = props.customDisplayValue ?? value.current;\n    const textStyle = Object.assign({}, ...isArray(props.style) ? props.style: [props.style]);\n    const hideInput = props.displayformat || props.maskchar;\n    return (\n      <>\n        {props.background}\n        {props.floatingLabel ? (\n          <FloatingLabel\n            moveUp={!!(value.current || props.isInputFocused || displayValue)}\n            label={props.floatingLabel ?? props.placeholder} \n            style={{\n              ...(props.floatingLabelStyle || []),\n              ...(props.isInputFocused ? (props.activeFloatingLabelStyle || {}) : {})\n            }}/>\n        ) : null}\n        {(Platform.OS === 'android' && !props.editable) ? (\n            <Text \n              style={[\n                props.style, hideInput ? {\n                  color: 'transparent', \n                  backgroundColor: 'transparent',\n                  borderColor: 'transparent',\n                  zIndex: 1\n                } : {},\n                props.autoCapitalize ? {textTransform: 'capitalize'} : {},\n                (!props.defaultValue && props.placeholder) ? { color: props.placeholderTextColor} : {}\n              ]}\n              selectable={false}\n              disabled={true}\n              {...(props.multiline) ? {numberOfLines: props.numberOfLines} : {}}\n            >{props.defaultValue || props.placeholder}</Text>\n          ) :\n           (<TextInput\n              {...props}\n              {...hideInput || props.customDisplayValue ? opts: {}}\n              placeholder={props.floatingLabel || displayValue ? '' : props.placeholder }\n              style={[props.style, hideInput ? {\n                color: 'transparent', \n                backgroundColor: 'transparent',\n                borderColor: 'transparent',\n                zIndex: 1\n              } : {}]}\n              onFocus={(e) => {\n                props.onFocus?.(e);\n                setDisplayCursor(true);\n                element.current = e.target;\n              }}\n              onBlur={(e) => {\n                props?.onBlur?.(e);\n                setDisplayCursor(false);\n              }}\n              ref={ref}\n              selection={selectRange}\n              onSelectionChange={onSelectionChange}\n              caretHidden={!!selectRange?.end}\n              onChangeText={(text) => {\n                if(props.autoCapitalize && props.autoCapitalize === 'characters') {\n                  onChangeText(text.toUpperCase());\n                  return;\n                }\n                onChangeText(text);\n              }}\n              {...hideInput ? {\n                selectionColor: 'transparent',\n                cursorColor: 'transparent',\n                onChange : () => {}\n              }: {}}\n              contextMenuHidden={!props.allowContentSelection}\n              autoCapitalize={props.autoCapitalize}\n              onLayout={props.handleLayout}\n              numberOfLines={1}\n            >\n            </TextInput>)\n        }\n        {\n          hideInput ? (\n            <View style={[props.style, {\n              display: 'flex',\n              flexDirection: 'row',\n              alignItems: 'center',\n              marginTop: -1 * (textStyle.height || textStyle.minHeight || 0)\n                + (textStyle.marginTop || 0)}]}>\n              <Text style={{ \n                width: undefined,\n                backgroundColor: 'transparent', \n                borderColor: 'transparent',\n                padding: 0,\n                display: 'flex',\n                color: textStyle.color,\n                fontFamily: textStyle.fontFamily,\n                fontSize: textStyle.fontSize,\n                fontWeight: textStyle.fontWeight\n                }}>\n                {displayValue}\n              </Text>\n              {\n                (displayCursor && !props.displayformat) ? React.createElement(WmCursor, {\n                  color: textStyle.color || '#000000',\n                  height: textStyle.fontSize || 14\n                }) : null\n              }\n            </View>\n          ) : null\n        }\n      </>\n    );\n});\n", "wavemaker-rn-runtime/src/core/components/floatinglabel.component.tsx": "import React, { useEffect, useState } from 'react';\nimport { Animated, TextStyle, Text, ViewStyle} from 'react-native';\n\nimport { Theme } from '@wavemaker/app-rn-runtime/styles/theme';\n\nexport const FloatingLabel = (props: {\n    label?: string,\n    style?: TextStyle & ViewStyle,\n    moveUp: boolean,\n  }) => {\n    const width = (props.style?.width as number) || 160;\n    const [labelPositionX] = useState(new Animated.Value(0));\n    const [labelPositionY] = useState(new Animated.Value(0));\n    const [labelScale] = useState(new Animated.Value(1));\n    const fontSize = (props.style?.fontSize || 16);\n    useEffect(() => {\n      Animated.parallel([\n        Animated.timing(labelPositionX, {\n          toValue: props.moveUp ? -1 * 0.1 * width : 0,\n          duration: 200,\n          useNativeDriver: true,\n        }),\n        Animated.timing(labelPositionY, {\n          toValue: props.moveUp ? -1 * fontSize : 0,\n          duration: 200,\n          useNativeDriver: true,\n        }),\n        Animated.timing(labelScale, {\n          toValue: props.moveUp ? 0.8 : 1,\n          duration: 200,\n          useNativeDriver: true,\n        })\n      ]).start();\n    }, [props.moveUp]);\n    return (\n        <Animated.View style={[{\n            position: 'absolute',\n            zIndex: 1,\n            width: width,\n            transform: [\n                {translateY: labelPositionY},\n                {translateX: labelPositionX},\n                {scale: labelScale}\n            ]},\n            props.style\n        ]}\n        pointerEvents=\"none\">\n          <Text\n            style={Theme.BASE.getTextStyle(props.style)}\n            ellipsizeMode=\"tail\">\n            {props.label}\n          </Text>\n        </Animated.View>\n    );\n  };\n  ", "wavemaker-rn-runtime/src/core/device/location-service.ts": "import {Input} from \"@wavemaker/app-rn-runtime/variables/device/operation.provider\";\n\nexport interface GeoPositionInput extends Input {\n  maximumAge: number;\n  timeout: number;\n  enableHighAccuracy: boolean;\n}\n\nexport interface LocationService {\n  getCurrentGeoPosition: (params: GeoPositionInput) => any;\n}\n", "wavemaker-rn-runtime/src/core/device/camera-service.ts": "import { Input } from '@wavemaker/app-rn-runtime/variables/device/operation.provider';\nimport React from 'react';\n\nexport interface CameraInput extends Input {\n  allowImageEdit: boolean;\n  imageQuality: number;\n  imageEncodingType: string;\n  imageTargetWidth: number;\n  imageTargetHeight: number;\n}\n\nexport interface CameraService {\n  captureImage: (params: CameraInput) => any\n  captureVideo: () => any;\n}\nconst CameraContext = React.createContext<CameraService>(null as any);\n\nexport const CameraProvider = CameraContext.Provider;\nexport const CameraConsumer = CameraContext.Consumer;\n", "wavemaker-rn-runtime/src/core/device/contacts-service.ts": "import { Input } from '@wavemaker/app-rn-runtime/variables/device/operation.provider';\n\nexport interface ContactsInput extends Input {\n  contactFilter: string;\n}\n\nexport interface ContactsService {\n  getContacts: (params: ContactsInput) => any;\n}\n", "wavemaker-rn-runtime/src/core/device/calendar-service.ts": "import { Input } from '@wavemaker/app-rn-runtime/variables/device/operation.provider';\n\nexport interface CalendarInput extends Input {\n  eventTitle: string;\n  eventLocation: string;\n  eventNotes: string;\n  eventStart: Date;\n  eventEnd: Date;\n}\n\nexport interface CalendarService {\n  getEvents: (params: CalendarInput) => any;\n  createEvent: (params: CalendarInput) => any;\n  deleteEvent: (params: CalendarInput) => any;\n}\n", "wavemaker-rn-runtime/src/core/device/scan-service.ts": "import {ScanInput} from \"@wavemaker/app-rn-runtime/variables/device/scan/scan.operation\";\nimport React from 'react';\n\nexport interface ScanService {\n  scanBarcode: (params: ScanInput) => any;\n}\nconst ScanContext = React.createContext<ScanService>(null as any);\n\nexport const ScanProvider = ScanContext.Provider;\nexport const ScanConsumer = ScanContext.Consumer;\n", "wavemaker-rn-runtime/src/runtime/platform.api.ts": "import log from '@wavemaker/app-rn-runtime/core/logger';\nimport { Watcher } from './watcher';\n\nexport default {\n    log: log,\n    watchers: Watcher.ROOT\n};", "wavemaker-rn-runtime/src/runtime/App.navigator.tsx": "import React, { ReactNode } from 'react';\nimport { Platform, View } from 'react-native';\nimport { NavigationContainer, DefaultTheme } from '@react-navigation/native';\nimport { isWebPreviewMode } from '@wavemaker/app-rn-runtime/core/utils';\nimport AppConfig from '@wavemaker/app-rn-runtime/core/AppConfig';\nimport injector from '@wavemaker/app-rn-runtime/core/injector';\nimport AppDrawerNavigator from './navigator/drawer.navigator';\nimport AppStackNavigator from './navigator/stack.navigator';\nimport { isEmpty, keys, last } from 'lodash';\nimport ThemeVariables from '../styles/theme.variables';\n\ndeclare const window: any;\n\nexport interface AppNavigatorProps {\n  drawerContent: () => ReactNode;\n  drawerAnimation: string;\n  hideDrawer: boolean;\n  landingPage?: string;\n  landingPageParams?: any;\n  app: any;\n}\n\nconst getNavigationState = (pageName: string, params: any) => {\n  return {\n    routes: [{\n      name: 'pages',\n      state: {\n        index: 0,\n        routes: [{\n          name: pageName,\n          params: params\n        }]\n      }\n    }]\n  };\n};\n\nconst getStateFromPath = (path: string, options?: any) => {\n  let hash: string = window.location.hash;\n  hash = hash.substring(1);\n  if (hash && hash.startsWith('/')) {\n    hash = hash.substring(1);\n  }\n  if (!hash) {\n    return;\n  }\n  let [pageName, paramstr] = hash.split('?');\n  let params = {} as any;\n  if (paramstr) {\n    paramstr.split('&').forEach((p) => {\n      const [k, v] = p.split('=');\n      params[k] = v;\n    });\n  }\n  return getNavigationState(pageName, params);\n};\n\nconst getPathFromState = (state: any, options: any) => {\n  const pagesRoute = state?.routes[0];\n  const pageRoute: any = last(pagesRoute?.state.routes);\n  let path = '';\n  if (pageRoute) {\n    path = window.location.href.split('#')[0] + '#/'+ pageRoute.name;\n    if (!isEmpty(pageRoute.params)) {\n      path += '?' + keys(pageRoute.params).map((k) => {\n        return `${k}=${pageRoute.params[k]}`\n      }).join('&');\n    }\n  }\n  setTimeout(() => {  \n    const id = window.history.state?.id;\n    window.history.replaceState({id}, null, path);\n  });\n  return path;\n};\n\nexport const AppNavigator = (props: AppNavigatorProps) => {\n  const appConfig = injector.get<AppConfig>('APP_CONFIG');\n  const pages = {};\n  const linking = {\n    prefixes: [`${appConfig.appId}://`],\n    config: {\n      screens: {\n        \"pages\": {\n          path: \"pages\",\n          screens: pages\n        }\n      }\n    },\n    getStateFromPath: isWebPreviewMode() ? getStateFromPath : undefined,\n    getPathFromState: isWebPreviewMode()? getPathFromState: undefined\n  } as any;\n\n  const navigationTheme = {\n    ...DefaultTheme,\n    colors: {\n      ...DefaultTheme.colors,\n      background: ThemeVariables.INSTANCE.pageContentBgColor\n    },\n  };\n  \n  appConfig.pages?.forEach((p) => {\n    //@ts-ignore\n    pages[p.name] = p.name;\n  });\n  const stack = (<AppStackNavigator\n    pages={appConfig.pages || []}\n    landingPage={appConfig.landingPage}></AppStackNavigator>);\n  const leftNav = (<AppDrawerNavigator\n      drawerWidth={props.app.appConfig.leftNavWidth}\n      type={props.drawerAnimation === 'slide-over' ? 'front' : 'slide'}\n      hide={props.hideDrawer}\n      content={() => (props.drawerContent && props.drawerContent())  || (<View/>)}\n      rootComponent={stack}/>);\n      const initialState = props.landingPage && Platform.OS !== 'web' ? \n        getNavigationState(props.landingPage, props.landingPageParams)\n      : undefined;\n  return (<NavigationContainer initialState={initialState} linking={linking} theme={navigationTheme}>{leftNav}</NavigationContainer>);\n};\n", "wavemaker-rn-runtime/src/runtime/App.tsx": "import React, { ReactNode } from 'react';\nimport axios, { AxiosError, InternalAxiosRequestConfig, AxiosResponse } from 'axios';\nimport { Platform, TouchableOpacity, View, ViewStyle, StatusBar } from 'react-native';\nimport { GestureHandlerRootView } from 'react-native-gesture-handler';\nimport ProtoTypes from 'prop-types';\nimport { SafeAreaProvider, SafeAreaInsetsContext, SafeAreaView, EdgeInsets } from 'react-native-safe-area-context';\nimport { DefaultTheme, Provider as PaperProvider } from 'react-native-paper';\nimport { Linking } from 'react-native';\nimport { NativeModulesProxy } from 'expo-modules-core';\nimport * as WebBrowser from 'expo-web-browser';\nimport { get, last } from 'lodash';\nimport { RENDER_LOGGER } from '@wavemaker/app-rn-runtime/core/logger';\nimport EventNotifier from '@wavemaker/app-rn-runtime/core/event-notifier';\nimport { ThemeProvider } from '@wavemaker/app-rn-runtime/styles/theme';\nimport AppConfig, { Drawer } from '@wavemaker/app-rn-runtime/core/AppConfig';\nimport StorageService from '@wavemaker/app-rn-runtime/core/storage.service';\nimport ConstantService from '@wavemaker/app-rn-runtime/core/constant.service';\nimport NetworkService, { NetworkState } from '@wavemaker/app-rn-runtime/core/network.service';\nimport injector from '@wavemaker/app-rn-runtime/core/injector';\nimport formatters from '@wavemaker/app-rn-runtime/core/formatters';\nimport { deepCopy, isWebPreviewMode } from '@wavemaker/app-rn-runtime/core/utils';\nimport * as Utils from '@wavemaker/app-rn-runtime/core/utils';\nimport { ModalProvider } from '@wavemaker/app-rn-runtime/core/modal.service';\nimport { FixedViewContainer } from '@wavemaker/app-rn-runtime/core/fixed-view.component';\nimport { ToastProvider } from '@wavemaker/app-rn-runtime/core/toast.service';\nimport NavigationService, { NavigationServiceProvider } from '@wavemaker/app-rn-runtime/core/navigation.service';\nimport { PartialProvider } from '@wavemaker/app-rn-runtime/core/partial.service';\nimport WmNetworkInfoToaster from '@wavemaker/app-rn-runtime/components/advanced/network-info-toaster/network-info-toaster.component';\nimport ThemeVariables from '@wavemaker/app-rn-runtime/styles/theme.variables';\nimport WmMessage from '@wavemaker/app-rn-runtime/components/basic/message/message.component';\nimport { Animatedview } from '@wavemaker/app-rn-runtime/components/basic/animatedview.component';\nimport AppI18nService from '@wavemaker/app-rn-runtime/runtime/services/app-i18n.service';\n\nimport { Watcher } from './watcher';\nimport { preparePatch } from './lib-patch';\nimport AppDisplayManagerService from './services/app-display-manager.service';\nimport AppModalService from './services/app-modal.service';\nimport AppToastService from './services/app-toast.service';\nimport AppPartialService from './services/partial.service';\nimport AppSpinnerService from './services/app-spinner.service';\nimport { AppNavigator } from './App.navigator';\nimport { SecurityProvider } from '../core/security.service';\nimport { CameraProvider } from '../core/device/camera-service';\nimport CameraService from './services/device/camera-service';\nimport { ScanProvider } from '../core/device/scan-service';\nimport ScanService from './services/device/scan-service';\nimport AppSecurityService from './services/app-security.service';\nimport { getValidJSON, parseErrors } from '@wavemaker/app-rn-runtime/variables/utils/variable.utils';\nimport MaterialCommunityIconsFont from '@expo/vector-icons/build/vendor/react-native-vector-icons/Fonts/MaterialCommunityIcons.ttf';\n\nimport * as SplashScreen from 'expo-splash-screen';\nimport BasePartial from './base-partial.component';\nimport BasePage from './base-page.component';\nimport { WmMemo } from './memo.component';\nimport { BaseVariable, VariableEvents } from '../variables/base-variable';\nimport { BlurView } from 'expo-blur';\nimport * as NavigationBar from 'expo-navigation-bar';\nimport moment, { Moment } from 'moment';\n\ndeclare const window: any;\n\n//some old react libraries need this\n((View as any)['propTypes'] = { style: ProtoTypes.any })\n\nconst MIN_TIME_BETWEEN_REFRESH_CYCLES = 200;\n\nclass DrawerImpl implements Drawer {\n  content: ReactNode;\n  animation: string = 'slide-in';\n\n  constructor(private onChange: () => void) {\n\n  }\n\n  setContent(content: ReactNode) {\n    this.content = content;\n    this.onChange();\n  }\n\n  getContent() {\n    return this.content;\n  }\n\n  setAnimation(animation: string) {\n    this.animation = animation;\n    this.onChange();\n  }\n\n  getAnimation() {\n    return this.animation;\n  }\n}\nconst SUPPORTED_SERVICES = {\n  Utils: Utils,\n  CONSTANTS: ConstantService,\n  StorageService: StorageService,\n  AppDisplayManagerService: AppDisplayManagerService,\n  i18nService: AppI18nService\n};\n(global as any)['axios'] = axios;\nexport default abstract class BaseApp extends React.Component implements NavigationService {\n\n  Actions: any = {};\n  Variables: any = {};\n  onAppVariablesReady = () => { };\n  isStarted = false;\n  appConfig = injector.get<AppConfig>('APP_CONFIG');\n  private eventNotifier = new EventNotifier();\n  public baseUrl = '';\n  public targetPlatform = 'NATIVE_MOBILE';\n  public cleanup = [] as Function[];\n  public commonPartial: BasePartial = null as any;\n  private startUpVariables: string[] = [];\n  private startUpActions: string[] = [];\n  private autoUpdateVariables: string[] = [];\n  private axiosInterceptorIds: number[] = [];\n  public formatters = formatters;\n  public serviceDefinitions = {} as any;\n  private animatedRef: any;\n  public modalsOpened: number = 0;\n  public toastsOpened: number = 0;\n  public watcher: Watcher = Watcher.ROOT;\n  public paperTheme = {\n    ...DefaultTheme,\n    colors: {\n      ...DefaultTheme.colors,\n      primary: ThemeVariables.INSTANCE.primaryColor\n    }\n  };\n  public lib = preparePatch(() => {\n    this.refresh();\n  });\n\n  public networkStatus = {} as NetworkState;\n  public statusbarInsets: any;\n\n  constructor(props: any) {\n    super(props);\n    SplashScreen.preventAutoHideAsync();\n    setTimeout(() => SplashScreen.hideAsync(), 10000);\n    this.appConfig.app = this;\n    this.appConfig.drawer = new DrawerImpl(() => this.refresh());\n    AppSpinnerService.setDefaultOptions({\n      spinner: this.appConfig.spinner\n    });\n    let refreshAfterWait = false;\n    this.baseUrl = this.appConfig.url;\n    let wait = 0;\n    this.bindServiceInterceptors();\n    this.appConfig.refresh = (complete = false) => {\n      if (complete) {\n        this.reload();\n        return;\n      }\n      if (!wait) {\n        RENDER_LOGGER.debug('refreshing the app...');\n        wait = MIN_TIME_BETWEEN_REFRESH_CYCLES;\n        refreshAfterWait = false;\n        setTimeout(() => {\n          this.forceUpdate();\n          this.commonPartial?.forceUpdate();\n          this.appConfig.currentPage?.forceUpdate();\n          this.watcher.check();\n        });\n        setTimeout(() => {\n          wait = 0;\n          refreshAfterWait && this.appConfig.refresh();\n        }, wait);\n      } else {\n        RENDER_LOGGER.debug('will refresh the app in the next cycle.');\n        refreshAfterWait = true;\n      }\n    }\n    this.cleanup.push(\n      NetworkService.notifier.subscribe('onNetworkStateChange', (networkState: NetworkState) => {\n        this.networkStatus = { ...networkState };\n        this.refresh();\n      }\n      ));\n  }\n\n  subscribe(event: string, fn: Function) {\n    return this.eventNotifier.subscribe(event, fn);\n  }\n\n  notify(event: string, ...args: any) {\n    return this.eventNotifier.notify(event, args);\n  }\n\n  get activePage() {\n    return this.appConfig.currentPage;\n  }\n\n  get Widgets() {\n    return this.commonPartial?.Widgets;\n  }\n\n  async onBeforePageLeave(currentPage: string, nextPage: string) {\n    //method can be override by the user from studio;\n    return true;\n  }\n\n  goToPage(pageName: string, params: any) {\n    return this.appConfig.currentPage?.goToPage(pageName, params);\n  }\n\n  goBack(pageName: string, params: any) {\n    return this.appConfig.currentPage?.goBack(pageName, params);\n  }\n\n  openUrl(url: string, params?: any) {\n    return this.appConfig.currentPage?.openUrl(url, params);\n  }\n\n  onBeforeServiceCall(config: InternalAxiosRequestConfig) {\n    //DO NOT WRITE CODE HERE:\n    //This is a placeholder for the WaveMaker developer.\n    return config;\n  }\n\n  isSkeletonEnabled() {\n    return this.appConfig.spinner.loader == \"skeleton\";\n  }\n\n  onServiceSuccess(data: any, response: AxiosResponse) {\n    //DO NOT WRITE CODE HERE:\n    //This is a placeholder for the WaveMaker developer.\n  }\n\n  onServiceError(errorMsg: any, error: AxiosError<any>) {\n    //DO NOT WRITE CODE HERE:\n    //This is a placeholder for the WaveMaker developer.\n  }\n\n  invokeNativeApi(key: string, data: Object) {\n    if (NativeModulesProxy.EmbedCommModule\n      && (Platform.OS === 'android' || Platform.OS === 'ios')) {\n      return NativeModulesProxy.EmbedCommModule.sendToNative(key, data || {});\n    } else {\n      return Promise.reject('Not able to invoke Native API in this platform.');\n    }\n  }\n\n  triggerPageReady(activePageName: string, activePageScope: BasePage) {\n    try {\n      this.onPageReady(activePageName, activePageScope);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n\n  onPageReady(activePageName: string, activePageScope: BasePage) {\n\n  }\n\n  setTimezone(timezone: any) {\n    AppI18nService.setTimezone(timezone);\n  }\n\n  get spinner() {\n    return AppSpinnerService;\n  }\n\n  openBrowser(url: string, params = {} as any) {\n    if (url) {\n      if (isWebPreviewMode()) {\n        window.open(url, '_blank');\n      } else if (url.startsWith('http') && params.target === '_blank') {\n        WebBrowser.openBrowserAsync(url);\n      } else {\n        return Linking.openURL(url);\n      }\n    }\n    return Promise.resolve();\n  }\n\n  // To support old api\n  reload() { }\n\n  bindServiceInterceptors() {\n    this.axiosInterceptorIds = [\n      axios.interceptors.request.use((config: InternalAxiosRequestConfig) => {\n        const url = config.url as string;\n        if (!(url.startsWith('http://') || url.startsWith(\"https://\"))) {\n          config.url = this.appConfig.url + '/' + url;\n        }\n        config.headers = config.headers || {};\n        config.headers['X-Requested-With'] = 'XMLHttpRequest';\n        console.log('onBeforeService call invoked on ' + config.url);\n        this.notify('beforeServiceCall', config);\n        return this.onBeforeServiceCall(config);\n      }),\n      axios.interceptors.response.use(\n        (response: AxiosResponse) => {\n          this.onServiceSuccess(response.data, response);\n          this.notify('afterServiceCall', response.config, response);\n          return response;\n        }, (error: AxiosError<any>) => {\n          let errorDetails: any = error.response, errMsg;\n          errorDetails = getValidJSON(errorDetails?.data) || errorDetails?.data;\n          if (errorDetails && errorDetails.errors) {\n            errMsg = parseErrors(errorDetails.errors) || \"Service Call Failed\";\n          } else {\n            errMsg = error.message || \"Service Call Failed\";\n          }\n          error.message = errMsg;\n          console.error(`Error ${errMsg} recieved from ${error.response?.config?.url}`);\n          this.onServiceError(error.message, error);\n          if (error.response?.config.url?.startsWith(this.appConfig.url) && !error.response?.config.url?.includes('/services/') && error.response?.status === 401) {\n            this.appConfig.currentPage?.pageName !== 'Login' && this.appConfig.currentPage?.goToPage('Login');\n          }\n          this.notify('afterServiceCall', error.config, error);\n          return Promise.reject(error)\n        })\n    ];\n  }\n\n  eval(fn: Function, failOnError = false) {\n    try {\n      return fn.call(this);\n    } catch (e) {\n      if (failOnError) {\n        throw e;\n      } else {\n        return null;\n      }\n    }\n  }\n\n  triggerStartUpVariables() {\n    return Promise.all(this.startUpVariables.map(s => this.Variables[s] && this.Variables[s].invoke()))\n      .catch(() => { });\n  }\n\n  componentDidMount() {\n    AppSpinnerService.show({\n      spinner: this.appConfig.spinner\n    });\n    this.cleanup.push(...Object.values(this.Variables).map((v: any) => {\n      return v.subscribe(VariableEvents.BEFORE_INVOKE, () => {\n        this.notify(VariableEvents.BEFORE_INVOKE, v);\n      });\n    }));\n    this.cleanup.push(...Object.values(this.Variables).map((v: any) => {\n      return v.subscribe(VariableEvents.AFTER_INVOKE, () => {\n        this.notify(VariableEvents.AFTER_INVOKE, v);\n      });\n    }));\n    this.startUpActions.map(a => this.Actions[a] && this.Actions[a].invoke());\n    return this.triggerStartUpVariables()\n      .then(() => {\n        this.onAppVariablesReady();\n        this.isStarted = true;\n        this.forceUpdate();\n      }, () => { });\n  }\n\n  componentWillUnmount(): void {\n    this.axiosInterceptorIds.map(id => {\n      axios.interceptors.request.eject(id);\n    });\n    this.cleanup.forEach(fn => fn());\n  }\n\n  refresh() {\n    this.appConfig.refresh();\n  }\n\n  getProviders(content: React.ReactNode) {\n    return (\n      <NavigationServiceProvider value={this}>\n        <ToastProvider value={AppToastService}>\n          <PartialProvider value={AppPartialService}>\n            <SecurityProvider value={AppSecurityService}>\n              <CameraProvider value={CameraService}>\n                <ScanProvider value={ScanService}>\n                  <ModalProvider value={AppModalService}>\n                    {content}\n                  </ModalProvider>\n                </ScanProvider>\n              </CameraProvider>\n            </SecurityProvider>\n          </PartialProvider>\n        </ToastProvider>\n      </NavigationServiceProvider>\n    );\n  }\n\n  renderToasters() {\n    this.toastsOpened = AppToastService.toastsOpened.length;\n    return <WmMemo watcher={this.watcher} render={(watch) => {\n      watch(() => AppToastService.refreshCount);\n      return (\n        <>\n          {AppToastService.toastsOpened.map((o, i) => {\n            return this.getProviders((\n              <ThemeProvider value={this.appConfig.theme}>\n                <View key={i} style={[{\n                  position: 'absolute',\n                  width: '100%',\n                  bottom: 0,\n                  elevation: o.elevationIndex,\n                  zIndex: o.elevationIndex\n                }, o.styles]}>\n                  <TouchableOpacity onPress={() => o.onClick && o.onClick()}>\n                    {o.content}\n                    {o.text && <WmMessage name={\"message\" + i} type={o.type} caption={o.text} hideclose={!o.showclosebutton} onClose={o.closeToast} closeiconclass={o.closeiconclass}></WmMessage>}\n                  </TouchableOpacity>\n                </View>\n              </ThemeProvider>\n            )\n            )\n          })}\n        </>);\n    }} />;\n  }\n\n  renderDialogs(): ReactNode {\n    return <WmMemo watcher={this.watcher} render={(watch) => {\n      watch(() => last(AppModalService.modalsOpened)?.content);\n      this.modalsOpened = AppModalService.modalsOpened.length;\n      AppModalService.animatedRefs.length = 0;\n      return (\n        <>\n          {AppModalService.modalOptions.content &&\n            AppModalService.modalsOpened.map((o, i) => {\n              return (\n                <View key={(o.name || '') + i}\n                  onStartShouldSetResponder={() => true}\n                  onResponderEnd={() => o.isModal && AppModalService.hideModal(o)}\n                  style={deepCopy(styles.appModal,\n                    o.centered ? styles.centeredModal : null,\n                    o.modalStyle,\n                    {\n                      elevation: o.elevationIndex,\n                      zIndex: o.elevationIndex\n                    })}>\n                  <Animatedview entryanimation={o.animation || 'fadeIn'} delay={o.animationdelay}\n                    ref={ref => {\n                      this.animatedRef = ref;\n                      AppModalService.animatedRefs[i] = ref;\n                    }}\n                    style={[styles.appModalContent, o.contentStyle]}>\n                    <GestureHandlerRootView style={{ width: '100%', alignItems: 'center' }}>\n                      <View\n                        onStartShouldSetResponder={evt => true}\n                        onResponderEnd={(e) => e.stopPropagation()}\n                        style={{ width: '100%', alignItems: 'center' }}>\n                        {this.getProviders(o.content)}\n                      </View>\n                    </GestureHandlerRootView>\n                  </Animatedview>\n                </View>\n              )\n            }\n            )\n          }\n        </>);\n    }} />;\n  }\n\n  renderDisplayManager(): ReactNode {\n    return <WmMemo watcher={this.watcher} render={(watch) => {\n      watch(() => AppDisplayManagerService.displayOptions.content);\n      return AppDisplayManagerService.displayOptions.content\n        ? (\n          <ThemeProvider value={this.appConfig.theme}>\n            <View style={[styles.displayViewContainer, {\n              elevation: this.toastsOpened + this.modalsOpened + 1,\n              zIndex: this.toastsOpened + this.modalsOpened + 1\n            }]}>\n              {AppDisplayManagerService.displayOptions.content}\n            </View>\n          </ThemeProvider>) : null;\n    }} />\n  }\n\n  renderIosStatusbarInsetsView(statusBarCustomisation: any, insets: EdgeInsets | null){\n    return Platform.OS == 'ios' && !statusBarCustomisation?.translucent ? (\n      <View style={{\n        backgroundColor: 'white', \n        position: 'absolute',\n        top: 0, \n        height: insets?.top || 0,\n        width: '100%',\n        zIndex: 9\n      }}></View>\n    ) : <></>\n  }\n\n  renderIconsViewSupportForWeb() {\n    try {\n      return (<style type=\"text/css\">{`\n        @font-face {\n          font-family: 'MaterialCommunityIcons';\n          src: url(${MaterialCommunityIconsFont}) format('truetype');\n        }\n      `}</style>);\n    } catch (e) {\n      console.log('require react-native-vector-icons could not be loaded.');\n    }\n    return null;\n  }\n\n  getSelectedLocale() {\n    return this.appConfig.selectedLocale;\n  }\n\n  importModule(service?: string){\n    if(service == \"moment\"){\n      return moment;\n    }\n    return undefined;\n  }\n  \n  getDependency(serviceName: string): any {\n    const service = get(SUPPORTED_SERVICES, serviceName);\n    if (service) {\n      return service;\n    }\n  }\n\n  renderBlurView(position: 'top' | 'bottom', insets: any) {\n    if (!insets?.[position]) return null;\n  \n    if (Platform.OS === \"android\") {\n      NavigationBar.setPositionAsync('absolute');\n      NavigationBar.setBackgroundColorAsync(\"transparent\");\n    }\n  \n    return (\n      <BlurView\n        intensity={50}\n        tint=\"dark\"\n        experimentalBlurMethod=\"dimezisBlurView\"\n        style={{\n          [position]: 0,\n          height: insets[position],\n          width: '100%',\n          position: 'absolute',\n          zIndex: 999,\n        }}\n      />\n    );\n  }\n\n  renderTransparentView(position: 'top' | 'bottom', insets: any) {\n    if (!insets?.[position]) return null;\n  \n    if (Platform.OS === \"android\") {\n      NavigationBar.setPositionAsync('absolute');\n      NavigationBar.setBackgroundColorAsync(\"transparent\");\n    }\n  \n    return (\n      <View\n        style={{\n          [position]: 0,\n          height: insets[position],\n          width: '100%',\n          position: 'absolute',\n          zIndex: 999,\n          backgroundColor:\"rgba(0,0,0,0.4)\"\n        }}\n      ></View>\n    );\n  }\n\n  renderApp(commonPartial: React.ReactNode) {\n    this.autoUpdateVariables.forEach(value => this.Variables[value]?.invokeOnParamChange());\n    const statusBarCustomisation = this.appConfig?.preferences?.statusbarStyles;\n    const isFullScreenMode = !!statusBarCustomisation?.translucent;\n    const Wrapper = isFullScreenMode ? View : SafeAreaView;\n    return (\n      <SafeAreaProvider>\n        <SafeAreaInsetsContext.Consumer>\n          {(insets = { top: 0, bottom: 0, left: 0, right: 0 }) => {\n            this.statusbarInsets = insets;\n            return <PaperProvider theme={this.paperTheme}>\n              <React.Fragment>\n                {Platform.OS === 'web' ? this.renderIconsViewSupportForWeb() : null}\n                {this.getProviders(\n                  <Wrapper style={{ flex: 1 }}>\n                    <StatusBar\n                      backgroundColor={statusBarCustomisation?.backgroundColor}\n                      translucent={isFullScreenMode}\n                      barStyle={statusBarCustomisation?.barStyle || 'default'}\n                    />\n                    <ThemeProvider value={this.appConfig.theme}>\n                      {this.renderIosStatusbarInsetsView(statusBarCustomisation, insets)}\n                      <View style={{ flex: 1 }}>\n                        \n                          <View style={styles.container}>\n                            <GestureHandlerRootView style={styles.container}>\n                              <AppNavigator\n                                app={this}\n                                landingPage={(this.props as any).pageName}\n                                landingPageParams={(this.props as any)?.pageName && this.props}\n                                hideDrawer={this.appConfig.drawer?.getContent() === null}\n                                drawerContent={() => this.appConfig.drawer ? this.getProviders(this.appConfig.drawer.getContent()) : null}\n                                drawerAnimation={this.appConfig.drawer?.getAnimation()}></AppNavigator>\n                               <FixedViewContainer>\n                                  {commonPartial}\n                                </FixedViewContainer>\n                            </GestureHandlerRootView>\n                          </View>\n                          {this.appConfig.url ?\n                            (<WmNetworkInfoToaster appLocale={this.appConfig.appLocale}></WmNetworkInfoToaster>)\n                            : null}\n                        {this.renderToasters()}\n                        {this.renderDialogs()}\n                        {this.renderDisplayManager()}\n                      </View>\n                      {/* Statusbar blur */}\n                      {/* {isFullScreenMode ? this.renderBlurView(\"top\",insets) : null}  */}\n                      {isFullScreenMode ? this.renderTransparentView(\"top\",insets) : null} \n                      {/* Navigation bar blur */}\n                      {/* {isFullScreenMode ? this.renderBlurView(\"bottom\",insets) : null} */}\n                      {/* {isFullScreenMode ? this.renderTransparentView(\"bottom\",insets) : null} */}\n                    </ThemeProvider>\n                  </Wrapper>\n                )}\n              </React.Fragment>\n            </PaperProvider>\n          }\n          }\n        </SafeAreaInsetsContext.Consumer>\n      </SafeAreaProvider>)\n\n  }\n}\n\nconst styles = {\n  container: {\n    flex: 1\n  },\n  appModal: {\n    position: 'absolute',\n    width: '100%'\n  },\n  appModalContent: {\n    flex: 1,\n    width: '100%',\n    alignItems: 'center',\n    flexDirection: 'column',\n    justifyContent: 'center'\n  },\n  centeredModal: {\n    flex: 1,\n    position: 'absolute',\n    top: 0,\n    flexDirection: 'row',\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: 'rgba(0, 0, 0, 0.4)',\n    height: '100%'\n  },\n  displayViewContainer: {\n    position: 'absolute',\n    justifyContent: 'center',\n    width: '100%',\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0\n  } as ViewStyle\n};\n", "wavemaker-rn-runtime/src/runtime/base-prefab.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { merge } from 'lodash-es';\n\nimport { BaseComponent } from '@wavemaker/app-rn-runtime/core/base.component';\nimport PartialService, { PartialProvider } from '@wavemaker/app-rn-runtime/core/partial.service';\nimport WmPrefabContainer from '@wavemaker/app-rn-runtime/components/prefab/prefab-container.component';\nimport BaseFragment, { FragmentProps, FragmentState } from './base-fragment.component';\nimport axios from 'axios';\nimport { Watcher } from './watcher';\nimport WmLottie from '../components/basic/lottie/lottie.component';\n\n\nexport interface PrefabProps extends FragmentProps {\n  prefabname: string;\n  parentWatcher: Watcher;\n}\n\nexport interface PrefabState extends FragmentState<PrefabProps> {}\n\nexport default abstract class BasePrefab extends BaseFragment<PrefabProps, PrefabState> {\n\n    private static SERVICE_DEFINITION_CACHE = {} as any;\n\n    public static getServiceDefinitions = (prefabName: string, url: string) => {\n      const defs = BasePrefab.SERVICE_DEFINITION_CACHE[prefabName];\n      if (defs) {\n        return Promise.resolve(defs);\n      } else {\n        return axios.get(url + '/servicedefs')\n          .catch(() => ({}))\n          .then((response: any) => {\n              const serviceDefinitions = response?.data?.serviceDefs || {};\n              BasePrefab.SERVICE_DEFINITION_CACHE[prefabName] = serviceDefinitions;\n              return Promise.resolve(serviceDefinitions);\n          });\n      }\n    };\n\n    private appUrl = '';\n    private prefabParams: any = {};\n    private _renderPrefab:() => React.ReactNode = null as any;\n\n    constructor(props: PrefabProps, defualtProps: PrefabProps, private partialService: PartialService) {\n      super(props, defualtProps);\n      this.App = this.appConfig.app;\n      this.Actions = {};\n      this.Variables = {};\n      this.appUrl = this.appConfig.url;\n      this.resourceBaseUrl = `${this.baseUrl}/app/prefabs/${props.prefabname}`;\n      this.baseUrl = `${this.baseUrl}/prefabs/${props.prefabname}`;\n      this.watcher = props.parentWatcher.create();\n    }\n\n    getServiceDefinitions() {\n      return BasePrefab.getServiceDefinitions(this.props.prefabname, `${this.appUrl}/services/prefabs/${this.props.prefabname}`);\n    }\n\n    onComponentInit(w: BaseComponent<any, any, any>) {\n      super.onComponentInit(w);\n      if (w instanceof WmPrefabContainer) {\n        this.targetWidget = w;\n      }\n    }\n\n    onFragmentReady(): Promise<void> {\n      this._renderPrefab = () => {\n        const component = this.renderPrefab();\n        super.onFragmentReady()\n        .then(() => {\n          this.onContentReady();\n          this.invokeEventCallback('onLoad', [null, this]);\n        });\n        this._renderPrefab = () => this.renderPrefab();\n        return component;\n      };\n      this.refresh();\n      return Promise.resolve();\n    }\n\n    resetAppLocale() {\n      this.appLocale = merge({ }, this.appConfig.appLocale.messages, this.appConfig.appLocale.prefabMessages[this.props.prefabname]);\n      Object.values(this.fragments).forEach((f: any) => (f as BaseFragment<any, any>).resetAppLocale());\n    }\n\n    componentDidUpdate(prevProps: Readonly<PrefabProps>, prevState: Readonly<PrefabState>, snapshot?: any): void {\n      super.componentDidUpdate(prevProps, prevState, snapshot);\n      this.watcher.check();\n    }\n\n    componentWillUnmount() {\n      super.componentWillUnmount();\n      this.invokeEventCallback('onDestroy', [null, this]);\n    }\n\n    abstract renderPrefab(): React.ReactNode;\n    \n    renderWidget(props: PrefabProps) {\n      return (\n        <PartialProvider value={this.partialService}>\n          <View style={[{width: '100%'}, props.styles?.root]}>\n            {this._renderPrefab ? this._renderPrefab(): null}\n          </View>\n        </PartialProvider>\n      );\n    }\n}\n", "wavemaker-rn-runtime/src/runtime/watcher.ts": "import { isEqual as _isEqual, isArray, isObject, clone, remove, reverse, sortBy } from 'lodash';\nimport { useEffect, useMemo, useState } from 'react';\nimport { WIDGET_LOGGER } from '@wavemaker/app-rn-runtime/core/base.component';\n\nconst WATCH_LOGGER = WIDGET_LOGGER.extend(\"watch\");\n\nclass WatchExpression {\n    private last: any = null;\n    private expBody: string = null as any;\n    public lastExecutionTime = 0;\n\n    constructor(private fn: Function, private onChange: (prev: any, now: any) => any) {\n        this.last = this.execute();\n        if (isArray(this.last)) {\n            this.last = clone(this.last);\n        }\n    }\n\n    private getExpBody() {\n        if (!this.expBody) {\n            const expStr = this.fn.toString();\n            this.expBody = expStr.substring(\n                expStr.indexOf('return ') + 7,\n                expStr.lastIndexOf(';'));\n        }\n        return this.expBody;\n    }\n    \n    private execute() {\n        try {\n            return this.fn();\n        } catch(e) {\n            //do nothing\n            return null;\n        }\n    }\n\n    private isEqual($old: any, $new: any) {\n        const isArrayObj = isArray($old) || isArray($new);\n        if (isArrayObj) {\n            if (($old && !$new) \n                || (!$old && $new)\n                || $old.length !== $new.length) {\n                return false;\n            }\n            for(let i = 0; i < $old.length; i++) {\n                if ($old[i] !== $new[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return $old === $new;\n    }\n\n    get value() {\n        return this.last;\n    }\n\n    public check() {\n        const start = Date.now();\n        const now = this.execute();\n        const changed = !this.isEqual(this.last, now);\n        this.lastExecutionTime = Date.now() - start;\n        if (changed) {\n            WATCH_LOGGER.debug(() => {\n                if (this.getExpBody() !== 'fragment') {\n                    return `Watcher: <${this.getExpBody()}> Changed from ${this.last} to ${now} `;\n                }\n                return '';\n            });\n            this.onChange(this.last, now);\n            this.last = now;\n            if (isArray(this.last)) {\n                this.last = clone(this.last);\n            }\n            return true;\n        }\n        return false;\n    }\n}\n\nexport class Watcher {\n    public static ROOT = new Watcher();\n    public expressions = [] as WatchExpression[];\n    public isActive = true;\n    public parent: Watcher = null as any;\n    public children = [] as Watcher[];\n    private constructor() {}\n\n    check() {\n        if (this.isActive) {\n            this.expressions.forEach(expression => expression.check());\n            this.children.forEach(child => {\n                child.check();\n            });\n        }\n    }\n    \n    create() {\n        const child = new Watcher();\n        child.parent = this;\n        this.children.push(child);\n        return child;\n    }\n\n    remove(child: Watcher) {\n        if (this.children.length > 0) {\n            const i = this.children.indexOf(child);\n            if (i >= 0) {\n                this.children.splice(i, 1);\n            }\n        }\n    }\n\n    destroy() {\n        this.clear();\n        this.parent && this.parent.remove(this);\n    }\n\n    clear() {\n        this.children = [];\n        this.expressions = [];\n    }\n\n    watch(fn: Function, onChange: (prev: any, now: any) => any) {\n        const expression = new WatchExpression(fn, onChange);\n        this.expressions.push(expression);\n        return expression;\n    }\n\n    count() {\n        if (!this.isActive) {\n            return 0;\n        }\n        let count = this.expressions.length;\n        this.children.forEach(child => {\n            count += child.count();\n        });\n        return count;\n    }\n}\n\nexport function useWatcher(parent: Watcher) {\n    const [change, onChange] = useState({});\n    let [ watcher ] = useState(() => parent.create());\n    watcher.clear();\n    useEffect(() => { \n        return () => {\n            watcher.destroy();\n        };\n    }, []);\n    return {\n        watch: (fn: Function) => {\n            return watcher.watch(fn, () => onChange({})).value;\n        }\n    };\n};", "wavemaker-rn-runtime/src/runtime/lib-patch.ts": "\nexport const setTimeout = (onComplete: Function) => {\n    return (cb: Function, millis: number) => {\n        const patch = () => {\n            cb && cb();\n            onComplete && onComplete();\n        };\n        return global.setTimeout(patch, millis);\n    };\n};\n\nexport const setInterval = (onComplete: Function) => {\n    return (cb: Function, millis: number, ...params: any[]) => {\n        const patch = () => {\n            cb && cb();\n            onComplete && onComplete();\n        };\n        return global.setInterval(patch, millis);\n    };\n};\n\nexport const preparePatch = (onComplete: Function) => {\n    return {\n        'setTimeout': setTimeout(onComplete),\n        'setInterval': setInterval(onComplete)\n    };\n};\n", "wavemaker-rn-runtime/src/runtime/base-fragment.component.tsx": "import React from 'react';\nimport { Text, View } from 'react-native';\nimport { get, filter, isNil } from 'lodash';\n\nimport AppConfig from '@wavemaker/app-rn-runtime/core/AppConfig';\nimport { Formatter } from '@wavemaker/app-rn-runtime/core/formatters';\nimport { TestIdPrefixProvider, TextIdPrefixConsumer } from '@wavemaker/app-rn-runtime/core/testid.provider';\nimport injector from '@wavemaker/app-rn-runtime/core/injector';\nimport { toBoolean, toNumber, isFullPathUrl } from '@wavemaker/app-rn-runtime/core/utils';\nimport { BaseComponent, BaseComponentState, BaseStyles, BaseProps, LifecycleListener, ParentContext } from '@wavemaker/app-rn-runtime/core/base.component';\nimport BASE_THEME, { Theme, ThemeProvider } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseVariable, VariableEvents } from '@wavemaker/app-rn-runtime/variables/base-variable';\nimport { default as _viewPort, EVENTS as viewportEvents } from '@wavemaker/app-rn-runtime/core/viewport';\nimport App from './App';\nimport WmFormField from '@wavemaker/app-rn-runtime/components/data/form/form-field/form-field.component';\nimport WmForm from '@wavemaker/app-rn-runtime/components/data/form/form.component';\nimport { ToastConsumer, ToastService } from '@wavemaker/app-rn-runtime/core/toast.service';\nimport spinnerService from '@wavemaker/app-rn-runtime/runtime/services/app-spinner.service';\n\nimport AppI18nService from './services/app-i18n.service';\nimport { Watcher } from './watcher';\nimport WmFormAction from '@wavemaker/app-rn-runtime/components/data/form/form-action/form-action.component';\nimport WmLottie from '@wavemaker/app-rn-runtime/components/basic/lottie/lottie.component';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\nimport WmLeftPanel from '@wavemaker/app-rn-runtime/components/page/left-panel/left-panel.component';\nimport WmLabel from '../components/basic/label/label.component';\n\nexport class SkeletonAnimationProps extends BaseProps {\n  skeletonanimationresource = \"\";\n  skeletonanimationspeed = 1;\n}\n\nexport class FragmentProps extends SkeletonAnimationProps {}\n\nexport interface FragmentState<T extends FragmentProps> extends BaseComponentState<T> {}\n\nexport type FragmentStyles = BaseStyles & {\n  skeleton?: WmSkeletonStyles\n};\nexport default abstract class BaseFragment<P extends FragmentProps, S extends FragmentState<P>> extends BaseComponent<P, S, FragmentStyles> implements LifecycleListener {\n    public App: App;\n    public onReady: Function = () => {};\n    public baseUrl = '';\n    public resourceBaseUrl = '';\n    public targetWidget = null as unknown as BaseComponent<any, any, any>;\n    public Widgets: any = {};\n    public Variables: any = {};\n    public theme: Theme = BASE_THEME;\n    public appLocale: any = injector.get<AppConfig>('APP_CONFIG')?.appLocale?.messages ? injector.get<AppConfig>('APP_CONFIG').appLocale.messages : {};\n    private startUpVariables: string[] = [];\n    protected startUpVariablesLoaded = false;\n    private startUpActions: string[] = [];\n    private autoUpdateVariables: string[] = [];\n    private cleanUpVariablesandActions: BaseVariable<any>[] = [];\n    public fragmentVariables: any = {};\n    public fragmentActions: any = {};\n    public Actions: any = {};\n    public appConfig = injector.get<AppConfig>('APP_CONFIG');\n    public cache = false;\n    public refreshdataonattach= true;\n    public isReactNativeApp = true;\n    public fragments: any = {};\n    public isDetached = false;\n    public _memoize = {} as any;\n    public toaster: any;\n    public formatters: Map<string, Formatter>;\n    public serviceDefinitions = {} as any;\n    public Viewport = _viewPort;\n    public loadingMessage = React.createElement(Text, [] as any, ['loading...']);\n    public showContent = false;\n    public notification = {\n                            text: '',\n                            title: '',\n                            okButtonText: '',\n                            cancelButtonText: '',\n                            onOk: () => {},\n                            onCancel: () => {},\n                            onClose: () => {}\n                          };\n    public watcher: Watcher = null as any;\n    constructor(props: P, defaultProps?: P) {\n        super(props, null as any, defaultProps);\n        this.App = this.appConfig.app;\n        this.formatters = this.App.formatters;\n        this.Actions = Object.assign({}, this.App.Actions);\n        this.Variables = Object.assign({}, this.App.Variables);\n        this.cleanup.push(_viewPort.subscribe(viewportEvents.ORIENTATION_CHANGE, ($new: any, $old: any) => {\n          !this.isDetached && this.targetWidget && this.targetWidget.invokeEventCallback('onOrientationchange', [null, this.proxy,\n            {screenWidth: _viewPort.width,\n              screenHeight: _viewPort.height}]);\n        }));\n        this.cleanup.push(_viewPort.subscribe(viewportEvents.SIZE_CHANGE, ($new: any, $old: any) => {\n          !this.isDetached && this.targetWidget && this.targetWidget.invokeEventCallback('onResize', [null, this.proxy,\n            {screenWidth: $new.width,\n              screenHeight: $new.height}]);\n        }));\n        this.cleanup.push(() => this.theme?.destroy());\n        this.baseUrl = this.appConfig.url;\n        this.resourceBaseUrl = this.appConfig.url;\n        this.cleanup.push(() => this.onDestroy());\n    }\n\n    onContentReady() {\n      try {\n        this.onReady();\n      } catch(e) {\n        console.error(e);\n      }\n      this.appConfig.refresh();\n      this.targetWidget && this.targetWidget.invokeEventCallback('onLoad', [null, this.proxy]);\n      this.onContentReady = () => {};\n    }\n\n    onComponentChange(w: BaseComponent<any, any, any>) {\n      this.refresh();\n    }\n\n    onComponentInit(w: BaseComponent<any, any, any>) {\n      const id = w.props.id || w.props.name;\n      let formWidgets: any, formFields: any, formActions: any;\n\n      if (w instanceof WmForm) {\n        if (!this.Widgets[id]) {\n          this.Widgets[id] = w;\n        }\n        if (w.props.id) {\n          const name: any = w.props.name;\n          formWidgets = this.Widgets[name].formWidgets;\n          formFields = this.Widgets[name].formFields;\n          formActions = this.Widgets[name].buttonArray;\n          this.Widgets[name].formFields = [];\n          this.Widgets[name].buttonArray = [];\n          this.Widgets[name].formWidgets = {};\n        } else {\n          formWidgets = this.Widgets[id].formWidgets;\n          formFields = this.Widgets[id].formFields;\n          formActions = this.Widgets[id].buttonArray;\n        }\n        this.Widgets[id] = w;\n        if (w.parentFormRef) {\n          let pid = w.parentFormRef.props.id || w.parentFormRef.props.name;\n          formFields.forEach((ff: any) => {\n            const formKey = ff.props.formKey || ff.props.name;\n            this.Widgets[pid].formFields.push(ff);\n            this.Widgets[pid].formWidgets[formKey] = formWidgets[ff.props.name];\n          });\n        }\n        w.registerFormFields(formFields, formWidgets);\n        w.registerFormActions(formActions);\n        return;\n      }\n      if (w.props.formfield) {\n        if (!this.Widgets[w.props.formRef]) {\n          this.Widgets[w.props.formRef] = {formFields: [], formWidgets: {}};\n        } else if (!this.Widgets[w.props.formRef].formFields) {\n          this.Widgets[w.props.formRef].formFields = [];\n        }\n        if (!this.Widgets[w.props.formRef].formWidgets) {\n          this.Widgets[w.props.formRef].formWidgets = {}\n        }\n        this.Widgets[w.props.formRef].formWidgets[w.props.name] = w;\n        return;\n      }\n      if (w instanceof WmFormAction) {\n        if (!this.Widgets[w.props.formKey]) {\n          this.Widgets[w.props.formKey] = {};\n        }\n        if (!this.Widgets[w.props.formKey].buttonArray) {\n          this.Widgets[w.props.formKey].buttonArray = [];\n        }\n        this.Widgets[w.props.formKey].buttonArray.push(w);\n        return;\n      }\n\n      if (w instanceof WmFormField) {\n        if (!this.Widgets[w.props.formRef]) {\n          this.Widgets[w.props.formRef] = {};\n        }\n        if (!this.Widgets[w.props.formRef].formFields) {\n          this.Widgets[w.props.formRef].formFields = [];\n        }\n        this.Widgets[w.props.formRef].formWidgets = this.Widgets[w.props.formRef].formWidgets || {};\n        this.Widgets[w.props.formRef].formFields.push(w);\n        return;\n      }\n      this.Widgets[id] = w;\n      if (w instanceof BaseFragment && w !== this) {\n        this.fragments[id] = w;\n      }\n      if (w instanceof WmLeftPanel) {\n        this.appConfig.leftNavWidth = w._INSTANCE.styles?.root?.width;\n      }\n      // temporary fix need to be removed in Expo53\n      if (this.appConfig.revertLayoutToExpo50 && w instanceof WmLabel) {\n        w.styles?.root && (w.styles.root.flexDirection = \"row\");\n      }\n    }\n\n    onComponentDestroy(w: BaseComponent<any, any, any>) {\n      const id = w.props.id || w.props.name;\n      delete this.Widgets[id];\n      if (w instanceof BaseFragment) {\n        delete this.fragments[id];\n      }\n      if (w instanceof WmForm) {\n        w.formWidgets = {};\n        w.formFields = [];\n        w.formfields = {};\n      }\n    }\n\n    handleUrl(url: string) {\n      if (isFullPathUrl(url)) {\n        return url;\n      }\n      return this.appConfig.url + (url.startsWith('/') ? '' : '/') + url;\n    }\n\n    getDateFormat(fmt?: string) {\n      // getting formats from appLocale when app locale is loaded locally.\n      return (fmt || AppI18nService.dateFormat || get(this.appConfig, 'appLocale.formats.date')).replace(/d/g, 'D').replace(/E/g, 'd').replace(/y/g, 'Y');\n    }\n\n    getTimeFormat(fmt?: string) {\n      return fmt || AppI18nService.timeFormat || get(this.appConfig, 'appLocale.formats.time');\n    }\n\n    getDateTimeFormat(fmt?: string) {\n      return (fmt || AppI18nService.dateTimeFormat || (get(this.appConfig, 'appLocale.formats.date') + ' ' + get(this.appConfig, 'appLocale.formats.time'))).replace(/d/g, 'D').replace(/E/g, 'd').replace(/y/g, 'Y');\n    }\n\n    getCurrencySymbol(fmt?: string) {\n      return (fmt || AppI18nService.currencyCode || 'USD');\n    }\n\n    getStyle(classes: string, inlineStyles:any = {}) {\n      if (classes && classes.trim().length > 0) {\n        return this.theme.mergeStyle({}, this.theme.getStyle(classes), inlineStyles);\n      }\n      return inlineStyles;\n    }\n\n    getFormFieldStyles(formField: any, type: string){\n      let suffix = ''\n      switch(type){\n        case 'label' :\n          suffix = '_formLabel'\n          break\n        case 'commonField' :\n          suffix = '-input'\n          break\n        default :\n          ''\n      }\n      return formField?.classname?.trim()?.split(' ')?.map((s:string) => s.trim() + suffix).join(' ');\n    }\n\n    resetAppLocale() {\n      this.appLocale = this.appConfig.appLocale.messages;\n      Object.values(this.fragments).forEach((f: any) => (f as BaseFragment<any, any>).resetAppLocale());\n    }\n\n    eval(fn: Function, failOnError = false) {\n      try {\n        return fn.call(this);\n      } catch (e) {\n        if (failOnError) {\n          throw e;\n        } else {\n          return null;\n        }\n      }\n    }\n\n    toBoolean(val: any) {\n      if (isNil(val)) {\n        return false;\n      }\n      return toBoolean(val);\n    }\n\n    toNumber(val: any) {\n      if (isNil(val)) {\n        return val;\n      }\n      return toNumber(val);\n    }\n\n    componentWillUnmount() {\n      super.componentWillUnmount();\n      this.targetWidget && this.targetWidget.invokeEventCallback('onDestroy', [null, this.proxy]);\n    }\n\n    componentDidMount(): void {\n      this.resetAppLocale();\n      super.componentDidMount();\n    }\n\n    memoize(key: string, o: any) {\n      if (!this._memoize[key])  {\n        this._memoize[key] = o;\n      }\n      return this._memoize[key];\n    }\n\n    initVariableSpinner() {\n      let variables = filter(this.Variables, (v: BaseVariable<any>) => !!get(v, 'config.spinnerContext'));\n      const actions = filter(this.Actions, (v: BaseVariable<any>) => !!get(v, 'config.spinnerContext'));\n      variables = variables.concat(actions);\n      if (!variables.length) {\n        return;\n      }\n      this.cleanup.push(...variables.map(v => {\n          return ((v as BaseVariable<any>)\n            .subscribe(VariableEvents.BEFORE_INVOKE, () => {\n              this.App.notify(VariableEvents.BEFORE_INVOKE, v);\n              spinnerService.show({\n                message: get(v, 'config.spinnerMessage'),\n                spinner: this.App.appConfig.spinner\n              });\n            }))\n      }));\n      this.cleanup.push(...variables.map(v => {\n        return ((v as BaseVariable<any>)\n          .subscribe(VariableEvents.AFTER_INVOKE, () => {\n            this.App.notify(VariableEvents.AFTER_INVOKE, v);\n            spinnerService.hide();\n          }));\n      }));\n    }\n\n    onFragmentReady() {\n      this.cleanup.push(...Object.values({...this.Variables, ...this.Actions}).map(v => {\n        return ((v as BaseVariable<any>)\n          .subscribe(VariableEvents.AFTER_INVOKE, () => this.App.refresh()));\n      }));\n      (Object.values({...this.fragmentVariables, ...this.fragmentActions} as BaseVariable<any>))\n      .map(v => {\n        (v as BaseVariable<any>).subscribe(VariableEvents.BEFORE_INVOKE, () => {\n          this.App.notify(VariableEvents.BEFORE_INVOKE, v);\n        });\n        (v as BaseVariable<any>).subscribe(VariableEvents.AFTER_INVOKE, () => {\n          this.App.notify(VariableEvents.AFTER_INVOKE, v);\n        });\n      });\n      this.initVariableSpinner();\n      this.cleanUpVariablesandActions.push(...Object.values({...this.fragmentVariables, ...this.fragmentActions} as BaseVariable<any>));\n      this.startUpActions.map(a => this.Actions[a] && this.Actions[a].invoke());\n      return Promise.all(this.startUpVariables.map(s => this.Variables[s] && this.Variables[s].invoke()))\n      .catch((error) => {\n        // catch errors and show content\n        console.error(error);\n      })\n      .then(() => {\n        this.startUpVariablesLoaded = true;\n        this.showContent = true;\n        this.appConfig.refresh();\n      });\n    }\n\n    onAttach() {\n      this.isDetached = false;\n      this.watcher.isActive = true;\n      this.resetAppLocale();\n      Object.values(this.fragments).forEach((f: any) => f.onAttach());\n      this.cleanUpVariablesandActions.forEach((v: any) => v.unmute && v.unmute());\n      this.targetWidget?.invokeEventCallback('onAttach', [null, this.proxy]);\n      if (this.refreshdataonattach) {\n        Promise.all(this.startUpVariables.map(s => this.Variables[s] && this.Variables[s].invoke()));\n      }\n      Object.values(this.Widgets).forEach((w: any) => {\n        w.componentWillAttach && w.componentWillAttach();\n      });\n    }\n\n    onDetach() {\n      this.isDetached = true;\n      this.watcher.isActive = false;\n      Object.values(this.fragments).forEach((f: any) => f.onDetach());\n      this.cleanUpVariablesandActions.forEach((v: any) => v.mute && v.mute());\n      this.targetWidget?.invokeEventCallback('onDetach', [null, this.proxy]);\n      Object.values(this.Widgets).forEach((w: any) => {\n        w.componentWillDetach && w.componentWillDetach();\n      });\n    }\n\n    onDestroy() {\n      this.cleanUpVariablesandActions.forEach((v: any) => v.destroy());\n      this.watcher.destroy();\n    }\n\n    refresh() {\n      (injector.get('AppConfig') as AppConfig).refresh();\n    }\n\n    forceUpdate() {\n      super.forceUpdate();\n      Object.values(this.fragments).forEach((f: any) => (f as BaseFragment<any, any>).forceUpdate());\n    }\n\n    generateTestIdPrefix() {\n      const testId = this.getTestId();\n      return testId && (testId.split('')\n        .reduce((a, v, i) => a + (v.charCodeAt(0)  * (i + 1)), 0) + '');\n    }\n\n    render() {\n      if (this.startUpVariablesLoaded) {\n        this.autoUpdateVariables\n          .forEach(value => this.Variables[value]?.invokeOnParamChange());\n      }\n      return this.isVisible() ? (\n      <ParentContext.Consumer>\n        {(parent) => {\n        this.setParent(parent);\n        this._showSkeleton = this.state.props.showskeleton !== false \n        && (this.parent?._showSkeleton || this.state.props.showskeleton === true);\n        let theme = this.theme;\n        return (\n      <ParentContext.Provider value={this}>\n        <ThemeProvider value={theme}>\n          <TextIdPrefixConsumer>\n              {(testIdPrefix) => {\n                this.testIdPrefix = testIdPrefix || '';\n                return (\n                <TestIdPrefixProvider value={this.generateTestIdPrefix() || ''}>\n                  <ToastConsumer>\n                  {(toastService: ToastService) => {\n                    this.toaster = toastService;\n                    return this.renderWidget(this.props);\n                  }}\n                </ToastConsumer>\n                </TestIdPrefixProvider>);\n              }}\n          </TextIdPrefixConsumer>\n        </ThemeProvider>\n      </ParentContext.Provider>);\n      }}\n      </ParentContext.Consumer>) : null;\n    }\n\n\n}\n\n\n", "wavemaker-rn-runtime/src/runtime/base-partial.component.tsx": "import React from 'react';\nimport { BaseComponent } from '@wavemaker/app-rn-runtime/core/base.component';\nimport WmPartial from '@wavemaker/app-rn-runtime/components/page/partial/partial.component';\nimport BaseFragment, { FragmentProps, FragmentState } from './base-fragment.component';\nimport { ReactNode } from 'react';\nimport BasePrefab from './base-prefab.component';\nimport { Watcher } from './watcher';\nimport { View } from 'react-native';\nimport WmLottie from '../components/basic/lottie/lottie.component';\n\nexport interface PartialProps extends FragmentProps {\n  serviceDefinitions: any;\n  prefab: any;\n  parent: any;\n  onLoad?: Function;\n  parentWatcher: Watcher;\n  invokeVariables: boolean;\n}\n\nexport interface PartialState extends FragmentState<PartialProps> {}\n\nexport default abstract class BasePartial extends BaseFragment<PartialProps, PartialState> {\n    private partialParams: any = {};\n    Prefab: BasePrefab = null as any;\n\n    constructor(props: PartialProps) {\n        super(props);\n        const isPartOfPrefab = !!this.props.prefab;\n        this.App = this.appConfig.app;\n        this.Actions = Object.assign({}, isPartOfPrefab ? {} : this.App.Actions);\n        this.Variables = Object.assign({}, isPartOfPrefab ? {} : this.App.Variables);\n        this.serviceDefinitions = this.props.serviceDefinitions;\n        if (isPartOfPrefab) {\n          this.Prefab = this.props.prefab;\n          this.baseUrl =this.Prefab.baseUrl;\n        }\n        this.watcher = props.parentWatcher.create();\n    }\n\n    onFragmentReady() {\n      if(this.props.invokeVariables === false) {\n        return Promise.resolve();\n      }\n      return super.onFragmentReady().then(() => {\n        this.onContentReady();\n        this.invokeEventCallback('onLoad', [this]);\n      });\n    }\n\n    get prefabname() {\n      return this.Prefab?.props.prefabname;\n    }\n\n    onComponentInit(w: BaseComponent<any, any, any>) {\n      super.onComponentInit(w);\n      if (w instanceof WmPartial) {\n        this.targetWidget = w;\n      }\n    }\n\n    onComponentDestroy(w: BaseComponent<any, any, any>): void {\n      super.onComponentDestroy(w);\n      const parent: any = this.props.parent;\n      if (parent) {\n        delete (parent as any).Widgets;\n        delete (parent as any).Variables;\n      }\n    }\n\n    componentDidUpdate(prevProps: Readonly<PartialProps>, prevState: Readonly<PartialState>, snapshot?: any): void {\n      super.componentDidUpdate(prevProps, prevState, snapshot);\n      const parent: any = this.props.parent;\n      if (parent) {\n        parent.pageParams = (this as any).pageParams;\n        parent.partialParams  = (this as any).pageParams;\n        parent.Widgets = this.Widgets;\n        parent.Variables = this.fragmentVariables;\n      }\n    }\n    \n    abstract renderPartial(): ReactNode;\n\n    renderWidget(props: PartialProps) {\n      return this.renderPartial();\n    }\n}\n", "wavemaker-rn-runtime/src/runtime/memo.component.tsx": "import React from \"react\";\nimport { Watcher } from \"./watcher\";\n\ninterface MemoProps {\n    watcher: Watcher;\n    render: (watch: Function) => React.ReactNode\n}\n\ninterface MemoState {\n    id: number;\n}\n\nexport class WmMemo extends React.Component<MemoProps, MemoState> {\n\n    private watcher: Watcher = null as any;\n\n    constructor(props: MemoProps) {\n        super(props);\n        this.watcher = props.watcher.create();\n        this.state = {\n            id: 0\n        }\n    }\n\n    shouldComponentUpdate(nextProps: any, nextState: any) {\n        return Object.keys(nextProps).reduce((p, k) => {\n            return p || (k !== 'render' && (this.props as any)[k] !== nextProps[k]);\n        }, false) || this.state.id !== nextState.id;\n    }\n\n    componentWillUnmount() {\n        this.watcher && this.watcher.destroy();\n    }\n\n    refresh = () => {\n        this.setState({\n            id: this.state.id + 1\n        });\n    }\n\n     watch(fn: Function) {\n        return this.watcher.watch(fn, this.refresh).value;\n     }\n\n    render() {\n        this.watcher.clear();\n        return this.props.render(this.watch.bind(this));\n    }\n}", "wavemaker-rn-runtime/src/runtime/base-page.component.tsx": "import { clone, isEqual } from 'lodash';\nimport React, { ReactNode } from 'react';\nimport { CommonActions } from '@react-navigation/native';\nimport * as SplashScreen from 'expo-splash-screen';\nimport { BaseComponent } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmPage from '@wavemaker/app-rn-runtime/components/page/page.component';\nimport NavigationService, { NavigationServiceProvider } from '@wavemaker/app-rn-runtime/core/navigation.service';\n\nimport AppSecurityService from './services/app-security.service';\nimport AppSpinnerService from './services/app-spinner.service';\nimport BaseFragment, { FragmentProps, FragmentState } from './base-fragment.component';\nimport { Watcher } from './watcher';\nimport { setCurrentPageInAppLayout } from '../core/utils';\n\ndeclare const window: any;\n\nexport interface PageProps extends FragmentProps {\n  route: any;\n  navigation: any;\n  destroyMe: Function;\n}\n\nexport interface PageState extends FragmentState<PageProps> {}\n\nexport default abstract class BasePage extends BaseFragment<PageProps, PageState> implements NavigationService {\n    private pageName = null as unknown as string;\n    private pageParams: any = {};\n    private hasDrawer = false;\n    private hasTabbar = false;\n    private drawerContent = null as React.ReactNode;\n    private drawerType = '';\n\n    constructor(props: PageProps) {\n      super(props);\n      setTimeout(() => {\n        SplashScreen.hideAsync();\n      }, 300);\n      this.pageName = props.route.name;\n      this.pageParams = props.route.params;\n      this.appConfig.currentPage = this;\n      this.appConfig.drawer?.setContent(null);\n      this.serviceDefinitions = this.App.serviceDefinitions;\n      this.watcher = Watcher.ROOT.create();\n      AppSecurityService.canUserAccessPage(this.pageName)\n        .then(flag => {\n          if (!flag) {\n            this.cache = false;\n            AppSecurityService.redirectToLogin(this.toHashURL());\n          }\n        });\n      if (this.App.appConfig.diagnostics.pageStartTime < 0) {\n        this.App.appConfig.diagnostics.pageStartTime = Date.now();\n      }\n\n      setCurrentPageInAppLayout(props.route.name);\n    }\n\n    onComponentInit(w: BaseComponent<any, any, any>) {\n      super.onComponentInit(w);\n      if (w instanceof WmPage) {\n        this.targetWidget = w;\n        const props = w.props as any;\n        this.cache = !(props.cache === false);\n        this.refreshdataonattach = !(props.refreshdataonattach === false);\n      }\n    }\n\n    toggleDrawer() {\n      (this.props as PageProps).navigation.toggleDrawer();\n    }\n\n    setDrawerContent(content = this.drawerContent, drawerType = this.drawerType) {\n      if (!content) {\n        return;\n      }\n      this.drawerContent = content;\n      this.drawerType = drawerType;\n      this.hasDrawer = true;\n      setTimeout(() => {\n        if (this.appConfig.currentPage === this \n          || this.appConfig.currentPage.proxy === this) {\n          this.appConfig.drawer?.setContent(null);\n          setTimeout(() => {\n            this.appConfig.drawer?.setContent((\n              <NavigationServiceProvider value={this}>\n              {content}\n              </NavigationServiceProvider>));\n          }, 500);\n          this.appConfig.drawer?.setAnimation(drawerType);\n        }\n      }, 10);\n    }\n\n    onAttach() {\n      super.onAttach();\n      this.setDrawerContent();\n      this.App.appConfig.diagnostics.pageReadyTime = Date.now();\n      this.App.notify('pageAttached', this);\n    }\n\n    onFragmentReady() {\n      return super.onFragmentReady().then(() => {\n        this.onContentReady();\n        this.App.triggerPageReady(this.pageName, this.proxy as BasePage);\n        this.App.appConfig.diagnostics.pageReadyTime = Date.now(); \n        this.App.notify('pageReady', this);\n        AppSpinnerService.hide();\n        this.cleanup.push((this.props as PageProps).navigation.addListener('focus', () => {\n          if (this.appConfig.currentPage !== this) {\n            this.appConfig.currentPage = this;\n            this.onAttach();\n            this.appConfig.refresh();\n          }\n        }));\n      });\n    }\n\n    componentWillUnmount() {\n      super.componentWillUnmount();\n      this.App.notify('pageDestroyed', this);\n    }\n\n    async canNavigate (currentPage: string, nextPage: string) {\n      let navigate = true;\n      navigate = await this.onBeforePageLeave(currentPage, nextPage);\n      if(navigate !== false){\n        navigate = await this.App.onBeforePageLeave(currentPage, nextPage);\n      }\n\n      if(navigate !== false) navigate = true;\n\n      return navigate; \n    }\n\n    async onBeforePageLeave(currentPage: string, nextPage: string) {\n      //method can be override by the user from studio;\n      return true;\n    }\n\n    async goToPage(pageName: string, params: any, clearCahe = false) {\n      const isNavigable = await this.canNavigate(this.pageName, pageName)\n      if(!isNavigable){\n        return Promise.resolve();\n      }\n\n      const navigation = (this.props as PageProps).navigation;\n      const _params = clone(params);\n      _params && delete _params['pageName'];\n      this.App.appConfig.diagnostics.pageStartTime = Date.now();\n      if (pageName !== this.pageName || !isEqual(_params || null, this.pageParams || null)) {\n        if (pageName === this.pageName) {\n          navigation.push(pageName, _params);\n        } else if (clearCahe) {\n          navigation.dispatch(CommonActions.reset({\n            index: 0,\n            routes: [\n              { name: pageName, params: params }\n            ]}));\n        } else {\n          navigation.navigate(pageName, _params);\n        }\n        if (this.cache) {\n          this.onDetach();\n        } else {\n          this.props.destroyMe();\n        }\n      } else {\n        (this.props as PageProps).navigation.closeDrawer();\n      }\n      return Promise.resolve();\n    }\n\n    public navigateToLandingPage() {\n      AppSecurityService.navigateToLandingPage();\n    }\n\n    public toHashURL() {\n      const hash = `#/${this.pageName}`;\n      const paramStr = Object.keys(this.pageParams || [])\n        .map(k => k && `${k}=${this.pageParams[k]}`)\n        .join('&');\n      return hash + (paramStr ? `?${paramStr}` : '');\n    }\n\n    async goBack() {\n      const navigation = (this.props as PageProps).navigation;\n      const routes = navigation.getState()?.routes;\n      let isNavigable = true;\n\n      if(navigation.canGoBack()){\n        isNavigable = await this.canNavigate(this.pageName, routes[routes.length - 2].name)\n      }\n      if(!isNavigable){\n        return Promise.resolve();\n      }\n\n      this.App.appConfig.diagnostics.pageStartTime = Date.now();\n      if (navigation.canGoBack()) {\n        navigation.goBack();\n      } else if (window && window.history) {\n        window.history.back();\n      }\n      return Promise.resolve();\n    }\n\n    openUrl(url: string, params = {} as any) {\n      if (url) {\n        if (url.startsWith('#')) {\n          url = url.substring(1);\n          url = url.startsWith('/') ? url.substring(1) : url;\n          const splits = url.split('?');\n          const pageName = splits[0];\n          let params = {} as any;\n          if (splits.length > 1) {\n            splits[1].split('&')\n              .map(p => p.split('='))\n              .forEach(p => params[p[0]] = p[1]);\n          }\n          return this.goToPage(pageName, params);\n        } else {\n          this.App.openBrowser(url, params);\n        }\n      }\n      return Promise.resolve();\n    }\n\n    isActiveTabbarItem({label, link, links}: {label: string, link: string, links: string[]}) {\n      const pageName = this.pageName;\n      const possibleLinks = [pageName, '#' + pageName, '#/' + pageName];\n      return links && links.find(l => possibleLinks.includes(l));\n    }\n\n    abstract renderPage(): ReactNode;\n\n    renderWidget(props: PageProps) {\n      return this.renderPage();\n    }\n}\n", "wavemaker-rn-runtime/src/runtime/navigator/drawer.navigator.tsx": "import React, { ReactNode } from 'react';\nimport { createDrawerNavigator, getDrawerStatusFromState } from '@react-navigation/drawer';\nimport ThemeVariables from '@wavemaker/app-rn-runtime/styles/theme.variables';\nconst Drawer = createDrawerNavigator();\n\ninterface AppDrawerNavigatorProps {\n  content: (props: any) => ReactNode;\n  hide: boolean,\n  drawerWidth: any;\n  type: any;\n  rootComponent: React.ReactNode;\n}\n\nclass AppDrawerNavigator extends React.Component<AppDrawerNavigatorProps, any, any> {\n\n  constructor(props: AppDrawerNavigatorProps) {\n    super(props);\n  }\n\n  render(){\n    return (<Drawer.Navigator\n      initialRouteName=\"pages\"\n      drawerContent={this.props.content}\n      useLegacyImplementation={false}\n      screenOptions={({navigation})=> {\n        const widthStyle = (this.props.drawerWidth && getDrawerStatusFromState(navigation.getState()) === 'open' ? {width: this.props.drawerWidth, maxWidth: null} : {})\n        return {\n          drawerType: this.props.type,\n          headerShown: false,\n          gestureHandlerProps: { enabled: !this.props.hide },\n          drawerStyle: { backgroundColor:  ThemeVariables.INSTANCE.pageContentBgColor, ...widthStyle}}\n      }}>\n      <Drawer.Screen name=\"pages\">\n        {(_props) => this.props.rootComponent}\n      </Drawer.Screen>\n    </Drawer.Navigator>);\n  }\n}\n\nexport default AppDrawerNavigator;\n", "wavemaker-rn-runtime/src/runtime/navigator/stack.navigator.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { createStackNavigator } from '@react-navigation/stack';\nimport ThemeVariables from '@wavemaker/app-rn-runtime/styles/theme.variables';\n\nconst Stack = createStackNavigator();\n\ninterface AppStackNavigatorProps {\n  pages: any[];\n  landingPage: string; \n}\n\nconst pages = {} as any;\n\nclass Screen extends React.Component {\n\n  private cleanUp = [] as Function[];\n\n  constructor(props: any) {\n    super(props);\n    this.state = {\n      renew: false,\n      page: this.createPage()\n    };\n    const navigation = (this.props as any).navigation as any;\n    this.cleanUp.push(navigation.addListener('focus', () => {\n      const state = (this.state as any);\n      if (state.renew) {\n        state.page = this.createPage();\n        this.setState(() => ({\n          renew: false,\n          page: state.page\n        }));\n      }\n    }));\n  }\n\n  private createPage() {\n    const props = this.props as any;\n    return React.createElement(pages[props.route.name].component, {...props, destroyMe: () => {\n      setTimeout(() => {\n        this.setState(() => ({renew: true, page: null}));\n      }, 100);\n    }});\n  }\n\n  componentWillUnmount() {\n    this.cleanUp.forEach(fn => fn && fn());\n  }\n\n  render() {\n    return (this.state as any).page || (<View/>);\n  }\n}\n\nconst getPageId = (pageName: string, pageParams: any) => {\n  const pageParamsStr = pageParams ? Object.keys(pageParams)\n    .sort()\n    .map((k: string) => `${k}=${pageParams[k]}`)\n    .join('&') : '';\n  return `${pageName}?${pageParamsStr}`;\n}\n\nconst AppStackNavigator = (props: AppStackNavigatorProps) => {\n  return (<Stack.Navigator initialRouteName={props.landingPage}>\n    {props.pages.map(p => {\n      pages[p.name] = p;\n      return (\n        <Stack.Screen key={p.name}\n          name={p.name}\n          component={Screen}\n          getId={({params}) => getPageId(p.name, params)}\n          options={{\n            headerShown: false,\n            cardStyle: {\n              backgroundColor: ThemeVariables.INSTANCE.pageContentBgColor\n            }\n          }}\n        />);\n      })}\n  </Stack.Navigator>);\n};\n\nexport default AppStackNavigator;", "wavemaker-rn-runtime/src/runtime/services/webprocess.service.tsx": "import axios from \"axios\";\nimport React, { Component } from \"react\";\nimport { Dimensions, View } from \"react-native\";\n\nimport WmWebview from \"@wavemaker/app-rn-runtime/components/advanced/webview/webview.component\";\nimport AppConfig from \"@wavemaker/app-rn-runtime/core/AppConfig\";\nimport injector from \"@wavemaker/app-rn-runtime/core/injector\";\n\nimport AppDisplayManagerService from \"./app-display-manager.service\";\n\ndeclare const window: any, document: any, alert: any;\n\nconst windowWidth = Dimensions.get('window').width;\nconst windowHeight = Dimensions.get('window').height;\n\nclass WebProcessWebViewProps {\n    src: string = \"\";\n    process: string = \"\";\n    incognito = false;\n    onComplete?: (output: string) => any = null as any;\n}\n  \nclass WebProcessWebView extends Component<WebProcessWebViewProps> {\n\n    constructor(props: WebProcessWebViewProps) {\n      super(props);\n    }\n\n    private getScriptToInject(process: string): string {\n        return `(function() {\n            var elements = document.querySelectorAll('body.flex>a.link');\n            for (var i = 0; i < elements.length; i++) {\n                var href = elements[i].href;\n                if (href && href.indexOf('://services/webprocess/${process}?process_output=')) {\n                    return href.split('process_output=')[1];\n                }\n            }\n            window.isWebLoginProcess = true;\n        })()`;\n    }\n\n    render() {\n      return(\n        <View style={{\n          width: windowWidth,\n          height: windowHeight\n        }}>\n          <WmWebview src={this.props.src}\n            incognito={this.props.incognito}\n            styles={{\n            root: {\n              width: '100%',\n              height: '100%'\n            }\n          }}\n          onLoad={(e, w) => {\n            setTimeout(() => {\n              w.executeScript(this.getScriptToInject(this.props.process))\n              .then((output) => {\n                  if (output) {\n                    const onComplete = this.props.onComplete;\n                    onComplete && onComplete(output as string);\n                  }\n              });\n            }, 1000);\n          }}></WmWebview>\n        </View>\n      );\n    }\n}\n\nexport class WebProcessService {\n\n    baseUrl: string | null = null;\n\n    constructor() {}\n\n    public execute(process: string, hookUrl: string, useSystemBrowser = false, incognito = false): Promise<any> {\n        if (!this.baseUrl) {\n            this.baseUrl = injector.get<AppConfig>('APP_CONFIG').url;\n          }\n        return axios.get(this.baseUrl + `/services/webprocess/prepare?processName=${process}&hookUrl=${hookUrl}&requestSourceType=MOBILE`, {\n          withCredentials: true\n        })\n            .then((response) => {\n                if (useSystemBrowser) {\n                    return this.executeWithSystemBrowser(response.data);\n                } else {\n                    return this.executeWithInAppBrowser(response.data, process, incognito);\n                }\n            }).then(output => {\n                return axios.get(this.baseUrl + '/services/webprocess/decode?encodedProcessdata=' + output, {\n                  withCredentials: true\n                });\n            });\n    }\n\n    private executeWithSystemBrowser(processInfo: string): Promise<any> {\n        return Promise.reject('Web Process in System browser is nor ready yet');\n    }\n\n    private executeWithInAppBrowser(processInfo: string, process: string, incognito: boolean): Promise<any> {\n        return new Promise((resolve, reject) => {\n            let destroyFn = () => {};\n            destroyFn = AppDisplayManagerService.show({\n                content: (\n                  <WebProcessWebView \n                    src={this.baseUrl  + '/services/webprocess/start?process=' + encodeURIComponent(processInfo)}\n                    incognito={incognito}\n                    process={process}\n                    onComplete={(ouput) => {\n                      resolve(ouput);\n                      destroyFn.call(AppDisplayManagerService);\n                    }}></WebProcessWebView>\n                ),\n                \n              });\n        });\n    }\n}\n\nexport default new WebProcessService();", "wavemaker-rn-runtime/src/runtime/services/app-modal.service.tsx": "import { BackHandler } from \"react-native\";\n\nimport injector from '@wavemaker/app-rn-runtime/core/injector';\nimport AppConfig from '@wavemaker/app-rn-runtime/core/AppConfig';\nimport { ModalOptions, ModalService } from '@wavemaker/app-rn-runtime/core/modal.service';\nimport { isAndroid, isWebPreviewMode } from \"@wavemaker/app-rn-runtime/core/utils\";\n\nclass AppModalService implements ModalService {\n    public modalOptions = {} as ModalOptions;\n\n    public modalsOpened = [] as ModalOptions[];\n    public appConfig: any;\n\n    animatedRefs: any = [];\n\n    private clearBackButtonPress() {\n      if (isAndroid() && !isWebPreviewMode()) {\n        BackHandler.removeEventListener('hardwareBackPress', this.handleBackButtonPress);\n      }\n    }\n\n    private setBackButtonPress() {\n      this.clearBackButtonPress();\n      if (isAndroid() && !isWebPreviewMode() && this.modalsOpened.length > 0) {\n        BackHandler.addEventListener('hardwareBackPress', this.handleBackButtonPress);\n      }\n    }\n\n    private handleBackButtonPress = () => {\n      if (this.modalsOpened.length) {\n        this.hideModal();\n        return true;\n      }\n      return false;\n    }\n\n    private getAppConfig() {\n      if (!this.appConfig) {\n        this.appConfig = injector.get<AppConfig>('APP_CONFIG');\n      }\n      return this.appConfig;\n    }\n\n    private showLastModal() {\n        this.modalOptions = this.modalsOpened.length ? this.modalsOpened[this.modalsOpened.length - 1] : {} as ModalOptions;\n        this.refresh();\n        this.setBackButtonPress();\n    }\n\n    public refresh() {\n      this.getAppConfig().refresh();\n    }\n\n    public showModal(options: ModalOptions) {\n        const i = this.modalsOpened.findIndex(o => o === options);\n        if (i < 0) {\n          options.elevationIndex = parseInt(this.getAppConfig().app.toastsOpened + this.modalsOpened.length + 1);\n          this.modalsOpened.push(options);\n            this.showLastModal();\n             // widgets in dialog are not accessible. Hence adding setTimeout\n        setTimeout(() => {\n          this.modalOptions.onOpen && this.modalOptions.onOpen();\n        },500);\n        }\n    }\n\n    public hideModal(options?: ModalOptions) {\n        const i = options ? this.modalsOpened.findIndex(o => o === options) : (this.modalsOpened.length - 1);\n        if (i >= 0) {\n          Promise.resolve()\n            .then(() => this.modalsOpened.length > 1 && this.animatedRefs && this.animatedRefs[i].triggerExit())\n            .then(() => {\n              const o = this.modalsOpened[i];\n              return o && o.onClose && o.onClose();\n            })\n            .then(() => this.modalsOpened.splice(i, 1))\n            .then(() => this.showLastModal());\n        }\n        this.clearBackButtonPress();\n    }\n}\n\nconst appModalService = new AppModalService();\n\nexport default appModalService;\n", "wavemaker-rn-runtime/src/runtime/services/app-toast.service.tsx": "import injector from '@wavemaker/app-rn-runtime/core/injector';\nimport AppConfig from '@wavemaker/app-rn-runtime/core/AppConfig';\nimport { ToastOptions, ToastService } from '@wavemaker/app-rn-runtime/core/toast.service';\n\nclass AppToastService implements ToastService {\n\n    public toastsOpened = [] as ToastOptions[];\n    public appConfig: any;\n    public refreshCount = 0;\n\n    private getAppConfig() {\n      if (!this.appConfig) {\n        this.appConfig = injector.get<AppConfig>('APP_CONFIG');\n      }\n      return this.appConfig;\n    }\n    \n    refresh() {\n      this.refreshCount++;\n      this.appConfig.refresh();\n    }\n\n    public showToast(options: ToastOptions) {\n        const i = this.toastsOpened.findIndex(o => o.name === options.name);\n        let timeout: any;\n        this.refreshCount++;\n        if (i < 0) {\n          options.elevationIndex = this.toastsOpened.length + this.getAppConfig().app.modalsOpened + 1;\n          this.toastsOpened.push(options);\n            // hide the toast when toaster is clicked\n            if (options.hideOnClick) {\n              let cb = options.onClick;\n              options.onClick = () => {\n                cb && cb();\n                this.hideToast(options);\n                clearTimeout(timeout);\n              }\n            }\n            if (options.duration) {\n              timeout = setTimeout(() => {\n                    this.hideToast(options);\n                }, options.duration);\n            }\n            options.closeToast = () => {\n              this.hideToast(options);\n              clearTimeout(timeout);\n            }\n        }\n        this.refresh();\n    }\n\n    public hideToast(options?: ToastOptions) {\n        const i = options ? this.toastsOpened.findIndex(o => o.name === options.name) : (this.toastsOpened.length - 1);\n        if (i >= 0) {\n            const o = this.toastsOpened.splice(i, 1)[0];\n            this.refresh();\n            options?.onClose && options.onClose();\n        }\n    }\n}\n\nconst appToastService = new AppToastService();\n\nexport default appToastService;\n", "wavemaker-rn-runtime/src/runtime/services/partial.service.tsx": "import injector from '@wavemaker/app-rn-runtime/core/injector';\nimport PartialService from '@wavemaker/app-rn-runtime/core/partial.service';\nimport AppConfig from '@wavemaker/app-rn-runtime/core/AppConfig';\n\nexport class PartialServiceImpl implements PartialService {\n\n    public constructor(private partials = null as any) {\n\n    }\n\n    get(partialName: string) {\n        if (!this.partials) {\n            this.partials = injector.get<AppConfig>('APP_CONFIG').partials;\n        }\n        const partial = this.partials.find((p: any) => p.name === partialName);\n        return partial?.component;\n    }\n}\n\nexport default new PartialServiceImpl();", "wavemaker-rn-runtime/src/runtime/services/app-i18n.service.tsx": "import axios, { AxiosResponse } from 'axios';\nimport StorageService from '@wavemaker/app-rn-runtime/core/storage.service';\nimport { isWebPreviewMode } from '@wavemaker/app-rn-runtime/core/utils';\nimport { I18nManager, Platform } from 'react-native';\nimport { I18nService } from '@wavemaker/app-rn-runtime/core/i18n.service';\n\nconst APP_LOCALE_ROOT_PATH = '/resources/i18n';\nconst STORAGE_KEY = 'selectedLocale';\nconst RTL_LANGUAGE_CODES = (()=>{\n  const map = {} as any;\n  [\"ar\", \"ar-001\", \"ar-ae\", \"ar-bh\", \"ar-dz\", \"ar-eg\", \"ar-iq\", \"ar-jo\", \"ar-kw\", \"ar-lb\",\n   \"ar-ly\", \"ar-ma\", \"ar-om\", \"ar-qa\", \"ar-sa\", \"ar-sd\", \"ar-sy\", \"ar-tn\", \"ar-ye\", \"arc\",\n    \"bcc\", \"bqi\", \"ckb\", \"dv\", \"fa\", \"glk\", \"he\", \"ku\", \"mzn\", \"pnb\", \"ps\", \"sd\", \"ug\", \"ur\", \"yi\"].forEach(v=>{\n      map[v] = true;\n    });\n    return map;\n  })();\n\nclass AppI18nService implements I18nService{\n    appLocale: any;\n    defaultSupportedLocale = 'en';\n    selectedLocale: any;\n    dateFormat: string = '';\n    timeFormat: string = '';\n    dateTimeFormat: string = '';\n    currencyCode: string = '';\n    timezone: string = '';\n\n    constructor() {}\n\n    async init() {\n      this.selectedLocale = await StorageService.getItem(STORAGE_KEY);\n    }\n\n    isRTLLocale(newLocale: string = this.selectedLocale){\n      return !!(newLocale && RTL_LANGUAGE_CODES[newLocale]);\n    }\n\n    setRTL(locale?: string){\n      const flag = this.isRTLLocale(locale);\n      const needsRestart = !isWebPreviewMode() && I18nManager.isRTL !== flag;\n      I18nManager.allowRTL(flag);\n      I18nManager.forceRTL(flag);\n      return needsRestart; \n    }\n\n    loadAppLocaleBundle(url: string) {\n        return Promise.resolve().then(() => {\n          const path = `${url + APP_LOCALE_ROOT_PATH}/${this.selectedLocale}.json`;\n          return axios.get(path)\n            .then((bundle) => {\n              this.dateFormat = bundle.data.formats.date;\n              this.timeFormat = bundle.data.formats.time;\n              this.currencyCode = bundle.data.formats.currency;\n              this.dateTimeFormat = this.dateFormat + ' ' + this.timeFormat;\n              return bundle;\n            })\n            .catch(() => {\n              console.warn(`error loading locale resource from ${path}`);\n            });\n\n        });\n    }\n\n    // app defaults support same as web  \n    get appDefaults(){\n      return {\n        dateFormat : this.dateFormat,\n        timeFormat : this.timeFormat,\n        currencyCode:  this.currencyCode,\n        dateTimeFormat: this.dateTimeFormat\n      }\n    }\n\n    setTimezone(timezone: string){\n      this.timezone = timezone;\n    }\n\n    getTimezone(){\n      return this.timezone;\n    }\n\n    setSelectedLocale(locale: string) {\n        this.selectedLocale = locale;\n        StorageService.setItem(STORAGE_KEY, locale);\n        return this.setRTL(locale);\n    }\n\n    getSelectedLocale() {\n      return this.selectedLocale;\n    }\n}\n\nconst i18nService = new AppI18nService();\n\nexport default i18nService;\n", "wavemaker-rn-runtime/src/runtime/services/app-spinner.service.tsx": "import React from 'react';\n\nimport { View, ViewStyle } from 'react-native';\n\nimport { SpinnerService, DisplayOptions } from '@wavemaker/app-rn-runtime/core/spinner.service';\nimport { DisplayManager } from '@wavemaker/app-rn-runtime/core/display.manager';\nimport appDisplayManagerService from '@wavemaker/app-rn-runtime/runtime/services/app-display-manager.service';\nimport WmSpinner from '@wavemaker/app-rn-runtime/components/basic/spinner/spinner.component';\nimport ThemeVariables from '@wavemaker/app-rn-runtime/styles/theme.variables';\n\nexport class AppSpinnerService implements SpinnerService {\n  public displayOptions = {} as DisplayOptions;\n  public destroy: any;\n  public delay = 0;\n  private count = 0;\n  private image: string = '';\n  public skeleton: boolean = false;\n  private defaultDisplayOptions: DisplayOptions =  {} as any;\n  constructor(private displayManager: DisplayManager) {}\n\n  setImage(path: string) {\n    this.image = path;\n  }\n\n  setDefaultOptions(options: DisplayOptions) {\n    this.defaultDisplayOptions = options;\n  }\n\n  show(options: DisplayOptions = this.defaultDisplayOptions) {\n    this.skeleton = options.spinner.loader == 'skeleton';\n    if (this.count === 0 && !this.destroy) { \n      setTimeout(() => {\n        const content = (<>\n          {!this.skeleton? \n            <View style={[styles.appSpinnerContainer, { backgroundColor: ThemeVariables.INSTANCE.pageContentBgColor }]}>\n              <WmSpinner\n                caption={options.message || ''}\n                classname=\"global-spinner\"\n                lottie={options.spinner}></WmSpinner>\n            </View> : null}\n            </>);\n        this.destroy = this.displayManager.show({ content: content });\n      }, this.delay);\n    }\n    this.count++;\n  }\n\n  hide() {\n    if (this.count > 0) {\n      this.count--;\n    } else {\n      this.count = 0;\n    }\n    if (this.count === 0) {\n      setTimeout(() => {\n        if (!this.count && this.destroy) {\n          this.destroy.call(this.displayManager);\n          this.destroy = null;\n          this.skeleton = false;\n        }\n      }, 300);\n    }\n  }\n}\n\nconst styles = {\n  appSpinnerContainer:{ \n    justifyContent: 'center', \n    alignItems: 'center', \n    width:'100%', \n    height:'100%',  \n    opacity: 0.8 \n  } as ViewStyle\n}\n\nconst spinnerService = new AppSpinnerService(appDisplayManagerService);\nexport default spinnerService;\n", "wavemaker-rn-runtime/src/runtime/services/app-display-manager.service.tsx": "import { BackHandler } from \"react-native\";\n\nimport {DisplayManager, DisplayOptions} from \"@wavemaker/app-rn-runtime/core/display.manager\";\nimport AppConfig from \"@wavemaker/app-rn-runtime/core/AppConfig\";\nimport injector from \"@wavemaker/app-rn-runtime/core/injector\";\nimport { isAndroid, isWebPreviewMode } from \"@wavemaker/app-rn-runtime/core/utils\";\n\nexport class AppDisplayManagerService implements DisplayManager {\n  public displayOptions = {} as DisplayOptions;\n\n  private clearBackButtonPress() {\n    if (isAndroid() && !isWebPreviewMode()) {\n      BackHandler.removeEventListener('hardwareBackPress', this.handleBackButtonPress);\n    }\n  }\n\n  private setBackButtonPress() {\n    this.clearBackButtonPress();\n    if (isAndroid() && !isWebPreviewMode() && this.displayOptions.content) {\n      BackHandler.addEventListener('hardwareBackPress', this.handleBackButtonPress);\n    }\n  }\n\n  private handleBackButtonPress = () => {\n    if (this.displayOptions.content) {\n      this.destroy();\n      return true;\n    }\n    return false;\n  }\n\n  show(options: DisplayOptions) {\n    this.displayOptions = options;\n    this.refresh();\n    this.setBackButtonPress();\n    return this.destroy;\n  }\n\n  displayContent(content: React.ReactNode) {\n    this.displayOptions.content = content;\n  }\n\n  refresh() {\n    (injector.get('AppConfig') as AppConfig).refresh();\n  }\n\n  destroy() {\n    this.clearBackButtonPress();\n    this.displayOptions.onDestroy && this.displayOptions.onDestroy();\n    this.displayOptions = {} as DisplayOptions;\n    this.refresh();\n  }\n}\n\nconst appDisplayManagerService = new AppDisplayManagerService();\n\nexport default appDisplayManagerService;\n", "wavemaker-rn-runtime/src/runtime/services/app-security.service.tsx": "import { Platform } from 'react-native';\nimport axios, { InternalAxiosRequestConfig, AxiosResponse } from 'axios';\nimport { each, includes } from 'lodash';\n\nimport networkService from '@wavemaker/app-rn-runtime/core/network.service';\nimport injector from '@wavemaker/app-rn-runtime/core/injector';\nimport AppConfig from '@wavemaker/app-rn-runtime/core/AppConfig';\nimport StorageService from '@wavemaker/app-rn-runtime/core/storage.service';\nimport { SecurityService } from '@wavemaker/app-rn-runtime/core/security.service';\n\nimport WebProcessService from './webprocess.service';\nimport { isWebPreviewMode } from '@wavemaker/app-rn-runtime/core/utils';\n\ndeclare const window: any;\n\ninterface LoggedInUserConfig {\n    isAuthenticated: Boolean;\n    isSecurityEnabled: Boolean;\n    roles: Array<string>;\n    name: String;\n    id: String;\n    tenantId: String;\n    userAttributes: any;\n    landingPage: string;\n}\n\nenum USER_ROLE {\n    EVERYONE = 'Everyone',\n    ANONYMOUS = 'Anonymous',\n    AUTHENTICATED = 'Authenticated'\n}\n\nconst authCookieStr = 'AUTH_COOKIE';\nconst XSRF_COOKIE_NAME = 'wm_xsrf_token';\nconst xsrf_header_name = 'X-WM-XSRF-TOKEN';\n\nclass AppSecurityService implements SecurityService {\n\n    securityConfig: any;\n    isLoggedIn = false;\n    loggedInUser: any = {};\n    token: any;\n    appConfig: any;\n    baseUrl: string = '';\n    defaultSecurityConfig: any;\n    landingPage = '';\n\n    constructor() {\n      axios.interceptors.request.use((config: InternalAxiosRequestConfig) => this.onBeforeServiceCall(config));\n    }\n\n    getRegex = (str: string) =>{\n      const wm_xsrf_token_index = str.indexOf('wm_xsrf_token') + 13;  // 13 is the length of 'wm_xsrf_token' string\n      let index = wm_xsrf_token_index;\n\n      while(str[index] !== ':'){\n        index++;\n      }\n  \n      const regExp = str.substring(wm_xsrf_token_index, index);\n      return new RegExp(regExp, \"g\");\n    }\n  \n    formateData = (data: string) => {\n      const regex = this.getRegex(data)\n      return JSON.parse(data.replace(regex, \"\\\"\"));\n    }\n\n    onBeforeServiceCall(config: InternalAxiosRequestConfig) {\n      if (!this.appConfig) {\n        this.appConfig = this.getAppConfig();\n        this.baseUrl = this.appConfig.url;\n      }\n      return this.getXsrfToken().then((token: string) => {\n        if (config.url?.startsWith(this.baseUrl) && token) {\n          if(config.headers) config.headers[xsrf_header_name] = token;\n        }\n        return config\n      });\n    }\n\n    private getXsrfToken(): Promise<string> {\n      if (this.token) {\n        return Promise.resolve(this.token);\n      }\n      return StorageService.getItem(XSRF_COOKIE_NAME).then(xsrf_token => {\n        this.token = xsrf_token;\n        return this.token;\n      });\n    }\n\n    private getAppConfig() {\n      return injector.get<AppConfig>('APP_CONFIG');\n    }\n\n    public navigateToLandingPage() {\n      this.appConfig.currentPage?.goToPage(\n        this.appConfig.loggedInUser?.landingPage \n        || this.appConfig.landingPage \n        || 'Main', null, true);\n      if (this.landingPage) {\n        const landingPage = this.landingPage;\n        this.landingPage = '';\n        setTimeout(() => {\n          this.appConfig.currentPage?.openUrl(landingPage);\n        }, 100);\n      }\n    }\n\n    public appLogin(options: any) {\n        // encode all parameters\n        let payload = '';\n        each(options.formData, function (value, name) {\n            payload += (payload ? '&' : '') + encodeURIComponent(name) + '=' + encodeURIComponent(value);\n        });\n        axios.defaults.withCredentials = true;\n        return axios.post(options.baseURL + '/j_spring_security_check', payload, {\n            withCredentials: true,\n            headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n          }}).then((response: AxiosResponse) => {\n            const xsrfCookieValue = response.data ? response.data[XSRF_COOKIE_NAME] : '';\n            this.token = xsrfCookieValue;\n            StorageService.setItem(XSRF_COOKIE_NAME, xsrfCookieValue);\n            this.isLoggedIn = true;\n          }).then(() => this.load(options.baseURL))\n          .then(async () => {\n            const userData = await this.getLoggedInUserDetails(options.baseURL, options.useDefaultSuccessHandler);\n            await this.appConfig.app.triggerStartUpVariables();\n            return userData;\n          });\n    }\n\n    public load(baseURL: string) {\n      if (isWebPreviewMode()) {\n        const token = document?.cookie?.split(';').filter(item => item.includes('wm_xsrf_token'))\n        if (token && token.length > 0) {\n          const wm_xsrf_token = token[0].split('=')[1];\n          wm_xsrf_token && StorageService.setItem(XSRF_COOKIE_NAME, wm_xsrf_token);\n        }\n      }\n\n      return Promise.resolve().then(() => {\n        if (networkService.isConnected()) {\n          return axios.get(baseURL + '/services/security/info')\n            .then((response: AxiosResponse) => response.data);\n        }\n        return this.appConfig.getServiceDefinitions(this.appConfig.url)\n          .then(() => Promise.resolve(this.defaultSecurityConfig));\n        }).then((details: any) => {\n          const loggedInUser = {} as LoggedInUserConfig;\n          this.securityConfig = details || {};\n          this.securityConfig.isSecurityEnabled = !!details?.securityEnabled;\n          const appConfig = this.appConfig;\n          if (typeof details !== 'string' && (!details.securityEnabled || details.authenticated)) {\n              if (details.authenticated) {\n                  loggedInUser.isAuthenticated = details.authenticated;\n                  loggedInUser.isSecurityEnabled = details.authenticated;\n                  loggedInUser.roles           = details.userInfo.userRoles;\n                  loggedInUser.name            = details.userInfo.userName;\n                  loggedInUser.id              = details.userInfo.userId;\n                  loggedInUser.tenantId        = details.userInfo.tenantId;\n                  loggedInUser.userAttributes  = details.userInfo.userAttributes;\n                  loggedInUser.landingPage  = details.userInfo.landingPage;\n                  appConfig.loggedInUser = loggedInUser;\n                  this.loggedInUser.dataSet = loggedInUser;\n                  appConfig.landingPage = appConfig.appProperties?.homePage;\n              }\n              return appConfig.getServiceDefinitions(appConfig.url)\n              .then(() => {\n                return details;\n              });\n          } else {\n            return appConfig.getServiceDefinitions(appConfig.url)\n              .then(() => {\n                this.redirectToLogin();\n              });\n          }\n        });\n    }\n\n    private getLoggedInUserDetails(baseURL: string, useDefaultSuccessHandler: boolean = true) {\n        if (!baseURL) {\n            this.loggedInUser = {};\n            return Promise.resolve({});\n        }\n        return this.load(baseURL);\n    }\n\n    \n    public redirectToLogin(redirectTo?: string) {\n      if (this.securityConfig?.loginConfig?.type  === 'SSO') {\n        const authUrl = this.appConfig.url  + '/services/security/ssologin';\n        if (Platform.OS === 'web') {\n          (window.parent || window).location.href = authUrl;\n        } else {\n          setTimeout(() => {\n            WebProcessService.execute('LOGIN', '/services/security/ssologin', false, true)\n            .then((output: any) => {\n              if (output) {\n                if(output.data){\n                  return this.formateData(`${output.data}`);\n                }\n              }\n              return Promise.reject();\n            }).then((output: any) => {\n              if (output[XSRF_COOKIE_NAME]) {\n                this.token = output[XSRF_COOKIE_NAME];\n                StorageService.setItem(XSRF_COOKIE_NAME, output[XSRF_COOKIE_NAME]);\n              }\n            }).then(() => {\n              this.appConfig.refresh(true);\n            }).then(() => this.load(this.baseUrl)).then(() => {\n              return this.getLoggedInUserDetails(this.baseUrl);\n            });\n          }, 1000);\n        }\n      } else {\n        const loginPage = this.securityConfig.loginConfig?.pageName || 'Login';\n        if (redirectTo && !redirectTo.startsWith('#/'+ loginPage)) {\n          this.landingPage = redirectTo;\n        }\n        injector.get<AppConfig>('APP_CONFIG').landingPage = loginPage;\n        this.appConfig.currentPage?.goToPage(loginPage, null, true);\n      }\n      this.appConfig.refresh();\n    }\n\n    public appLogout(options: any) {\n      return axios.post(options.baseURL + '/j_spring_security_logout', null, {\n          withCredentials: true\n      })\n      .catch(() => {})\n      .then((response) => {\n          if(response?.data?.result){\n            if (isWebPreviewMode()) {\n              location.href = response.data.result;\n              return new Promise(r => setTimeout(r, 5000));\n            } else {\n              return axios.get(`${response?.data?.result}`, {\n                withCredentials: true,\n              });\n            }\n          }\n          return Promise.reject();\n      })\n      .catch((e) => {\n        console.error(e);\n      })\n      .then(()=>{\n        this.isLoggedIn = false;\n        this.redirectToLogin();\n      });\n    }\n\n    public canUserAccessPage(pageName: string) {\n      if (this.baseUrl && this.securityConfig?.isSecurityEnabled) {\n        return axios.get(this.baseUrl + `/pages/${pageName}/${pageName}.html`)\n          .catch((res) => res)\n          .then((res) => res.status === 200 || res.status === 304); \n      } else {\n        return Promise.resolve(true);\n      }\n    }\n\n    private matchRoles(widgetRoles: Array<String>, userRoles: Array<String>) {\n        return widgetRoles.some(function (item) {\n            return includes(userRoles, item);\n        });\n    }\n\n    public hasAccessToWidget(widgetRoles: String) {\n        const widgetRolesArr = widgetRoles.split(',');\n        // access the widget when 'Everyone' is chosen\n        if (includes(widgetRolesArr, USER_ROLE.EVERYONE)) {\n            return true;\n        }\n\n        // access the widget when 'Anonymous' is chosen and user is not authenticated\n        if (includes(widgetRolesArr, USER_ROLE.ANONYMOUS) && !this.loggedInUser.dataSet?.isAuthenticated) {\n            return true;\n        }\n\n        // access the widget when 'Only Authenticated Users' is chosen and user is authenticated\n        if (includes(widgetRolesArr, USER_ROLE.AUTHENTICATED) && this.loggedInUser.dataSet?.isAuthenticated) {\n            return true;\n        }\n\n        // access the widget when widget role and logged in user role matches\n        return this.loggedInUser.dataSet?.isAuthenticated && this.matchRoles(widgetRolesArr, this.loggedInUser.dataSet?.roles);\n    }\n}\n\nconst appSecurityService = new AppSecurityService();\n\nexport default appSecurityService;\n", "wavemaker-rn-runtime/src/runtime/services/device/camera-service.tsx": "import React from \"react\";\nimport { ImageBackground, Platform, TouchableOpacity, View, ViewStyle } from \"react-native\";\nimport { Ionicons } from \"@expo/vector-icons\";\nimport { ResizeMode, Video } from \"expo-av\";\nimport { CameraView, CameraType } from \"expo-camera\";\nimport * as FileSystem from \"expo-file-system\";\nimport * as Application from 'expo-application';\n\nimport { DisplayManager } from \"@wavemaker/app-rn-runtime/core/display.manager\";\nimport { CaptureVideoOutput } from \"@wavemaker/app-rn-runtime/variables/device/camera/capture-video.operation\";\nimport { CaptureImageOutput } from \"@wavemaker/app-rn-runtime/variables/device/camera/capture-image.operation\";\nimport permissionManager from '@wavemaker/app-rn-runtime/runtime/services/device/permissions';\nimport { CameraInput } from \"@wavemaker/app-rn-runtime/core/device/camera-service\";\nimport { Input } from \"@wavemaker/app-rn-runtime/variables/device/operation.provider\";\nimport appDisplayManagerService from \"@wavemaker/app-rn-runtime/runtime/services/app-display-manager.service\";\nconst styles = {\n  preview: {\n    top: 0,\n    left: 0,\n    right: 0,\n    flexGrow: 1,\n    backgroundColor: 'black'\n  },\n  actionBtn: {\n    flex: 0,\n    padding: 15,\n    paddingHorizontal: 20,\n    alignSelf: 'center',\n    margin: 20,\n  } as ViewStyle,\n  actionBar: {\n    flex: 0,\n    flexDirection: 'row',\n    justifyContent: 'center',\n    backgroundColor: 'rgba(0,0,0,0.6)',\n    position: 'absolute',\n    bottom: 0,\n    left: 0,\n    right: 0,\n    padding: 20\n  } as ViewStyle,\n  leftWrapper: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'flex-start',\n  } as ViewStyle,\n  midWrapper: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n  } as ViewStyle,\n  rightWrapper: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'flex-end',\n  } as ViewStyle,\n  circle: {\n    display: 'flex',\n    justifyContent: 'center',\n    alignItems: 'center',\n  } as ViewStyle,\n  outerCircle: {\n    borderWidth: 3,\n    height: 50,\n    width: 50,\n    borderRadius: 25,\n    borderColor: 'white'\n  },\n  innerCircle: {\n    borderRadius:2,\n    height: 20,\n    width:20,\n    backgroundColor: 'red'\n  }\n};\n\nexport interface CameraVideoInput extends Input {}\n\nexport class CameraService {\n  private type: CameraType = \"back\";\n\n  constructor(private displayManager: DisplayManager) {\n  }\n\n  public captureVideo(options?: CameraVideoInput): Promise<CaptureVideoOutput> {\n    return new Promise((resolve, reject) => {\n      permissionManager.requestPermissions('video').then(() => {\n        const destroy = this.displayManager.show({\n          content: (<Camera testID={\"camera_view\"} type={this.type} captureType={'video'} onSuccess={(o) => {\n            destroy.call(this.displayManager);\n            /*o.content().catch(() => {}).then(base64 => {\n              resolve({videoPath: o.uri, content: base64 || ''});\n            });*/\n            resolve({videoPath: o.uri, content: ''});\n          }}\n          onCancel={() => {\n            destroy.call(this.displayManager);\n          }}\n          ></Camera>)\n        });\n      }, reject);\n    });\n  }\n\n  public captureImage(params: CameraInput): Promise<CaptureImageOutput> {\n    return new Promise((resolve, reject) => {\n      permissionManager.requestPermissions('image').then(() => {\n        const destroy = this.displayManager.show({\n          content: (<Camera testID={\"camera_view\"} type={this.type} captureType={'image'} onSuccess={(o) => {\n            destroy.call(this.displayManager);\n            o.content().catch(() => {}).then(base64 => {\n              resolve({imagePath: o.uri, content: base64 || ''});\n            });\n          }} onCancel={() => {destroy.call(this.displayManager);}}\n          ></Camera>)\n        });\n      }, reject);\n    });\n  }\n}\n\ninterface CameraOutput {\n  uri: string;\n  content: () => Promise<string>;\n}\n\nclass CameraViewProps {\n  testID: string = 'camera_view';\n  type: 'front' | 'back' = 'back' as CameraType;\n  captureType: 'image' | 'video' = 'image';\n  onSuccess: (o: CameraOutput) => any = () => {};\n  onCancel: () => any = () => {};\n}\n\nclass CameraViewState {\n    recording: boolean = false;\n    showActionBtns: boolean = false;\n    cameraType: CameraType = 'back';\n    isCaptured: boolean = false;\n    closeView: boolean = false;\n    cameraContent: CameraOutput = {} as CameraOutput;\n}\n\nexport class Camera extends React.Component<CameraViewProps, CameraViewState> {\n  private camera: any = {};\n\n  constructor(props: CameraViewProps) {\n    super(props);\n    this.state = new CameraViewState();\n  }\n\n  toggleCapture() {\n    if (this.props.captureType === 'image') {\n      this.takePicture();\n    } else {\n      if (!this.state.recording) {\n        this.startRecord();\n      } else {\n        this.stopRecord();\n        this.setState({showActionBtns: true} as CameraViewState);\n      }\n    }\n  }\n\n  getTestProps(suffix: string) {\n    const id = this.props.testID + (suffix ? '_' + suffix  : '');\n    if (Platform.OS === 'android' || Platform.OS === 'web') {\n      return {\n          accessibilityLabel: id,\n          testID: id\n      };\n    }\n    return {\n        accessible: false,\n        testID: id\n    };\n  }\n\n  async takePicture() {\n    const options = {\n      quality: 0.5,\n      base64: false,\n      skipProcessing: true,\n      onPictureSaved: (response: any) => {\n        response.content = async () => {\n          return await FileSystem.readAsStringAsync(response.uri, { encoding: 'base64' });\n        };\n        this.setState({ \n          cameraContent: response,\n          isCaptured: true,\n          showActionBtns: true } as CameraViewState);\n      }\n    }\n    await this.camera.takePictureAsync(options);\n\n    if (this.state.showActionBtns) {\n      this.setState({showActionBtns: false} as CameraViewState);\n    }\n    this.setState({showActionBtns: true} as CameraViewState);\n  }\n\n  // start recording\n  startRecord = async () => {\n    this.camera.recordAsync().then((response: any) => {\n      response.content = async () => {\n        return await FileSystem.readAsStringAsync(response.uri, { encoding: 'base64' });\n      };\n      this.setState({ cameraContent: response, isCaptured: true } as CameraViewState);\n    });\n    if (this.state.showActionBtns) {\n      this.setState({showActionBtns: false} as CameraViewState);\n    }\n\n    this.setState({recording: true} as CameraViewState);\n  };\n\n  // stop recording\n  stopRecord = async () => {\n    this.camera.stopRecording();\n    this.setState({recording: false} as CameraViewState);\n    this.setState({showActionBtns: true} as CameraViewState);\n  };\n\n  getActionsTemplate() {\n    return <View style={styles.actionBar}>\n      <View style={styles.leftWrapper}>\n        <TouchableOpacity\n          {...this.getTestProps('close')}\n          onPress={() => {\n            this.setState({ cameraContent: {uri: ''}, isCaptured: false,  closeView: true } as CameraViewState);\n            this.props.onCancel();\n          }}>\n          <Ionicons name='close-circle' size={32} color='white' />\n        </TouchableOpacity>\n      </View>\n      <View style={styles.midWrapper}>\n        {!this.state.isCaptured ? <TouchableOpacity style={[styles.circle, styles.outerCircle, this.props.captureType === 'video' && !this.state.recording ? { backgroundColor: \"red\" } : {},\n          this.props.captureType === 'image' ? { backgroundColor: \"white\" } : {}]}\n                          onPress={this.toggleCapture.bind(this)}\n                          {...this.getTestProps('capture')}>\n          <View style={[styles.circle as ViewStyle, this.props.captureType === 'image' ? {} : styles.innerCircle, this.props.captureType === 'image' ? { backgroundColor: \"white\" } : {}]}></View>\n        </TouchableOpacity> : null}\n      </View>\n      <View style={styles.rightWrapper}>\n        {this.state.showActionBtns ? (<TouchableOpacity\n          onPress={() => {\n            this.setState({ isCaptured: false, closeView: true } as CameraViewState);\n            this.props.onSuccess(this.state.cameraContent);\n            this.setState({ cameraContent: {uri: ''} } as CameraViewState);\n          }}\n          {...this.getTestProps('ok')}>\n          <Ionicons name='checkmark-circle' size={32} color='white'/>\n        </TouchableOpacity>) : (<TouchableOpacity\n          {...this.getTestProps('toggle')}\n          onPress={() => {\n            this.setState({cameraType: this.state.cameraType === 'back' ? 'front' : 'back'} as CameraViewState);\n          }}>\n          <Ionicons name='camera-reverse' size={32} color='white' />\n        </TouchableOpacity>)}\n      </View>\n    </View>\n  }\n\n  getPreviewTemplate(actions: any) {\n    return this.props.captureType === 'image' ?\n      <ImageBackground source={{uri : this.state.cameraContent.uri}} resizeMode={ResizeMode.CONTAIN} style={{flex: 1}} />\n      : <Video\n          style={{ flex: 1 }}\n          source={{\n            uri: this.state.cameraContent.uri,\n          }}\n          shouldPlay={true}\n          useNativeControls\n          isLooping\n          resizeMode={ResizeMode.CONTAIN}\n        ></Video>\n  }\n\n  render() {\n    if (this.state.closeView) {\n      return null;\n    }\n    const actions = this.getActionsTemplate();\n    return (\n      <View style={styles.preview}>\n        {this.state.isCaptured ? (\n          this.getPreviewTemplate(actions)\n        ) : (\n          <CameraView facing={this.state.cameraType} ref={(ref) => { this.camera = ref; }}\n              style={{flex: 1}}\n              onCameraReady={() => {}}>\n\n          </CameraView>)}\n        {actions}\n      </View>)\n  }\n}\nconst cameraService = new CameraService(appDisplayManagerService);\nexport default cameraService;", "wavemaker-rn-runtime/src/runtime/services/device/location-service.ts": "import * as Location from 'expo-location';\nimport permissionManager from \"@wavemaker/app-rn-runtime/runtime/services/device/permissions\";\nimport {\n  GeoPositionInput,\n  GeoPositionOutput\n} from \"@wavemaker/app-rn-runtime/variables/device/device/current-geo-position.operation\";\n\n\nexport class LocationService {\n\n  constructor() {}\n\n  public getCurrentGeoPosition(params: GeoPositionInput): Promise<GeoPositionOutput> {\n    return new Promise((resolve, reject) => {\n      permissionManager.requestPermissions('location').then(() => {\n        const options = {\n          accuracy: 4\n        }\n          resolve(Location.getCurrentPositionAsync(options));\n        }, reject)\n      });\n  }\n}\n", "wavemaker-rn-runtime/src/runtime/services/device/permissions.ts": "import * as Location from 'expo-location';\nimport * as Contacts from 'expo-contacts';\nimport * as Calendar from 'expo-calendar';\nimport * as Camera from 'expo-camera';\nimport { Platform } from 'react-native';\n\nconst rejectionMsgMap = new Map<string, string>();\n\nrejectionMsgMap.set('camera', 'camera permission is required to capture image');\nrejectionMsgMap.set('video', 'camera and audio permissions are required to capture video');\nrejectionMsgMap.set('location', 'enable geolocation permission to access the location');\nrejectionMsgMap.set('contacts', 'enable contacts permission to access the contacts');\nrejectionMsgMap.set('calendar', 'enable calendar permission to access the calendar events');\n\ninterface objectMap {\n  [key: string]: Array<string>\n}\n\nexport default {\n  requestPermissions: (type: string) => {\n    let query;\n    if (type === 'location') {\n      // requestPermissionsAsync is deprecated and requestForegroundPermissionsAsync is available only in sdk 41+\n      query = Location.requestForegroundPermissionsAsync();\n    } else if (type === 'video') {\n      query = Promise.all([Camera.Camera.requestCameraPermissionsAsync(), Camera.Camera.requestMicrophonePermissionsAsync()]);\n    } else if (type === 'image' || type === 'camera') {\n      query = Camera.Camera.requestCameraPermissionsAsync();\n    } else if (type === 'contacts') {\n      query = Contacts.requestPermissionsAsync();\n    } else if (type === 'calendar') {\n      if (Platform.OS === 'ios') {\n        query = Promise.all([Calendar.requestCalendarPermissionsAsync(), Calendar.requestRemindersPermissionsAsync()]);\n      } else {\n        query = Calendar.requestCalendarPermissionsAsync();\n      }\n    }\n    if (!query) {\n      return Promise.reject('no supported permission type.');\n    }\n    return (query as any).then((response: any) => {\n      if (Array.isArray(response)) {\n        const isRejected = response.find(o => o.status !== 'granted');\n        if (isRejected) {\n          return Promise.reject(rejectionMsgMap.get(type));\n        }\n      } else if (response && response.status !== 'granted') {\n        return Promise.reject(rejectionMsgMap.get(type));\n      }\n      return Promise.resolve();\n    }, (error: any) => {\n      console.log('permission is not enabled ', error);\n      return Promise.reject();\n    });\n  }\n}", "wavemaker-rn-runtime/src/runtime/services/device/scan-service.tsx": "import { CameraView } from 'expo-camera';\nimport { Ionicons } from '@expo/vector-icons';\nimport * as Application from 'expo-application';\nimport { Platform, StyleSheet, TouchableOpacity, View } from 'react-native';\nimport React from 'react';\nimport { ScanInput, ScanOutput } from '@wavemaker/app-rn-runtime/variables/device/scan/scan.operation';\nimport { DisplayManager } from '@wavemaker/app-rn-runtime/core/display.manager';\nimport permissionManager from '@wavemaker/app-rn-runtime/runtime/services/device/permissions';\nimport appDisplayManagerService from '@wavemaker/app-rn-runtime/runtime/services/app-display-manager.service';\n\ninterface objectMap {\n  [key: string]: string\n}\n\nconst barcodeFormatOptions: objectMap = {\n  'ALL': 'ALL',\n  'CODABAR': 'codabar',\n  'CODE_39': 'code39',\n  'CODE_93': 'code93',\n  'CODE_128': 'code128',\n  'DATA_MATRIX': 'datamatrix',\n  'EAN_8': 'ean8',\n  'EAN_13': 'ean13',\n  'ITF': 'itf14',\n  'PDF_417': 'pdf417',\n  'QR_CODE': 'qr',\n  'RSS14': 'rss14',\n  'RSS_EXPANDED': 'rssexpanded',\n  'UPC_E': 'upc_e',\n  'UPC_A': 'upc_a'\n};\nconst opacity = 'rgba(0, 0, 0, 0.6)';\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    flexDirection: 'column'\n  },\n  closeWrapper: {\n    flex: 1,\n    justifyContent: 'flex-end',\n    alignItems: 'center',\n    paddingBottom: 32\n  },\n  topWrapper: {\n    flex: 2,\n    backgroundColor: opacity\n  },\n  centerWrapper: {\n    flex: 2,\n    flexDirection: 'row'\n  },\n  leftWrapper: {\n    flex: 2,\n    backgroundColor: opacity\n  },\n  focused: {\n    flex: 10\n  },\n  rightWrapper: {\n    flex: 2,\n    backgroundColor: opacity\n  },\n  bottomWrapper: {\n    flex: 2,\n    backgroundColor: opacity\n  },\n});\n\nconst BarCodeType: any = [\n  { 0: 'aztec' },\n  { 1: 'ean13' },\n  { 2: 'ean8' },\n  { 3: 'qr' },\n  { 4: 'pdf417' },\n  { 5: 'upc_e' },\n  { 6: 'datamatrix' },\n  { 7: 'code39' },\n  { 8: 'code93' },\n  { 9: 'itf14' },\n  { 10: 'codabar' },\n  { 11: 'code128' },\n  { 12: 'upc_a' }\n];\n\n\nexport class ScanService {\n\n  constructor(private displayManager: DisplayManager) {}\n\n  getTestProps(suffix: string) {\n    const id = \"scan\" + (suffix ? '_' + suffix  : '');\n    if (Platform.OS === 'android' || Platform.OS === 'web') {\n      return {\n          accessibilityLabel: id,\n          testID: id\n      };\n    }\n    return {\n        accessible: false,\n        testID: id\n    };\n  }\n\n  public scanBarcode(params: ScanInput): Promise<ScanOutput> {\n    const format = params?.barcodeFormat || 'ALL';\n    const barcodeFormat: string | undefined = Platform.OS === 'ios' ? undefined : barcodeFormatOptions[format];\n    return new Promise((resolve, reject) => {\n      permissionManager.requestPermissions('camera').then(() => {\n        const destroy = this.displayManager.show({\n          content: (<CameraView\n            barcodeScannerSettings={barcodeFormat ? {\n              barcodeTypes: [BarCodeType[barcodeFormat]],\n            }: undefined}\n            onBarcodeScanned={(result) => {\n              destroy.call(this.displayManager);\n              resolve(result);\n            }}\n            style={StyleSheet.absoluteFillObject}\n          >\n            <View style={styles.topWrapper}>\n            </View>\n            <View style={styles.centerWrapper}>\n              <View style={styles.leftWrapper}/>\n              <View style={styles.focused}/>\n              <View style={styles.rightWrapper}/>\n            </View>\n            <View style={styles.bottomWrapper}>\n              \n              <View style={styles.closeWrapper}>\n                  <TouchableOpacity\n                      {... this.getTestProps('close_button')}\n                      onPress={() => {\n                        destroy.call(this.displayManager);\n                      }}>\n                      <Ionicons name='close-circle' size={48} color='white' />\n                  </TouchableOpacity>\n              </View>\n            </View>\n          </CameraView>)\n        });\n      }, reject)\n    }).then((response: any) => {\n      let format;\n      if (response.type) {\n        const values = Object.values(BarCodeType);\n        const index = values.indexOf(response.type);\n        format = index > -1 ? Object.keys(BarCodeType)[index] : '';\n      }\n      return Promise.resolve({\n        text: response.data,\n        format : format || response.type,\n        cancelled : false\n      });\n    });\n  }\n}\nconst scanService = new ScanService(appDisplayManagerService);\nexport default scanService;", "wavemaker-rn-runtime/src/runtime/services/device/contacts-service.ts": "import * as Contacts from 'expo-contacts';\nimport permissionManager from '@wavemaker/app-rn-runtime/runtime/services/device/permissions';\nimport { ContactsInput } from '@wavemaker/app-rn-runtime/core/device/contacts-service';\nimport { ContactsOutput, PhoneNumber} from \"@wavemaker/app-rn-runtime/variables/device/contacts/get-contacts.operation\";\n\nexport class ContactsService {\n\n  constructor() {}\n\n  public getContacts(params: ContactsInput): Promise<Array<ContactsOutput>> {\n    return new Promise((resolve, reject) => {\n      permissionManager.requestPermissions('contacts').then(() => {\n        return Contacts.getContactsAsync({\n          fields: [Contacts.Fields.ID, Contacts.Fields.Name, Contacts.Fields.PhoneNumbers],\n          name: params.contactFilter\n        }).then((value: Contacts.ContactResponse) => {\n          let contacts: any = [];\n          value.data.forEach((c: Contacts.Contact) => {\n            const numbers = [] as Array<PhoneNumber>;\n            c.phoneNumbers?.forEach((num: Contacts.PhoneNumber) => {\n              numbers.push({\n                value: num.number as string\n              });\n            });\n            contacts.push({\n              id: c.id,\n              displayName: c.name,\n              phoneNumbers: numbers\n            });\n          });\n          return resolve(contacts);\n        });\n      }, () => resolve([]));\n      });\n  }\n}\n", "wavemaker-rn-runtime/src/runtime/services/device/calendar-service.ts": "import * as Calendar from 'expo-calendar';\nimport permissionManager from '@wavemaker/app-rn-runtime/runtime/services/device/permissions';\nimport { CalendarInput } from '@wavemaker/app-rn-runtime/core/device/calendar-service';\nimport { CalendarEvent } from '@wavemaker/app-rn-runtime/variables/device/calendar/get-events.operation';\nimport {\n  CreateEventOutput,\n  getDateObj\n} from '@wavemaker/app-rn-runtime/variables/device/calendar/create-event.operation';\nimport { DeleteEventOutput } from '@wavemaker/app-rn-runtime/variables/device/calendar/delete-event.operation';\n\nconst DEFAULT_TIME = new Date().getTime();\nconst DELTA_VALUE_DATE = 3 * 30 * 24 * 60 * 60 * 1000;\nconst DEFAULT_START_DATE = new Date(DEFAULT_TIME - DELTA_VALUE_DATE);\nconst DEFAULT_END_DATE = new Date(DEFAULT_TIME + DELTA_VALUE_DATE);\n\nexport class CalendarService {\n\n  constructor() {}\n\n  public getEvents(params: CalendarInput): Promise<Array<CalendarEvent>> {\n    return new Promise((resolve, reject) => {\n      permissionManager.requestPermissions('calendar').then(() => {\n          return Calendar.getCalendarsAsync().then(result => {\n            let calendarIds: Array<string> = [];\n            result.forEach(c => calendarIds.push(c.id));\n            Calendar.getEventsAsync(calendarIds, params.eventStart || DEFAULT_START_DATE, params.eventEnd || DEFAULT_END_DATE)\n              .then(res => {\n                let filteredResult = res;\n                if (params.eventTitle || params.eventLocation || params.eventNotes) {\n                  filteredResult = res.filter(event => event.title === params.eventTitle || event.location === params.eventLocation || event.notes === params.eventNotes);\n                }\n                let events: Array<CalendarEvent> = [];\n                filteredResult.forEach(e => {\n                  events.push({\n                    title: e.title,\n                    message: e.notes,\n                    location: e.location,\n                    startDate: e.startDate,\n                    endDate: e.endDate\n                  })\n                });\n                return resolve(events);\n              })\n          })\n      }, reject);\n    });\n  }\n\n\n  public createEvent(params: CalendarInput): Promise<CreateEventOutput> {\n    const eventMetadata = {\n      title: params.eventTitle,\n      location: params.eventLocation,\n      notes: params.eventNotes,\n      startDate: getDateObj(params.eventStart) || DEFAULT_START_DATE,\n      endDate: getDateObj(params.eventEnd) || DEFAULT_END_DATE\n    };\n\n    return new Promise((resolve, reject) => {\n      permissionManager.requestPermissions('calendar').then(() => {\n          return Calendar.getCalendarsAsync().then(result => {\n            let calendarIds: Array<string> = [];\n            result.forEach(c => {\n              if (c.allowsModifications) {\n                calendarIds.push(c.id);\n              }\n            });\n            // createEventAsync has calendarId as required parameter. Need to expose ownerAccount as filter field in studio. Right now passing calendar index as zero.\n            return Calendar.createEventAsync(calendarIds[0], eventMetadata).then(res => {\n              const event = {\n                dataValue: res\n              };\n              return resolve(event);\n            })\n          }, reject);\n      });\n    });\n  }\n\n\n  public deleteEvent(params: CalendarInput): Promise<DeleteEventOutput> {\n\n    return new Promise((resolve, reject) => {\n      permissionManager.requestPermissions('calendar').then(() => {\n          return Calendar.getCalendarsAsync().then(result => {\n            let calendarIds: Array<string> = [];\n            result.forEach(c => {\n              if (c.allowsModifications) {\n                calendarIds.push(c.id);\n              }\n            });\n            Calendar.getEventsAsync(calendarIds, params.eventStart || DEFAULT_START_DATE, params.eventEnd || DEFAULT_END_DATE)\n              .then((res) => {\n                const filteredResult = res.filter(event => event.title === params.eventTitle || event.location === params.eventLocation\n                  || event.notes === params.eventNotes);\n                Promise.all(\n                  filteredResult.map((event) => { Calendar.deleteEventAsync(event.id)}))\n                  .then(res => {\n                    const event = {\n                      dataValue: true\n                    }\n                    return resolve(event);\n                  })\n              })\n          }, reject);\n      });\n    });\n  }\n}\n", "wavemaker-rn-runtime/src/styles/MediaQueryList.ts": "import mediaQuery from \"css-mediaquery\";\nimport { Dimensions } from \"react-native\";\nimport viewport from \"@wavemaker/app-rn-runtime/core/viewport\";\n\nexport default class MediaQueryList /* extends MediaQueryList */ {\n\n  constructor(private query: string) {}\n\n  public get matches(): boolean {\n    const windowDimensions = Dimensions.get(\"window\");\n    return mediaQuery.match(this.query, {\n      type: \"screen\",\n      orientation: viewport.orientation,\n      ...windowDimensions,\n      \"device-width\": viewport.width,\n      \"device-height\": viewport.height,\n    } as any);\n  }\n}", "wavemaker-rn-runtime/src/styles/theme.variables.ts": "import Color, { rgb } from \"color\";\nimport { Dimensions, StatusBar } from \"react-native\";\n\nexport default class ThemeVariables {\n    \n    primaryColor = '#4263eb';\n    primaryColor1 = Color(this.primaryColor).lighten(0.2).rgb().toString();\n    primaryColor2 = Color(this.primaryColor).lighten(0.4).rgb().toString();\n    primaryColor3 = Color(this.primaryColor).lighten(0.6).rgb().toString();\n    primaryContrastColor = '#ffffff';\n    secondaryColor = '#6c757d';\n    secondaryContrastColor = '#ffffff';\n    successColor = '#28a745';\n    successContrastColor = '#ffffff';\n    infoColor = '#17a2b8';\n    infoContrastColor = '#ffffff';\n    warningColor = '#ffc107';\n    warningContrastColor = '#ffffff';\n    dangerColor = '#dc3545';\n    dangerContrastColor = '#ffffff';\n    defaultColor = '#000000';\n    defaultColor1 = '#111111';\n    defaultColor2 = '#222222';\n    defaultColor3 = '#333333';\n    defaultColor4 = '#444444';\n    defaultColor5 = '#555555';\n    defaultColor6 = '#666666';\n    defaultColor7 = '#777777';\n    defaultColor8 = '#888888';\n    defaultColor9 = '#999999';\n    defaultColorA = '#aaaaaa';\n    defaultColorB = '#bbbbbb';\n    defaultColorC = '#cccccc';\n    defaultColorD = '#dddddd';\n    defaultColorE = '#eeeeee';\n    defaultColorF = '#ffffff';\n    defaultBgColor = this.defaultColorF;\n    defaultTextColor = '#151420';\n    lightColor = this.defaultColorF;\n    darkColor = this.defaultColor;\n    muteColor = this.defaultColorA;\n    heading1FontSize = 36;\n    heading2FontSize = 30;\n    heading3FontSize = 24;\n    heading4FontSize = 18;\n    heading5FontSize = 14;\n    heading6FontSize = 12;\n    transparent = 'transparent';\n    badgeColor = '#6c757d';\n    badgeContrastColor = '#ffffff';\n    baseFont = 'Roboto';\n    tabbarInactiveColor  = '#d8d8d8';\n    maxModalHeight = Dimensions.get('window').height - 64 - (StatusBar.currentHeight || 0);\n    maxWidth = Dimensions.get(\"window\").width; \n    skeletonBackgroundColor = \"#F4F5F8\";\n    \n     //rippleColor\n     rippleColor = this.transparent\n\n    // page\n    pageContentBgColor = this.defaultColorE;\n\n    // common widget color\n    widgetHeaderBgColor = this.defaultColorF;\n    widgetHeaderTextColor = this.defaultColor3;\n    widgetActiveHeaderBgColor = this.primaryColor;\n    widgetActiveHeaderTextColor = this.primaryContrastColor;\n    widgetBorderColor = this.defaultColorC;\n    widgetBgColor = this.defaultColorF;\n\n    //App Navbar\n    titleBadgeBackgroundColor = Color('#151420').fade(0.8).rgb().toString();\n    titleBadgeTextColor = '#151420';\n\n    // Navbar variables\n    navbarBackgroundColor = this.defaultColorF;\n    navbarBorderColor = this.widgetBorderColor;\n    navbarTextColor = '#151420';\n    navbarIconSize = 32;\n    navbarFontSize = 24;\n    navbarImageSize = 32;\n    navbarCaretColor = this.primaryColor;\n    navitemChildBackgroundColor = this.primaryContrastColor;\n    navitemChildTextColor = this.primaryColor;\n    navitemChildIconColor = this.primaryColor;\n    navitemActiveBackgroundColor = this.primaryColor;\n    navitemActiveTextColor = this.primaryContrastColor;\n    navitemActiveIconColor = this.navitemActiveTextColor;\n\n    //Anchor variables\n    linkDefaultColor = this.defaultTextColor;\n    linkPrimaryColor = this.primaryColor;\n    linkSecondaryColor = this.secondaryColor;\n    linkSuccessColor = this.successColor;\n    linkInfoColor = this.infoColor;\n    linkWarningColor = this.warningColor;\n    linkDangerColor = this.dangerColor;\n    linkLightColor = this.lightColor;\n    linkDarkColor = this.darkColor;\n    anchorTextPadding = 2;\n\n    //Grid Layout variables\n    layoutGridBgColor = this.widgetBgColor;\n    layoutGridBorderColor = this.widgetBorderColor;\n    layoutGridStripColor1 = Color(this.primaryColor).lighten(0.9).rgb().toString();\n    layoutGridHeaderBgColor = this.widgetHeaderBgColor;\n    layoutGridHeaderTextColor = this.widgetHeaderTextColor;\n    layoutGridStripColor2 = this.transparent;\n    gridColumnBorderColor = this.widgetBorderColor;\n\n    //Spinner Variables\n    spinnerIconColor = this.primaryColor;\n\n    //tabbar variables\n    tabbarBackgroundColor = this.primaryContrastColor;\n    tabbarTextColor =  'var(--tabbarInactiveColor)';\n    tabbarIconColor = 'var(--tabbarInactiveColor)';\n    tabShadowColor = this.defaultColor;\n    tabActiveBackgroundColor = this.primaryColor3;\n    tabActiveIconColor = this.primaryColor;\n    tabLabelTextColor = this.primaryColor;\n\n    centerHubItemColor = 'var(--primaryColor)';\n    centerHubIconColor = 'var(--defaultColorF)';\n    centerHubLabelColor = 'var(--defaultColorF)';\n\n    // tab variables\n    tabHeaderBgColor = this.widgetBgColor;\n    tabHeaderTextColor =  this.defaultColorA;\n    tabHeaderIconColor = this.defaultColorA;\n    tabActiveHeaderBgColor = this.defaultColorF;\n    tabActiveHeaderTextColor =  this.primaryColor;\n    tabActiveIndicatorBgColor =  this.primaryColor;\n    tabActiveHeaderIconColor = this.primaryColor;\n    tabBorderColor = this.widgetBorderColor;\n    tabContentBgColor = this.widgetBgColor;\n    tabArrowIndicatorBgColor = this.tabContentBgColor;\n    tabArrowIndicatorDotColor = this.primaryColor;\n\n    //label Variables\n    labelHeaderColor = '#151420';\n    labelDefaultColor = this.defaultColor8;\n    labelDefaultContrastColor = this.defaultColorF;\n    labelDangerColor = this.dangerColor;\n    labelDangerContrastColor = this.dangerContrastColor;\n    labelInfoColor = this.infoColor;\n    labelInfoContrastColor = this.infoContrastColor;\n    labelPrimaryColor = this.primaryColor;\n    labelPrimaryContrastColor = this.primaryContrastColor;\n    labelSuccessColor = this.successColor;\n    labelSuccessContrastColor = this.successContrastColor;\n    labelWarningColor = this.warningColor;\n    labelWarningContrastColor = this.warningContrastColor;\n    labelTextSuccessColor = this.successColor;\n    labelTextDangerColor = this.dangerColor;\n    labelTextInfoColor = this.infoColor;\n    labelTextMutedColor = this.muteColor;\n    labelTextPrimaryColor = this.primaryColor;\n    labelTextWarningColor = this.warningColor;\n    labelAsteriskColor = this.dangerColor;\n\n    //List\n    listHeaderBgColor = this.widgetHeaderBgColor;\n    listTitleColor = this.widgetHeaderTextColor;\n    listSubTitleColor = this.defaultColor6;\n    listDividerColor = this.widgetBorderColor;\n    itemBgColor = this.defaultColorF;\n    selectedItemBorderColor = this.primaryColor;\n\n    //button Variables\n    buttonBorderColor = this.widgetBorderColor;\n    buttonBadgeBackgroundColor = this.badgeColor;\n    buttonBadgeTextColor = this.badgeContrastColor;\n    buttonTextPadding = 2;\n    buttonSuccessColor = this.successColor;\n    buttonDefaultColor = this.defaultColorF;\n    buttonPrimaryColor = this.primaryColor;\n    buttonSecondaryColor = this.defaultColorF;\n    buttonDangerColor = this.dangerColor;\n    buttonWarningColor = this.warningColor;\n    buttonInfoColor = this.infoColor;\n    buttonSuccessTextColor = this.successContrastColor;\n    buttonDefaultTextColor = this.defaultTextColor;\n    buttonPrimaryTextColor = this.primaryContrastColor;\n    buttonSecondaryTextColor = this.primaryColor;\n    buttonDangerTextColor = this.dangerContrastColor;\n    buttonWarningTextColor = this.warningContrastColor;\n    buttonInfoTextColor = this.infoContrastColor;\n    buttonLinkColor = this.transparent;\n    buttonLinkTextColor = this.primaryColor;\n    buttonDarkColor = this.darkColor;\n    buttonDarkTextColor = this.lightColor;\n    buttonLightColor = this.lightColor;\n    buttonLightTextColor = this.darkColor;\n    buttonGrpBorderColor = this.widgetBorderColor;\n    buttonGrpBgColor = this.defaultColorF;\n\n    //picture variables\n    pictureThumbBgColor = this.defaultColorF;\n    pictureThumbBorderColor = this.defaultColorD;\n\n    //input variables\n    inputTextColor = this.defaultTextColor;\n    inputBorderColor = this.defaultColorD;\n    inputBackgroundColor = this.defaultColorF;\n    inputDisabledBgColor = '#f6f6f6';\n    inputFocusBorderColor = this.transparent;\n    inputInvalidBorderColor = this.dangerColor;\n    inputPlaceholderColor = this.defaultColorB;\n\n    //wheel picker variables\n    wheelSelectedColor  = '#1d1d1b';\n    wheelColor = '#737373';\n\n    //floating label\n    floatingLabelColor = 'var(--inputPlaceholderColor)';\n    activeFloatingLabelColor = 'var(--primaryColor)';\n\n    //slider variables\n    minimumTrackTintColor = this.primaryColor;\n    maximumTrackTintColor = this.widgetHeaderBgColor;\n    thumbTintColor = this.primaryColor;\n\n    //rating color\n    ratingIconColor = this.defaultColorA;\n    ratingSelectedIconColor = '#eb8600';\n\n    //toggle variables\n    toggleOnColor = Color(this.primaryColor).lighten(0.4).rgb().toString();\n    toggleOffColor = this.defaultColorB;\n    toggleHandleColor = this.primaryColor;\n    toggleHandleDisableColor = this.defaultColorA;\n    toggleOffBorderColor = this.defaultColorB;\n    toggleUnselectedTrackbgColor = this.defaultColorC;\n\n    // radioset, checkboxset variables\n    groupHeadingBgColor = 'var(--transparent)';\n    checkedColor = 'var(--primaryColor)';\n    checkedDisabledColor = 'var(--defaultColorA)';\n    checkedEnabledColor = 'var(--defaultColorF)';\n    checkboxBorderColor = 'var(--defaultColor9)';\n    checkedBgColor = 'var(--primaryColor)';\n    uncheckedBgColor = 'var(--transparent)';\n    checkedIconColor = 'var(--defaultColorF)';\n    checkedBorderColor = 'var(--primaryColor)';\n    uncheckedBorderColor = 'var(--defaultColor9)';\n    \n    //form\n    formBorderColor = this.widgetBorderColor;\n    formTitleColor = this.defaultTextColor;\n    formSubTitleColor = this.defaultColor6;\n\n    //dialog\n    dialogBackgroundColor = this.widgetBgColor;\n    dialogBorderColor = this.widgetBorderColor;\n    dialogCloseIconColor = this.defaultColorA;\n    dialogLabelColor = this.defaultColor3;\n    dialogIconColor = this.defaultColor4;\n    dialogSupportingTextColor = this.defaultColor1;\n\n    //alert dialog\n    alertMessageColor = this.defaultColor8;\n\n    badgeTextColor = this.defaultColorF;\n\n    //popover\n    popoverBackgroundColor = this.defaultColorF;\n    popoverTitleBackgroundColor = this.defaultColorD;\n    popoverTitleColor = this.defaultColor1;\n\n    //menu\n    menuIconColor = this.defaultColor6;\n    menuTextColor = this.defaultColor6;\n    menuBackgroundColor = this.popoverBackgroundColor;\n    menuItemBorderColor = this.widgetBorderColor;\n    menuItemIconColor = this.defaultColor6;\n    menuItemTextColor = this.defaultColor6;\n\n    //tile Variables\n    tileDangerColor = this.dangerColor;\n    tileInfoColor = this.infoColor;\n    tilePrimaryColor = this.primaryColor;\n    tileSuccessColor = this.successColor;\n    tileWarningColor = this.warningColor;\n    tileWellbgColor = this.defaultColorF;\n    tileWellBorderColor = this.defaultColorE;\n    tilePrimaryTextColor = this.primaryContrastColor;\n\n    //switch\n    switchBgColor = this.widgetBgColor;\n    switchTextColor = this.defaultTextColor;\n    switchActiveBgColor = this.primaryColor;\n    switchActiveTextColor = this.primaryContrastColor;\n    switchBorderColor = this.widgetBorderColor;\n\n    //message\n    messageSuccessColor = this.successColor;\n    messageErrorColor = this.dangerColor;\n    messageWarningColor = this.warningColor;\n    messageInfoColor = this.infoColor;\n    messageLoadingColor = this.infoColor;\n\n    //panel\n    panelBgColor = this.widgetBgColor;\n    panelHeaderBgColor = this.widgetHeaderBgColor;\n    panelHeaderTextColor = this.widgetHeaderTextColor;\n    panelFooterColor = this.defaultColorD;\n    panelBorderColor = this.widgetBorderColor;\n    panelDangerColor = this.dangerColor;\n    panelDefaultColor = this.defaultColor;\n    panelInfoColor = this.infoColor;\n    panelPrimaryColor = this.primaryColor;\n    panelSuccessColor = this.successColor;\n    panelWarningColor = this.warningColor;\n    panelTextColor = this.defaultColorF;\n\n    //card\n    cardHeaderBgColor = this.defaultColorD;\n    cardBgColor = this.widgetBgColor;\n    cardTitleColor = this.listTitleColor;\n    cardShadowColor = this.defaultColor;\n    cardSubTitleColor = this.listSubTitleColor;\n    cardBorderColor = this.defaultColorD;\n    cardContentBgColor = this.defaultColorF;\n    cardFooterBgColor = this.defaultColorF;\n    cardFooterBorderColor = this.defaultColorD;\n\n    //progress bar\n    progressBarDefaultColor = this.primaryColor;\n    progressBarTrackColor = this.defaultColorD;\n    progressBarSuccessColor = this.successColor;\n    progressBarDangerColor = this.dangerColor;\n    progressBarInfoColor = this.infoColor;\n    progressBarWarningColor = this.warningColor;\n\n    //progress circle\n    progressCircleDefaultColor = this.primaryColor;\n    progressCircleSuccessColor = this.successColor;\n    progressCircleDangerColor = this.dangerColor;\n    progressCircleInfoColor = this.infoColor;\n    progressCircleWarningColor = this.warningColor;\n\n    //container\n    containerOutlineColor = this.defaultColorC;\n\n    //accordion\n    accordionBgColor = this.widgetBgColor;\n    accordionTitleColor = this.widgetHeaderTextColor;\n    accordionHeaderBgColor = this.defaultColorF;\n    accordionIconColor= this.defaultColorB;\n    accordionActiveIconColor= this.defaultColorF;\n    accordionActiveHeaderBgColor = this.widgetActiveHeaderBgColor;\n    accordionActiveHeaderTextColor = this.widgetActiveHeaderTextColor;\n    accordionBorderColor = this.defaultColorE;\n    accordionPaneBgColor = this.defaultColorF;\n\n    //carousel\n    carouselPrevBtnColor=this.defaultColorF;\n    carouselPrevBgColor=Color(this.defaultColorF).fade(0.6).rgb().toString();\n    carouselNextBtnColor=this.defaultColorF;\n    carouselNextBgColor=Color(this.defaultColorF).fade(0.6).rgb().toString();\n    carouselDotWrapperBgColor=this.transparent;\n    carouselDotColor=this.defaultColorF;\n    carouselActiveDotColor=this.defaultColorF;\n\n    //calendar\n    calendarBgColor = this.defaultColorF;\n    calendarHeaderBgColor = this.defaultColorF;\n    calendarHeaderTextColor = this.defaultTextColor;\n    calendarWeekDayTextColor = this.defaultColorA;\n    calendarDateColor = this.defaultColor;\n    calendarNotCurrentMonthDateColor = this.defaultColor6;\n    calendarHeaderColor = this.defaultColorF;\n    calendarPrevYearIconColor = this.defaultColorA;\n    calendarNextYearIconColor = this.defaultColorA;\n    calendarPrevMonthIconColor = this.defaultColorA;\n    calendarNextMonthIconColor = this.defaultColorA;\n    calendarDayBgColor = this.defaultColor;\n    calendarSelectedDayBgColor = this.primaryColor;\n    calendarSelectedDayTextColor = this.defaultColorF;\n    calendarTodayBgColor = this.defaultColorE;\n    calendarEventDay1Color = this.primaryColor1;\n    calendarEventDay2Color = this.primaryColor2;\n    calendarEventDay3Color = this.primaryColor3;\n\n    //date picker\n    datepickerBgColor = this.defaultColorF;\n\n    //wizard\n    wizardBackgroundColor = this.widgetBgColor;\n    wizardStepActiveColor = this.primaryColor;\n    wizardStepDoneColor = this.successColor;\n    wizardStepDoneTextColor = this.defaultColorF;\n    wizardStepIconColor = this.defaultColorF;\n    wizardStepColor = this.defaultColor9;\n    wizardActiveStepColor = this.defaultColorF;\n    wizardDoneStepColor = this.defaultColorF;\n    wizardStepTitleColor = this.defaultColorA;\n    wizardNextBtnColor= this.primaryColor;\n    wizardDoneBtnColor = this.successColor;\n    wizardStepConnectorColor = this.defaultColorE;\n    wizardStepCounerColor = this.defaultColor9;\n    wizardBorderColor = this.widgetBorderColor;\n\n    //Search\n    searchBorderColor = this.defaultColorD;\n    searchButtonColor = this.primaryColor;\n    searchButtonTextColor = this.primaryContrastColor;\n    searchItemBorderColor = this.defaultColorD;\n    searchItemTextColor = this.defaultColor6;\n    searchDropdownBackgroundColor = this.defaultColorF;\n    searchDataCompleteItemBgColor = this.defaultColorE;\n    searchBgContainerColor = this.defaultColorD;\n    //Select\n    selectBorderColor = this.defaultColorD;\n    selecttemBorderColor = this.defaultColorD;\n    selectItemTextColor = this.defaultColor6;\n    selectDropdownBackgroundColor = this.defaultColorF;\n\n    //Chip\n    chipActiveTextColor = this.defaultColorF;\n    chipDefaultTextColor = this.defaultColorA;\n    chipborderColor = this.defaultColorD;\n    chipContainerColor = this.defaultColorF; \n    chipIconColor = this.primaryColor;\n    chipSelectedOutlineColor = this.defaultColor6;\n    chipSelectedContainerColor = this.defaultColor7;\n    //Login\n    loginErrorMsgColor = this.dangerContrastColor;\n    loginErrorMsgBgColor = this.dangerColor;\n    loginErrorMsgBorderColor = this.dangerColor;\n\n    //camera\n    cameraBgColor = this.defaultColorF;\n    cameraBorderColor = this.widgetBorderColor;\n    cameraTextColor = this.defaultTextColor;\n\n    //barcode-scanner\n    barcodeScannerBgColor = this.defaultColorF;\n    barcodeScannerBorderColor = this.widgetBorderColor;\n    barcodeScannerTextColor = this.defaultTextColor;\n\n    //fileupload\n    fileuploadBgColor = this.defaultColorF;\n    fileuploadBorderColor = this.widgetBorderColor;\n    fileuploadTextColor = this.defaultTextColor;\n\n    //charts\n    chartLabelColor = this.defaultTextColor;\n    chartGraphLinesColor = this.defaultColorC;\n    chartLineColor = this.defaultColor8;\n    chartLegendBorder = this.defaultColor7;\n    chartAxisColor = this.defaultColor5;\n    chartAxisPointColor = this.defaultColor9;\n    chartTitleColor = this.widgetHeaderTextColor;\n    chartSubTitleColor = this.defaultColor6;\n\n    // Network Toast\n    networkToastBgColor = this.defaultColor3;\n    networkToastTextColor = this.defaultColorF;\n    networkToastActionTextColor = this.primaryColor;\n    networkToastActionSeparatorColor = this.networkToastTextColor;\n\n    // Skeleton\n    skeletonBgColor = this.defaultColorE;\n    skeletonAnimatedBgColor = this.defaultColorE;\n    skeletonGradientBgColor = this.defaultColorF;\n    skeletonGradientShadowColor = this.defaultColorF;\n    skeletonGradientForegroundColor = this.transparent;\n\n    // Audio\n    audioPlayerBgColor = this.defaultColorF;\n    audioPlayerFgColor = this.defaultColor3;\n\n    //Tool tip\n    tooltipBgColor = \"#e7f9fd\";\n\n    // Wheel Picker\n    wheelHighlightBorder = 'var(--primaryColor)';\n    wheelSelectedTextColor = 'var(--wheelSelectedColor)';\n    wheelTextColor = 'var(--wheelColor)';\n\n    // Text Area\n    textAreaHelpTextColor = '#61656c'\n\n    static INSTANCE = new ThemeVariables();\n}", "wavemaker-rn-runtime/src/styles/theme.tsx": "import { cloneDeep, isNil, forEach, flatten, isArray, isEmpty, isObject, isString, isFunction, get, reverse } from 'lodash';\nimport React from 'react';\nimport { camelCase } from 'lodash-es';\nimport { TextStyle, ViewStyle, ImageStyle, ImageBackground, Dimensions } from 'react-native';\nimport { deepCopy, isWebPreviewMode } from '@wavemaker/app-rn-runtime/core/utils';\nimport EventNotifier from '@wavemaker/app-rn-runtime/core/event-notifier';\nimport ViewPort, {EVENTS as ViewPortEvents} from '@wavemaker/app-rn-runtime/core/viewport';\nimport MediaQueryList from './MediaQueryList';\nimport ThemeVariables from './theme.variables';\nimport { getErrorMessage, getStyleReference, isValidStyleProp } from './style-prop.validator';\nimport injector from '@wavemaker/app-rn-runtime/core/injector';\nimport AppConfig from '@wavemaker/app-rn-runtime/core/AppConfig';\nexport const DEFAULT_CLASS = 'DEFAULT_CLASS';\n\ndeclare const matchMedia: any, window: any;\n\nif (typeof window !== \"undefined\") {\n    // @ts-ignore: does not properly extend MediaQueryList\n    window.matchMedia = (query: string) => new MediaQueryList(query);\n}\n\nexport const DEVICE_BREAK_POINTS = {\n    'MIN_EXTRA_SMALL_DEVICE' : '0px',\n    'MAX_EXTRA_SMALL_DEVICE' : '767px',\n    'MIN_SMALL_DEVICE' : '768px',\n    'MAX_SMALL_DEVICE' : '991px',\n    'MIN_MEDIUM_DEVICE' : '992px',\n    'MAX_MEDIUM_DEVICE' : '1199px',\n    'MIN_LARGE_DEVICE' : '1200px',\n    'MAX_LARGE_DEVICE' : '1000000px',\n};\n\nexport type styleGeneratorFn<T extends NamedStyles<any>> = (\n    themeVariables: ThemeVariables,\n    addStyle: (name: string, extend: string, style: T) => void) => void\n\nexport enum ThemeEvent {\n    CHANGE ='change'\n};\n\nexport class Theme {\n    public static BASE = new Theme(null as any, 'default');\n\n    static {\n        ViewPort.subscribe(ViewPortEvents.SIZE_CHANGE, () => {\n            Theme.BASE.reset();\n        });\n    }\n\n\n    private eventNotifer = new EventNotifier();\n\n    private children: Theme[] = [];\n\n    private styles: any = {};\n\n    private cache: any = {};\n\n    private traceEnabled = false;\n    \n    private revertLayoutToExpo50: Boolean;\n\n    private styleGenerators: styleGeneratorFn<any>[] = [];\n\n    private constructor(private parent:Theme, public readonly name: string) {\n        this.revertLayoutToExpo50 = this.getAppConfig()?.revertLayoutToExpo50 || false;\n        if (parent) {\n            this.traceEnabled = parent.traceEnabled;\n        } else {\n            this.traceEnabled = isWebPreviewMode();\n        }\n    }\n\n    private getAppConfig() {\n        return injector.get<AppConfig>('APP_CONFIG');\n    }\n\n    public enableTrace(flag: boolean) {\n        this.traceEnabled = flag;\n        this.reset();\n        this.children.forEach(t => t.enableTrace(flag));\n    }\n\n    public subscribe(event: ThemeEvent, fn: Function) {\n        return this.eventNotifer.subscribe(event, fn);\n    }\n\n    public notify(event: ThemeEvent): void {\n        this.eventNotifer.notify(event, []);\n        this.children.forEach(t => t.notify(event));\n    }\n\n    private replaceVariables(val: string) {\n        if(isString(val)) { \n            (val.match(/_*var\\([^\\)]*\\)/g) || []).forEach((s) => {\n                const variableName = s.substring(4, s.length - 1);\n                val = val.replace(s, (ThemeVariables.INSTANCE as any)[variableName]\n                    || (ThemeVariables.INSTANCE as any)[variableName.substring(2)]\n                    || (ThemeVariables.INSTANCE as any)[camelCase(variableName.substring(2))]);\n                val = this.replaceVariables(val);\n            });\n        }\n        return val; \n    }\n\n    clearCache() {\n        this.cache = {};\n        this.children.forEach((t) => t.clearCache());\n    }\n\n    registerStyle<T extends NamedStyles<any>>(fn: styleGeneratorFn<T>) {\n        this.styleGenerators.push(fn);\n        fn(ThemeVariables.INSTANCE, this.addStyle.bind(this));\n    }\n\n    checkStyleProperties(name: string, value : any) {\n        if (isObject(value)) {\n            Object.keys(value).map((k) => this.checkStyleProperties(k, (value as any)[k]));\n        } else if(name && !isValidStyleProp(name, value)) {\n            console.log(\n                `%cInvalid Style property in ${this.name}: ${getErrorMessage(name, value)}`,\n                'background-color: #FF0000;font-weight: bold; color: #fff'\n            );\n            console.log(`Refer: ${getStyleReference(name)}`);\n        }\n    }\n\n    private addStyle<T extends NamedStyles<any>>(name: string, extend: string, style: T) {\n        this.styles[name] = deepCopy(this.getStyle(extend), this.styles[name], style);\n    }\n\n    private addTrace(styleName: string, mergedChildstyle: any, childStyle: any, parentStyle?: any) {\n        if (!this.traceEnabled) {\n            return;\n        }\n        let addTrace = !isEmpty(childStyle);\n        forEach(mergedChildstyle, (v: any, k: string) => {\n            if (v && !isString(v) && !isArray(v) && isObject(v)) {\n                addTrace = false;\n                this.addTrace(styleName + '.' + k, v, childStyle && childStyle[k], parentStyle && parentStyle[k])\n            }\n        });\n        if (addTrace) {\n            mergedChildstyle['__trace'] = [\n                {\n                    name: styleName,\n                    value: childStyle\n                },\n                ...(parentStyle?.__trace|| [])\n            ];\n        } else {\n            mergedChildstyle['__trace'] = [...(parentStyle?.__trace|| [])];\n        }\n    }\n\n    private flatten(style: any, prefix = \"\", result = {} as any) {\n        let collect = !isEmpty(style);\n        forEach(style, (v: any, k: string) => {\n            if (v && !isString(v) && !isArray(v) && isObject(v)) {\n                collect = false;\n                this.flatten(v, (prefix ?  prefix + '.' : '') + k, result)\n            }\n        });\n        if (collect) {\n            result[prefix] = style;\n        }\n        return result;\n    }\n\n    mergeStyle(...styles: any) {\n        const style = deepCopy(...styles);\n        if (this.traceEnabled) {\n            const flattenStyles = this.flatten(style);\n            Object.keys(flattenStyles).forEach(k => {\n                const s = flattenStyles[k];\n                s['__trace'] = flatten(reverse(styles.map((v: any) => {\n                    const cs = get(v, k);\n                    if (cs && cs.__trace) {\n                        return [...cs.__trace];\n                    }\n                    return [];\n                }).filter((t: any) => t.length > 0)));\n            });\n        }\n        return style;\n    }\n\n    cleanseStyleProperties(style: any) {\n        if (!(style && isObject(style)) || isString(style) || isArray(style)) {\n            return style;\n        }\n        style = style as any;\n        if (isObject(style) && !isArray(style)) {\n            Object.keys(style).forEach(k => {\n                (style as any)[k] = this.replaceVariables((style as any)[k]);\n            });\n        }\n        if (!isNil(style['shadowRadius'])) {\n            if (style['shadowRadius'] <= 0) {\n                style['shadowColor'] = 'transparent';\n            } else if (isNil(style['elevation'])) {\n                style['elevation'] = 2;\n            }\n        }\n        if (!isNil(style['margin'])) {\n            style['marginLeft'] = style['marginLeft'] || style['margin'];\n            style['marginRight'] = style['marginRight'] || style['margin'];\n            style['marginTop'] = style['marginTop'] || style['margin'];\n            style['marginBottom'] = style['marginBottom'] || style['margin'];\n            delete style['margin'];\n        }\n        if (!isNil(style['padding'])) {\n            style['paddingLeft'] = style['paddingLeft'] || style['padding'];\n            style['paddingRight'] = style['paddingRight'] || style['padding'];\n            style['paddingTop'] = style['paddingTop'] || style['padding'];\n            style['paddingBottom'] = style['paddingBottom'] || style['padding'];\n            delete style['padding'];\n        }\n        if (this.revertLayoutToExpo50 && !isNil(style['flexDirection']) && style['flexDirection'] === 'row-reverse') {\n            if (!isNil(style['paddingLeft']) || !isNil(style['paddingRight'])) {\n                if (!isNil(style['paddingLeft']) && !isNil(style['paddingRight'])) {\n                  [style['paddingLeft'], style['paddingRight']] = [style['paddingRight'], style['paddingLeft']];\n                } else {\n                  const [paddingLeft, paddingRight] = [style['paddingLeft'], style['paddingRight']];\n                  if (paddingLeft !== undefined) {\n                    style['paddingRight'] = paddingLeft;\n                    delete style['paddingLeft'];\n                  }\n                  if (paddingRight !== undefined) {\n                    style['paddingLeft'] = paddingRight;\n                    delete style['paddingRight'];\n                  }\n                }\n              }\n        \n              if (!isNil(style['marginLeft']) || !isNil(style['marginRight'])) {\n                if (!isNil(style['marginLeft']) && !isNil(style['marginRight'])) {\n                  [style['marginLeft'], style['marginRight']] = [style['marginRight'], style['marginLeft']];\n                } else {\n                  const [marginLeft, marginRight] = [style['marginLeft'], style['marginRight']];\n                  if (marginLeft !== undefined) {\n                    style['marginRight'] = marginLeft;\n                    delete style['marginLeft'];\n                  }\n                  if (marginRight !== undefined) {\n                    style['marginLeft'] = marginRight;\n                    delete style['marginRight'];\n                  }\n                }\n              }        \n        }\n        let screenWidth = Dimensions.get('window').width;\n        let screenHeight = Dimensions.get('window').height;\n        Object.keys(style).forEach((k, i) => {\n            let stylePropertyValue = style[k]\n            if(typeof stylePropertyValue === 'string' && stylePropertyValue.endsWith('vw')) {\n                stylePropertyValue = stylePropertyValue.replace('vw','')\n                style[k] = Number(stylePropertyValue)/100 * screenWidth\n            }\n            if((typeof stylePropertyValue === 'string' && stylePropertyValue.endsWith('vh'))) {\n                stylePropertyValue = stylePropertyValue.replace('vh','')\n                style[k] = Number(stylePropertyValue)/100 * screenHeight\n            }\n        })\n        Object.keys(style).forEach((k, i) => this.cleanseStyleProperties(style[k]));\n        return style;\n    }\n\n    getStyle(name: string) {\n        let style = this.cache[name];\n        if (style) {\n            return style;\n        }\n        if (!name) {\n            return {};\n        }\n        if (name.indexOf(' ') > 0) {\n            style = this.mergeStyle(...(name.split(' ').map(c => this.getStyle(c))));\n        } else {\n            const parentStyle = this.parent && this.parent.getStyle(name);\n            const mediaQuery = (this.styles[name] || {})['@media'];\n            let clonedStyle = {};\n            if (!mediaQuery || matchMedia(mediaQuery).matches) {\n                clonedStyle = cloneDeep(this.styles[name]);\n                this.cleanseStyleProperties(clonedStyle);\n            }\n            if (this !== Theme.BASE && isWebPreviewMode()) {\n                this.checkStyleProperties('', clonedStyle);\n            }\n            style = deepCopy(parentStyle, clonedStyle);\n            this.addTrace(`@${this.name}:${name}`, style, clonedStyle, parentStyle);\n        }\n        this.cache[name] = style;\n        return style;\n    }\n\n    $new(name = \"\", styles = {} as NamedStyles<any>) {\n        const newTheme = new Theme(this, name);\n        newTheme.reset(styles);\n        this.children.push(newTheme);\n        return newTheme;\n    }\n\n    destroy() {\n        const i = this.parent.children.indexOf(this);\n        if (i >= 0) {\n            this.parent.children.splice(i, 1);\n        }\n    }\n    \n    getTextStyle(s: any) {\n        if (!s) {\n            return {};\n        }\n        return {\n            color: s.color,\n            fontFamily: s.fontFamily,\n            fontSize: s.fontSize,\n            fontStyle: s.fontStyle,\n            fontWeight: s.fontWeight,\n            includeFontPadding: s.includeFontPadding,\n            fontVariant: s.fontVariant,\n            letterSpacing: s.letterSpacing,\n            lineHeight: s.lineHeight,\n            textAlign: s.textAlign,\n            textAlignVertical: s.textAlignVertical,\n            textDecorationColor: s.textDecorationColor,\n            textDecorationStyle: s.textDecorationStyle,\n            textShadowColor: s.textShadowColor,\n            textShadowOffset: s.textShadowOffset,\n            textShadowRadius: s.textShadowRadius,\n            textTransform: s.textTransform,\n            verticalAlign: s.verticalAlign,\n            writingDirection: s.writingDirection,\n            userSelect: s.userSelect,\n        } as TextStyle;\n    }\n\n    reset(styles?: NamedStyles<any>) {\n        this.styles = {};\n        this.clearCache();\n        if (styles) {\n            this.registerStyle((themeVariables, addStyle) => {\n                Object.keys(styles).forEach(k => {\n                    addStyle(k, '', styles[k] as any);\n                });\n            });\n        } else {\n            this.styleGenerators.forEach(fn => \n                fn(ThemeVariables.INSTANCE, this.addStyle.bind(this)));\n        }\n        this.notify(ThemeEvent.CHANGE);\n    }\n}\nexport default Theme.BASE;\nexport type NamedStyles<T> = { [P in keyof T]: AllStyle | NamedStyles<T>};\nexport type BackgroundImageStyle = {\n    backgroundImage: string,\n    backgroundPosition: string,\n    backgroundRepeat: string,\n    backgroundSize: string | number\n};\n\nexport type AllStyle = (ViewStyle & TextStyle & ImageStyle & {userSelect?: 'none'| 'text'} & {rippleColor?: string});\n\nconst ThemeContext = React.createContext<Theme>(null as any);\n\nexport const ThemeProvider = ThemeContext.Provider;\nexport const ThemeConsumer = ThemeContext.Consumer;\n/**\n * Common styles\n */\n Theme.BASE.registerStyle((themeVariables, addStyle) => {\n    const addColStyles = (device: string, minWidth: string) => {\n        for(let i = 1; i <= 12; i++) {\n            addStyle(`col-${device}-${i}`, '', {\n                \"@media\": `(min-width: ${minWidth})`,\n                root: {\n                    width: (100 * i / 12) + '%'\n                }\n            } as any)\n        }\n    };\n    addColStyles('xs', DEVICE_BREAK_POINTS.MIN_EXTRA_SMALL_DEVICE);\n    addColStyles('sm',  DEVICE_BREAK_POINTS.MIN_SMALL_DEVICE);\n    addColStyles('md',  DEVICE_BREAK_POINTS.MIN_MEDIUM_DEVICE);\n    addColStyles('lg',  DEVICE_BREAK_POINTS.MIN_LARGE_DEVICE);\n\n    addStyle('d-none', '', {\n        root: {\n            display: 'none'\n        }\n    } as any);\n    addStyle('d-flex', '', {\n        root: {\n            display: 'flex'\n        }\n    } as any);\n\n    const addDisplayStyles = (device: string, minWidth: string, maxWidth: string) => {\n        addStyle(`d-${device}-none`, '', {\n            \"@media\": `(min-width: ${minWidth}) and (max-width: ${maxWidth})`,\n            root: {\n                display: 'none'\n            }\n        } as any);\n        addStyle(`d-${device}-flex`, '', {\n            \"@media\": `(min-width: ${minWidth}) and (max-width: ${maxWidth})`,\n            root: {\n                display: 'flex'\n            }\n        } as any);\n    };\n    addDisplayStyles('all', \n        DEVICE_BREAK_POINTS.MIN_EXTRA_SMALL_DEVICE,\n        DEVICE_BREAK_POINTS.MAX_LARGE_DEVICE);\n    addDisplayStyles('xs', \n        DEVICE_BREAK_POINTS.MIN_EXTRA_SMALL_DEVICE,\n        DEVICE_BREAK_POINTS.MAX_EXTRA_SMALL_DEVICE);\n    addDisplayStyles('sm',   \n        DEVICE_BREAK_POINTS.MIN_SMALL_DEVICE,\n        DEVICE_BREAK_POINTS.MAX_SMALL_DEVICE);\n    addDisplayStyles('md',   \n        DEVICE_BREAK_POINTS.MIN_MEDIUM_DEVICE,\n        DEVICE_BREAK_POINTS.MAX_MEDIUM_DEVICE);\n    addDisplayStyles('lg',   \n        DEVICE_BREAK_POINTS.MIN_LARGE_DEVICE,\n        DEVICE_BREAK_POINTS.MAX_LARGE_DEVICE);\n\n    const addElevationClasses = () => {\n        for(let i = 1; i <= 10; i++) {\n            addStyle(`elevate${i}`, '', {\n                root : {\n                    shadowColor: \"#000000\",\n                    shadowOffset: {\n                        width: i,\n                        height: i,\n                    },\n                    shadowOpacity: 0.27,\n                    shadowRadius: i,\n                    elevation: i,\n                    zIndex: 1\n                }\n            });\n        }\n    };\n    addElevationClasses();\n    addStyle('hidden', '', {\n        root: {\n            width: 0,\n            height: 0,\n            transform: [{ scale: 0 }],\n            overflow: 'hidden'\n        }\n    });\n    addStyle('bg-danger', '', { root: { backgroundColor: themeVariables.dangerColor }});\n    addStyle('bg-info', '', { root: { backgroundColor: themeVariables.infoColor }});\n    addStyle('bg-primary', '', { root: { backgroundColor: themeVariables.primaryColor }});\n    addStyle('bg-success', '', { root: { backgroundColor: themeVariables.successColor }});\n    addStyle('bg-warning', '', { root: { backgroundColor: themeVariables.warningColor }});\n\n    addStyle('border-danger', '', { root: { borderColor: themeVariables.dangerColor }});\n    addStyle('border-info', '', { root: { borderColor: themeVariables.infoColor }});\n    addStyle('border-primary', '', { root: { borderColor: themeVariables.primaryColor }});\n    addStyle('border-success', '', { root: { borderColor: themeVariables.successColor }});\n    addStyle('border-warning', '', { root: { borderColor: themeVariables.warningColor }});\n\n    addStyle('hide-context-menu', '', { text: { userSelect: 'none' }});\n    addStyle('hide-context-menu-input', '', { text: { userSelect: 'none' }});\n});\n\n", "wavemaker-rn-runtime/src/styles/background.component.tsx": "import * as React from 'react';\nimport { LinearGradient as ExpoLinearGradient, LinearGradientPoint } from 'expo-linear-gradient';\nimport { DimensionValue, Image, StyleSheet, View, ViewStyle } from 'react-native';\nimport { isEmpty, isNil, isNumber, isString } from 'lodash-es';\nimport imageSizeEstimator from '@wavemaker/app-rn-runtime/core/imageSizeEstimator';\nimport { AssetConsumer } from '@wavemaker/app-rn-runtime/core/asset.provider';\nimport { isFullPathUrl } from '@wavemaker/app-rn-runtime/core/utils';\n\nexport interface LinearGradientProps {\n    value: string;\n    children: any;\n    style?: ViewStyle;\n    size?: ViewStyle;\n    position?: ViewStyle;\n    middle?: boolean;\n}\n\nexport interface LinearGradientState {\n    colors: string[];\n    locations: number[];\n    start: LinearGradientPoint;\n    end: LinearGradientPoint;\n}\n\nconst IMAGE_URL_REGEX = /url\\(['|\"]?(.+)['|\"]?\\)$/gi;\nconst LINEAT_GRADIENT_REGEX = /linear-gradient\\((.+)\\)$/gi;\nconst DIMENSION_REGEX = /([0-9%]+)[a-z]*/g;\nconst BACKGROUND_POSITION_REGEX = /([0-9%]+)[a-z]*\\s*([0-9%]+)[a-z]*/g;\nconst BACKGROUND_SIZE_REGEX = /([0-9%]+)[a-z]*\\s*([0-9%]+)[a-z]*/g;\n\nconst ASSET_CACHE = {} as any;\n\nexport class LinearGradient extends React.Component<LinearGradientProps, LinearGradientState> {\n\n    constructor(props: LinearGradientProps) {\n        super(props);\n        this.state = this.parse();\n    }\n\n    parse(val = this.props.value) {\n        let state = {} as LinearGradientState;\n        const splits = val.split(',').map(v => v.trim());\n        let angle = 0;\n        const locations: LinearGradientPoint[] = [];\n        if (splits[0].endsWith('deg')) {\n            angle = (parseInt(splits[0].split('deg')[0]))%360;\n            angle = angle < 0 ? (360 + angle) : angle;\n            splits.shift();\n        }\n        angle += 90;\n        const delta = Math.round(Math.tan((angle * Math.PI) / 180) * 100)/100;\n        if (Math.abs(delta) > 1) {\n            state = {\n                end: {\n                    x: -0.5 / delta + 0.5,\n                    y: 0\n                },\n                start: {\n                    x: 0.5 / delta + 0.5,\n                    y: 1\n                }\n            }  as LinearGradientState;\n        } else {\n            state = {\n                start: {\n                    x: 0,\n                    y: -0.5 * delta + 0.5\n                },\n                end: {\n                    x: 1,\n                    y: 0.5 * delta + 0.5\n                }\n            }  as LinearGradientState;\n        }\n        if (angle >= 270 && angle <= 450) {\n            state = {\n                start : state.end,\n                end: state.start\n            } as LinearGradientState;\n        }\n        state.colors = [];\n        state.locations = [];\n        splits.map(s => {\n            const p = s.matchAll(/\\s*([0-9.]+)%/g).next()?.value;\n            if (p) {\n                state.locations.push(parseFloat(p[1]) / 100);\n                state.colors.push(s.replace(p[0], ''));\n            } else {\n                state.locations.push(null as any);\n                state.colors.push(s);\n            }\n        });\n        return state;\n    }\n\n    componentDidUpdate(prevProps: Readonly<LinearGradientProps>, prevState: Readonly<{}>, snapshot?: any): void {\n        if (prevProps.value !== this.props.value) {\n            this.setState(this.parse());\n        }\n    }\n    \n\n    public render() {\n        return (\n            <View style={[{borderWidth: 0, overflow: 'hidden'}, StyleSheet.absoluteFill, this.props.style]}>\n                <View style={[\n                    StyleSheet.absoluteFill, this.props.middle ? {\n                        flexDirection: 'row',\n                        justifyContent: 'center',\n                        alignItems: 'center'\n                    } : null]}>\n                    <ExpoLinearGradient testID=\"wm-expo-linear-gradient\"\n                        colors={this.state.colors as any}\n                        locations={this.state.locations as any}\n                        start={this.state.start}\n                        end={this.state.end}\n                        style={[\n                            this.props.size?.width ? this.props.size : StyleSheet.absoluteFill,\n                            this.props.position,\n                            {position: 'absolute', borderRadius: this.props.style?.borderRadius}\n                        ]}\n                    />\n                </View>\n                {this.props.children}\n            </View>\n        );\n    }\n}\n\nexport interface BackgroundProps {\n    image?: string;\n    position?: string;\n    children?: any;\n    resizeMode?: string;\n    repeat?: string;\n    style?: ViewStyle;\n    size: string;\n}\n\nexport interface BackgroundState {\n    imageSrc: any;\n    naturalImageWidth: number,\n    naturalImageHeight: number\n}\n\nexport class BackgroundComponent extends React.Component<BackgroundProps, BackgroundState> {\n\n    private loadAsset: (path: string) => number | string = null as any;\n\n    constructor(props: BackgroundProps) {\n        super(props);\n        this.state = {\n            imageSrc : this.props.image ? ASSET_CACHE[this.props.image] : undefined\n        } as BackgroundState;\n    }\n\n    public caluculateSize(imageSrc: any) {\n        if (isNumber(imageSrc)) {\n            const {width, height} = Image.resolveAssetSource(imageSrc);\n            this.setState({\n              naturalImageWidth: width,\n              naturalImageHeight: height\n            } as BackgroundState);\n          } else if (!isNil(imageSrc)) {\n            imageSizeEstimator.getSize(imageSrc.uri, (width: number, height: number) => {\n              this.setState({\n                naturalImageWidth: width,\n                naturalImageHeight: height\n              } as BackgroundState);\n            });\n          }\n    }\n\n    getDimension(dim: string) {\n        if (dim) {\n            const value = dim.matchAll(DIMENSION_REGEX).next().value!;\n            if (value[1]) {\n                return value[1].endsWith('%') ? value[1] : parseInt(value[1]);\n            }\n        }\n        return null;\n    }\n\n    public getPosition() {\n        const result = {} as ViewStyle;\n        if (!this.props.position) {\n            return result;\n        }\n        const position = this.props.position.split(' ').map(s => s.trim());\n        if (position[0] === 'center') {\n            result.alignItems = 'center';\n        } else if (position[0] === 'top') {\n            result.top = 0;\n        } else if (position[0] === 'bottom') {\n            result.bottom = 0;\n        } else {\n            result.top = this.getDimension(position[0]) as DimensionValue;\n        }\n        if (position[1] === 'center') {\n            result.justifyContent = 'center';\n        } else if (position[1] === 'left') {\n            result.left = 0;\n        } else if (position[1] === 'bottom') {\n            result.right = 0;\n        } else {\n            result.left = this.getDimension(position[1]) as DimensionValue;\n        }\n        return result;\n    }\n\n    public getPositionAndSize() {\n        const result: {\n            resizeMode? : string,\n            position?: ViewStyle,\n            size?: ViewStyle\n        } = {} as any;\n        if (this.props.resizeMode) {\n            result.resizeMode = this.props.resizeMode;\n            return result;\n        } else if (this.props.position === 'center') {\n            result.resizeMode = 'center';\n            result.position = {\n                justifyContent: 'center',\n                alignItems: 'center'\n            };\n        } else if (this.props.size === 'contain' || this.props.size === 'cover') {\n            result.resizeMode = this.props.size;\n            return result;\n        }\n        const size = this.props.size?.matchAll(BACKGROUND_SIZE_REGEX).next().value;\n        result.size = {};\n        if (size) {\n            result.size.width = (size[1].endsWith('%') ? size[1] : parseInt(size[1])) as DimensionValue;\n            result.size.height = (size[2].endsWith('%') ? size[2] : parseInt(size[2])) as DimensionValue\n        }\n        if (!result.resizeMode && this.props.position) {\n            result.position = this.getPosition();\n        }\n        if (!this.getGradient()?.value?.length) {\n            if (this.props.repeat === 'no-repeat') {\n                result.size.width = result.size.width || this.state.naturalImageWidth; \n                result.size.height = result.size.height || this.state.naturalImageHeight; \n            } else if (this.props.repeat === 'repeat-x') {\n                result.resizeMode = 'repeat';\n                result.size.width = result.size.width || '100%'; \n                result.size.height = result.size.height || this.state.naturalImageHeight; \n            } else if (this.props.repeat === 'repeat-y') {\n                result.resizeMode = 'repeat';\n                result.size.width = result.size.width || this.state.naturalImageWidth; \n                result.size.height = result.size.height || '100%'; \n            } else {\n                result.resizeMode = 'repeat';\n            }\n        }\n        return result;\n    }\n\n    public renderLinearGradient(data: string) {\n        const psresult = this.getPositionAndSize();\n        return  (\n            <LinearGradient\n                value={data || ''}\n                style={this.props.style}\n                size={psresult.size}\n                position={psresult.position}\n                middle={psresult.resizeMode === 'center'}> \n                <></> \n            </LinearGradient>\n        );\n    }\n\n    componentDidUpdate(prevProps: Readonly<BackgroundProps>, prevState: Readonly<{}>, snapshot?: any): void {\n        if (this.props.image && prevProps.image !== this.props.image) {\n            this.setImage();\n        }\n    }\n\n    componentDidMount(): void {\n        setTimeout(() => this.setImage(), 100);\n    }\n\n    setImage() {\n        let source = this.props.image?.trim() as any;\n        if (!source) {\n            return;\n        }\n        if (source?.startsWith('url')) {\n            source = this.props.image?.matchAll(IMAGE_URL_REGEX)?.next()?.value?.[1];\n        }\n        if (this.loadAsset) {\n            source = this.loadAsset(source);\n        }\n        if (isFullPathUrl(source)) {\n            source = {\n                uri: source\n            };\n        }\n        this.caluculateSize(source);\n        this.setState({\n            imageSrc: source\n        } as BackgroundState);\n        if (this.props.image) {\n            ASSET_CACHE[this.props.image] = source;\n        }\n    }\n\n    public getGradient() {\n        return this.props.image?.trim().matchAll(LINEAT_GRADIENT_REGEX).next();\n    }\n\n    public renderImage() {\n        const psresult = this.getPositionAndSize();\n        return (\n        <AssetConsumer>\n            {(loadAsset) => {\n            const loadImage = this.loadAsset !== loadAsset;\n            this.loadAsset = loadAsset;\n            if (loadImage) {\n                setTimeout(() => this.setImage(), 10);\n            }\n            return (<View style={[{borderWidth: 0, overflow: 'hidden'}, StyleSheet.absoluteFill, this.props.style]}>\n                <View style={[\n                    StyleSheet.absoluteFill, {\n                        flexDirection: 'row',\n                        justifyContent: psresult.position?.justifyContent,\n                        alignItems: psresult.position?.alignItems\n                    }]}>\n                    <View style={[\n                        { position: 'absolute', overflow: 'hidden' },\n                        psresult.position,\n                        isEmpty(psresult.size) ?  StyleSheet.absoluteFill : psresult.size\n                    ]}>\n                        <Image\n                            source={this.state.imageSrc}\n                            resizeMode={psresult.resizeMode as any || 'cover'}\n                            style={[\n                                { \n                                    width: '100%',\n                                    height: '100%'\n                                }, \n                                !isEmpty(psresult.size)\n                                    || (psresult.resizeMode === 'cover'\n                                        || psresult.resizeMode  === 'contain') ? null : {\n                                    minWidth: this.state.naturalImageWidth,\n                                    minHeight: this.state.naturalImageHeight\n                                }\n                            ]}/> \n                    </View>\n                </View>\n            </View>);\n            }}\n        </AssetConsumer>\n        );\n    }\n\n    public render() {\n        const gradientData = this.getGradient();\n        if (gradientData?.value?.length) {\n            return this.renderLinearGradient(gradientData.value[1]);\n        } else if (this.props.image && this.state.imageSrc) {\n            return this.renderImage();\n        }\n        return null;\n    }\n}\n", "wavemaker-rn-runtime/src/styles/style-props.ts": "export class StyleProps {\n    backgroundimage?: any;\n    backgroundsize?: any;\n    backgroundrepeat?: any;\n    backgroundresizemode?: any;\n    backgroundposition?: any;\n    backgroundcolor?: any;\n    bordercolor?: any;\n    borderradius?: any;\n    borderstyle?: any;\n    borderwidth?: any;\n    borderbottomwidth?: any;\n    borderleftwidth?: any;\n    borderrightwidth?: any;\n    bordertopwidth?: any;\n    color?: any;\n    display?: any;\n    fontsize?: any;\n    fontfamily?: any;\n    fontstyle?: any;\n    fontvariant?: any;\n    fontweight?: any;\n    height?: any;\n    horizontalalign?: any;\n    lineheight?: any;\n    margin?: any;\n    marginbottom?: any;\n    marginleft?: any;\n    marginright?: any;\n    margintop?: any;\n    opacity?: any;\n    overflow?: any;\n    padding?: any;\n    paddingbottom?: any;\n    paddingleft?: any;\n    paddingright?: any;\n    paddingtop?: any;\n    textalign?: any;\n    textdecoration?: any;\n    verticalalign?: any;\n    width?: any;\n    zindex?: any;\n    top?: number | string;  // Use appropriate type (number, string, etc.)\n    bottom?: number | string;\n    left?: number | string;\n    right?: number | string;\n}\n\nconst styleMapping = {\n    backgroundimage: 'backgroundImage',\n    backgroundsize: 'backgroundSize',\n    backgroundrepeat: 'backgroundRepeat',\n    backgroundresizemode: 'backgroundResizeMode',\n    backgroundposition: 'backgroundPosition',\n    backgroundcolor: 'backgroundColor',\n    bordercolor: 'borderColor',\n    borderradius: 'borderRadius',\n    borderstyle: 'borderStyle',\n    borderwidth: 'borderWidth',\n    borderbottomwidth: 'borderBottomWidth',\n    borderleftwidth: 'borderLeftWidth',\n    borderrightwidth: 'borderRightWidth',\n    bordertopwidth: 'borderTopWidth',\n    color: 'color',\n    display: 'display',\n    fontsize: 'fontSize',\n    fontfamily: 'fontFamily',\n    fontstyle: 'fontStyle',\n    fontvariant: 'fontVariant',\n    fontweight: 'fontWeight',\n    height: 'height',\n    //horizontalalign: any;\n    lineheight: 'lineHeight',\n    margin: 'margin',\n    marginbottom: 'marginBottom',\n    marginleft: 'marginLeft',\n    marginright: 'marginRight',\n    margintop: 'marginTop',\n    opacity: 'opacity',\n    overflow: 'overflow',\n    padding: 'padding',\n    paddingbottom: 'paddingBottom',\n    paddingleft: 'paddingLeft',\n    paddingright: 'paddingRight',\n    paddingtop: 'paddingTop',\n    textalign: 'textAlign',\n    textdecoration: 'textDecoration',\n    verticalalign: 'verticalAlign',\n    width: 'width',\n    zindex: 'zindex',\n    top: 'top',\n    bottom: 'bottom',\n    left: 'left',\n    right: 'right'\n    };\n\nexport const getStyleName = (name: string) => (styleMapping as any)[name];\n", "wavemaker-rn-runtime/src/styles/style-prop.validator.ts": "import {isNumber, isNil, isString } from 'lodash-es';\nimport * as Font from 'expo-font';\n\nconst isColor = (c: string) => true;\nconst isStringOrNumber = (v: any) => isNumber(v) || isString(v);\nconst isIn = (...arr: any) => {\n    const obj = {};\n    arr.forEach((v: any) => {\n        (obj as any)[v] = true;\n    })\n    return (k: any) => (obj as any)[k] === true ;\n};\n\nconst STYLE_PROP_TYPE_INFO = {\n    alignContent: {\n        isValid: isIn('flex-start', 'flex-end', 'center', 'stretch', 'space-between', 'space-around'),\n        ref: 'https://reactnative.dev/docs/layout-props#aligncontent'\n    },\n    alignItems: {\n        isValid: isIn('flex-start', 'flex-end', 'center', 'stretch', 'baseline'),\n        ref: 'https://reactnative.dev/docs/layout-props#alignitems'\n    },\n    alignSelf: {\n        isValid: isIn('auto', 'flex-start', 'flex-end', 'center', 'stretch', 'baseline'),\n        ref: 'https://reactnative.dev/docs/layout-props#alignself'\n    },\n    aspectRatio: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#aspectratio'\n    },\n    backfaceVisibility: {\n        isValid: isIn('visible', 'hidden'),\n        ref: 'https://reactnative.dev/docs/image-style-props#backfacevisibility'\n    },\n    backgroundColor: {\n        isValid: isColor,\n        ref: 'https://reactnative.dev/docs/image-style-props#backgroundcolor'\n    },\n    backgroundImage: {\n        isValid: isString,\n        ref: 'http://www.wavemakeronline.com/app-runtime/latest/rn/style-docs/widgets/view'\n    },\n    borderBottomColor: {\n        isValid: isColor,\n        ref: 'https://reactnative.dev/docs/view-style-props#borderbottomcolor'\n    },\n    borderBottomEndRadius: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/view-style-props#borderbottomendradius'\n    },\n    borderBottomLeftRadius: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/image-style-props#borderbottomleftradius'\n    },\n    backgroundPosition: {\n        isValid: isStringOrNumber,\n        ref: 'http://www.wavemakeronline.com/app-runtime/latest/rn/style-docs/widgets/view'\n    },\n    backgroundRepeat: {\n        isValid: isIn('repeat', 'repeat-x', 'repeat-y', 'no-repeat'),\n        ref: 'http://www.wavemakeronline.com/app-runtime/latest/rn/style-docs/widgets/view'\n    },\n    backgroundSize: {\n        isValid: isStringOrNumber,\n        ref: 'http://www.wavemakeronline.com/app-runtime/latest/rn/style-docs/widgets/view'\n    },\n    borderBottomRightRadius: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/image-style-props#borderbottomrightradius'\n    },\n    borderBottomStartRadius: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/view-style-props#borderbottomstartradius'\n    },\n    borderBottomWidth: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#borderbottomwidth'\n    },\n    borderColor: {\n        isValid: isColor,\n        ref: 'https://reactnative.dev/docs/image-style-props#bordercolor'\n    },\n    borderCurve: {\n        isValid: isIn('circular', 'continuous'),\n        ref: 'https://reactnative.dev/docs/view-style-props#bordercurve-ios'\n    },\n    borderEndColor: {\n        isValid: isColor,\n        ref: 'https://reactnative.dev/docs/view-style-props#borderendcolor'\n    },\n    borderEndWidth: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#borderendwidth'\n    },\n    borderLeftColor: {\n        isValid: isColor,\n        ref: 'https://reactnative.dev/docs/view-style-props#borderleftcolor'\n    },\n    borderLeftWidth: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#borderleftwidth'\n    },\n    borderRadius: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/image-style-props#borderradius'\n    },\n    borderRightColor: {\n        isValid: isColor,\n        ref: 'https://reactnative.dev/docs/view-style-props#borderrightcolor'\n    },\n    borderRightWidth: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#borderrightwidth'\n    },\n    borderStartColor: {\n        isValid: isColor,\n        ref: 'https://reactnative.dev/docs/view-style-props#borderstartcolor'\n    },\n    borderStartWidth: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#borderstartwidth'\n    },\n    borderStyle: {\n        isValid: isIn('solid', 'dotted', 'dashed'),\n        ref: 'https://reactnative.dev/docs/view-style-props#borderstyle'\n    },\n    borderTopEndRadius: {\n        isValid: isColor,\n        ref: 'https://reactnative.dev/docs/view-style-props#bordertopendradius'\n    },\n    borderTopLeftRadius: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/image-style-props#bordertopleftradius'\n    },\n    borderTopRightRadius: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/image-style-props#bordertoprightradius'\n    },\n    borderTopStartRadius: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/view-style-props#bordertopstartradius'\n    },\n    borderTopColor: {\n        isValid: isColor,\n        ref: 'https://reactnative.dev/docs/layout-props#bordertopwidth'\n    },\n    borderTopWidth: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#bordertopwidth'\n    },\n    borderWidth: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/image-style-props#borderwidth'\n    },\n    bottom: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#bottom'\n    },\n    color: {\n        isValid: isColor,\n        ref: 'https://reactnative.dev/docs/text-style-props#color'\n    },\n    columnGap: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#columngap'\n    },\n    direction: {\n        isValid: isIn('inherit', 'LTR', 'RTL'),\n        ref: 'https://reactnative.dev/docs/layout-props#direction'\n    },\n    display: {\n        isValid: isIn('none', 'flex'),\n        ref: 'https://reactnative.dev/docs/layout-props#display'\n    },\n    elevation: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/view-style-props#elevation-android'\n    },\n    end: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#end'\n    },\n    flex: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#flex'\n    },\n    flexBasis: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#flexbasis'\n    },\n    flexDirection: {\n        isValid: isIn('column', 'row', 'column-reverse', 'row-reverse'),\n        ref: 'https://reactnative.dev/docs/layout-props#flexdirection'\n    },\n    flexGrow: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#flexgrow'\n    },\n    flexShrink: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#flexshrink'\n    },\n    flexWrap: {\n        isValid: isIn('wrap', 'nowrap', 'wrap-reverse'),\n        ref: 'https://reactnative.dev/docs/layout-props#flexwrap'\n    },\n    fontFamily: {\n        isValid: (v: string) => Font.isLoaded(v),\n        errorMsg: (v: string) => `Font '${v}' is not loaded. Font family names are case-sensitive. Please add font either in theme or app.`,\n        ref: 'https://reactnative.dev/docs/text-style-props#fontfamily'\n    },\n    fontSize: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/text-style-props#fontsize'\n    },\n    fontStyle: {\n        isValid: isIn('normal', 'italic'),\n        ref: 'https://reactnative.dev/docs/text-style-props#fontstyle'\n    },\n    fontVariant: {\n        isValid: (v: any) => isIn('small-caps', 'oldstyle-nums', 'lining-nums', 'tabular-nums', 'proportional-nums') || isString(v),\n        ref: 'https://reactnative.dev/docs/text-style-props#fontvariant'\n    },\n    fontWeight: {\n        isValid: (v: any) => isIn('normal', 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900') || isNumber(v),\n        ref: 'https://reactnative.dev/docs/text-style-props#fontweight'\n    },\n    gap: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#gap'\n    },\n    height: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#height'\n    },\n    justifyContent: {\n        isValid: isIn('flex-start', 'flex-end', 'center', 'space-between', 'space-around', 'space-evenly'),\n        ref: 'https://reactnative.dev/docs/layout-props#justifycontent'\n    },\n    left: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#left'\n    },\n    letterSpacing: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/text-style-props#letterspacing'\n    },\n    lineHeight: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/text-style-props#lineheight'\n    },\n    margin: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#margin'\n    },\n    marginBottom: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#marginbottom'\n    },\n    marginEnd: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#marginend'\n    },\n    marginHorizontal: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#marginhorizontal'\n    },\n    marginLeft: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#marginleft'\n    },\n    marginRight: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#marginright'\n    },\n    marginStart: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#marginstart'\n    },\n    marginTop: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#margintop'\n    },\n    marginVertical: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#marginvertical'\n    },\n    maxHeight: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#maxheight'\n    },\n    maxWidth: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#maxwidth'\n    },\n    minHeight: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#minheight'\n    },\n    minWidth: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#minwidth'\n    },\n    opacity: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/image-style-props#opacity'\n    },\n    overflow: {\n        isValid: isIn('visible', 'hidden', 'scroll'),\n        ref: 'https://reactnative.dev/docs/image-style-props#overflow'\n    },\n    overlayColor: {\n        isValid: isColor,\n        ref: 'https://reactnative.dev/docs/image-style-props#overlaycolor-android'\n    },\n    padding: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#padding'\n    },\n    paddingBottom: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#paddingbottom'\n    },\n    paddingEnd: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#paddingend'\n    },\n    paddingHorizontal: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#paddinghorizontal'\n    },\n    paddingLeft: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#paddingleft'\n    },\n    paddingRight: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#paddingright'\n    },\n    paddingStart: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#paddingstart'\n    },\n    paddingTop: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#paddingtop'\n    },\n    paddingVertical: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#paddingvertical'\n    },\n    pointerEvents: {\n        isValid: isIn('auto', 'box-none', 'box-only', 'none' ),\n        ref: 'https://reactnative.dev/docs/view-style-props#pointerevents'\n    },\n    position: {\n        isValid: isIn('absolute', 'relative', 'fixed'),\n        ref: 'https://reactnative.dev/docs/layout-props#position'\n    },\n    resizeMode: {\n        isValid: isIn('cover', 'contain', 'stretch', 'repeat', 'center'),\n        ref: 'https://reactnative.dev/docs/image-style-props#resizemode'\n    },\n    right: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#right'\n    },\n    rowGap: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#rowgap'\n    },\n    shadowColor: {\n        isValid: isColor,\n        ref: 'https://reactnative.dev/docs/shadow-props#shadowcolor'\n    },\n    shadowOpacity: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/shadow-props#shadowopacity-ios'\n    },\n    shadowRadius: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/shadow-props#shadowradius-ios'\n    },\n    start: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#start'\n    },\n    textAlign: {\n        isValid: isIn('auto', 'left', 'right', 'center', 'justify'),\n        ref: 'https://reactnative.dev/docs/text-style-props#textalign'\n    },\n    textAlignVertical: {\n        isValid: isIn('auto', 'top', 'bottom', 'center'),\n        ref: 'https://reactnative.dev/docs/text-style-props#textalignvertical-android'\n    },\n    textDecorationColor: {\n        isValid: isColor,\n        ref: 'https://reactnative.dev/docs/text-style-props#textdecorationcolor-ios'\n    },\n    textDecorationLine: {\n        isValid: isIn('none', 'underline', 'line-through', 'underline line-through'),\n        ref: 'https://reactnative.dev/docs/text-style-props#textdecorationline'\n    },\n    textDecorationStyle: {\n        isValid: isIn('solid', 'double', 'dotted', 'dashed'),\n        ref: 'https://reactnative.dev/docs/text-style-props#textdecorationstyle-ios'\n    },\n    textShadowColor: {\n        isValid: isColor,\n        ref: 'https://reactnative.dev/docs/text-style-props#textshadowcolor'\n    },\n    textShadowRadius: {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/text-style-props#textshadowoffset'\n    },\n    textTransform: {\n        isValid: isIn('none', 'uppercase', 'lowercase', 'capitalize'),\n        ref: 'https://reactnative.dev/docs/text-style-props#texttransform'\n    },\n    tintColor: {\n        isValid: isColor,\n        ref: 'https://reactnative.dev/docs/image-style-props#tintcolor'\n    },\n    top: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#top'\n    },\n    userSelect: {\n        isValid: isIn('text', 'none'),\n        ref: 'valid values to user-select are text, none.'\n    },\n    verticalAlign: {\n        isValid: isIn('auto', 'top', 'bottom', 'middle'),\n        ref: 'https://reactnative.dev/docs/text-style-props#verticalalign-android'\n    },\n    width: {\n        isValid: isStringOrNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#width'\n    },\n    writingDirection: {\n        isValid: isIn('auto', 'ltr', 'rtl'),\n        ref: 'https://reactnative.dev/docs/text-style-props#writingdirection-ios'\n    },\n    zIndex:  {\n        isValid: isNumber,\n        ref: 'https://reactnative.dev/docs/layout-props#zindex'\n    },\n};\n\nexport const getStyleReference = (name: string) => {\n    const info = (STYLE_PROP_TYPE_INFO as any)[name];\n    return !info || info.ref;\n};\n\nexport const isValidStyleProp = (name: string, value: any) => {\n    const info = (STYLE_PROP_TYPE_INFO as any)[name];\n    return name?.trim().startsWith('__') || (info && info.isValid(value));\n};\n\nexport const getErrorMessage = (name: string, value: any) => {\n    const info = (STYLE_PROP_TYPE_INFO as any)[name];\n    name = name.replace(/([A-Z])/g, (g) => `-${g[0].toLowerCase()}`);\n    if (info) {\n        if (info.errorMsg) {\n            return info.errorMsg(value);\n        } else {\n            return `'${value}' is not a valid value to '${name}'.`;\n        }\n    }\n    return `'${name}' is not a supported style property in one or all Native Platforms.`\n};", "wavemaker-rn-runtime/src/components/advanced/webview/webview.component.tsx": "import React from 'react';\nimport { BackHandler, Platform, View } from 'react-native';\nimport { WebView, WebViewNavigation, WebViewMessageEvent } from 'react-native-webview';\nimport { HideMode } from '@wavemaker/app-rn-runtime/core/if.component';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmWebviewProps from './webview.props';\nimport { DEFAULT_CLASS, WebviewStyles } from './webview.styles';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility';\nimport { isAndroid, isWebPreviewMode } from '@wavemaker/app-rn-runtime/core/utils';\n\nclass WmWebViewState extends BaseComponentState<WmWebviewProps> {\n  currentTarget = {\n    title: '',\n    src: ''\n  };\n\n}\n\nexport default class WmWebview extends BaseComponent<WmWebviewProps, WmWebViewState, WebviewStyles> {\n\n  private webview: WebView | null = null as any;\n  private webViewState: WebViewNavigation = null as any;\n  private invokeJSCallbacks = {} as any;\n\n  constructor(props: WmWebviewProps) {\n    super(props, DEFAULT_CLASS, new WmWebviewProps());\n    this.hideMode = HideMode.DONOT_ADD_TO_DOM;\n    if (isAndroid() && !isWebPreviewMode()) {\n      BackHandler.addEventListener('hardwareBackPress', this.handleBackButtonPress);\n    }\n  }\n\n  componentWillUnmount() {\n    super.componentWillUnmount();\n    if (isAndroid() && !isWebPreviewMode()) {\n      BackHandler.removeEventListener('hardwareBackPress', this.handleBackButtonPress);\n    }\n  }\n\n  handleBackButtonPress = (): boolean => {\n    if (this.webview && this.webViewState && this.webViewState.canGoBack) {\n      this.webview.goBack();\n      return true;\n    }\n    return false;\n  }\n\n  get title() {\n    return this.state.currentTarget?.title;\n  }\n\n  get currentsrc() {\n    return this.state.currentTarget?.src;\n  }\n\n  executeScript(fn: string) {\n    return new Promise((resolve, reject) => {\n      if (this.webview) {\n        const id = '' + Date.now();\n        this.invokeJSCallbacks[id] = resolve;\n        fn = `\n         (function(){\n          try{\n            return (${fn});\n          } catch(e) {\n            return e.getMessage();\n          }\n         }())\n        `;\n        this.webview.injectJavaScript(\n          `window.ReactNativeWebView.postMessage('afterInjectJavaScript:' + ${id} + ':' + JSON.stringify(${fn}))`\n        );\n      } else {\n        reject();\n      }\n    });\n  }\n\n  insertCSS(style = '') {\n    style = style.replace(/[\\n\\t\\r]/g, '');\n    return this.executeScript(`\n    function() {\n      const style = document.createElement('style');\n      style.innerHTML = '${style}';\n      document.head.appendChild(style);\n      return 'SUCCESS';\n    }()\n    `);\n  }\n\n  parseResult(result: string) {\n    try {\n      return JSON.parse(result);\n    } catch(e) {\n      if (result === 'undefined' || result === 'null') {\n        return null;\n      }\n      return result;\n    }\n  }\n\n  onMessage = (event: WebViewMessageEvent) => {\n    const data: string = event.nativeEvent?.data;\n    if (data && data.startsWith('afterInjectJavaScript')) {\n      const id = data?.match(/\\:([0-9]+)\\:/);\n      const callback = id && this.invokeJSCallbacks[id[1]];\n      const result = data.substring(data.indexOf(':', data.indexOf(':') + 1) + 1);\n      callback && callback(this.parseResult(result));\n    } else {\n      this.invokeEventCallback('onMessage', [event, this]);\n    }\n  }\n\n  getTitle(iframe: any) {\n    try {\n      return iframe.currentTarget.contentWindow.document.title;\n    } catch(e) {\n      // browser blocks cross origin access to iframe content.\n    }\n  }\n\n  public onLoad(e: any, title: string, src: string) {\n    this.updateState({\n      currentTarget: {\n        title: title,\n        src: src\n      }\n    } as WmWebViewState, () => {\n      this.invokeEventCallback('onLoad', [e, this]);\n    });\n  }\n\n  protected renderWidget(props: WmWebviewProps) {\n    return (\n      <View \n        style={this.styles.root}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        {this._background}\n        {Platform.OS === 'web' ?\n          (<iframe src={props.src} width={'100%'} height={'100%'}\n            onLoad={(e) => this.onLoad(e, this.getTitle(e.currentTarget), (e.currentTarget as any).src)}></iframe>) :\n          (<WebView\n            ref={(ref) => this.webview = ref}\n            nestedScrollEnabled={true}\n            containerStyle = {this.styles.webview}\n            // style={this.styles.webview} // when using style, there are some inconsistencies observed in Android. containerStyle gives us a uniformity in IOS and Android.\n            source={{\n              uri: props.src\n            }}\n            testID={this.getTestId('web_view')}\n            {...getAccessibilityProps(AccessibilityWidgetType.WEBVIEW, props)}\n            incognito={props.incognito}\n            onMessage={this.onMessage}\n            sharedCookiesEnabled={true}\n            onNavigationStateChange={(state) => {\n              this.webViewState = state;\n            }}\n            scrollEnabled={true}\n            onLoadEnd={(e) => this.onLoad(e, e.nativeEvent.title, e.nativeEvent.url)}\n            allowsFullscreenVideo={true}\n            allowsInlineMediaPlayback={true}\n          >\n          </WebView>)}\n      </View>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/advanced/webview/webview.styles.ts": "import BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type WebviewStyles = BaseStyles & {\n  container: AllStyle;\n  webview: AllStyle;\n}\n\nexport const DEFAULT_CLASS = 'app-webview';\n\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WebviewStyles = defineStyles({\n      root: {},\n      text: {},\n      container : {\n        flex: 1,\n        minHeight: 100\n      },\n      webview: {\n        flex: 1\n      }\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/advanced/webview/webview.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\nimport WmWebview from './webview.component';\nimport { AccessibilityRole } from 'react-native';\n\nexport default class WmWebviewProps extends BaseProps {\n  src: string = null as any;\n  incognito? = false;\n  onLoad?: ($event: any, $widget: WmWebview) => void = null as any;\n  accessibilitylabel?: string = undefined;\n  hint?: string = undefined;\n  accessibilityrole?: AccessibilityRole;\n}", "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\nimport React from 'react';\n\nexport default class WmCarouselProps extends BaseProps {\n  dataset: any = null;\n  type?: 'static' | 'dynamic' = 'static';\n  animation?: 'auto' | 'none' = 'auto';\n  animationinterval?: number = 3;\n  controls?: 'both' | 'none' | 'navs' | 'indicators' = 'both';\n  children? = null as any;\n  itemkey?: ($item: any, $index: any) => any = null as any;\n  renderSlide?: ($item: any, $index: number, carousel: any) => React.ReactNode;\n  enablegestures  = true;\n  maxnoofdots = 5;\n  showskeletonchildren?: boolean = false;\n  threshold: number = 5;\n}", "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.component.tsx": "import React from 'react';\nimport { isArray, isUndefined } from 'lodash-es';\nimport { Animated, Easing, View, LayoutChangeEvent, LayoutRectangle } from 'react-native';\nimport { DefaultKeyExtractor } from '@wavemaker/app-rn-runtime/core/key.extractor';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport * as SwipeAnimation from '@wavemaker/app-rn-runtime/gestures/carousel-swipe.animation';\nimport { Tappable } from '@wavemaker/app-rn-runtime/core/tappable.component';\n\nimport WmCarouselProps from './carousel.props';\nimport { DEFAULT_CLASS, WmCarouselStyles } from './carousel.styles';\nimport { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\n\nexport class WmCarouselState extends BaseComponentState<WmCarouselProps> {\n  activeIndex = 1;\n}\n\nexport default class WmCarousel extends BaseComponent<WmCarouselProps, WmCarouselState, WmCarouselStyles> {\n\n  noOfSlides: number = 0;\n  private slidesLayout: LayoutRectangle[] = [];\n  private keyExtractor = new DefaultKeyExtractor();\n  stopPlay: Function = null as any;\n  private dotPosition = new Animated.Value(0);\n  private wrapperPosition = new Animated.Value(0);\n  private animationView: SwipeAnimation.View | null = null as any;\n  private animationHandlers = {\n    bounds: (e) => {\n      const activeTabIndex = this.state.activeIndex - 1;\n      let lower = 0;\n      if (activeTabIndex > 0) {\n        lower = this.slidesLayout\n          .filter((l , i) => i < activeTabIndex - 1)\n          .reduce((s, l) => s + l.width, 0);\n      }\n      let center = lower + (this.slidesLayout[activeTabIndex - 1]?.width || 0);\n      let upper = center + (this.slidesLayout[activeTabIndex]?.width || 0);\n      return {\n        lower: -1 * lower,\n        center: -1 * center,\n        upper:  -1 * upper\n      };\n    },\n    computePhase: (value) => {\n      const activeTabIndex = this.state.activeIndex - 1;\n      const w = this.slidesLayout[activeTabIndex]?.width || 0;\n      return w && Math.abs(value / w);\n    },\n    onLower: (e) => {\n      this.onSlideChange(this.state.activeIndex - 1);\n    },\n    onUpper: (e) => {\n      if(this.noOfSlides < this.state.activeIndex + 1){\n        this.onSlideChange(1);\n        this.animationView?.setPosition(0);\n      }\n      else{\n        this.onSlideChange(this.state.activeIndex + 1);\n      }\n    }\n  } as SwipeAnimation.Handlers;\n\n  constructor(props: WmCarouselProps) {\n    super(props, DEFAULT_CLASS, new WmCarouselProps(), new WmCarouselState());\n    this.cleanup.push(() => {\n      this.stopPlay && this.stopPlay();\n    })\n  }\n\n  addSlideLayout(index: number, nativeEvent: LayoutChangeEvent) {\n    this.slidesLayout[index] = nativeEvent.nativeEvent.layout;\n    if (index === this.state.activeIndex) {\n      this.forceUpdate();\n    }\n  }\n\n  private generateItemKey(item: any, index: number, props: WmCarouselProps) {\n    if (props.itemkey && item && !this._showSkeleton) {\n      return props.itemkey(item, index);\n    }\n    return 'list_item_' +  this.keyExtractor.getKey(item, true);\n  }\n\n  autoPlay() {\n    if(!this.initialized){\n      return;\n    }\n    const props = this.state.props;\n    this.stopPlay && this.stopPlay();\n    if (props.animation === 'auto' && props.animationinterval) {\n      const intervalId = setInterval(() => {\n        this.next();\n      }, props.animationinterval * 1000);\n      this.stopPlay = () => clearInterval(intervalId);\n    } else {\n      setTimeout(() => {\n        this.onSlideChange(1);\n        this.animationView?.setPosition(0);\n      }, 1000);\n    }\n  }\n\n  stopAnimation(){  \n    this.stopPlay();\n  }\n  startAnimation() {\n      this.autoPlay();\n  }\n  \n\n  onPropertyChange(name: string, $new: any, $old: any): void {\n      super.onPropertyChange(name, $new, $old);\n      switch (name) {\n        case 'dataset': {\n          this.keyExtractor?.clear();\n          this.updateState({\n            activeIndex: Math.min(this.state.activeIndex, $new?.length || 1)\n          } as WmCarouselState);\n          break;\n        }\n        case 'animation':\n        case 'animationinterval' : {\n          this.autoPlay();\n        }\n      }\n  }\n\n  animatePagination(index: number) {\n    const prevIndex = this.state.activeIndex;\n    const props = this.state.props;\n    const maxNoOfDots = this.state.props.maxnoofdots;\n    const margin = ((this.styles.dotStyle?.marginLeft as number)|| 0) + \n    ((this.styles.dotStyle?.marginRight as number)|| 0)\n    const width = (this.styles.dotStyle?.width as number)|| 2;\n    const size = margin + width;\n    const multiplier = this.isRTL ? -1 : 1;\n    const options = {\n      useNativeDriver: true,\n      duration: 100,\n      easing: Easing.out(Easing.linear),\n    };\n    let data = props.type === 'dynamic' ? props.dataset : props.children;\n    const shouldAnimate = !(maxNoOfDots >= data?.length) && index > 3 && index <= data?.length - 2;\n    if (shouldAnimate) {\n      const newTranslateX = multiplier * -(index - 3) * (width + margin);\n      Animated.timing(this.wrapperPosition, {\n        toValue: newTranslateX,\n        ...options,\n      }).start();\n    }\n    if (index == 1 && prevIndex == data?.length) {\n      Animated.timing(this.wrapperPosition, {\n        toValue: 0,\n        ...options,\n      }).start();\n    }   \n    if (prevIndex < index || prevIndex > index) {\n      Animated.timing(this.dotPosition, {\n        toValue: multiplier * size * Math.max(index - 1, 0),\n        ...options,\n      }).start();\n    } \n  }\n\n  onSlideChange = (index: number) => {\n    const prevIndex = this.state.activeIndex;\n    this.updateState({\n      activeIndex: index\n    } as WmCarouselState,\n    () => this.invokeEventCallback('onChange', [this, index, prevIndex]));\n    this.animatePagination(index);\n  }\n\n  renderItem = (item: any, index: number) => {\n    const props = this.state.props;\n    if (props.type === 'dynamic') {\n      return props.renderSlide ? props.renderSlide(item, index, this) : null;\n    }\n    return props.children[index];\n  }\n\n  next = () => {\n    const props = this.state.props;\n    const data = props.type === 'dynamic' ? props.dataset : props.children;\n    if (this.state.activeIndex >= data?.length || 0) {\n      this.onSlideChange(1);\n      this.animationView?.setPosition(0);\n    } else {\n      this.animationView?.goToUpper();\n    }\n  }\n\n  prev = () => {\n    this.animationView?.goToLower();\n  }\n\n  renderPagination(data: any) {\n    const maxNoOfDots = data.length > 5 ? this.state.props.maxnoofdots : data.length;\n    const activeIndex = this.state.activeIndex - 1;\n    const dotMargin = ((this.styles.dotStyle?.marginLeft as number)|| 0) + \n    ((this.styles.dotStyle?.marginRight as number)|| 0);\n    const wrapperWidth = (this.styles.dotStyle.width as any * maxNoOfDots) + (dotMargin * maxNoOfDots);\n    let minIndex = Math.max(this.state.activeIndex - maxNoOfDots + 1, 0);\n    let maxIndex = Math.min(minIndex + maxNoOfDots - 1, data.length);\n    if (maxIndex === data.length) {\n      minIndex = maxIndex - maxNoOfDots;\n    }\n    const dotStyle = this._showSkeleton ? {\n      ...this.styles.dotStyle,\n      ...this.styles.dotSkeleton.root\n    } : this.styles.dotStyle\n    return (<View style={{ width: '100%', justifyContent: 'center', alignItems: 'center' }}>\n        <View style={[this.styles.dotsWrapperStyle, { width: wrapperWidth }]}>\n          <Animated.View\n            style={{\n              flexDirection: this.isRTL ? 'row-reverse' : 'row',\n              alignItems: 'center',\n              transform: [{ translateX: this.wrapperPosition }],\n            }}\n          >\n            {data.map((item: any, index: number) => {\n              const isActive = index === activeIndex;\n              let scale = 1;\n              if (activeIndex <= 2) {\n                scale = index <= 2 ? 1 : 1 - 0.1 * (index - 2);\n              } else if (activeIndex >= data.length - 3) {\n                  scale = index >= data.length - 3 ? 1 : 1 - 0.1 * ((data.length - 3) - index);\n              } else {\n                  scale = index === activeIndex ? 1 : (Math.abs(index - activeIndex) === 1 ? 0.9 : 0.8);\n              }\n              const animatedScale = new Animated.Value(scale);\n              Animated.timing(animatedScale, {\n                toValue: scale,\n                duration: 100,\n                easing: Easing.out(Easing.ease),\n                useNativeDriver: true,\n              }).start();\n              return (\n                <Animated.View\n                  key={'dots_' + this.generateItemKey(item, index, this.state.props)}\n                  {...this.getTestPropsForAction('indicator' + index)}\n                  style={[dotStyle,\n                    isActive && this.styles.activeDotStyle,\n                    {                \n                      transform: [{scale: animatedScale}]\n                    },\n                  ]}\n                />\n              );\n            })}\n          </Animated.View>\n        </View>\n      </View>);\n  }\n\n  public renderSkeleton(props: WmCarouselProps): React.ReactNode | null {\n    return <View style={[this.styles.root, {...this.styles.skeleton.root}]}>\n       {this.renderItem({}, 0)}\n      {this.renderPagination([{}, {}, {}])}\n    </View>\n  }\n\n  componentDidMount(): void {\n    super.componentDidMount();\n    this.autoPlay();\n  }\n\n  renderWidget(props: WmCarouselProps) {\n    const hasNavs = props.controls === 'both' || props.controls ==='navs';\n    const hasDots = props.controls === 'both' || props.controls ==='indicators';\n    let styles = this.styles;\n    let data = props.type === 'dynamic' ? props.dataset : props.children;\n    data = isArray(data) ? data : [];\n    this.noOfSlides = data?.length || 0;\n    let slideScale = undefined as any;\n    let slideTranslateX = undefined as any;\n    if (isArray(this.styles.slide?.transform)) {\n      slideScale = (this.styles.slide?.transform?.find(o => !isUndefined((o as any).scale)) as any)?.scale;\n      slideTranslateX = (this.styles.slide?.transform?.find(o => !isUndefined((o as any).translateX)) as any)?.translateX;\n    }\n    // TODO: loop prop on Carousel is not working Refer: https://github.com/meliorence/react-native-snap-carousel/issues/608\n    return (\n      <View \n        style={styles.root}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        {this._background}\n        <SwipeAnimation.View \n            enableGestures={props.enablegestures && this.noOfSlides > 1}\n            style={{\n              flex: 1\n            }}\n            direction='horizontal'\n            threshold={this.state.props.threshold}\n            ref={(r) => {this.animationView = r}}\n            handlers = {this.animationHandlers}\n            slideMinWidth={this.styles.slide.width}\n            slidesLayout={this.slidesLayout}\n            activeIndex={this.state.activeIndex}\n          >\n          {data.map((item: any, index: number) => {\n            const isActive = index === this.state.activeIndex - 1;\n            let scale = this.animationView?.animationPhase.interpolate({\n              inputRange: [-2000, index - 1, index, index + 1, 2000],\n              outputRange: [slideScale, slideScale, 1, slideScale, slideScale]\n            });\n            let translateX = this.animationView?.animationPhase.interpolate({\n              inputRange: [-2000, index - 1, index, index + 1, 2000],\n              outputRange: [-56, -56, 0, 56, 56]\n            });\n            return (\n              <Animated.View key={this.generateItemKey(item, index, props)}\n                onLayout={this.addSlideLayout.bind(this, index)}\n                testID={`carousel_item_${index}`}\n                style={[\n                  {height: props.type === 'dynamic' ? undefined : '100%'},\n                  this.styles.slide,\n                  index === 0 ? this.styles.firstSlide : null,\n                  index === data.length - 1 ? this.styles.lastSlide: null,\n                  isActive ? this.styles.activeSlide: null,\n                  translateX && scale ? {\n                    transform: [\n                      {\n                        translateX: !isUndefined(slideTranslateX) ? slideTranslateX : translateX\n                      }, {\n                        scale: scale\n                      }\n                    ]\n                  } : null]}>\n                <Tappable onTap={() => {\n                  this.onSlideChange(index + 1);\n                  const position = this.slidesLayout\n                    .filter((l , i) => i < index)\n                    .reduce((s, l) => s + l.width, 0);\n                  this.animationView?.setPosition(-1 * position);\n                }} rippleColor={this.styles.root.rippleColor} styles={{height: \"100%\"}}\n                disableTouchEffect={this.state.props.disabletoucheffect}>\n                  {this.renderItem(item, index)}\n                </Tappable>\n              </Animated.View>\n            );\n          })}\n        </SwipeAnimation.View>\n        {hasNavs ? (\n          <View style={styles.btnPanel}>\n            <WmIcon\n              id={this.getTestId('prev_icon')}\n              iconclass=\"wi wi-chevron-left fa-2x\"\n              styles={styles.prevBtn}\n              onTap={this.prev}\n              accessibilitylabel='back'/>\n            <WmIcon\n              id={this.getTestId('next_icon')}\n              iconclass=\"wi wi-chevron-right fa-2x\"\n              styles={styles.nextBtn}\n              onTap={this.next}\n              accessibilitylabel='next'/>\n          </View>): null}\n          {hasDots && data ? this.renderPagination(data) : null}\n      </View>);\n  }\n}\n", "wavemaker-rn-runtime/src/components/advanced/carousel/carousel.styles.ts": "import { ViewStyle } from 'react-native';\nimport BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmIconStyles } from '@wavemaker/app-rn-runtime/components/basic/icon/icon.styles';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmCarouselStyles = BaseStyles & {\n    btnPanel: AllStyle,\n    prevBtn: WmIconStyles,\n    slide: AllStyle,\n    firstSlide: AllStyle,\n    lastSlide: AllStyle,\n    activeSlide: AllStyle,\n    nextBtn: WmIconStyles,\n    dotsWrapperStyle: AllStyle,\n    dotStyle: AllStyle,\n    activeDotStyle: AllStyle,\n    skeleton: WmSkeletonStyles\n    dotSkeleton: WmSkeletonStyles\n};\nexport const DEFAULT_CLASS = 'app-carousel';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const btn: ViewStyle = {\n        height: 48,\n        width: 48,\n        borderRadius: 48,\n        borderColor: themeVariables.transparent,\n        borderWidth: 1,\n        justifyContent: 'center'\n    };\n    const defaultStyles: WmCarouselStyles = defineStyles({\n        root: {\n            position: 'relative',\n            rippleColor: themeVariables.transparent\n        },\n        text: {},\n        slide: {\n            width: '100%',\n            overflow: 'hidden',\n            paddingHorizontal: 16,\n            transform: [\n                {\n                    scale: 0.8\n                }\n            ]\n        },\n        firstSlide: {},\n        lastSlide: {},\n        activeSlide: {},\n        btnPanel: {\n            position: 'absolute',\n            top: '50%',\n            marginTop: -64,\n            height: 64,\n            flexDirection: 'row',\n            alignItems: 'center',\n            justifyContent: 'space-between',\n            width: '100%'\n        },\n        prevBtn : {\n            root: {\n                marginLeft: 12,\n                ...btn,\n                backgroundColor: themeVariables.carouselPrevBgColor,\n                rippleColor: themeVariables.transparent\n            },\n            text: {\n                fontSize: 32\n            },\n            icon : {\n                color: themeVariables.carouselPrevBtnColor\n            }\n        } as WmIconStyles,\n        nextBtn : {\n            root: {\n                marginRight: 12,\n                ...btn,\n                backgroundColor: themeVariables.carouselPrevBgColor,\n                rippleColor: themeVariables.transparent\n            },\n            text: {\n                fontSize: 32\n            },\n            icon : {\n                color: themeVariables.carouselNextBtnColor\n            }\n        } as WmIconStyles,\n        dotsWrapperStyle:{\n            opacity: 1,\n            backgroundColor: themeVariables.carouselDotWrapperBgColor,\n            paddingTop: 4,\n            paddingBottom: 4,\n            overflow: 'hidden',\n        },\n        activeDotStyle: {\n            backgroundColor: themeVariables.carouselActiveDotColor,\n            opacity: 1,\n        },\n        dotStyle: {\n            width: 10,\n            height: 10,\n            opacity: 0.6,\n            borderRadius: 5,\n            marginLeft: 4,\n            marginRight: 4,\n            backgroundColor: themeVariables.carouselDotColor\n        },\n        skeleton: {\n            root: {\n                width: '100%',\n            },\n            text: {}\n        } as any as WmSkeletonStyles,\n        dotSkeleton: {\n            root: {\n                width: 10,\n                height: 10,\n                borderRadius: 5,\n                opacity: 1,\n                backgroundColor: themeVariables.skeletonAnimatedBgColor    \n            }\n        } as any as WmSkeletonStyles\n    } as WmCarouselStyles);\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n    addStyle(DEFAULT_CLASS + '-rtl', '', {\n        prevBtn : {\n            root:{\n                transform: [{rotateY: '180deg'}]\n            }\n        },\n        nextBtn : {\n            root:{\n                transform: [{rotateY: '180deg'}]\n            }\n        }\n    });\n\n    addStyle('app-carousel-1', '', {\n        btnPanel: {\n            top: '100%'\n        },\n        prevBtn: {\n            root: {\n                borderRadius: 6\n            }\n        },\n        nextBtn: {\n            root: {\n                borderRadius: 6\n            }\n        }\n    } as any as WmCarouselStyles);\n\n    addStyle('app-carousel-2', '', {\n        btnPanel: {\n            backgroundColor: themeVariables.defaultColorF,\n            width: '100%',\n            top: '100%',\n            right: 0,\n            padding: 8,\n            justifyContent: 'flex-end'\n        },\n        dotsWrapperStyle:{\n            alignSelf: 'flex-start',\n            justifyContent: 'flex-start'\n        },\n        activeDotStyle: {\n            backgroundColor: themeVariables.primaryColor,\n        },\n        dotStyle: {\n            backgroundColor: themeVariables.primaryColor,\n        },\n        prevBtn: {\n            root: {\n                backgroundColor: 'rgba(255, 255, 255, 0.1)',\n                borderColor: themeVariables.primaryColor,\n            },\n            icon : {\n                color: themeVariables.primaryColor\n            }\n        },\n        nextBtn: {\n            root: {\n                marginLeft: 8,\n                backgroundColor: 'rgba(255, 255, 255, 0.1)',\n                borderColor: themeVariables.primaryColor,\n            },\n            icon : {\n                color: themeVariables.primaryColor\n            }\n        }\n    } as any as WmCarouselStyles);\n});", "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-template/carousel-template.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmCarouselTemplateProps extends BaseProps {\n    children = null as any;\n}", "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-template/carousel-template.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type WmCarouselTemplateStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-carousel-template';\n\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmCarouselTemplateStyles = defineStyles({\n        root: {\n            flexDirection: 'column',\n            justifyContent: 'center',\n            alignItems: 'center',\n            width: '100%'\n        },\n        text: {}\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-template/carousel-template.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmCarouselTemplateProps from './carousel-template.props';\nimport { DEFAULT_CLASS, WmCarouselTemplateStyles } from './carousel-template.styles';\n\nexport class WmCarouselTemplateState extends BaseComponentState<WmCarouselTemplateProps> {}\n\nexport default class WmCarouselTemplate extends BaseComponent<WmCarouselTemplateProps, WmCarouselTemplateState, WmCarouselTemplateStyles> {\n\n  constructor(props: WmCarouselTemplateProps) {\n    super(props, DEFAULT_CLASS, new WmCarouselTemplateProps());\n  }\n\n  renderWidget(props: WmCarouselTemplateProps) {\n    return (<View style={[this.styles.root, {\n      height: this.styles.root.height || (this.parent?.styles.root.height && '100%')\n    }]}>{this._background}{props.children}</View>);  \n  }\n}\n", "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-content/carousel-content.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmCarouselContentProps extends BaseProps {\n    children? = null as any;\n}", "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-content/carousel-content.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmCarouselContentProps from './carousel-content.props';\nimport { DEFAULT_CLASS, WmCarouselContentStyles } from './carousel-content.styles';\n\nexport class WmCarouselContentState extends BaseComponentState<WmCarouselContentProps> {}\n\nexport default class WmCarouselContent extends BaseComponent<WmCarouselContentProps, WmCarouselContentState, WmCarouselContentStyles> {\n\n  constructor(props: WmCarouselContentProps) {\n    super(props, DEFAULT_CLASS, new WmCarouselContentProps());\n  }\n\n  renderWidget(props: WmCarouselContentProps) {\n    return (<View style={this.styles.root}>{this._background}{props.children}</View>); \n  }\n}\n", "wavemaker-rn-runtime/src/components/advanced/carousel/carousel-content/carousel-content.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type WmCarouselContentStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-carousel-content';\n\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmCarouselContentStyles = defineStyles({\n        root: {\n            flexDirection: 'column',\n            justifyContent: 'center',\n            alignItems: 'center',\n            width: '100%',\n            height: '100%'\n        },\n        text: {}\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/advanced/login/login.component.tsx": "import React from 'react';\nimport { Text, View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmLoginProps from './login.props';\nimport { DEFAULT_CLASS, WmLoginStyles } from './login.styles';\nimport { AxiosError, AxiosResponse } from 'axios';\n\nexport class WmLoginState extends BaseComponentState<WmLoginProps> {\n  errorMsg = '';\n}\n\nexport default class WmLogin extends BaseComponent<WmLoginProps, WmLoginState, WmLoginStyles> {\n  constructor(props: WmLoginProps) {\n    super(props, DEFAULT_CLASS, new WmLoginProps());\n  }\n\n  onLoginSuccess(response: AxiosResponse) {\n  }\n\n  onLoginError(error: AxiosError) {\n    this.updateState({errorMsg: error?.message} as WmLoginState);\n  }\n\n  doLogin(formData: any) {\n    this.props.onLogin(formData, this.onLoginSuccess.bind(this), this.onLoginError.bind(this));\n  }\n\n  renderWidget(props: WmLoginProps) {\n    return (\n    <View \n      style={this.styles.root}\n      onLayout={(event) => this.handleLayout(event)}\n    >\n      {this._background}\n      {(this.state.errorMsg && props.showerror) && <Text {...this.getTestPropsForLabel('error')} style={this.styles.errorMsgStyles}>{this.state.errorMsg}</Text>}\n      <View style={this.styles.formStyles}>{props.children}</View>\n    </View>); \n  }\n}\n", "wavemaker-rn-runtime/src/components/advanced/login/login.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmLoginProps extends BaseProps {\n    children: any;\n    onLogin: Function = () => {};\n    showerror: boolean = true;\n}", "wavemaker-rn-runtime/src/components/advanced/login/login.styles.ts": "import BASE_THEME, {AllStyle} from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport ThemeVariables from \"@wavemaker/app-rn-runtime/styles/theme.variables\";\n\nexport type WmLoginStyles = BaseStyles & {\n    errorMsgStyles: AllStyle,\n    formStyles: AllStyle\n};\n\nexport const DEFAULT_CLASS = 'app-login';\n\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmLoginStyles = defineStyles({\n        root: {},\n        text: {},\n        errorMsgStyles: { \n            color: themeVariables.loginErrorMsgColor, \n            fontSize: 14, \n            backgroundColor: themeVariables.loginErrorMsgBgColor , \n            borderColor: themeVariables.loginErrorMsgBorderColor, \n            padding: 12,\n            fontFamily: themeVariables.baseFont\n        },\n        formStyles: {\n            padding: 35\n        }\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n\n    const paddingStyle = {\n        padding: 5\n    };\n    addStyle('app-login-username', DEFAULT_CLASS, {\n        root: paddingStyle\n    });\n\n    addStyle('app-login-password', DEFAULT_CLASS, {\n        root: paddingStyle\n    });\n});", "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.component.tsx": "import React from 'react';\nimport { Text, TouchableOpacity, View } from 'react-native';\nimport NetworkService, { NetworkState } from '@wavemaker/app-rn-runtime/core/network.service';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { ToastConsumer, ToastOptions, ToastService } from '@wavemaker/app-rn-runtime/core/toast.service';\n\nimport WmNetworkInfoToasterProps from './network-info-toaster.props';\nimport { DEFAULT_CLASS, WmNetworkInfoToasterStyles } from './network-info-toaster.styles';\nimport { isEqual } from 'lodash-es';\n\nexport class WmNetworkInfoToasterState extends BaseComponentState<WmNetworkInfoToasterProps> {\n  newtworkState = {} as NetworkState;\n  showToast = false;\n}\n\nexport default class WmNetworkInfoToaster extends BaseComponent<WmNetworkInfoToasterProps, WmNetworkInfoToasterState, WmNetworkInfoToasterStyles> {\n  options = {} as ToastOptions;\n  private _close: Function = null as any;\n\n  constructor(props: WmNetworkInfoToasterProps) {\n    super(props, DEFAULT_CLASS, new WmNetworkInfoToasterProps(), new WmNetworkInfoToasterState());\n    this.updateState({\n      newtworkState: NetworkService.getState(),\n      showToast: !NetworkService.isConnected()\n    } as WmNetworkInfoToasterState);\n    this.cleanup.push(\n      NetworkService.notifier.subscribe('onNetworkStateChange', (networkState: NetworkState) => {\n        if (!isEqual(networkState, this.state.newtworkState)) {\n          this.updateState({\n            newtworkState: networkState,\n            showToast: true\n          } as WmNetworkInfoToasterState);\n        }\n      }\n    ));\n  }\n\n  getToastContent() {\n    if (this.state.newtworkState.isConnected) { \n      return (\n      <View style={this.styles.root}>\n        {this._background}\n        <Text {...this.getTestPropsForLabel('msg')} style={this.styles.text}>{this.props.appLocale.messages.MESSAGE_SERVICE_CONNECTED}</Text>\n        <TouchableOpacity {...this.getTestPropsForAction('close')} style={this.styles.action} onPress={() => this._close()}>\n          <Text style={this.styles.actionText}>{this.props.appLocale.messages.LABEL_HIDE_NETWORK_INFO}</Text>\n        </TouchableOpacity>\n      </View>);\n    }\n    if (this.state.newtworkState.isConnecting) { \n      return (\n        <View style={this.styles.root}>\n          {this._background}\n          <Text {...this.getTestPropsForLabel('msg')} style={this.styles.text}>{this.props.appLocale.messages.MESSAGE_SERVICE_CONNECTING}</Text>\n        </View>);\n    }\n    if (this.state.newtworkState.isServiceAvailable) { \n      return (\n      <View style={this.styles.root}>\n        {this._background}\n        <Text {...this.getTestPropsForLabel('msg')} style={this.styles.text}>{this.props.appLocale.messages.MESSAGE_SERVICE_AVAILABLE}</Text>\n        <TouchableOpacity {...this.getTestPropsForAction('close')} style={this.styles.action} onPress={() => this._close()}>\n          <Text style={this.styles.actionText}>{this.props.appLocale.messages.LABEL_HIDE_NETWORK_INFO}</Text>\n        </TouchableOpacity>\n          <Text style={this.styles.actionSeparator}>|</Text>\n        <TouchableOpacity {...this.getTestPropsForAction('connect')} style={this.styles.action}>\n          <Text style={this.styles.actionText}>{this.props.appLocale.messages.LABEL_CONNECT_TO_SERVICE}</Text>\n        </TouchableOpacity>\n      </View>);\n    }\n    if (!this.state.newtworkState.isNetworkAvailable) { \n      return (\n      <View style={this.styles.root}>\n        {this._background}\n        <Text {...this.getTestPropsForLabel('msg')} style={this.styles.text}>{this.props.appLocale.messages.MESSAGE_NETWORK_NOT_AVAILABLE}</Text>\n        <TouchableOpacity {...this.getTestPropsForAction('close')} style={this.styles.action} onPress={() => this._close()}>\n          <Text style={this.styles.actionText}>{this.props.appLocale.messages.LABEL_HIDE_NETWORK_INFO}</Text>\n        </TouchableOpacity>\n      </View>);\n    }\n    return (\n      <View style={this.styles.root}>\n        {this._background}\n        <Text {...this.getTestPropsForLabel('msg')} style={this.styles.text}>{this.props.appLocale.messages.MESSAGE_SERVICE_NOT_AVAILABLE}</Text>\n        <TouchableOpacity  {...this.getTestPropsForAction('close')} style={this.styles.action} onPress={() => this._close()}>\n          <Text style={this.styles.actionText}>{this.props.appLocale.messages.LABEL_HIDE_NETWORK_INFO}</Text>\n        </TouchableOpacity>\n      </View>);\n  }\n\n  renderWidget(props: WmNetworkInfoToasterProps) {\n    this.options.content = this.getToastContent();\n    this.options.onClose = () => {\n      this._close = null as any;\n      this.updateState({\n        showToast : false\n      } as WmNetworkInfoToasterState);\n    };\n    return this.options.content && this.state.showToast ? (\n      <ToastConsumer>\n        {(toastService: ToastService) => {\n          this._close = () => toastService.hideToast(this.options);\n          toastService.showToast(this.options)\n          return null;\n        }}\n      </ToastConsumer>\n    ) : null; \n  }\n}\n", "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmNetworkInfoToasterProps extends BaseProps {\n    appLocale = {} as any;\n}", "wavemaker-rn-runtime/src/components/advanced/network-info-toaster/network-info-toaster.styles.ts": "import { TextStyle, ViewStyle } from 'react-native';\nimport BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type WmNetworkInfoToasterStyles = BaseStyles & {\n    action: ViewStyle,\n    actionSeparator: TextStyle\n    actionText: TextStyle\n};\n\nexport const DEFAULT_CLASS = 'app-network-info-toaster';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles = defineStyles<WmNetworkInfoToasterStyles>({\n        root: {\n            width: '100%',\n            paddingVertical: 16,\n            paddingHorizontal: 16,\n            backgroundColor: themeVariables.networkToastBgColor,\n            flexDirection: 'row',\n            alignItems: 'center'\n        },\n        text: {\n            color: themeVariables.networkToastTextColor,\n            fontSize: 16,\n            flex: 1\n        },\n        action: {\n            padding: 4\n        },\n        actionSeparator : {\n            color: themeVariables.networkToastActionSeparatorColor,\n            fontSize: 16,\n            marginHorizontal: 2\n        },\n        actionText: {\n            color: themeVariables.networkToastActionTextColor\n        }\n    });\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/page/page.styles.ts": "import BASE_THEME, { NamedStyles } from '@wavemaker/app-rn-runtime/styles/theme';\n\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmSkeletonStyles } from '../basic/skeleton/skeleton.styles';\nimport { Dimensions } from 'react-native';\n\nexport type WmPageStyles = BaseStyles & {\n    skeleton: WmSkeletonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-page';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmPageStyles = defineStyles({\n        root: {\n            flexDirection: 'column',\n            top: 0,\n            left: 0,\n            right: 0,\n            bottom: 0,\n            position: 'absolute'\n        },\n        text: {},\n        skeleton: {\n            root: {\n                height: Dimensions.get('window').height\n            }\n        } as WmSkeletonStyles\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/page/page.component.tsx": "import React from 'react';\nimport { PanResponder, ScrollView, View, NativeSyntheticEvent,  NativeScrollEvent} from 'react-native';\n\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmPageProps from './page.props';\nimport { DEFAULT_CLASS, WmPageStyles } from './page.styles';\nimport { SafeAreaInsetsContext } from 'react-native-safe-area-context';\nimport { StickyViewContainer } from '@wavemaker/app-rn-runtime/core/sticky-container.component';\nimport { FixedViewContainer } from '@wavemaker/app-rn-runtime/core/fixed-view.component';\nimport injector from '@wavemaker/app-rn-runtime/core/injector';\nimport AppConfig from '@wavemaker/app-rn-runtime/core/AppConfig';\n\nexport class WmPageState extends BaseComponentState<WmPageProps> {}\n\ninterface CustomScrollEvent {\n  scrollDirection: number;\n  scrollDelta: number;\n}\n\n\nexport default class WmPage extends BaseComponent<WmPageProps, WmPageState, WmPageStyles> {\n  private scrollRef: React.RefObject<any>;\n  private previousScrollPosition: number = 0;\n  private appConfig = injector.get<AppConfig>('APP_CONFIG');\n\n  panResponder = PanResponder.create({\n    onStartShouldSetPanResponderCapture: (e) => {\n      this.notify('globaltouch', [e]);\n      return false;\n    },\n  });\n  constructor(props: WmPageProps) {\n    super(props, DEFAULT_CLASS, );\n    this.scrollRef = React.createRef();\n  }\n\n  private onScroll = (event: NativeSyntheticEvent<NativeScrollEvent>)=>{\n    const scrollPosition = event.nativeEvent.contentOffset.y;\n    const scrollDelta = Math.abs(scrollPosition - this.previousScrollPosition)  \n    if(scrollPosition >=0){\n      const e = event as unknown as CustomScrollEvent;\n      if (scrollPosition > this.previousScrollPosition) {\n        e.scrollDirection = 1;\n      } else if (scrollPosition === this.previousScrollPosition) {\n        e.scrollDirection = 0;\n      } else {\n        e.scrollDirection = -1;\n      }\n      e.scrollDelta = scrollDelta;\n      this.previousScrollPosition = scrollPosition;\n      this.notify('scroll', [e]);\n    }\n  }\n\n  public scrollTo(position: {x: number, y: number}){\n    this.scrollRef?.current?.scrollTo({\n      x: position.x,\n      y: position.y,\n      Animated: true\n    });\n  }\n\n  renderWidget(props: WmPageProps) {\n\n    const statusBarCustomisation = this.appConfig?.preferences?.statusbarStyles;\n    const isFullScreenMode = !!statusBarCustomisation?.translucent;\n\n    return (\n      <StickyViewContainer>\n        <FixedViewContainer>\n        <SafeAreaInsetsContext.Consumer>\n          {(insets = { top: 0, bottom: 0, left: 0, right: 0 }) => {\n            return props.scrollable ? \n            <ScrollView\n              ref={this.scrollRef}\n              {...this.panResponder.panHandlers}\n              style={[{ width:'100%', height:'100%', paddingTop : !props?.hasappnavbar && isFullScreenMode ? insets?.top : 0 }, this.styles.root]}\n              onScroll={this.onScroll}\n              scrollEventThrottle={16}\n            >\n              {this._background}\n              {props.children}\n            </ScrollView> : \n            <View style={[{paddingTop : !props?.hasappnavbar && isFullScreenMode ? insets?.top : 0 },this.styles.root]}> \n              {this._background}\n              {props.children}\n            </View>\n          }}\n        </SafeAreaInsetsContext.Consumer>\n        </FixedViewContainer>\n     </StickyViewContainer>\n    ); \n  }\n}\n", "wavemaker-rn-runtime/src/components/page/page.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\nexport default class WmPageProps extends BaseProps{\n  children: any[] = [];\n  scrollable: boolean = false;\n  hasappnavbar:boolean = true;\n}", "wavemaker-rn-runtime/src/components/page/partial/partial.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmPartialProps from './partial.props';\nimport { DEFAULT_CLASS, WmPartialStyles } from './partial.styles';\nimport WmLottie from '@wavemaker/app-rn-runtime/components/basic/lottie/lottie.component';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport class WmPartialState extends BaseComponentState<WmPartialProps> {\n\n}\n\nexport default class WmPartial extends BaseComponent<WmPartialProps, WmPartialState, WmPartialStyles> {\n\n  constructor(props: WmPartialProps) {\n    super(props, DEFAULT_CLASS, );\n  }\n\n  public renderSkeleton(props: WmPartialProps): React.ReactNode {\n    const lottieContentStyles = this.styles?.skeleton as any as WmSkeletonStyles\n    if(this.props.skeletonanimationresource) {\n      return <View style={[{width: '100%'}, this.styles.root]}>\n        <WmLottie styles={{ content: lottieContentStyles.root}} source={this.props.skeletonanimationresource} loop={true} autoplay={true} speed={this.props.skeletonanimationspeed}/>\n      </View>\n    }\n    return null;\n  }\n\n  renderWidget(props: WmPartialProps) {\n    const styles = this._showSkeleton ? {\n      ...this.styles.root,\n      ...this.styles.skeleton?.root\n    } : this.styles.root\n    \n    return (\n      <View style={styles}>\n        {this._background}\n        {props.children}\n      </View>\n    ); \n  }\n}\n", "wavemaker-rn-runtime/src/components/page/partial/partial.styles.ts": "import BASE_THEME, { NamedStyles } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmPartialStyles = BaseStyles & {\n    skeleton: WmSkeletonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-partial';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmPartialStyles = defineStyles({\n        root: {\n            width: \"100%\"\n        },\n        text: {},\n        skeleton: {\n            root: {\n                height: 200\n            }\n        } as WmSkeletonStyles\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/page/partial/partial.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { SkeletonAnimationProps } from '@wavemaker/app-rn-runtime/runtime/base-fragment.component';\n\nexport default interface WmPartialProps extends SkeletonAnimationProps {\n    children: any[];\n}", "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.styles.ts": "import BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmIconStyles } from '../../basic/icon/icon.styles';\n\nexport type WmTabbarStyles = BaseStyles & {\n    menu: AllStyle,\n    modalContent: AllStyle,\n    moreMenu: AllStyle,\n    moreMenuRow: AllStyle,\n    tabItem: AllStyle,\n    activeTabItem: AllStyle,\n    tabIcon: WmIconStyles,\n    activeTabIcon: WmIconStyles,\n    tabLabel: AllStyle,\n    activeTabLabel: AllStyle,\n    centerHubItem: AllStyle,\n    centerHubIcon: WmIconStyles,\n    centerHubLabel: AllStyle\n};\n\nexport const DEFAULT_CLASS = 'app-tabbar';\n    BASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmTabbarStyles = defineStyles<WmTabbarStyles>({\n        root: {\n            height: 80,\n            elevation: 3,\n            shadowColor : themeVariables.tabShadowColor\n        },\n        text: {},\n        menu: {\n            height: '100%',\n            flexDirection: 'row',\n            backgroundColor: themeVariables.tabbarBackgroundColor,\n            justifyContent: 'space-around',\n            alignItems: 'flex-end',\n        },\n        modalContent: {},\n        moreMenu: {\n            width: '100%',\n            flexDirection: 'column-reverse',\n            justifyContent: 'flex-end',\n            backgroundColor: themeVariables.tabbarBackgroundColor,\n            ...BASE_THEME.getStyle('elevate1').root,\n            shadowOffset: {\n                width: 0,\n                height: -6\n            },\n            shadowOpacity: 0.3,\n            shadowRadius: 6\n        },\n        moreMenuRow: {\n            flexDirection: 'row-reverse',\n            justifyContent: 'space-around',\n            width: '100%',\n            paddingTop: 4,\n            paddingBottom: 4\n        },\n        tabItem: {\n            flexDirection: 'column',\n            justifyContent: 'center',\n            alignItems: 'center',\n            minHeight: 32,\n            minWidth: 64,\n            opacity: 1,\n            marginBottom: 16\n        },\n        activeTabItem: {\n            opacity: 1,\n            height: 32,\n            width: 64,\n            borderRadius: 50,\n            marginBottom: -2,\n            backgroundColor: themeVariables.tabActiveBackgroundColor\n        },\n        tabIcon: {\n            root: {\n                alignSelf: 'center',\n                borderBottomColor: themeVariables.transparent,\n                paddingBottom: 4\n            },\n            icon: {\n                fontSize: 24,\n                paddingRight: 0,\n                color:  themeVariables.tabbarIconColor\n            }\n        } as WmIconStyles,\n        activeTabIcon: {\n            root: {\n            },\n            icon:{\n                color: themeVariables.tabActiveIconColor,\n            }\n        } as WmIconStyles,\n        tabLabel: {\n            fontSize: 12,\n            marginTop: 4,\n            fontWeight: '500',\n            fontFamily: themeVariables.baseFont,\n            color:  themeVariables.tabbarTextColor,\n            textAlign: 'center',\n        },\n        activeTabLabel: {\n            fontWeight: '700',\n            fontSize: 12,\n            fontFamily: themeVariables.baseFont,\n            color:  themeVariables.tabLabelTextColor,\n        },\n        centerHubItem: {},\n        centerHubIcon: {} as WmIconStyles, \n        centerHubLabel:{}\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n    addStyle('tabbar-spacer', '', {\n        root: {\n            height: 96\n        }\n    });\n    addStyle(DEFAULT_CLASS+ '-1', '', {\n        root: {\n            height: undefined\n        },\n        tabItem: {\n            justifyContent: 'space-between' \n        },\n        activeTabItem: {\n            borderTopWidth: 4,\n            borderTopColor: themeVariables.tabbarIconColor\n        },\n        tabIcon: {\n            root: {\n                paddingTop: 8,\n                paddingBottom: 8,\n                borderBottomWidth: 0\n            }\n        },\n        tabLabel: {\n            marginTop: 0\n        }\n    } as WmTabbarStyles);\n    addStyle('clipped-tabbar', '', {\n        root:{\n            backgroundColor: themeVariables.transparent,\n            marginTop: -88\n        },\n        menu: {\n            backgroundColor: themeVariables.transparent\n        },\n        centerHubItem: {\n            width: 70,\n            height: 70,\n            shadowColor: 'grey',\n            shadowOpacity: 0.1,\n            opacity: 1,\n            shadowOffset: { width: 2, height: 0 },\n            shadowRadius: 2,\n            borderRadius: 35,\n            position: 'absolute',\n            bottom: 28,\n            alignItems: 'center',\n            justifyContent: 'center',\n            backgroundColor: themeVariables.centerHubItemColor,\n            left: (themeVariables.maxWidth/2) - 35\n        },\n        centerHubIcon: {\n            root: {\n                alignSelf: 'center',\n                paddingBottom: 0,\n                borderBottomColor: themeVariables.transparent,\n                borderBottomWidth: 0 \n            },\n            icon: {\n                fontSize: 24,\n                color:  themeVariables.centerHubIconColor\n            }\n        } as WmIconStyles, \n        centerHubLabel:{\n            color:  themeVariables.centerHubLabelColor,\n            marginTop: 0,\n            paddingBottom: 4\n        }\n    })\n});", "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.component.tsx": "import React, { ReactNode } from 'react';\nimport { Text, View, TouchableOpacity, Dimensions, Keyboard, Animated, Easing, LayoutChangeEvent, \n  NativeSyntheticEvent,  NativeScrollEvent\n} from 'react-native';\nimport { ThemeProvider } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { ModalConsumer, ModalOptions, ModalService } from '@wavemaker/app-rn-runtime/core/modal.service';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport NavigationService, { NavigationServiceConsumer } from '@wavemaker/app-rn-runtime/core/navigation.service';\nimport { BaseNavProps } from '@wavemaker/app-rn-runtime/components/navigation/basenav/basenav.props';\nimport { BaseNavComponent, BaseNavState, NavigationDataItem } from '@wavemaker/app-rn-runtime/components/navigation/basenav/basenav.component';\n\nimport WmTabbarProps from './tabbar.props';\nimport { DEFAULT_CLASS, WmTabbarStyles } from './tabbar.styles';\nimport Svg, { Path } from 'react-native-svg';\nimport { getPathDown } from './curve';\n// import { scale } from 'react-native-size-scaling';\nimport ThemeVariables from '@wavemaker/app-rn-runtime/styles/theme.variables';\nimport { FixedView } from '@wavemaker/app-rn-runtime/core/fixed-view.component';\nimport { EdgeInsets, SafeAreaInsetsContext } from 'react-native-safe-area-context';\nimport injector from '@wavemaker/app-rn-runtime/core/injector';\nimport AppConfig from '@wavemaker/app-rn-runtime/core/AppConfig';\n\ninterface TabDataItem extends NavigationDataItem {\n  floating: boolean;\n  indexBeforeMid: number;\n}\n\ninterface CustomScrollEvent {\n  scrollDirection: number;\n  scrollDelta: number;\n}\n\nconst scale = (n: number) => n;\n\nclass WmTabbarState<T extends BaseNavProps> extends BaseNavState<T> {\n  showMore = false;\n  modalOptions = {} as ModalOptions;\n  dataItems: TabDataItem[] = [];\n}\n\nexport default class WmTabbar extends BaseNavComponent<WmTabbarProps, WmTabbarState<WmTabbarProps>, WmTabbarStyles> {\n\n  private tabbarHeight = 0;\n  private keyBoardShown = false;\n  private destroyScrollListner: Function = null as any;\n  private translateY = new Animated.Value(0);\n  private insets: EdgeInsets | null = null;\n  private appConfig = injector.get<AppConfig>('APP_CONFIG');\n  private tabbarHeightWithInsets: number = 0;\n\n  constructor(props: WmTabbarProps) {\n    super(props, DEFAULT_CLASS, new WmTabbarProps(), new WmTabbarState());\n    this.cleanup.push(Keyboard.addListener('keyboardWillShow', () => {\n      this.keyBoardShown = true;\n      this.forceUpdate();\n    }).remove);\n    this.cleanup.push(Keyboard.addListener('keyboardWillHide', () => {\n      this.keyBoardShown = false;\n      this.forceUpdate();\n    }).remove);\n  }\n\n  private maxWidth = Dimensions.get(\"window\").width;  \n  private returnpathDown: any;\n\n  onPropertyChange(name: string, $new: any, $old: any): void {\n      super.onPropertyChange(name, $new, $old);\n      switch(name){\n        case 'hideonscroll':\n          this.destroyScrollListner && this.destroyScrollListner();\n          if($new) {\n            this.subscribeToPageScroll();\n          }\n          break;\n      }\n  }\n\n  renderTabItem(item: TabDataItem, testId: string, props: WmTabbarProps, onSelect: Function, floating = false) {\n\n    const isActive = props.isActive && props.isActive(item);\n    const getDisplayLabel = this.props.getDisplayExpression || ((label: string) => label);\n    let increasedGap = Number(testId) === item?.indexBeforeMid && (this.state.dataItems.length % 2!=0)  && ((props.classname || '').indexOf('clipped-tabbar') >= 0)\n    ? [this.styles.tabItem, { paddingRight: 70 }]\n    : [this.styles.tabItem];\n  \n    return (\n      <TouchableOpacity \n        {...this.getTestPropsForAction('item' + testId)}\n        style={[increasedGap, floating? this.styles.centerHubItem: {}]}\n        key={`${item.label}_${testId}`}\n        onPress={() => onSelect && onSelect()}>\n        <View key={item.key}>\n          <View style={[isActive && !floating  ? this.styles.activeTabItem : {}]}>\n            <WmIcon\n              styles={this.theme.mergeStyle({}, this.styles.tabIcon, floating? this.styles.centerHubIcon: {}, isActive ? this.styles.activeTabIcon : {})}\n              iconclass={item.icon}\n            ></WmIcon>\n          </View>\n        </View>\n        <Text style={[this.styles.tabLabel, floating? this.styles.centerHubLabel: {},  isActive ? this.styles.activeTabLabel : {}]} numberOfLines={1}>\n          {getDisplayLabel(item.label)}\n        </Text>\n      </TouchableOpacity>\n    );\n  }\n  \n  onItemSelect(item: NavigationDataItem, navigationService: NavigationService) {\n    item.link && navigationService.openUrl(item.link);\n    this.invokeEventCallback('onSelect', [null, this.proxy, item]);\n  }\n\n  prepareModalOptions(content: ReactNode) {\n    const o = this.state.modalOptions;\n    o.content = content;\n    o.modalStyle = {\n      bottom: this.tabbarHeight\n    };\n    o.contentStyle = this.styles.modalContent; \n    return o;\n  }\n\n  isVisible(): boolean {\n    return super.isVisible() && !this.keyBoardShown;\n  }\n\n  animateWithTiming(value: number, duratiion: number): void {\n    Animated.timing(this.translateY, {\n      toValue: value, \n      easing: Easing.linear,\n      duration: duratiion, \n      useNativeDriver: false\n    }).start()\n  }\n\n  subscribeToPageScroll(){\n    this.tabbarHeightWithInsets = 0;\n    this.destroyScrollListner = this.subscribe('scroll', (event: NativeSyntheticEvent<NativeScrollEvent>)=>{\n      const { contentOffset, layoutMeasurement, contentSize } = event.nativeEvent ;\n      const scrollPosition = contentOffset.y ;\n      this.tabbarHeightWithInsets = this.tabbarHeightWithInsets ? this.tabbarHeightWithInsets : this.getLayout()?.height ;\n      const visibleContentHeight = layoutMeasurement.height ;\n      const endReached = (scrollPosition + visibleContentHeight + this.tabbarHeightWithInsets) >= contentSize.height ;\n      const bottomInsets = this.insets?.bottom || 0\n      const e = event as unknown as CustomScrollEvent;\n      if(e.scrollDelta >= 2){\n        if(e.scrollDirection < 0){\n          this.animateWithTiming(0, 100)\n        }else if(e.scrollDirection > 0) {\n          this.animateWithTiming(this.tabbarHeightWithInsets + bottomInsets, 100)\n        }\n      }\n        if(endReached){\n          this.animateWithTiming(0, 0)\n        }\n    })\n  }\n\n  componentWillUnmount(): void {\n      this.destroyScrollListner && this.destroyScrollListner();\n  }\n\n  renderContent(props: WmTabbarProps){\n    let max = 5;\n    const tabItems = this.state.dataItems;\n    const tabItemsLength = tabItems.length;\n    const isClippedTabbar = ((props.classname || '').indexOf('clipped-tabbar') >= 0) && (tabItemsLength % 2 !== 0);\n    if (isClippedTabbar && tabItemsLength % 2 !== 0) {\n      const middleIndex = Math.floor(tabItemsLength / 2);\n      tabItems[middleIndex]['floating'] = true;\n      tabItems[middleIndex - 1]['indexBeforeMid'] = middleIndex-1;\n    }\n   this.returnpathDown = getPathDown(this.maxWidth, 65 ,60,this.styles.root.height as number);\n    const moreItems = [] as any[][];\n    if (tabItems.length > max) {\n      const moreItemsCount = Math.ceil((tabItems.length + 1 - max)/ max) * max;\n      let j = 0;\n      for (let i = max-1; i < moreItemsCount;) {\n        const row = [];\n        for (let j = 0; j < max; j++) {\n          row[j] = tabItems[i++] || {key: 'tabItem' + i} as TabDataItem;\n        }\n        moreItems.push(row);\n      }\n      max = max - 1;\n    }\n    return (\n      <SafeAreaInsetsContext.Consumer>\n      {(insets = { top: 0, bottom: 0, left: 0, right: 0 }) => {\n      this.insets = insets;\n      const paddingBottomVal = this.styles.root.paddingBottom || this.styles.root.padding;\n      const statusBarCustomisation = this.appConfig?.preferences?.statusbarStyles;\n      const isFullScreenMode = !!statusBarCustomisation?.translucent;\n      const stylesWithFs = isFullScreenMode ?  {height: this.styles.root.height as number + (insets?.bottom || 0) as number, \n        paddingBottom: (paddingBottomVal || 0) as number + (insets?.bottom || 0) as number} : {}\n      return (\n      <NavigationServiceConsumer>\n      {(navigationService) =>(\n        <View style={[this.styles.root, stylesWithFs]} \n          ref={(ref)=> {this.baseView = ref as any}}\n          onLayout={(event: LayoutChangeEvent) => this.handleLayout(event)}  \n        >\n      {isClippedTabbar ? (\n        <Svg width={this.maxWidth} height={scale(this.styles.root.height as number)} style={{zIndex: -1,position: 'absolute',backgroundColor: ThemeVariables.INSTANCE.transparent}}>\n        <Path fill={ThemeVariables.INSTANCE.tabbarBackgroundColor} {...{ d: this.returnpathDown }}/>\n        </Svg>\n           ): <></>}   \n          <ModalConsumer>\n            {(modalService: ModalService) => {\n              if (this.state.showMore) {\n                modalService.showModal(this.prepareModalOptions((\n                <ThemeProvider value={this.theme} >\n                  <View style={this.styles.moreMenu}>\n                    {moreItems.map((a, i) =>\n                      (<View key={i} style={this.styles.moreMenuRow}>\n                        {a.map((item, index) => this.renderTabItem(item, i + '', props,  () => this.onItemSelect(item, navigationService)))}\n                      </View>)\n                    )}\n                  </View>\n                </ThemeProvider>)));\n              } else {\n                modalService.hideModal(this.state.modalOptions);\n              }\n              return null;\n            }}\n          </ModalConsumer>\n          <View style={this.styles.menu}\n            onLayout={e => { this.tabbarHeight = e.nativeEvent.layout.height}}> \n            {tabItems.filter((item, i) => i < max)\n              .map((item, i) => this.renderTabItem(item, i + '', props, () => this.onItemSelect(item, navigationService), item.floating))}\n            {tabItems.length > max && (\n              this.renderTabItem({\n                label: props.morebuttonlabel,\n                icon: props.morebuttoniconclass\n              } as TabDataItem, 6666 +'', props,  () => {\n                this.updateState({showMore: !this.state.showMore} as WmTabbarState<WmTabbarProps>);\n              })\n            )}\n          </View>\n        </View>)}\n      </NavigationServiceConsumer>\n      )}}\n    </SafeAreaInsetsContext.Consumer>\n    )\n  }\n\n  renderWidget(props: WmTabbarProps) {\n    this.isFixed = true;\n    const animateStyle = props.hideonscroll ? {transform: [{translateY: this.translateY}]} : {};\n    return <>\n        <FixedView \n          style={{...{bottom: 0, width:'100%'}, ...animateStyle}} \n          theme={this.theme}\n          animated={props.hideonscroll || false}>\n          {this.renderContent(props)}\n        </FixedView>\n        <View style={{ opacity: 0}}>\n          {this.renderContent(props)}\n        </View>\n    </>\n  }\n}\n", "wavemaker-rn-runtime/src/components/page/tabbar/tabbar.props.ts": "import { BaseNavProps } from '../../navigation/basenav/basenav.props';\nimport WmTabbar from './tabbar.component';\n\nexport default class WmTabbarProps extends BaseNavProps {\n  morebuttoniconclass? = 'wi wi-more-horiz';\n  morebuttonlabel? = 'more';\n  itemchildren?: string = 'children';\n  isActive? = (item: any) => false;\n  onSelect? : (event: any, widget: WmTabbar) => any;\n  dataset?: any = [{\n      'label' : 'Home',\n      'icon'  : 'wm-sl-r sl-home'\n    },{\n      'label' : 'Analytics',\n      'icon'  : 'wm-sl-r sl-graph-ascend'\n    },{\n      'label' : 'Alerts',\n      'icon'  : 'wm-sl-r sl-alarm-bell'\n    },{\n      'label' : 'Settings',\n      'icon'  : 'wm-sl-r sl-settings'\n  }];\n  hideonscroll: boolean = false;\n}\n", "wavemaker-rn-runtime/src/components/page/tabbar/curve.tsx": "import * as d3Shape from \"d3-shape\";\n// import { scale } from \"react-native-size-scaling\";\nconst scale = (n: number) => n;\n\ninterface LineDatum {\n  x: number;\n  y: number;\n  missing?: boolean;\n}\n\n//** Path Line */\nconst line = (width : number, height: number) => {\n  const path: any = d3Shape\n  .line<LineDatum>()\n  .x((d) => d.x)\n  .y((d) => d.y)([\n    { x: width / 2, y: 0 },\n    { x: width, y: 0 },\n    { x: width, y: height },\n    { x: 0, y: height},\n    { x: 0, y: 0 },\n    { x: width / 2, y: 0 },\n  ]);\n  \nreturn path;\n};\n\n//** Path Curved*/\nconst lineCurvedDown = (iPosition: number, height: number, circle: number) => {\n  const position = iPosition;\n  const circleWidth = circle + position;\n  const trim = (position + circleWidth) / 2;\n  \n  const curved: any = d3Shape\n    .line<LineDatum>()\n    .x((d) => d.x)\n    .y((d) => d.y)\n    .curve(d3Shape.curveBasis)([\n      { x: position - scale(20), y: 0 }, // border center left\n      { x: position - scale(10), y: scale(2) },\n      { x: position - scale(2), y: scale(10) },\n      { x: position, y: scale(17) },\n  \n      { x: trim - scale(25), y: height / 2 + scale(2) },\n      { x: trim - scale(10), y: height / 2 + scale(10) },\n      { x: trim, y: height / 2 + scale(10) },\n      { x: trim + scale(10), y: height / 2 + scale(10) },\n      { x: trim + scale(25), y: height / 2 + scale(2) },\n  \n      { x: circleWidth, y: scale(17) }, // border center right\n      { x: circleWidth + scale(2), y: scale(10) },\n      { x: circleWidth + scale(10), y: 0 },\n      { x: circleWidth + scale(20), y: 0 },\n    ]);\n  return curved;\n};\n\nexport const getPathDown = (width: number, iHeight: number, centerWidth: number, clippedTabbarHeight: number) => {\n  const height = scale(iHeight);\n  const circleWidth = scale(centerWidth) + scale(16);\n  return `${line(width, clippedTabbarHeight)} ${lineCurvedDown(\n    width / 2 - circleWidth / 2,\n    height,\n    circleWidth\n  )}`;\n};\n", "wavemaker-rn-runtime/src/components/page/content/content.component.tsx": "import React from 'react';\nimport { KeyboardAvoidingView, Platform, View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { SafeAreaInsetsContext } from 'react-native-safe-area-context';\n\nimport WmContentProps from './content.props';\nimport { DEFAULT_CLASS, WmContentStyles } from './content.styles';\n\nexport class WmContentState extends BaseComponentState<WmContentProps> {\n\n}\n\nexport default class WmContent extends BaseComponent<WmContentProps, WmContentState, WmContentStyles> {\n\n  constructor(props: WmContentProps) {\n    super(props, DEFAULT_CLASS, );\n  }\n  \n  renderWidget(props: WmContentProps) {\n    return (\n      <View style={this.styles.root}>\n        {this._background}\n        {props.children}\n      </View>\n    ); \n  }\n}\n", "wavemaker-rn-runtime/src/components/page/content/content.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type WmContentStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-content';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmContentStyles = defineStyles({\n        root: {\n            flex:1\n        },\n        text: {}\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/page/content/content.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default interface WmContentProps extends BaseProps {\n  children: any[]\n}", "wavemaker-rn-runtime/src/components/page/left-panel/left-panel.component.tsx": "import React from 'react';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmLeftPanelProps from './left-panel.props';\nimport { DEFAULT_CLASS, WmLeftPanelStyles } from './left-panel.styles';\nimport { ScrollView } from 'react-native-gesture-handler';\nimport { FixedViewContainer } from '@wavemaker/app-rn-runtime/core/fixed-view.component';\nimport { SafeAreaInsetsContext } from 'react-native-safe-area-context';\nimport injector from '@wavemaker/app-rn-runtime/core/injector';\nimport AppConfig from '@wavemaker/app-rn-runtime/core/AppConfig';\n\nexport class WmLeftPanelState extends BaseComponentState<WmLeftPanelProps> {\n  isPartialLoaded = false;\n}\n\nexport default class WmLeftPanel extends BaseComponent<WmLeftPanelProps, WmLeftPanelState, WmLeftPanelStyles> {\n  private appConfig = injector.get<AppConfig>('APP_CONFIG');\n  \n  constructor(props: WmLeftPanelProps) {\n    super(props, DEFAULT_CLASS, new WmLeftPanelProps());\n  }\n\n  onPartialLoad() {\n    this.invokeEventCallback('onLoad', [null, this]);\n  }\n\n  renderContent(props: WmLeftPanelProps) {\n    if (props.renderPartial) {\n      if (!this.state.isPartialLoaded) {\n        setTimeout(() => {\n          this.updateState({\n            isPartialLoaded: true\n          } as WmLeftPanelState);\n        });\n      }\n      return props.renderPartial(props, this.onPartialLoad.bind(this));\n    }\n    return props.children;\n  }\n\n  renderWidget(props: WmLeftPanelProps) {\n    return (\n      <SafeAreaInsetsContext.Consumer>{(insets = { top: 0, bottom: 0, left: 0, right: 0 })=>{\n        const paddingTopVal = this.styles.root.paddingTop || this.styles.root.padding;\n        const statusBarCustomisation = this.appConfig?.preferences?.statusbarStyles;\n        const isFullScreenMode = !!statusBarCustomisation?.translucent;\n        const stylesWithFs = isFullScreenMode ? {paddingTop: (paddingTopVal || 0) as number + (insets?.top || 0) as number} : {}\n       return (\n        <FixedViewContainer>\n          <ScrollView \n            onScroll={(event) => {this.notify('scroll', [event])}}\n            scrollEventThrottle={48}\n            contentContainerStyle={[this.styles.root, {width: \"100%\", maxWidth: \"100%\"},stylesWithFs]}>\n            {this._background}\n            {this.renderContent(props)}\n          </ScrollView>\n        </FixedViewContainer>)\n      }}\n      </SafeAreaInsetsContext.Consumer>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/page/left-panel/left-panel.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type WmLeftPanelStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-left-panel';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmLeftPanelStyles = defineStyles({\n        root: {\n            minHeight: '100%',\n            backgroundColor: themeVariables.navbarBackgroundColor,\n            elevation: 1,\n            borderTopRightRadius: 16,\n            borderBottomRightRadius: 16,\n            maxWidth: 360\n        },\n        text: {}\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/page/left-panel/left-panel.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmLeftPanelProps extends BaseProps {\n  children?: any;\n  renderPartial?: Function;\n}\n", "wavemaker-rn-runtime/src/components/page/page-content/page-content.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\nimport { Dimensions } from 'react-native';\n\nexport type WmPageContentStyles = BaseStyles & {\n    skeleton: WmSkeletonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-page-content';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmPageContentStyles = defineStyles({\n        root: {\n            padding: 8,\n            backgroundColor: themeVariables.pageContentBgColor,\n            minHeight: '100%'\n        },\n        text: {},\n        skeleton: {\n            root: {\n                height: themeVariables.maxModalHeight\n            }\n        } as any as WmSkeletonStyles\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/page/page-content/page-content.component.tsx": "import React, { createRef, RefObject } from 'react';\nimport { KeyboardAvoidingView, Platform, View, NativeSyntheticEvent, NativeScrollEvent } from 'react-native';\nimport { isWebPreviewMode } from '@wavemaker/app-rn-runtime/core/utils';\nimport { HideMode } from '@wavemaker/app-rn-runtime/core/if.component';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmPageContentProps from './page-content.props';\nimport { DEFAULT_CLASS, WmPageContentStyles } from './page-content.styles';\nimport { ScrollView } from 'react-native-gesture-handler';\nimport WmLottie from '@wavemaker/app-rn-runtime/components/basic/lottie/lottie.component';\nimport { SafeAreaInsetsContext } from 'react-native-safe-area-context';\n\nexport class WmPageContentState extends BaseComponentState<WmPageContentProps> {}\n\nexport interface CustomScrollEvent {\n  scrollDirection: number;\n}\n\nexport default class WmPageContent extends BaseComponent<WmPageContentProps, WmPageContentState, WmPageContentStyles> {\n  private scrollRef: RefObject<any>;\n  private previousScrollPosition: number = 0;\n\n  constructor(props: WmPageContentProps) {\n    super(props, DEFAULT_CLASS, new WmPageContentProps());\n    this.hideMode = HideMode.DONOT_ADD_TO_DOM;\n    this.scrollRef = createRef();\n\n    this.subscribe('scrollToPosition', (args: any) => {\n      this.scrollTo(args);\n    });\n\n    this.subscribe('scrollToEnd', () => {\n      this.scrollRef?.current.scrollToEnd();\n    });\n  }\n\n  public scrollTo(position: {x: number, y: number}){\n    this.scrollRef?.current?.scrollTo({\n      x: position.x,\n      y: position.y,\n      Animated: true\n    });\n  }\n\n  private handleScroll = (event: NativeSyntheticEvent<NativeScrollEvent>) => {\n    const scrollPosition = event.nativeEvent.contentOffset.y;\n    if(Math.abs(scrollPosition - this.previousScrollPosition) >= 8 && scrollPosition >=0){\n      const e = event as unknown as CustomScrollEvent;\n      if (scrollPosition > this.previousScrollPosition) {\n        e.scrollDirection = 1;\n        this.invokeEventCallback('onSwipeup', [null, this.proxy]);\n      } else if (scrollPosition === this.previousScrollPosition) {\n        e.scrollDirection = 0;\n      } else {\n        e.scrollDirection = -1;\n        this.invokeEventCallback('onSwipedown', [null, this.proxy]);\n      }\n      this.previousScrollPosition = scrollPosition;\n      this.notify('scroll', [e]);\n    }\n  };\n\n  public renderSkeleton(props: WmPageContentProps): React.ReactNode {\n    if(this.props.skeletonanimationresource) {\n      return <View style={[{width: '100%'}, this.styles.root]}>\n       <WmLottie styles={{ content: {...this.styles.root, ...this.styles.skeleton.root} }} source={this.props.skeletonanimationresource} loop={true} autoplay={true} speed={this.props.skeletonanimationspeed}/>\n      </View>\n    } \n    return null;\n  }  \n\n  renderWidget(props: WmPageContentProps) {\n    const showScrollbar = (this.styles.root as any).scrollbarColor != 'transparent';\n    \n    return (props.scrollable || isWebPreviewMode()) ? (\n      <View style={{height: '100%', width: '100%', backgroundColor: this._showSkeleton && this.styles.skeleton.root.backgroundColor ? this.styles.skeleton.root.backgroundColor : this.styles.root.backgroundColor}}>\n        {this._background}\n        <SafeAreaInsetsContext.Consumer>\n          {(insets = { top: 0, bottom: 0, left: 0, right: 0 }) => {\n            const keyboardOffset = props.consumenotch ? (insets?.bottom || 0) : 0;\n            const verticalOffset = Platform.OS === 'ios' ? keyboardOffset + props.keyboardverticaloffset : keyboardOffset;\n            return (\n              <KeyboardAvoidingView\n                behavior={Platform.OS === 'ios' ? 'padding' : undefined}\n                keyboardVerticalOffset={verticalOffset}\n                style={{ flex: 1 }}>\n                <ScrollView \n                  keyboardShouldPersistTaps={props.keyboardpersisttaps}\n                  testID={this.getTestId(\"page_content_scrollview\")}\n                  ref={this.scrollRef}\n                  contentContainerStyle={[this.styles.root, {backgroundColor: 'transparent'}]}\n                  showsVerticalScrollIndicator={showScrollbar}\n                  onScroll={this.handleScroll}\n                  alwaysBounceVertical={false}\n                  alwaysBounceHorizontal={false}\n                  bounces={false}\n                  scrollEventThrottle={48}>\n                  {props.children}\n                </ScrollView>\n              </KeyboardAvoidingView>\n            )}}\n        </SafeAreaInsetsContext.Consumer>\n      </View>      \n    ) : (\n      <View style={[this.styles.root,\n          {backgroundColor: this._showSkeleton ?\n            this.styles.skeleton.root.backgroundColor : \n            this.styles.root.backgroundColor}]}>\n        <SafeAreaInsetsContext.Consumer>\n          {(insets = { top: 0, bottom: 0, left: 0, right: 0 }) => {\n            const keyboardOffset = props.consumenotch ? (insets?.bottom || 0) : 0;\n            const verticalOffset = Platform.OS === 'ios' ? keyboardOffset + props.keyboardverticaloffset : keyboardOffset;\n            return (\n              <KeyboardAvoidingView\n                behavior={Platform.OS === 'ios' ? 'padding' : undefined}\n                keyboardVerticalOffset={verticalOffset}\n                style={{ flex: 1 }}>\n                {this._background}\n                {props.children}\n              </KeyboardAvoidingView>\n            )}}\n        </SafeAreaInsetsContext.Consumer>\n      </View>\n    );\n  }\n}", "wavemaker-rn-runtime/src/components/page/page-content/page-content.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { SkeletonAnimationProps } from '@wavemaker/app-rn-runtime/runtime/base-fragment.component';\n\nexport default class WmPageContentProps extends SkeletonAnimationProps {\n    children: any[] = null as any;\n    scrollable: boolean = true;\n    onSwipeup?: Function = null as any;  \n    onSwipedown?: Function = null as any;\n    keyboardverticaloffset: number = 100;\n    keyboardpersisttaps: 'never'| 'always' | 'handled' = 'never';\n    consumenotch: boolean = true;\n}", "wavemaker-rn-runtime/src/components/page/partial-container/partial-container.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type WmPartialContainerStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-partial-container';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmPartialContainerStyles = defineStyles({\n        root: {\n            width: '100%',\n            backgroundColor: themeVariables.pageContentBgColor\n        },\n        text: {}\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/page/partial-container/partial-container.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmPartialContainerProps extends BaseProps {\n  content: string = null as any;\n  onLoad?: Function = () => {};\n}\n", "wavemaker-rn-runtime/src/components/page/partial-container/partial-container.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\n\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmPartialContainerProps from './partial-container.props';\nimport { DEFAULT_CLASS, WmPartialContainerStyles } from './partial-container.styles';\nimport { HideMode } from '@wavemaker/app-rn-runtime/core/if.component';\nimport PartialService, { PartialConsumer } from '@wavemaker/app-rn-runtime/core/partial.service';\n\nexport class WmPartialContainerState extends BaseComponentState<WmPartialContainerProps> {}\n\nexport default class WmPartialContainer extends BaseComponent<WmPartialContainerProps, WmPartialContainerState, WmPartialContainerStyles> {\n\n  constructor(props: WmPartialContainerProps) {\n    super(props, DEFAULT_CLASS, new WmPartialContainerProps());\n    this.hideMode = HideMode.DONOT_ADD_TO_DOM;\n  }\n\n  renderWidget(props: WmPartialContainerProps) {\n    const params = {} as any;\n    Object.keys(this.props).forEach((k: string) => {\n      //@ts-ignore\n      params[k] = props[k];\n    });\n    params.parent = this.parent;\n    params['name'] = params['partial_name'];\n    delete params['partial_name'];\n    return (\n      <View style={this.styles.root}>\n        {this._background}\n        <PartialConsumer>\n          {(partialService: PartialService) => {\n            const partial = partialService.get(props.content);\n            return partial ? React.createElement(partial, params) : null;\n          }}\n        </PartialConsumer>\n      </View>\n    ); \n  }\n}\n", "wavemaker-rn-runtime/src/components/input/radioset/radioset.styles.ts": "import BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\nimport { WmIconStyles } from '@wavemaker/app-rn-runtime/components/basic/icon/icon.styles';\n\nexport type WmRadiosetStyles = BaseStyles & {\n  group: AllStyle,\n  groupHeaderTitle: AllStyle;\n  item: AllStyle;\n  selectedItem: AllStyle;\n  radioLabel: AllStyle;\n  skeleton: WmSkeletonStyles;\n  uncheckedRadio: WmIconStyles;\n  checkedRadio: WmIconStyles;\n};\n\nexport const DEFAULT_CLASS = 'app-radioset';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmRadiosetStyles = defineStyles({\n      root: {\n        color: themeVariables.checkedColor\n      },\n      text: {},\n      group: {\n        flexDirection: 'row',\n        flexWrap: 'wrap'\n      },\n      groupHeaderTitle: {\n        backgroundColor: themeVariables.groupHeadingBgColor,\n        fontSize: 16,\n        paddingLeft: 8,\n        paddingRight: 8,\n        lineHeight: 40,\n        fontFamily: themeVariables.baseFont\n      } as AllStyle,\n      item: {\n        flexDirection: 'row',\n        alignContent: 'center',\n        marginRight: -20,\n        marginTop: 8\n      } as AllStyle,\n      noscrollitem:{\n        flexDirection: 'row',\n        alignContent: 'center',\n        marginTop: 8, \n        marginLeft: 16 \n      } as AllStyle,\n      selectedItem: {} as AllStyle,\n      selectedLabel: {} as AllStyle,\n      radioLabel: {\n          alignSelf: 'center',\n          fontFamily: themeVariables.baseFont,\n          fontSize: 16,\n          color: themeVariables.labelDefaultColor,\n          marginLeft: 8\n      } as AllStyle,\n      skeleton: {\n        root: {\n          width: '100%',\n          height: 16,\n          borderRadius: 4,\n        }\n      } as any as WmSkeletonStyles,\n      uncheckedRadio: {\n        root: {\n          width: 20,\n          height: 20,\n          borderRadius: 10,\n          borderStyle: \"solid\",\n          borderWidth: 2,\n          borderColor: themeVariables.checkedBorderColor,\n        },\n        text: {},\n        icon: {\n          opacity: 0,\n        }\n      } as WmIconStyles,\n      checkedRadio : {\n        root: {\n          width: 20,\n          height: 20,\n          borderRadius: 10,\n          borderStyle: \"solid\",\n          borderWidth: 2,\n          borderColor: themeVariables.checkedBorderColor,\n        },\n        text: {\n          fontSize: 16,\n        },\n        icon : {\n          color: themeVariables.checkedColor,\n          padding: 0,\n        }\n  } as WmIconStyles\n});\n\n  addStyle(DEFAULT_CLASS + '-disabled', '', {\n    root : {\n      color: themeVariables.checkedDisabledColor,\n      opacity: 0.8\n    }\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n});\n", "wavemaker-rn-runtime/src/components/input/radioset/radioset.props.ts": "import BaseDatasetProps from '@wavemaker/app-rn-runtime/components/input/basedataset/basedataset.props';\n\nexport default class WmRadiosetProps extends BaseDatasetProps {\n  dataset: any = 'Option 1, Option 2, Option 3';\n  itemsperrow =  {\n    xs: 1,\n    sm: 1,\n    md: 1,\n    lg: 1,\n };\n radiosetscroll: boolean = true;\n renderitempartial?: (item: any, index: number, partialName: string)=> React.ReactNode;\n numberofskeletonitems?: number | string\n}\n", "wavemaker-rn-runtime/src/components/input/radioset/radioset.component.tsx": "import React from 'react';\nimport { View, Text, DimensionValue, TouchableOpacity, Platform } from 'react-native';\nimport { ScrollView } from 'react-native-gesture-handler';\n\nimport WmRadiosetProps from './radioset.props';\nimport { DEFAULT_CLASS, WmRadiosetStyles } from './radioset.styles';\nimport {\n  BaseDatasetComponent,\n  BaseDatasetState\n} from '@wavemaker/app-rn-runtime/components/input/basedataset/basedataset.component';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport WmSkeleton, { createSkeleton } from '../../basic/skeleton/skeleton.component';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility';\nimport { find, forEach, isEqual } from 'lodash-es';\nimport { isEmpty } from 'lodash';\nimport WmLabel from '@wavemaker/app-rn-runtime/components/basic/label/label.component';\nimport { getNumberOfEmptyObjects } from '@wavemaker/app-rn-runtime/core/utils';\n\nexport class WmRadiosetState extends BaseDatasetState<WmRadiosetProps> {\n  template: string = '';\n}\n\nexport default class WmRadioset extends BaseDatasetComponent<WmRadiosetProps, WmRadiosetState, WmRadiosetStyles> {\n\n  constructor(props: WmRadiosetProps) {\n    super(props, DEFAULT_CLASS, new WmRadiosetProps());\n  }\n\n  onPress(item: any) {\n    if (this.state.props.disabled || this.state.props.readonly) {\n      return;\n    }\n    this.invokeEventCallback('onTap', [null, this.proxy]);\n    item.selected = true;\n    let selectedValue: any = \"\";\n    const selectedItem = find(this.state.dataItems, d => isEqual(d.key, item.key));\n    const oldValue = this.state.props.datavalue;\n    selectedItem.selected = item.selected;\n    selectedValue = selectedItem.selected ? selectedItem.datafield : null;\n    this.validate(selectedValue);\n    this.updateState({ props: { datavalue: selectedValue }} as WmRadiosetState,() => {\n      this.computeDisplayValue();\n      this.invokeEventCallback('onChange', [ undefined, this.proxy, selectedValue, oldValue ]);\n    });\n  }\n\n  renderChild(item: any, index: any, colWidth?: DimensionValue) {\n    const displayText = item.displayexp || item.displayfield;\n    const value = this.state.props.datafield === 'All Fields' ? this.getItemKey(item.datafield) : item.datafield;\n    const itemStyle = colWidth  ? [{ width: colWidth }, this.styles.item] \n    : [this.styles.noscrollitem];\n    return (\n      <TouchableOpacity style={[\n        itemStyle,\n         item.selected ? this.styles.selectedItem : null]}\n         onPress={this.onPress.bind(this, item)} key={item.key} {...this.getTestPropsForAction(\"radio\"+index)}>\n          <WmIcon id={this.getTestId('radiobutton' + index)} iconclass=\"wi wi-fiber-manual-record\" styles={item.selected ? this.styles.checkedRadio : this.styles.uncheckedRadio} disabled={this.state.props.readonly || this.state.props.disabled}></WmIcon>\n          {!isEmpty(this.state.template) && this.props.renderitempartial ?\n          this.props.renderitempartial(item.dataObject, index, this.state.template) : <Text style={[this.styles.radioLabel, item.selected ? this.styles.selectedLabel : null]} {...this.getTestPropsForLabel('caption'+index)}>{displayText}</Text>}\n      </TouchableOpacity>)\n  }\n\n  setTemplate(partialName: any) {\n    this.updateState({ template: partialName } as WmRadiosetState);\n  }\n\n  renderGroupby() {\n    const groupedData = this.state.groupedData;\n    return (\n      <View accessibilityRole='radiogroup'>\n        {groupedData && groupedData.length\n          ? groupedData.map((groupObj: any, index: any) => {\n            return(\n              <View key={groupObj.key}>\n                <Text style={this.styles.groupHeaderTitle}>{groupObj.key}</Text>\n                {this.renderRadioButtons(groupObj.data)}\n              </View>)\n          })\n          : null}\n      </View>\n    );\n  }\n\n  renderRadioButtons(items: any) {\n    const props = this.state.props;\n    const noOfColumns = props.itemsperrow.xs || 1;\n    const colWidth = Math.round(100/ noOfColumns) + '%' as DimensionValue;\n    return props.radiosetscroll ? (\n      <View style={noOfColumns === 1 ? {} : this.styles.group}>\n        {items && items.length ?\n          items.map((item: any, index: any) => this.renderChild(item, index, colWidth)): null}\n      </View>\n      ) : (\n       <View style={[this.styles.group]}>\n          {items && items.length ?\n           items.map((item: any, index: any) => this.renderChild(item, index)): null}\n       </View>\n      )\n  }\n\n  public renderSkeleton(props: WmRadiosetProps): React.ReactNode {\n    const noOfColumns = props.itemsperrow.xs || 1;\n    const colWidth = Math.round(100/ noOfColumns) + '%' as DimensionValue;\n\n    return [...getNumberOfEmptyObjects(props.numberofskeletonitems as number ?? 5)].map(_ => {\n      return <View style={[this.styles.item, {width: colWidth}]}>\n        <WmIcon styles={this.styles.checkedRadio}/>\n        <WmLabel styles={{ skeleton: this.styles.skeleton }}/>\n      </View>\n    })\n\n  }\n\n  renderWidget(props: WmRadiosetProps) {\n    const items = this.state.dataItems;\n    return props.radiosetscroll ? (\n      <ScrollView style={this.styles.root} onLayout={(event) => this.handleLayout(event)}>\n        <ScrollView horizontal={true}\n          style={this.isRTL && Platform.OS == 'android' ? { transform: [{ scaleX: -1 }] } : {}}\n          contentContainerStyle={this.isRTL && Platform.OS == 'android' ? { transform: [{ scaleX: -1 }] } : {}}\n        >\n          {props.groupby && this.renderGroupby()}\n          {!props.groupby && this.renderRadioButtons(items)}\n        </ScrollView>\n      </ScrollView>\n    ) : (\n      <View style={[this.styles.root]} onLayout={(event) => this.handleLayout(event)}>\n        {props.groupby && this.renderGroupby()}\n        {!props.groupby && this.renderRadioButtons(items)}\n      </View>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\nimport {AccessibilityRole} from 'react-native';\n\nexport default class WmFileuploadProps extends BaseProps {\n  iconclass: string = 'wm-sl-l sl-cloud-upload';\n  iconsize: number = 16;\n  caption: string = 'Upload';\n  selectedFiles?: any;\n  contenttype?: string;\n  accessibilitylabel?: string = undefined;\n  hint?: string = undefined;\n}\n", "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmButtonStyles } from '@wavemaker/app-rn-runtime/components/basic/button/button.styles';\n\nexport type WmFileuploadStyles = BaseStyles & {\n  button: WmButtonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-fileupload';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmFileuploadStyles = defineStyles({\n    root: {\n      borderRadius: 32,\n      alignSelf: 'flex-start',\n      borderWidth: 1,\n      borderColor: themeVariables.fileuploadBorderColor,\n      borderStyle: 'solid',\n      backgroundColor: themeVariables.fileuploadBgColor\n    },\n    text: {\n\n    },\n    button: {\n      root: {},\n      text: {\n        fontSize: 16,\n        fontWeight: '500',\n        textAlign: 'center',\n        textTransform: 'capitalize',\n      }\n    } as WmButtonStyles\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n});\n", "wavemaker-rn-runtime/src/components/input/fileupload/fileupload.component.tsx": "import React from 'react';\nimport { Platform, View } from 'react-native';\nimport * as DocumentPicker from 'expo-document-picker';\n\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmFileuploadProps from './fileupload.props';\nimport { DEFAULT_CLASS, WmFileuploadStyles } from './fileupload.styles';\nimport WmButton from '@wavemaker/app-rn-runtime/components/basic/button/button.component';\nimport { getMimeType } from '@wavemaker/app-rn-runtime/core/utils';\n\nexport interface SelectFileOutput {\n  mimeType: string;\n  name: string;\n  size: number;\n  type: 'cancel' | 'success';\n  uri: string;\n}\n\nexport class WmFileuploadState extends BaseComponentState<WmFileuploadProps> {\n  selectedFiles: any;\n}\n\ntype NamedParametersType = {\n  copyToCacheDirectory: boolean,\n  multiple: boolean,\n  type: string | string[]\n};\n\nconst namedParameters: NamedParametersType = {\n  copyToCacheDirectory: false,\n  multiple: false,\n  type: '*/*'\n};\n\nexport default class WmFileupload extends BaseComponent<WmFileuploadProps, WmFileuploadState, WmFileuploadStyles> {\n\n  constructor(props: WmFileuploadProps) {\n    super(props, DEFAULT_CLASS, new WmFileuploadProps());\n  }\n\n  onTap(props: WmFileuploadProps) {\n    namedParameters.type = getMimeType(props.contenttype);\n    DocumentPicker.getDocumentAsync(namedParameters).then((response: any) => {\n      let selectedFile;\n      if (Platform.OS !== 'web') {\n        selectedFile = response.assets[0];\n        selectedFile.type = selectedFile.mimeType;\n      } else {\n        selectedFile = [response.assets[0].file];\n      }\n      this.invokeEventCallback('onBeforeselect', [null, this.proxy, selectedFile]);\n\n      this.updateState({\n          props: {\n          selectedFiles: selectedFile\n        }\n      } as WmFileuploadState, this.invokeEventCallback.bind(this, 'onSelect', [null, this.proxy, selectedFile]));\n    });\n  }\n\n  renderWidget(props: WmFileuploadProps) {\n    return <View style={this.styles.root} onLayout={(event) => this.handleLayout(event)}>\n      {this._background}\n      <WmButton accessibilitylabel={props.accessibilitylabel || props.caption} hint = {props.hint} id={this.getTestId()} iconclass={props.iconclass} caption={props.caption} styles={this.styles.button} iconsize={props.iconsize} onTap={() => this.onTap.bind(this)(props)}></WmButton>\n    </View>\n  }\n}\n", "wavemaker-rn-runtime/src/components/input/rating/rating.component.tsx": "import React from 'react';\nimport { View, Text } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\n\nimport WmRatingProps from './rating.props';\nimport { DEFAULT_CLASS, WmRatingStyles } from './rating.styles';\nimport { cloneDeep, isArray, isEmpty, isNumber, isString } from 'lodash-es';\n\nexport class WmRatingState extends BaseComponentState<WmRatingProps> {\n  items: any[] = null as any;\n  caption: any = null as any;\n  selectedIndex = -1;\n  isDefault = false;\n}\n\nexport default class WmRating extends BaseComponent<WmRatingProps, WmRatingState, WmRatingStyles> {\n\n  constructor(props: WmRatingProps) {\n    super(props, DEFAULT_CLASS, new WmRatingProps());\n  }\n\n  get caption() {\n    return this.state.caption;\n  }\n\n  prepareItems(props: WmRatingProps) {\n    let items: any[] = [];\n    if (!props.dataset && props.maxvalue) {\n      items = Array.from(Array(+props.maxvalue).keys());\n      items = items.map(v => v + 1);\n    } else if (isString(props.dataset)) {\n      items = props.dataset.split(',');\n    } else {\n      items = props.dataset as any[] || [];\n    }\n    if (isArray(items) && items[0] !== Object(items[0])) {\n      items = items.map((v, i) => ({\n        key: i + 1,\n        value: v\n      }));\n    }\n    let selectedIndex = -1;\n    if (props.datavalue !== undefined && props.datavalue !== null) {\n      selectedIndex = items.findIndex((item: any, k) => item[props.datafield as string] == props.datavalue);\n      if (selectedIndex === -1 && isNumber(props.datavalue)) {\n        selectedIndex = props.datavalue;\n      }\n    }\n    let caption: any = '';\n    if (selectedIndex > -1 && props.showcaptions) {\n      const selectedItem = items[selectedIndex];\n      if (selectedItem) {\n        if (props.getDisplayExpression) {\n          caption = props.getDisplayExpression(selectedItem);\n        } else {\n          caption = selectedItem[props.displayfield as string];\n        }\n      } else {\n        caption = selectedIndex + 1;\n      }\n    }\n    this.updateState({\n      items: items,\n      selectedIndex: selectedIndex,\n      caption: caption\n    } as WmRatingState);\n  }\n\n  onPropertyChange(name: string, $new: any, $old: any) {\n    switch(name) {\n      case 'dataset' :\n      case 'datafield' :\n      case 'displayfield' :\n      case 'maxvalue':\n      case 'datavalue' :\n        this.prepareItems(this.state.props);\n        if (name === 'datavalue') {\n          const isDefault = this.state.isDefault;\n          if (isDefault) {\n            this.updateState({ isDefault: false } as WmRatingState, this.props.onFieldChange && this.props.onFieldChange.bind(this, 'datavalue', $new, $old, isDefault));\n          } else {\n            this.props.onFieldChange && this.props.onFieldChange('datavalue', $new, $old, isDefault);\n          }\n        }\n        break;\n      case 'readonly' :\n        this.updateState({\n          props: {\n            disabled: $new\n          }\n        } as WmRatingState);\n        break;\n    }\n  }\n\n  changeValue(i: number) {\n    const props = this.state.props;\n    const oldValue = props.datavalue;\n    if (!props.readonly) {\n      let value = this.state.items[i] ? this.state.items[i][props.datafield || '']: i;\n      this.updateState({\n        props: {\n          datavalue:  value\n        }\n      } as WmRatingState, () => {\n        !this.props.onFieldChange && value !== oldValue && this.invokeEventCallback('onChange', [undefined, this.proxy, value, oldValue]);\n      });\n    }\n  }\n\n  renderWidget(props: WmRatingProps) {\n    const maxValue = props.maxvalue ? +props.maxvalue : 5;\n    const arr = Array.from(Array(maxValue).keys());\n\n    let selectedIconStyles = this.styles.selectedIcon;\n    if (props.iconcolor) {\n      selectedIconStyles = cloneDeep(this.styles.selectedIcon);\n      selectedIconStyles.text.color = props.iconcolor;\n    }\n    return (\n    <View style={this.styles.root} onLayout={(event) => this.handleLayout(event)}>\n      {this._background}\n      {arr.map((v, i) => (\n        (this.state.selectedIndex > -1 && i <= this.state.selectedIndex) ? <WmIcon\n          id={this.getTestId('star' + i)}\n          key={i}\n          iconclass=\"wi wi-star\"\n          iconsize={props.iconsize}\n          styles={selectedIconStyles}\n          onTap={() => { this.changeValue(i)}}\n        ></WmIcon> : null\n      ))}\n      {arr.map((v, i) => (\n        (this.state.selectedIndex === -1 || i > this.state.selectedIndex) ? <WmIcon\n          id={this.getTestId('star' + i)}\n          key={i}\n          iconclass=\"wi wi-star-border\"\n          iconsize={props.iconsize}\n          styles={this.styles.icon}\n          onTap={() => { this.changeValue(i)}}\n        ></WmIcon> : null\n      ))}\n      { !!props.showcaptions ? (<Text style={this.styles.text}>{this.state.caption}</Text>) : null }\n    </View>);\n  }\n}\n", "wavemaker-rn-runtime/src/components/input/rating/rating.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmRatingProps extends BaseProps {\n    dataset?: any[] = null as any;\n    datafield?: string = 'key';\n    displayfield?: string = 'value';\n    getDisplayExpression: Function = null as any;\n    datavalue?: number = null as any;\n    maxvalue: number = 5;\n    readonly? = false;\n    iconcolor?: string = null as any;\n    iconsize?: number = null as any;\n    showcaptions? = true;\n    onFieldChange: any;\n}\n", "wavemaker-rn-runtime/src/components/input/rating/rating.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmIconStyles } from '../../basic/icon/icon.styles';\n\nexport type WmRatingStyles = BaseStyles & {\n    icon: WmIconStyles,\n    selectedIcon: WmIconStyles\n};\n\nexport const DEFAULT_CLASS = 'app-rating';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmRatingStyles = defineStyles({\n        root: {\n            flexDirection: 'row',\n            alignContent: 'center',\n            padding: 8\n        },\n        icon: {\n            text: {\n                fontSize: 32,\n                color: themeVariables.ratingIconColor\n            }\n        } as WmIconStyles,\n        selectedIcon: {\n            text: {\n                fontSize: 32,\n                color: themeVariables.ratingSelectedIconColor\n            }\n        } as WmIconStyles,\n        text: {\n            alignSelf: 'center',\n            paddingLeft: 8,\n            color: themeVariables.ratingSelectedIconColor\n        }\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n    addStyle(DEFAULT_CLASS + '-disabled', '', {\n        root : {\n        opacity: 0.5\n        }\n    });\n});", "wavemaker-rn-runtime/src/components/input/calendar/calendar.component.tsx": "import React from 'react';\nimport { DimensionValue, View } from 'react-native';\nimport { isString } from 'lodash';\nimport moment, { Moment } from 'moment';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport { MonthView } from './views/month-view';\nimport WmCalendarProps from './calendar.props';\nimport { DEFAULT_CLASS, WmCalendarStyles } from './calendar.styles';\nimport WmIcon from '../../basic/icon/icon.component';\nimport { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component'\nimport { WmSkeletonStyles } from '../../basic/skeleton/skeleton.styles';\n\nexport class WmCalendarState extends BaseComponentState<WmCalendarProps> {\n  selectedDate: Moment = moment();\n  calendar: Map<String, { date: number, events: any []}> = new Map();\n}\n\nconst DEFAULT_DATE_FORMAT = 'DD-MM-YYYY';\n\nexport default class WmCalendar extends BaseComponent<WmCalendarProps, WmCalendarState, WmCalendarStyles> {\n\n  constructor(props: WmCalendarProps) {\n    super(props, DEFAULT_CLASS, new WmCalendarProps(), new WmCalendarState());\n  }\n\n  onDateChange = (date: Moment) => {\n    const d = moment(date).format(DEFAULT_DATE_FORMAT);\n    const dateWindow = this.state.calendar.get(d);\n    this.updateState({\n      props: {datavalue: d},\n      selectedDate: date\n    } as WmCalendarState);\n    this.invokeEventCallback('onSelect', [d, d, this, dateWindow?.events]);\n  }\n\n  prepareDataset(dataset: any[]) {\n    if (!dataset) {\n      return;\n    }\n    const state = {\n      calendar: new Map()\n    } as WmCalendarState;\n    const eventStartKey = this.state.props.eventstart;\n    dataset.forEach(d => {\n      let startDate = d[eventStartKey];\n      if (!isString(startDate)) {\n        startDate = moment(startDate).format(DEFAULT_DATE_FORMAT);\n      }\n      if (!state.calendar.has(startDate)) {\n        state.calendar.set(startDate, {\n          date: moment(startDate, DEFAULT_DATE_FORMAT).get('milliseconds'),\n          events: []\n        });\n      }\n      const dateWindow = state.calendar.get(startDate);\n      dateWindow?.events.push(d);\n    });\n    this.updateState(state);\n  }\n\n  onPropertyChange(name: string, $new: any, $old: any) {\n    switch(name) {\n      case 'dataset':\n        this.prepareDataset($new);\n        break;\n      case 'datavalue':\n        if ($new) {\n          this.updateState({\n            selectedDate: isString($new) ? moment($new, DEFAULT_DATE_FORMAT) : moment($new)\n          } as WmCalendarState)\n      }\n    }\n  }\n\n  renderDay = (date: Moment) => {\n    const dateWindow = this.state.calendar.get(moment(date).format(DEFAULT_DATE_FORMAT));\n    if (dateWindow) {\n      return (\n        <WmIcon\n          iconclass=\"fa fa-circle\"\n          iconsize={8}\n          styles={{\n            root: {marginTop: -8, alignSelf: 'flexStart'},\n            icon: this.styles['eventDay' + Math.min(3, dateWindow.events.length)]}}></WmIcon>\n      );\n    }\n    return (<></>);\n  }\n\n  componentDidUpdate(prevProps: WmCalendarProps, prevState: WmCalendarState, snapshot: any) {\n    super.componentDidUpdate && super.componentDidUpdate(prevProps, prevState, snapshot);\n    this.invokeEventCallback('onViewrender', [this, null]);\n  }\n\n  public renderSkeleton(props: WmCalendarProps): React.ReactNode {\n    return (\n    <View style={[this.styles.root, this.styles.skeleton.root]}>\n      <View style={this.styles.headerSkeleton.root}>\n        {createSkeleton(this.theme, {} as WmSkeletonStyles, {width: '10%', height: 28,borderRadius: 4})}\n        {createSkeleton(this.theme, {} as WmSkeletonStyles, {width: '68%', height: 16, borderRadius: 4})}\n        {createSkeleton(this.theme, {}as WmSkeletonStyles, {width: '10%', height: 28, borderRadius: 4})}\n      </View>\n      {createSkeleton(this.theme, {} as WmSkeletonStyles, {width: '96%', margin: 8, height: 320, borderRadius: 4})}\n      </View>)\n  } \n\n  renderWidget(props: WmCalendarProps) {\n    this.invokeEventCallback('onBeforerender', [null, this]);\n    return (\n      <View style={this.styles.root} onLayout={(event) => this.handleLayout(event)}>\n        {this._background}\n        <MonthView\n            date={this.state.selectedDate}\n            selectDate={this.onDateChange}\n            format={DEFAULT_DATE_FORMAT}\n            renderChildDay={this.renderDay}\n            containerStyle={this.styles.calendar}\n            dateSelectedWarpDayStyle={this.styles.selectedDay}\n            selectedDayTextStyle={this.styles.selectedDayText}\n            warpRowWeekdays={this.styles.weekDay}\n            warpRowControlMonthYear={this.styles.calendarHeader}\n            weekdayStyle={this.styles.weekDayText}\n            warpDayStyle={this.styles.dayWrapper}\n            textDayStyle={this.styles.day}\n            yearTextStyle={this.styles.yearText}\n            monthTextStyle={this.styles.monthText}\n            currentDayStyle={this.styles.today}\n            currentDayTextStyle={this.styles.todayText}\n            notDayOfCurrentMonthStyle={this.styles.notDayOfCurrentMonth}\n            renderPrevYearButton={() =>\n              (<WmIcon id={this.getTestId('prevyearicon')} iconclass=\"wi wi-angle-double-left\" styles={this.styles.prevYearBtn}/>)}\n            renderPrevMonthButton={() =>\n              (<WmIcon id={this.getTestId('prevmonthicon')} iconclass=\"wi wi-chevron-left fa-2x\" styles={this.styles.prevMonthBtn}/>)}\n            renderNextMonthButton={() =>\n                (<WmIcon id={this.getTestId('nextmonthicon')} iconclass=\"wi wi-chevron-right fa-2x\" styles={this.styles.nextMonthBtn}/>)}\n            renderNextYearButton={() =>\n                (<WmIcon  id={this.getTestId('nextyearicon')} iconclass=\"wi wi-angle-double-right\" styles={this.styles.nextYearBtn}/>)}\n          />\n      </View>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/input/calendar/calendar.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmCalendarProps extends BaseProps {\n  dataset: any[] = null as any;\n  datavalue: string | number = null as any;\n  eventstart: string = null as any;\n  view: 'day' | 'month' | 'year' = 'day';\n}", "wavemaker-rn-runtime/src/components/input/calendar/calendar.styles.ts": "import BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmIconStyles } from '@wavemaker/app-rn-runtime/components/basic/icon/icon.styles';\nimport { TextStyle } from 'react-native';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmCalendarStyles = BaseStyles & {\n    calendar: AllStyle,\n    calendarHeader: AllStyle,\n    day: AllStyle,\n    dayWrapper: AllStyle,\n    notDayOfCurrentMonth: AllStyle,\n    monthText: TextStyle,\n    yearText: TextStyle,\n    weekDay: AllStyle,\n    today: AllStyle,\n    todayText: AllStyle,\n    prevMonthBtn: WmIconStyles,\n    nextMonthBtn: WmIconStyles,\n    prevYearBtn: WmIconStyles,\n    nextYearBtn: WmIconStyles,\n    selectedDay: AllStyle,\n    selectedDayText: AllStyle\n    eventDay1: AllStyle,\n    eventDay2: AllStyle,\n    eventDay3: AllStyle,\n    skeleton: WmSkeletonStyles;\n    headerSkeleton: WmSkeletonStyles;\n};\n\nexport const DEFAULT_CLASS = 'app-calendar';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmCalendarStyles = defineStyles<WmCalendarStyles>({\n        root: {\n            width: '100%',\n            minHeight: 456,\n            minWidth: 360\n        },\n        text: {\n            color: themeVariables.calendarDateColor\n        },\n        calendar : {\n            backgroundColor: themeVariables.calendarBgColor,\n            borderColor: themeVariables.calendarHeaderBgColor,\n            borderWidth: 1,\n            borderStyle: 'solid',\n            marginTop: 0,   \n            paddingTop: 0,\n            paddingBottom: 0,\n            elevation: 6\n        },\n        calendarHeader : {\n            backgroundColor: themeVariables.calendarHeaderBgColor,\n            borderColor: themeVariables.calendarHeaderBgColor,\n            borderBottomWidth: 1,\n            borderStyle: 'solid',\n            paddingTop: 8,\n            paddingBottom: 8\n        },\n        weekDay: {\n            backgroundColor: themeVariables.calendarBgColor,\n            borderColor: themeVariables.calendarHeaderBgColor,\n            borderBottomWidth: 1,\n            borderStyle: 'solid',\n            padding: 2,\n        },\n        weekDayText: {\n            color: themeVariables.calendarWeekDayTextColor,\n            fontWeight: '400',\n            fontFamily: themeVariables.baseFont,\n            fontSize: 16,\n        },\n        day: {\n            borderColor: 'transparent',\n            color: themeVariables.calendarDateColor,\n            fontSize: 16,\n            fontFamily: themeVariables.baseFont,\n            fontWeight: '400'\n        },\n        dayWrapper: {\n            backgroundColor: themeVariables.calendarBgColor,\n            borderColor: 'transparent',\n            width: 38,\n            height: 38,\n            borderRadius: 26\n        },\n        notDayOfCurrentMonth: {\n            color: themeVariables.calendarNotCurrentMonthDateColor,\n            fontWeight: 'normal',\n            opacity: 0\n        },\n        monthText: {\n            fontWeight: '500',\n            fontFamily: themeVariables.baseFont,\n            color: themeVariables.calendarHeaderTextColor\n        },\n        yearText: {\n            fontWeight: '500',\n            fontFamily: themeVariables.baseFont,\n            color: themeVariables.calendarHeaderTextColor\n        },\n        today: {\n            backgroundColor: themeVariables.calendarBgColor,\n            borderColor: themeVariables.primaryColor\n        },\n        todayText: {\n            backgroundColor: themeVariables.calendarSelectedDayBgColor\n        },\n        eventDay1 : {\n            color: themeVariables.calendarEventDay1Color\n        },\n        eventDay2 : {\n            color: themeVariables.calendarEventDay2Color\n        },\n        eventDay3 : {\n            color: themeVariables.calendarEventDay3Color\n        },\n        selectedDay: {\n            backgroundColor: themeVariables.calendarSelectedDayBgColor\n        },\n        selectedDayText: {\n            backgroundColor: themeVariables.calendarSelectedDayBgColor,\n            color: themeVariables.calendarSelectedDayTextColor,\n            fontWeight: 'bold'\n        },\n        prevMonthBtn: {\n            root: {\n                color: themeVariables.calendarPrevMonthIconColor\n            }\n        } as WmIconStyles,\n        nextMonthBtn: {\n            root: {\n                color: themeVariables.calendarNextMonthIconColor\n            }\n        } as WmIconStyles,\n        prevYearBtn: {\n            root: {\n                color: themeVariables.calendarPrevYearIconColor\n            }\n        } as WmIconStyles,\n        nextYearBtn: {\n            root: {\n                color: themeVariables.calendarNextYearIconColor\n            }\n        } as WmIconStyles,\n        skeleton: {\n            root: {\n                display:'flex', \n                justifyContent: 'center',\n                backgroundColor:'#fff',\n                paddingHorizontal: 8,\n                alignItems: 'center',\n            },\n          } as any as  WmSkeletonStyles ,\n        headerSkeleton: {\n            root: {\n                width: '100%',\n                display:'flex', \n                flexDirection:'row', \n                alignItems: 'center',\n                justifyContent: 'space-around',\n                marginBottom: 16\n            } \n        } as any as WmSkeletonStyles\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n    addStyle(DEFAULT_CLASS + '-rtl', '', {\n        prevMonthBtn: {\n            root: {\n                transform: [ {rotateY: '180deg'}]\n            }\n        } as any as WmIconStyles,\n        nextMonthBtn: {\n            root: {\n                transform: [ {rotateY: '180deg'}]            \n            },\n        } as any as WmIconStyles,\n        monthText: {\n            padding: 2\n        },\n        yearText: {\n            padding: 2\n        }\n    });\n});", "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.tsx": "/****\n * Copied code from a repo with no active maintenance.\n * https://github.com/hungdev/react-native-customize-selected-date\n * That js lib was converted to ts and fixed bugs. \n */\nimport React, { Component } from 'react';\nimport {\n  Text,\n  View,\n  FlatList,\n  TouchableOpacity,\n  ViewStyle,\n  TextStyle\n} from 'react-native';\nimport moment, { Moment } from 'moment';\nimport styles from './month-view.styles'\nimport _ from 'lodash';\n\nexport class MonthViewProps {\n  testID?: string = null as any;\n  accessibilityLabel?: string = null as any;\n  date?: Moment = null as any;\n  minDate? = moment('1990-01-01', 'YYYY-MM-DD');\n  maxDate? = moment('2100-01-01', 'YYYY-MM-DD');\n  customMonth?: string[] = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n  customWeekdays?: string[] = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\n  renderPrevYearButton?: () => React.ReactNode = null as any;\n  format?='YYYY-MM-DD';\n  renderPrevMonthButton?: () => React.ReactNode = null as any;\n  renderNextYearButton?: () => React.ReactNode = null as any;\n  renderNextMonthButton?: () => React.ReactNode = null as any;\n  renderChildDay? = (day: Moment) => (<></>);\n  selectDate? = (day: Moment) => {}; \n  //style\n  getDayStyle? = (date: Moment) => ({});\n  containerStyle?: ViewStyle = null as any;\n  warpRowControlMonthYear?: ViewStyle = null as any;\n  warpRowWeekdays?: ViewStyle = null as any;\n  weekdayStyle?: TextStyle = null as any;\n  textDayStyle?: TextStyle = null as any;\n  currentDayStyle?: ViewStyle = null as any;\n  currentDayTextStyle?: TextStyle = null as any;\n  notDayOfCurrentMonthStyle?: ViewStyle = null as any;\n  warpDayStyle?: ViewStyle = null as any;\n  dateSelectedWarpDayStyle?: ViewStyle = null as any;\n  selectedDayTextStyle?: TextStyle = null as any;\n  monthTextStyle?: TextStyle = null as any;\n  yearTextStyle?: TextStyle = null as any;\n}\n\nexport class MonthViewState {\n  viewMode = 'day';\n  currentYear: string = null as any;\n  constructor(public selectedDate: Moment = moment()) {\n\n  }\n}\n\nexport class MonthView extends Component<MonthViewProps, MonthViewState> {\n\n  static defaultProps = new MonthViewProps();\n\n  constructor(props: MonthViewProps) {\n    super(props);\n    this.state = new MonthViewState(this.props.date);\n  }\n\n  calendarArray (date: Moment): Moment[] {\n    const dates: Moment[] = [];\n    const currDate = date.clone().startOf('month').startOf('week');\n    for (let i = 0; i < 42; i += 1) {\n      dates[i] = currDate.clone();\n      currDate.add(1, 'day');\n    }\n    return dates;\n  }\n\n  renderDay(day: Moment) {\n    const { warpDayStyle, dateSelectedWarpDayStyle,\n      renderChildDay, textDayStyle, currentDayStyle, currentDayTextStyle, notDayOfCurrentMonthStyle, selectedDayTextStyle } = this.props;\n    const dateSelected = this.props.date?.isSame(day);\n    const isCurrent = moment().isSame(day, 'date');\n    const notCurrentMonth = !this.props.date?.isSame(day, 'month');\n    const dateStyle = ((this.props.getDayStyle ? this.props.getDayStyle(day) : null) || {}) as any;\n    return (\n      <TouchableOpacity \n        testID={this.props.testID + '_' + day.format('yyyy_mm_dd')}\n        accessibilityLabel={this.props.testID + '_' + day.format('yyyy_mm_dd')}\n        onPress={() => this.selectDate(day)}\n        style={[styles.warpDay, warpDayStyle,\n          isCurrent ? currentDayStyle : {},\n          dateSelected ? { backgroundColor: '#2C1F23', ...dateSelectedWarpDayStyle } : {},\n          dateStyle.containerStyle]}\n      >\n        <View style={{flexDirection: 'column', justifyContent: 'center', alignItems: 'center'}}>\n          <Text style={[styles.day, textDayStyle,\n            isCurrent ? currentDayTextStyle : {},\n            notCurrentMonth ? { color: '#493D40', ...notDayOfCurrentMonthStyle } : {},\n            dateSelected ? { color: '#000', ...selectedDayTextStyle } : {},\n            dateStyle.textStyle]}>\n            {day.get('date')}\n          </Text>\n          {renderChildDay && renderChildDay(day)}\n        </View>\n      </TouchableOpacity>\n    )\n  }\n\n  selectDate(date: Moment) {\n    if (this.isDateEnable(date)) {\n      this.props.selectDate && this.props.selectDate(date)\n    }\n  }\n\n  yearMonthChange(unit: number, type: string) {\n    this.selectDate((this.props.date || moment()).clone().add(unit, type as any).startOf('month'));\n  }\n\n  isDateEnable(date: Moment) {\n    const { minDate, maxDate } = this.props;\n    return minDate?.isSameOrBefore(date) && maxDate?.isSameOrAfter(date);\n  }\n\n  render() {\n    const {\n      renderPrevYearButton, renderPrevMonthButton,\n      renderNextYearButton, renderNextMonthButton,\n      weekdayStyle, customWeekdays, warpRowWeekdays,\n      warpRowControlMonthYear, monthTextStyle, yearTextStyle\n    } = this.props\n    const weekdays = customWeekdays || ['Sun', 'Mon', 'Tus', 'Wes', 'Thu', 'Fri', 'Sat']\n    const data = this.calendarArray(this.props.date || moment())\n    const dayOfWeek: React.ReactNode[] = [];\n    const month = this.props.customMonth ? this.props.customMonth[this.props.date?.get('month') || 0]: 'Jan';\n    const year = this.props.date?.get('year') || 1;\n    _.forEach(weekdays, element => {\n      dayOfWeek.push(<Text key={element} style={[styles.weekdays, weekdayStyle]}>{element}</Text>)\n    })\n\n    return (\n      <View style={[styles.container, this.props.containerStyle]}>\n        <View style={[{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }, warpRowControlMonthYear]}>\n          {/*<TouchableOpacity onPress={() => this.yearMonthChange(-1, 'year')}>\n            {renderPrevYearButton ? renderPrevYearButton() : <Text>{'<<'}</Text>}\n          </TouchableOpacity>*/}\n          <TouchableOpacity onPress={() => this.yearMonthChange(-1, 'month')}>\n            {renderPrevMonthButton ? renderPrevMonthButton() : <Text>{'<'}</Text>}\n          </TouchableOpacity>\n          <View style={{flexDirection: 'row'}}>\n            <Text style={[styles.txtHeaderDate, monthTextStyle]} >{month + '  '}</Text>\n            <Text style={[styles.txtHeaderDate, yearTextStyle]} >{year}</Text>\n          </View>\n          <TouchableOpacity onPress={() => this.yearMonthChange(1, 'month')}>\n            {renderNextMonthButton ? renderNextMonthButton() : <Text>{'>'}</Text>}\n          </TouchableOpacity>\n          {/*<TouchableOpacity onPress={() => this.yearMonthChange(1, 'year')}>\n            {renderNextYearButton ? renderNextYearButton() : <Text>{'>>'}</Text>}\n          </TouchableOpacity>*/}\n        </View>\n        <View style={[{ flexDirection: 'row', justifyContent: 'space-around' }, warpRowWeekdays]}>\n          {dayOfWeek}\n        </View>\n        <FlatList\n          data={data}\n          keyExtractor={(item) => '' + item.toDate().getTime()}\n          renderItem={({ item }) => this.renderDay(item)}\n          extraData={this.state}\n          columnWrapperStyle={{justifyContent: 'space-between'}}\n          numColumns={7}\n          style={{\n            padding: 4\n          }}\n        />\n      </View>\n    )\n  }\n}", "wavemaker-rn-runtime/src/components/input/calendar/views/month-view.styles.ts": "import { StyleSheet, Dimensions } from 'react-native';\nconst { width, height } = Dimensions.get('window');\nconst screenWidth = width < height ? width : height;\n\nexport default StyleSheet.create({\n  container: {},\n  day: {\n    color: '#fff'\n  },\n  txtHeaderDate: {\n    color: '#fff',\n    fontSize: 18,\n\n  },\n  weekdays: {\n    marginVertical: 10,\n    color: 'white',\n    width: screenWidth / 7 - 8,\n    textAlign: 'center'\n  },\n  warpDay: {\n    width: screenWidth / 7,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: '#25171A',\n    borderColor: '#201216',\n    borderWidth: 1,\n    marginVertical: 4,\n  },\n  icLockRed: {\n    width: 13 / 2,\n    height: 9,\n    position: 'absolute',\n    top: 2,\n    left: 1\n  }\n});", "wavemaker-rn-runtime/src/components/input/basedataset/basedataset.props.ts": "import {AccessibilityRole} from \"react-native\";\nimport { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class BaseDatasetProps extends BaseProps {\n  dataset: any;\n  datavalue?: any;\n  displayfield: any;\n  datafield: any;\n  displayexpression: any;\n  getDisplayExpression: any;\n  groupby?: any;\n  match?: any;\n  orderby?: any;\n  readonly: boolean = null as any;\n  dateformat?: any;\n  onFieldChange?: any;\n  displaylabel?: any;\n  displayValue?: any;\n  displayimagesrc: any;\n  iconclass?: any;\n  triggerValidation?: any;\n  accessibilitylabel?: string = undefined;\n  hint?: string = undefined;\n  accessibilityrole?: AccessibilityRole;\n  accessibilitylabelledby?: string = undefined;\n}\n", "wavemaker-rn-runtime/src/components/input/basedataset/basedataset.component.ts": "import { BaseComponent, BaseComponentState } from \"@wavemaker/app-rn-runtime/core/base.component\";\nimport BaseDatasetProps from '@wavemaker/app-rn-runtime/components/input/basedataset/basedataset.props';\nimport { find, isString, isEqual,isEmpty, isFunction, includes, get, forEach, isObject, isArray, filter, trim, uniqBy, uniqWith } from 'lodash';\nimport { getGroupedData, getOrderedDataset, isDefined, validateField } from \"@wavemaker/app-rn-runtime/core/utils\";\nimport { DEFAULT_CLASS, BaseDatasetStyles } from \"@wavemaker/app-rn-runtime/components/input/basedataset/basedataset.styles\";\n\nexport class BaseDatasetState <T extends BaseDatasetProps> extends BaseComponentState<T> {\n  dataItems: any;\n  groupedData: any;\n  isDefault = false;\n  isValid = true;\n  errorType = '';\n}\n\nexport abstract class BaseDatasetComponent< T extends BaseDatasetProps, S extends BaseDatasetState<T>, L extends BaseDatasetStyles> extends BaseComponent<T, S, L> {\n\n  constructor(props: T, public defaultClass: string = DEFAULT_CLASS, defaultProps?: T, defaultState?: S) {\n    super(props, defaultClass, defaultProps, defaultState);\n\n  }\n\n  onPropertyChange(name: string, $new: any, $old: any) {\n    const props = this.state.props;\n    switch (name) {\n      case 'dataset':\n        this.setDataItems($new);\n        break;\n      case 'getDisplayExpression':\n      case 'displayfield':\n      case 'displaylabel':\n      case 'displayimagesrc':\n      case 'datafield':\n      case 'orderby':\n        this.setDataItems(this.state.props.dataset);\n        break;\n      case 'groupby':\n      case 'match':\n        this.setGroupData(this.state.dataItems);\n      case 'datavalue':\n        this.setDataItems(this.state.props.dataset, { dataValue: $new });\n        const isDefault = this.state.isDefault;\n        if (isDefault) {\n          this.updateState({ isDefault: false } as S, this.props.onFieldChange && this.props.onFieldChange.bind(this, 'datavalue', $new, $old, isDefault));\n        } else {\n          this.props.onFieldChange && this.props.onFieldChange('datavalue', $new, $old, isDefault);\n        }\n    }\n  }\n\n  setGroupData(items: any) {\n    const dataItems = items;\n    const props = this.state.props;\n    if (props.groupby) {\n      const groupedData = dataItems && getGroupedData(dataItems, props.groupby, props.match, props.orderby, props.dateformat, this, 'dataObject');\n      this.updateState({ groupedData: groupedData } as S, () => this.onDataItemsUpdate());\n    }\n  }\n\n  validate(value: any) {\n    const validationObj = validateField(this.state.props, value);\n    this.setState({\n      isValid: validationObj.isValid,\n      errorType: validationObj.errorType\n    } as S);\n  }\n\n  updateDatavalue(value: any) {\n    return new Promise<void>((resolve) => {\n      this.updateState({\n        props: { datavalue: value }\n       } as S,\n       () => {\n        this.computeDisplayValue();\n        resolve();\n       });\n    });\n  }\n\n  onValueChange(value: any) {\n    if (this.state.props.datafield === 'All Fields') {\n      const selectedItem = find(this.state.dataItems, (item) => isEqual(item.key, value));\n      value = selectedItem && selectedItem.dataObject;\n    }\n    this.onChange(value);\n  }\n\n  getItemKey(value: any) {\n      const selectedItem = find(this.state.dataItems, (item) => isEqual(item.dataObject, value));\n      return selectedItem && selectedItem.key;\n  }\n\n  onChange(value: any) {\n    const oldValue = this.state.props.datavalue;\n    this.validate(value);\n    this.updateDatavalue(value)\n    .then(() => {\n      if (value !== oldValue) {\n        if (this.props.onFieldChange) {\n          this.props.onFieldChange('datavalue', value, oldValue);\n        } else {\n          this.invokeEventCallback('onChange', [\n            undefined,\n            this.proxy,\n            value,\n            oldValue,\n          ]);\n        }\n      }\n    });\n  }\n\n  computeDisplayValue() {\n    this.updateState({\n      props: {\n        displayValue: ((this.state.dataItems || [] as any)\n          .filter((item: any) => item.selected)\n          .map((item: any) => item.displayexp || item.displayfield))[0] || ''\n      }\n    } as S);\n  }\n\n  onDataItemsUpdate() {\n    this.computeDisplayValue();\n  }\n\n  getUniqObjsByDataField(\n    data: any,\n    allowEmptyFields: boolean = true\n  ) {\n    let uniqData;\n    const isAllFields = this.state.props.datafield === 'All Fields';\n\n    uniqData = isAllFields ? uniqWith(data, isEqual) : uniqBy(data, 'datafield');\n\n    if (!this.state.props.displayfield || allowEmptyFields) {\n      return uniqData;\n    }\n\n    // return objects having non empty datafield and display field values.\n    return filter(uniqData, (obj) => {\n      if (isAllFields) {\n        return trim(obj.displayfield);\n      }\n      return trim(obj.datafield) && trim(obj.displayfield);\n    });\n  }\n\n  setDataItems(dataset: any, propsObj?: { [key: string]: any }, allowEmpty: boolean = true) {\n    const name = this.props.name;\n    const props = this.state.props;\n    const datavalue = propsObj ? propsObj['dataValue'] : props.datavalue;\n    let dataItems: any = [];\n    let datavalueItems: any = [];\n    if (typeof datavalue === 'string') {\n      datavalueItems = datavalue.split(',');\n      datavalueItems = allowEmpty ? datavalueItems : datavalueItems.map((item: any) => item.trim());\n    } else if (isArray(datavalue)) {\n      datavalueItems = datavalue;\n    } else {\n      if (isDefined(datavalue)) {\n        datavalueItems = [datavalue];\n      }\n    }\n    if (typeof dataset === 'string') {\n      dataset = dataset.split(',');\n    }\n    if (isArray(dataset) && !isObject(dataset[0])) {\n      dataItems = dataset.map((s, i) => {\n        s = isString(s) ? s.trim() : s;\n        return {\n          key: `${name}_item${i}`,\n          dataObject: s,\n          displayfield: s.toString(),\n          datafield: s,\n          selected: includes(datavalueItems, s) || includes(datavalueItems, s.toString()) || datavalue === s ? true : false,\n        };\n      });\n    } else if (dataset) {\n      if (isObject(dataset) && !isArray(dataset)) {\n        forEach(dataset, (value, key) => {\n          if (isDefined(key) && key !== null) {\n            dataItems.push({key: `${name}_item${key}`, displayfield: value, datafield: key, dataObject: dataset});\n          }\n        });\n      } else {\n        const isSelected = (item: any) => {\n          if (datavalueItems.length) {\n            let datafield = this.state.props.datafield;\n            if (!datafield) {\n              datafield = 'All Fields';\n            }\n            if (datafield === 'All Fields') {\n              return includes(datavalueItems, item);\n            }\n            let df = get(item, datafield);\n            if (isDefined(df) && df !== null) {\n              return (includes(datavalueItems, df) || includes(datavalueItems, df.toString()));\n            }\n          }\n          return false;\n        };\n        forEach(dataset as any[], (d, i) => {\n          let datafieldValue = this.state.props.datafield === 'All Fields' ? d : get(d, this.state.props.datafield);\n          if (isDefined(datafieldValue) && datafieldValue !== null) {\n            dataItems.push({\n              key: `${name}_item${i}`,\n              dataObject: d,\n              displayfield: (get(d, this.state.props.displayfield))?.toString() || (get(d, this.state.props.displaylabel))?.toString(),\n              datafield: datafieldValue,\n              displayexp: this.state.props.getDisplayExpression ? this.state.props.getDisplayExpression(d) : get(d, this.state.props.displayfield),\n              selected: isSelected(d),\n              imgSrc: isFunction(this.state.props.displayimagesrc) ? this.state.props.displayimagesrc(d) : get(d, this.state.props.displayimagesrc),\n              icon: d[this.props.iconclass]\n            });\n          }\n        });\n      }\n    }\n    if (dataItems.length) {\n      dataItems = this.getUniqObjsByDataField(dataItems, allowEmpty);\n    }\n    const isUpdated = !isEqual(dataItems, this.state.dataItems);\n    if (props.groupby) {\n      this.setGroupData(dataItems);\n      this.updateState({ dataItems: dataItems } as S, () => isUpdated && this.onDataItemsUpdate());\n    } else if (props.orderby) {\n      this.updateState({ dataItems: getOrderedDataset(dataItems, props.orderby, 'dataObject')} as S, () => isUpdated && this.onDataItemsUpdate());\n    } else {\n      this.updateState({ dataItems: dataItems } as S, () => isUpdated && this.onDataItemsUpdate());\n    }\n  }\n}\n", "wavemaker-rn-runtime/src/components/input/basedataset/basedataset.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type BaseDatasetStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-basenumber';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: BaseDatasetStyles = defineStyles({\n    root: {},\n    text: {}\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n});\n", "wavemaker-rn-runtime/src/components/input/chips/chips.props.ts": "import BaseDatasetProps from '@wavemaker/app-rn-runtime/components/input/basedataset/basedataset.props';\n\nexport default class WmChipsProps extends BaseDatasetProps {\n  autofocus: boolean = false;\n  placeholder: string = 'Type here...';\n  dataset: any = 'Option 1, Option 2, Option 3';\n  searchable: boolean = false;\n  searchkey: string = null as any;\n  minchars: number = 1;\n  maxsize: number = null as any;\n  inputposition: string = 'last';\n  invokeEvent?: Function;\n}\n", "wavemaker-rn-runtime/src/components/input/chips/chips.component.tsx": "import React from 'react';\nimport { View, TouchableOpacity, Text, DimensionValue } from 'react-native';\nimport { LifecycleListener } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { clone, findIndex, get, isUndefined, pull, forEach, filter, find, isEqual, merge, isArray, isString } from 'lodash';\nimport WmChipsProps from './chips.props';\nimport { DEFAULT_CLASS, WmChipsStyles } from './chips.styles';\nimport WmSearch from '@wavemaker/app-rn-runtime/components/basic/search/search.component';\nimport {\n  BaseDatasetComponent,\n  BaseDatasetState\n} from '@wavemaker/app-rn-runtime/components/input/basedataset/basedataset.component';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport WmPicture from '@wavemaker/app-rn-runtime/components/basic/picture/picture.component';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility'; \nimport { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\nimport WmLabel from '../../basic/label/label.component';\nimport { isDefined } from '@wavemaker/app-rn-runtime/core/utils';\n\nexport class WmChipsState extends BaseDatasetState<WmChipsProps> {\n  chipsList: any = [];\n  saturate: any;\n}\n\nexport default class WmChips extends BaseDatasetComponent<WmChipsProps, WmChipsState, WmChipsStyles> {\n  constructor(props: WmChipsProps) {\n    super(props, DEFAULT_CLASS, new WmChipsProps(), new WmChipsState());\n  }\n\n  private searchRef: WmSearch = null as any;\n  private maxSizeReached = 'Max size reached';\n  private isDefaultQuery: boolean = true;\n  private prevDatavalue: any;\n\n  private listener: LifecycleListener = {\n    onComponentInit: (c) => {\n      if (c instanceof WmSearch) {\n        this.searchRef = c;\n      }\n    }\n  };\n\n  onPropertyChange(name: string, $new: any, $old: any): void {\n      super.onPropertyChange(name, $new, $old);\n      switch (name) {\n        case 'datavalue':\n          if (!$new || $new.length === 0) {\n            this.updateState({\n              chipsList: [],\n            } as WmChipsState);\n          }\n          break;\n        case 'maxsize':\n          if ($new) {\n            const { datavalue } = this.state.props;\n            const { dataItems } = this.state;\n            \n            let dataValueItems = Array.isArray(datavalue)\n              ? datavalue\n              : typeof datavalue === 'string'\n                ? datavalue.split(',').map((item) => item.trim())\n                : datavalue != null\n                  ? [datavalue]\n                  : [];\n\n            if (dataValueItems.length >= $new) {\n              dataValueItems = dataValueItems.slice(0, $new);\n              const updatedItems = dataItems.map((item:any) => ({\n                ...item,\n                selected: dataValueItems.includes(item.datafield),\n              }));\n              this.updateState({ dataItems: updatedItems } as WmChipsState);\n            }\n\n            break;\n          }\n      }\n  }\n\n  reset() {\n    if (this.searchRef?.state.props.query) {\n      this.searchRef.reset();\n    }\n  }\n\n  onDataItemsUpdate() {\n    super.onDataItemsUpdate();\n    this.isDefaultQuery = true;\n    this.updateDefaultQueryModel();\n  }\n\n  addItem($event: any, widget: any) {\n    let newChipList = clone(this.state.chipsList),\n      allowAdd;\n    newChipList.push(widget.queryModel);\n    const isFormFieldWidget = get(this.props, 'formfield');\n    if (this.isDuplicate(widget.queryModel)) {\n      this.resetSearchModel();\n      return;\n    }\n\n    // @ts-ignore\n    allowAdd = isFormFieldWidget ? this.props?.invokeEvent('onBeforeadd', [null, this, widget.queryModel]) : this.invokeEventCallback('onBeforeadd', [null, this, widget.queryModel]);\n\n    if (!isUndefined(allowAdd) && !this.toBoolean(allowAdd)) {\n      return;\n    }\n\n    this.updateState({\n      chipsList: newChipList\n    } as WmChipsState);\n\n    this.setDatavalue(newChipList);\n\n    // @ts-ignore\n    isFormFieldWidget ? this.props?.invokeEvent('onAdd', [null, this, widget.queryModel]) : this.invokeEventCallback('onAdd', [null, this, widget.queryModel]);\n    this.resetSearchModel();\n  }\n\n  computeDisplayValue() {\n    this.updateState({\n      props: {\n        displayValue: ((this.state.dataItems || [] as any)\n          .filter((item: any) => item.selected)\n          .map((item: any) => item.displayexp || item.displayfield)) || ''\n      }\n    } as WmChipsState);\n  }\n\n  selectChip(chipItem: any) {\n    if (!chipItem.selected && this.state.props.maxsize > 0 && (this.state.chipsList.length === this.state.props.maxsize)) {\n      return;\n    }\n    chipItem.selected = !chipItem.selected;\n    const newChipList: any = [];\n    const selectedItem = find(this.state.dataItems, d => isEqual(d.key, chipItem.key));\n    selectedItem.selected = chipItem.selected;\n    forEach(this.state.dataItems, (item) => {\n      if (item.selected) {\n        newChipList.push(item);\n      }\n    });\n    this.updateState({\n      chipsList: newChipList\n    } as WmChipsState);\n\n    this.setDatavalue(newChipList);\n  }\n\n  setDatavalue(newChipList: any) {\n    const dataValue = newChipList.map((item: any) => item.datafield);\n    this.updateDatavalue(dataValue);\n    this.updateMaxSize(newChipList.length);\n    if (!this.props.invokeEvent) {\n      this.invokeEventCallback('onChange', [null, this, dataValue, this.prevDatavalue])\n    }\n    this.prevDatavalue = dataValue;\n  }\n\n  toBoolean = (val: any) => ((val && val !== 'false') ? true  : false);\n\n  // Prepare datavalue object from a string(junk) value when datafield is allFields.\n  createCustomDataModel(val: string) {\n     return {\n        key: `${this.state.props.name}_item${this.state.chipsList.length}`,\n        dataObject: val,\n        displayfield: val,\n        datafield: val,\n        isCustom: true\n     }\n  }\n\n  resetSearchModel() {\n    (this as any).searchRef.isDefaultQuery = false;\n    this.searchRef.clearSearch();\n  }\n\n  isDuplicate(item: any) {\n    return findIndex(this.state.chipsList, {datafield: item.datafield}) > -1;\n  }\n\n  // Check if max size is reached\n  private updateMaxSize(chipListLength: number) {\n    const saturate = this.state.props.maxsize > 0 && (chipListLength || this.state.chipsList.length) === this.state.props.maxsize;\n    \n    this.updateState({\n      saturate: saturate\n    } as WmChipsState);\n  }\n\n  removeItem(item: any, index: any) {\n    let newChipList = clone(this.state.chipsList);\n    const isFormFieldWidget = get(this.props, 'formfield');\n    newChipList = pull(newChipList, item);\n    // prevent deletion if the before-remove event callback returns false\n    // @ts-ignore\n    const allowRemove = isFormFieldWidget ? this.props.invokeEvent('onBeforeremove',[null, this, item]) : this.invokeEventCallback('onBeforeremove',[null, this, item]);\n    if (!isUndefined(allowRemove) && !this.toBoolean(allowRemove)) {\n      return;\n    }\n\n    this.updateState({\n      chipsList: newChipList\n    } as WmChipsState,()=>{\n      this.setDatavalue(newChipList);\n       // @ts-ignore\n      isFormFieldWidget ? this.props.invokeEvent && this.props.invokeEvent('onRemove', [null, this, item]) : this.invokeEventCallback('onRemove', [null, this, item]);\n    });\n  }\n\n  private isDefaultView() {\n    return !this.state.props.searchable && this.state.dataItems?.length <= 10;\n  }\n\n  renderChip(item: any, index: any) {\n    const isSelected = this.isDefaultView() ? item.selected : true;\n    return (\n      <TouchableOpacity\n        {...this.getTestPropsForAction('chip'+ index)}\n        {...getAccessibilityProps(AccessibilityWidgetType.CHIPS, {...this.state.props, selected: isSelected})}\n        style={[this.styles.chip, isSelected ? this.styles.activeChip : null]}\n        key={'chipitem_'+ index}\n        onPress={() => {\n          if (this.state.props.disabled || this.state.props.readonly) {\n            return;\n          }\n          if (this.isDefaultView()) {\n            this.selectChip(item);\n          }\n          if (get(this.props, 'formfield')) {\n            // @ts-ignore\n            this.props.invokeEvent('onChipclick', [null, this, item]);\n            // @ts-ignore\n            this.props.invokeEvent('onChipselect', [null, this, item]);\n          } else {\n            this.invokeEventCallback('onChipclick', [null, this, item]);\n            this.invokeEventCallback('onChipselect', [null, this, item]);\n          }\n        }}>\n        {isSelected && this.isDefaultView() ? <WmIcon id={this.getTestId('checkicon')} iconclass={'wm-sl-l sl-check'} iconsize={16} styles={merge({}, this.styles.doneIcon, {icon: {color: isSelected ? this.styles.activeChipLabel.color : null}})}></WmIcon> : null}\n        { this._showSkeleton ? null : <WmPicture id={this.getTestId('chip'+ index + 'picture')} styles={this.styles.imageStyles} picturesource={item.imgSrc} shape='circle'></WmPicture>}\n        { this._showSkeleton ? <WmLabel styles={{root: {width: 50}}}/> :  <Text {...this.getTestPropsForAction('chip'+ index+'label')}style={[this.styles.chipLabel, isSelected ? this.styles.activeChipLabel : null]}>{item.displayexp || item.displayfield}</Text>}\n        {!this.isDefaultView() && !(this.state.props.disabled||this.state.props.readonly) ? <WmIcon id={this.getTestId('clearbtn')} iconclass={'wi wi-clear'} iconsize={16} styles={this.styles.clearIcon} onTap={() => this.removeItem(item, index)}></WmIcon> : null}\n      </TouchableOpacity>\n    )\n  }\n\n  updateDefaultQueryModel() {\n      if (this.state.dataItems && this.state.dataItems.length && this.isDefaultQuery) {\n          const selectedItems = filter(this.state.dataItems, (item) => item.selected);\n          if (selectedItems.length) {\n            this.updateState({\n              chipsList: selectedItems\n            } as WmChipsState);\n            this.updateMaxSize(selectedItems.length);\n          }\n          this.isDefaultQuery = false;\n      }\n  }\n\n  componentDidMount(): void {\n    super.componentDidMount();\n    this.updateDefaultQueryModel();\n  }\n\n  componentDidUpdate(prevProps: WmChipsProps, prevState: WmChipsState) {\n    super.componentDidUpdate(prevProps, prevState);\n    if (prevState.chipsList !== this.state.chipsList) {\n      this.searchRef?.computePosition();\n    }\n  } \n  renderSkeleton(): React.ReactNode {\n    return (<View style={this.styles.root}>\n      <View style={this.styles.chipsWrapper}>{ \n      [{}, {}, {}].map((item: any, index: any) => this.renderChip(item, index)) }\n      </View>\n      </View>)\n  }\n\n  renderWidget(props: WmChipsProps) {\n    const chips = this.state.chipsList;\n    return (<View style={this.styles.root} onLayout={(event) => this.handleLayout(event)}>\n\n      <View style={this.styles.chipsWrapper}>\n        {\n          this.isDefaultView() ? this.state.dataItems.map((item: any, index: any) => this.renderChip(item, index)) : null\n        }\n        { props.searchable || !this.isDefaultView() ?\n          <View style={[this.styles.searchContainer, {flexDirection: props.inputposition === 'first' ? 'column' : 'column-reverse'}]}>\n            <WmSearch\n              id={this.getTestId('search')}\n              name=\"app-chip-search\"\n              styles={this.styles.search}\n              placeholder={this.state.saturate ? this.maxSizeReached : props.placeholder}\n              listener={this.listener}\n              dataset={props.dataset}\n              searchkey={props.searchkey}\n              minchars={props.minchars}\n              autofocus={props.autofocus}\n              disabled={props.disabled || props.readonly || this.state.saturate}\n              readonly={props.readonly}\n              displayexpression={props.displayexpression}\n              getDisplayExpression={props.getDisplayExpression}\n              displayimagesrc={props.displayimagesrc}\n              displayfield={props.displayfield}\n              datafield={props.datafield}\n              onSubmit={this.addItem.bind(this)}\n              onChange={() => {\n                this.isDefaultQuery = false;\n                this.props.listener?.onComponentChange && this.props.listener?.onComponentChange(this)\n              }}\n              showSearchIcon={false}\n              showclear={false}\n              type={props.minchars === 0 ? 'autocomplete' : 'search'}/>\n              <View style={{ flexDirection: 'row', flexWrap: 'wrap'}}>\n                {chips && chips.length ?\n                chips.map((item: any, index: any) => this.renderChip(item, index))\n                : null}\n              </View>\n          </View>\n           : null }\n      </View>\n    </View>);\n  }\n}\n", "wavemaker-rn-runtime/src/components/input/chips/chips.styles.ts": "import { TextStyle } from 'react-native';\nimport BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmSearchStyles } from '@wavemaker/app-rn-runtime/components/basic/search/search.styles';\nimport { WmIconStyles } from '@wavemaker/app-rn-runtime/components/basic/icon/icon.styles';\nimport { WmPictureStyles } from '@wavemaker/app-rn-runtime/components/basic/picture/picture.styles';\nimport { WmSkeletonStyles } from '../../basic/skeleton/skeleton.styles';\n\nexport type WmChipsStyles = BaseStyles & {\n  chip: AllStyle;\n  chipLabel: TextStyle;\n  chipsWrapper: AllStyle;\n  search: WmSearchStyles;\n  searchContainer: AllStyle;\n  activeChip: AllStyle;\n  activeChipLabel: TextStyle;\n  clearIcon: WmIconStyles;\n  doneIcon: WmIconStyles;\n  imageStyles: WmPictureStyles;\n  skeleton: WmSkeletonStyles;\n};\n\nexport const DEFAULT_CLASS = 'app-chips';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmChipsStyles = defineStyles({\n      root: {\n        flexWrap: 'wrap',\n      },\n      text: {},\n      chipsWrapper: {\n        flexDirection: 'row',\n        flexWrap: 'wrap'\n      },\n      chip: {\n        margin: 2,\n        backgroundColor: themeVariables.chipContainerColor,\n        borderRadius: 8,\n        flexDirection: 'row',\n        alignItems: 'center',\n        justifyContent: 'center',\n        paddingVertical: 4,\n        paddingHorizontal: 4,\n        minWidth: 80,\n        minHeight: 32,\n        borderWidth: 1,\n        borderColor: themeVariables.chipborderColor,\n        elevation: 1\n      },\n      chipLabel : {\n        fontSize: 14,\n        paddingLeft: 8,\n        fontFamily: themeVariables.baseFont,\n        fontWeight: '500',\n        paddingRight: 12,\n        color: themeVariables.chipDefaultTextColor,\n        borderColor: themeVariables.chipborderColor\n      },\n      activeChip: {\n        backgroundColor: themeVariables.chipSelectedContainerColor, \n        borderColor: themeVariables.chipSelectedOutlineColor,\n        borderWidth: 0\n      },\n      activeChipLabel: {\n        color: themeVariables.chipActiveTextColor\n      },\n      searchContainer: {\n        width: '100%',\n        flexDirection: 'column'\n      },\n      search: {\n        root: {\n          marginBottom: 8\n        },\n        text: {\n          borderRightWidth: 1,\n          borderTopRightRadius: 4,\n          borderBottomRightRadius: 4\n        }\n      } as WmSearchStyles,\n      doneIcon: {\n        icon: {\n          paddingLeft: 8,\n          fontSize: 18,\n          color: themeVariables.chipIconColor,\n        }\n      } as WmIconStyles,\n      clearIcon: {\n        icon: {\n          color: themeVariables.chipIconColor,\n          paddingRight: 8,\n          fontSize: 18\n        }\n      } as WmIconStyles,\n      imageStyles: {\n        root: {\n          width: 32,\n          height: 32\n        }\n      } as WmPictureStyles,\n      skeleton: {\n        root:{\n          width: 80,\n          borderRadius: 8,\n          padding:4,\n          minHeight: 32,\n        }\n      } as any as WmSkeletonStyles,\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n  addStyle(DEFAULT_CLASS + '-disabled', '', {\n    chip: {\n      opacity: 0.5\n    },\n    search: {\n      root : {\n        backgroundColor: themeVariables.inputDisabledBgColor\n      }\n    }\n  });\n});\n", "wavemaker-rn-runtime/src/components/input/basenumber/basenumber.component.ts": "import { includes, intersection, isNaN, isFinite, toArray, isNil } from 'lodash';\nimport BaseNumberProps from '@wavemaker/app-rn-runtime/components/input/basenumber/basenumber.props';\nimport { BaseComponent, BaseComponentState } from \"@wavemaker/app-rn-runtime/core/base.component\";\nimport { BaseNumberStyles } from '@wavemaker/app-rn-runtime/components/input/basenumber/basenumber.styles';\nimport { DEFAULT_CLASS } from \"@wavemaker/app-rn-runtime/components/navigation/basenav/basenav.styles\";\nimport { Platform, TextInput } from 'react-native';\nimport { countDecimalDigits, validateField } from '@wavemaker/app-rn-runtime/core/utils';\n\nexport class BaseNumberState <T extends BaseNumberProps> extends BaseComponentState<T> {\n  isValid: boolean = true;\n  isInputFocused: boolean = false;\n  textValue: string = '';\n  isDefault = false;\n  errorType = '';\n}\n\nexport abstract class BaseNumberComponent< T extends BaseNumberProps, S extends BaseNumberState<T>, L extends BaseNumberStyles> extends BaseComponent<T, S, L> {\n  private DECIMAL;\n  private GROUP;\n  public widgetRef: TextInput | null = null;\n  private cursor: any = 0;\n  constructor(props: T, public defaultClass: string = DEFAULT_CLASS, defaultProps?: T, defaultState?: S) {\n    super(props, defaultClass, defaultProps, defaultState);\n    this.DECIMAL = '.';\n    this.GROUP = ',';\n  }\n\n  onChange(event: any) {\n    if (this.state.props.updateon === 'default') {\n      this.updateDatavalue(event.target.value, event);\n    }\n  }\n\n  focus() {\n    this?.widgetRef?.focus();\n  }\n\n  validateOnDevice(value: string, type: 'number' | 'currency') {\n    const isCurrencyField = type === 'currency';\n    let isValidText = true;\n\n    // * no alphabets except E, may contain E only once\n    if (/[a-df-zA-DF-Z]/.test(value) || !/^[^eE]*[eE]?[^eE]*$/.test(value)) {\n      isValidText = false;\n    }\n\n    // * currency only: check for negative number\n    if (isCurrencyField && (Number(value) < 0 || /-/g.test(value))) {\n      isValidText = false;\n    }\n\n    // * number only: not more than one minus and doesn't end with minus (-)\n    if (!isCurrencyField && (Number(value.match(/-/g)?.length) > 1) || /\\w-/.test(value)) {\n      isValidText = false;\n    }\n\n    // * check for more than one decimal point\n    if (/^\\d*\\.\\d*\\..*$/.test(value)) {\n      isValidText = false;\n    }\n\n    // * check for spaces and comma\n    if (/[\\s,]/.test(value)) {\n      isValidText = false;\n    }\n\n    return isValidText;\n  }\n\n  onChangeText(value: string, type: 'number' | 'currency', shouldFormateToNumber?: boolean) {\n    const newValue = shouldFormateToNumber ? `${this.parseNumber(value.replace(/[^0-9.]/g, ''))}` : value;\n    const isValidTextOnDevice = this.validateOnDevice(newValue, type);\n    if (!isValidTextOnDevice) {\n      return;\n    }\n\n    const decimalPlacesInNumber = countDecimalDigits(newValue);\n\n    if (this.props.decimalPlaces < decimalPlacesInNumber) {\n      return;\n    }\n\n    this.updateState({\n        textValue: newValue\n      } as S, () => {\n        if (this.state.props.updateon === 'default') {\n          this.validate(newValue);\n          this.updateDatavalue(newValue, null);\n        }\n      }\n    );\n  }\n\n  invokeChange(e: any) {\n    if (Platform.OS === 'web') {\n      this.cursor = e.target.selectionStart;\n      this.setState({ textValue: e.target.value });\n    }\n  }\n\n  validate(value: any) {\n    const validationObj = validateField(this.state.props, value);\n    this.updateState({\n      isValid: validationObj.isValid,\n      errorType: validationObj.errorType\n    } as S);\n\n  }\n\n  handleValidation(value: any) {\n    const props = this.state.props;\n    if (props.regexp) {\n      const condition = new RegExp(props.regexp, 'g');\n      return condition.test(value);\n    }\n    return true;\n  }\n\n  /**\n   * Method parses the Localized number(string) to a valid number.\n   * if the string dose not result to a valid number then returns NaN.\n   * @param {string} val Localized number.\n   * @returns {number}\n   */\n  private parseNumber(val: string): any {\n    // splits string into two parts. decimal and number.\n    const parts = val.split(this.DECIMAL);\n    if (!parts.length) {\n      return;\n    }\n    if (parts.length > 2) {\n      return NaN;\n    }\n    // If number have decimal point and not have a decimal value then return.\n    if (parts[1] === '') {\n      return NaN;\n    }\n    // replaces all group separators form the number.\n    const number = Number(parts[0].split(this.GROUP).join(''));\n    const decimal = Number(`0.${parts[1] || 0}`);\n    if (Number.isNaN(number) || Number.isNaN(decimal)) {\n      return NaN;\n    }\n    const sum = parts.length > 1 ? parseFloat((number + decimal).toFixed(parts[1].length)) : number + decimal;\n    // if the number is negative then calculate the number as number - decimal\n    // Ex: number = -123 and decimal = 0.45 then number - decimal = -123-045 = -123.45\n    // If entered number is -0.1 to -0.9 then the number is -0 and decimal is 0.1 to 0.9. Now calaculate the number as number-decimal\n    // Ex: number = -0 and decimal = 0.1 then number-decimal = -0-0.1 = -0.1\n    if (number === 0) {\n      return Object.is(0, number) ? sum : number - decimal;\n    }\n    return number > 0 ? sum : number - decimal;\n  }\n\n  updateDatavalue(value: any, event?: any, source?: any) {\n    const model = value && this.parseNumber(value.toString());\n    const props = this.state.props;\n    const oldValue = props.datavalue;\n    if (value === oldValue) {\n      return;\n    }\n    const validNumber = this.isValidNumber(model) || value === oldValue + '.';\n    if (!validNumber) {\n      this.invokeEventCallback('onError', [ event, this.proxy, value, oldValue ]);\n      return;\n    }\n\n    new Promise((resolve) => {\n      if (props.hastwowaybinding) {\n        const newProps: any = {\n          props: {\n            datavalue: model || Number(value)\n          }\n        }\n        if(this.state.props.updateon === 'blur'){\n          newProps.textValue = model || Number(value)\n        }\n\n        this.updateState({...newProps} as S)\n\n        setImmediate(()=> this.setProp(\"datavalue\", value));\n        resolve(true);\n      } else {\n        this.updateState({\n          props: {\n            datavalue: model || Number(value)\n          }\n        } as S, () => resolve(true));\n      }\n    }).then(() => {\n      !this.props.onFieldChange && value !== oldValue && this.invokeEventCallback('onChange', [event, this.proxy, model, oldValue]);\n      if (source === 'blur') {\n        setTimeout(() => {\n          this.invokeEventCallback('onBlur', [event, this.proxy]);\n        }, 10);\n      }\n    });\n  }\n\n  onBlur(event: any, isDisplayValuePresent?: boolean) {\n    const textVal = this.state.textValue || '';\n    let newVal = isDisplayValuePresent ? textVal : event.target.value || textVal;\n    this.validate(newVal);\n    if (newVal === '' || newVal == undefined) {\n      setTimeout(() => {\n        this.props.triggerValidation && this.props.triggerValidation();\n      },10)\n    }\n    if (this.state.props.updateon === 'blur' || this.state.props.updateon === 'default') {\n      let oldVal = this.state.props.datavalue || '';\n      if (oldVal !== newVal && this.state.props.updateon === 'blur') {\n        this.updateDatavalue(newVal, event, 'blur');\n      } else {\n        this.invokeEventCallback('onBlur', [event, this.proxy]);\n      }\n      this.setState({ isInputFocused: false});\n    }\n  }\n\n  onFocus(event: any) {\n    this.invokeEventCallback('onFocus', [ event, this.proxy]);\n    this.setState({ isInputFocused: true});\n  }\n\n  /**\n   * returns the number of decimal places a number have.\n   * @param value: number\n   * @returns {number}\n   */\n  private countDecimals(value: any) {\n    if (value && ((value % 1) !== 0)) {\n      const decimalValue = value.toString().split('.')[1];\n      return decimalValue && decimalValue.length;\n    }\n    return 0;\n  }\n\n  public validateInputEntry($event: any) {\n    const props = this.state.props;\n\n    // allow actions if control key is pressed or if backspace is pressed. (for Mozilla).\n    if ($event.ctrlKey || includes(['Backspace', 'ArrowRight', 'ArrowLeft', 'Tab', 'Enter', 'Delete'], $event.key)) {\n      return;\n    }\n\n    const validity = new RegExp(`^[\\\\d\\\\s-,.e+${this.GROUP}${this.DECIMAL}]$`, 'i');\n    const inputValue = $event.target.value;\n    // validates entering of decimal values only when user provides decimal limit(i.e step contains decimal values).\n    if (inputValue && this.countDecimals(props.step) && (this.countDecimals(inputValue) >= this.countDecimals(props.step))) {\n      $event.preventDefault();\n    }\n    // validates if user entered an invalid character.\n    if (!validity.test($event.key)) {\n      $event.preventDefault();\n    }\n    // a decimal value can be entered only once in the input.\n    if (includes(inputValue, this.DECIMAL) && $event.key === this.DECIMAL) {\n      $event.preventDefault();\n    }\n    // 'e' can be entered only once in the input.\n    if (intersection(toArray(inputValue), ['e', 'E']).length && includes('eE', $event.key)) {\n      $event.preventDefault();\n    }\n    if ((includes(inputValue, '+') || includes(inputValue, '-')) && ($event.key === '+' || $event.key === '-')) {\n      $event.preventDefault();\n    }\n    this.invokeEventCallback('onKeypress', [ $event, this.proxy]);\n  }\n\n  /**\n   * returns a valid number by validating the minimum and maximum values.\n   * @param {number} value\n   * @returns {number}\n   */\n  private getValueInRange(value: number): number {\n    const props = this.state.props;\n    if (props.minvalue && !isNil(value) && !isNaN(props.minvalue) && value < props.minvalue) {\n      this.updateState({ errorType: 'minvalue'} as S);\n      return props.minvalue;\n    }\n    if (props.maxvalue && !isNil(value) && !isNaN(props.maxvalue) && value > props.maxvalue) {\n      this.updateState({ errorType: 'maxvalue'} as S);\n      return props.maxvalue;\n    }\n    return value;\n  }\n\n  /**\n   * Adds validations for the number before updating the widget model. like validating min and max value for the widget.\n   * @param {number} val number to be validated\n   * @returns {number}\n   */\n  private isValidNumber(val: number): boolean {\n    const props = this.state.props;\n\n    //empty number widget should not show validation error when required is false\n    // @ts-ignore\n    if (this.state.props.required === false && val === '') {\n      return true;\n    }\n    // id number is infinite then consider it as invalid value\n    if (isNaN(val) || !isFinite(val) || (!Number.isInteger(props.step) &&\n      this.countDecimals(val) > this.countDecimals(props.step))) {\n      this.updateState({\n        isValid: false,\n      } as S);\n      return false;\n    }\n    if (val !== this.getValueInRange(val)) {\n      this.updateState({\n        isValid: false,\n      } as S);\n      return true;\n    }\n    this.resetValidations();\n    return true;\n  }\n\n  // resets all the flags related to the widget's validation.\n  protected resetValidations() {\n    this.updateState({\n      isValid: true,\n    } as S);\n  }\n\n  onPropertyChange(name: string, $new: any, $old: any) {\n    switch (name) {\n      case 'minvalue':\n      case 'maxvalue':\n        if ($new|| $old) {\n          this.isValidNumber($new);\n        }\n        break;\n      case 'datavalue':\n        this.updateState({\n          textValue: $new,\n        } as S);\n        const isDefault = this.state.isDefault;\n        if (isDefault) {\n          this.updateState({ isDefault: false } as S, this.props.onFieldChange && this.props.onFieldChange.bind(this, 'datavalue', $new, $old, isDefault));\n        } else {\n          this.props.onFieldChange && this.props.onFieldChange('datavalue', $new, $old, isDefault);\n        }\n        break;\n      case 'displayValue': \n        this.updateState({\n          displayValue: $new,\n        } as any)\n    }\n  }\n}\n", "wavemaker-rn-runtime/src/components/input/basenumber/basenumber.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type BaseNumberStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-basenumber';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: BaseNumberStyles = defineStyles({\n    root: {},\n    text: {}\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n});\n", "wavemaker-rn-runtime/src/components/input/basenumber/basenumber.props.ts": "import {AccessibilityRole} from \"react-native\";\nimport { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class BaseNumberProps extends BaseProps {\n  datavalue: any;\n  hastwowaybinding = false;\n  minvalue: number = null as any;\n  maxvalue: number = null as any;\n  step: number = 1;\n  updateon: string = 'blur' as any;\n  readonly: boolean = null as any;\n  regexp: string = null as any;\n  onFieldChange: any;\n  required: boolean = false;\n  triggerValidation: any;\n  decimalPlaces: number = 2;\n  accessibilitylabel?: string = undefined;\n  hint?: string = undefined;\n  accessibilityrole?: AccessibilityRole;\n  accessibilitylabelledby?: string = undefined;\n  displayValue?: string;\n}\n", "wavemaker-rn-runtime/src/components/input/epoch/base-datetime.component.tsx": "import React from 'react';\nimport { View, Text, Platform, TouchableOpacity, ViewStyle, DimensionValue, LayoutChangeEvent } from 'react-native';\nimport moment from 'moment';\nimport DateTimePicker, { DateTimePickerEvent } from '@react-native-community/datetimepicker';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\n\nimport WmDatetimeProps from './datetime/datetime.props';\nimport { DEFAULT_CLASS, WmDatetimeStyles } from './datetime/datetime.styles';\nimport WebDatePicker from './date-picker.component';\nimport { isEqual, isNumber, isString } from 'lodash-es';\nimport { ModalConsumer, ModalOptions, ModalService } from '@wavemaker/app-rn-runtime/core/modal.service';\nimport { isDateFormatAsPerPattern, validateField } from '@wavemaker/app-rn-runtime/core/utils';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility'; \nimport { FloatingLabel } from '@wavemaker/app-rn-runtime/core/components/floatinglabel.component';\nimport AppI18nService from '@wavemaker/app-rn-runtime/runtime/services/app-i18n.service';\nimport WmButton from '@wavemaker/app-rn-runtime/components/basic/button/button.component';\nimport WmDatePickerModal from './wheelpickermodal/date/date-picker-modal.component';\nimport WmTimePickerModal from './wheelpickermodal/time/time-picker-modal.component';\nimport { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\nimport { WmSkeletonStyles } from '../../basic/skeleton/skeleton.styles';\n\nexport class BaseDatetimeState extends BaseComponentState<WmDatetimeProps> {\n  showDatePicker = false;\n  showDatePickerModal = false;\n  showTimePickerModal = false;\n  dateValue: Date =  null as any;\n  displayValue: string = null as any;\n  isFocused = false;\n  timerId: NodeJS.Timer = null as any;\n  isValid: boolean = true;\n  errorType = '';\n}\n\nconst CURRENT_DATE = 'CURRENT_DATE';\nconst CURRENT_TIME = 'CURRENT_TIME';\n\nexport default abstract class BaseDatetime extends BaseComponent<WmDatetimeProps, BaseDatetimeState, WmDatetimeStyles> {\n  clearBtnClicked = false;\n  modes = [] as string[];\n  nativeModalOptions: ModalOptions = {} as any;\n  prevDatavalue: any;\n\n  constructor(props: WmDatetimeProps, defaultClass = DEFAULT_CLASS, defaultProps = new WmDatetimeProps(), defaultState= new BaseDatetimeState()) {\n    super(props, defaultClass, defaultProps, defaultState);\n  }\n\n  format(date: Date | number | undefined, format: string) {\n    if (format === 'timestamp') {\n      return date instanceof Date ? '' + date.getTime() : date;\n    }\n    \n    // Convert moment formatting with respect to the current local.\n    moment.locale(this.props.locale ?? 'en');\n    return date && moment(date).format(format);\n  }\n\n  parse(date: string | number, format: string) {\n    if (format === 'timestamp') {\n      if (isString(date)) {\n        return new Date(parseInt(date));\n      }\n      if (isNumber(date)) {\n        return new Date(date);\n      }\n    }\n    return date && moment(date, format).toDate();\n  }\n\n  private monitorAndUpdateCurrentTime() {\n    this.stopCurrentTimeMonitor();\n    const timerId = setInterval(() => {\n      this.updateState({\n        props: {\n          readonly: true,\n          datavalue: Date.now()\n        },\n        timerId: timerId\n      } as any as BaseDatetimeState);\n    }, 1000);\n  }\n\n  private stopCurrentTimeMonitor() {\n    if (this.state.timerId) {\n      clearInterval(this.state.timerId as any);\n    }\n  }\n\n  convertTimezone(date: any){ \n    const timezone = AppI18nService.getTimezone();\n    if (timezone) {\n      const parsedDateString = new Date(date).toLocaleString(this.props.locale ? this.props.locale : 'en-us', { timeZone: timezone });\n      return moment(parsedDateString, 'M/D/YYYY, h:mm:ss A');\n    }\n    else {\n      return null;\n    }\n  }\n\n  rtlSanityCheck(text: any) {\n    return text?.replace(/[\\u200E\\u200F\\u202B\\u202C]/g, '');\n  }\n  \n  momentPattern(pattern : String) {\n    const removeSpecialMarks = this.rtlSanityCheck(pattern);\n    return removeSpecialMarks?.replaceAll('y', 'Y').replaceAll('d', 'D');\n  }\n\n  onPropertyChange(name: string, $new: any, $old: any) {\n    super.onPropertyChange(name, $new, $old);\n    const props = this.state.props;\n    switch(name) {\n      //@ts-ignore\n      case 'datavalue':\n        this.prevDatavalue = $old;\n        if (props.datavalue === CURRENT_TIME) {\n          this.monitorAndUpdateCurrentTime();\n        }\n      case 'datepattern':\n      case 'outputformat':\n        if (props.datavalue && this.momentPattern(props.outputformat as String) && this.momentPattern(props.datepattern as String)) {\n          let datavalue: any = props.datavalue;\n          if (datavalue === CURRENT_DATE || datavalue === CURRENT_TIME) {\n            datavalue = new Date() as any;\n          }\n          const date = isString(datavalue) ? this.parse(datavalue as string, this.momentPattern(props.outputformat as String)) : datavalue;\n          datavalue = this.convertTimezone(datavalue);\n\n          console.log(\"===== output value ======\", date.toDateString(),  datavalue);\n\n          this.updateState({\n            dateValue : date,\n            displayValue: this.format(datavalue?datavalue:date as any, this.momentPattern(props.datepattern as String))\n          } as BaseDatetimeState);\n        } else {\n          this.updateState({\n            dateValue : null as any,\n            displayValue: null as any\n          } as BaseDatetimeState);\n        }\n        this.props.onFieldChange && this.props.onFieldChange('datavalue', props.datavalue, this.prevDatavalue);\n        break;\n      case 'mindate':\n        if (isString($new)) {\n          const minDateVal = ($new === CURRENT_DATE || $new === CURRENT_TIME) ? new Date() : props.mindate;\n          // * check if supplied mindate is as per datepattern\n          const isMinMatchingPattern = minDateVal\n            ? isDateFormatAsPerPattern(this.momentPattern(props.datepattern as String), minDateVal)\n            : false;\n          // * min date formatted as per datepattern\n          const minDatePatternFormatted = minDateVal && isMinMatchingPattern ? moment(\n            moment(\n              minDateVal,\n              this.momentPattern(props.datepattern as String)\n            ).format('YYYY-MM-DD')\n          ) : null;\n          // * min date formatted as per ISO, if mindate supplied is not as per datepattern\n          const formattedMinDate = minDatePatternFormatted && isMinMatchingPattern\n            ? minDatePatternFormatted.toDate()\n            : moment(minDateVal).toDate();\n          this.updateState({\n            props: {\n              mindate: formattedMinDate\n            }\n          } as BaseDatetimeState);\n        }\n        break;\n      case 'maxdate':\n        if (isString($new)) {\n          const maxDateVal = ($new === CURRENT_DATE || $new === CURRENT_TIME) ? new Date() : props.maxdate;\n          // * check if supplied maxdate is as per datepattern\n          const isMaxMatchingPattern = maxDateVal\n            ? isDateFormatAsPerPattern(this.momentPattern(props.datepattern as String), maxDateVal)\n            : false;\n          // * max date formatted as per datepattern\n          const maxDatePatternFormatted = maxDateVal && isMaxMatchingPattern ? moment(\n            moment(\n              maxDateVal,\n              this.momentPattern(props.datepattern as String)\n            ).format('YYYY-MM-DD')\n          ) : null;\n          // * max date formatted as per ISO, if maxdate supplied is not as per datepattern\n          const formattedMaxDate = maxDatePatternFormatted && isMaxMatchingPattern\n          ? maxDatePatternFormatted.toDate()\n          : moment(maxDateVal).toDate();\n\n          this.updateState({\n            props: {\n              maxdate: formattedMaxDate,\n            },\n          } as BaseDatetimeState);\n        }\n        break;\n      case 'readonly':\n        this.updateState({\n          props: {\n            disabled: $new\n          }\n        } as BaseDatetimeState)\n        break;\n    }\n  }\n\n  onDateChange($event: DateTimePickerEvent, date?: Date) {\n    const prevDate = this.format(this.state.dateValue,  this.momentPattern(this.state.props.outputformat as String) as string) || undefined;\n    this.validate(date);\n    this.modes.shift();\n    const newDate = this.format(date,  this.momentPattern(this.state.props.outputformat as String) as string)\n    this.updateState({\n      isFocused: false,\n      showDatePicker: !!this.modes.length,\n      props: {\n        datavalue: newDate,\n        timestamp: this.format(date, 'timestamp')\n      }\n    } as BaseDatetimeState, () => this.invokeEventCallback('onChange', [null, this, newDate, prevDate]));\n  }\n\n  onBlur() {\n    if (Platform.OS === 'web') {\n      this.validate(this.state.props.datavalue);\n      setTimeout(() => this.props.triggerValidation && this.props.triggerValidation());\n    }\n    this.invokeEventCallback('onBlur', [null, this]);\n  }\n\n  onFocus() {\n    if (!this.state.props.readonly) {\n      if (Platform.OS !== 'web' && this.state.props.mode === 'datetime') {\n        this.modes = ['date', 'time'];\n      } else {\n        this.modes = [this.state.props.mode];\n      }\n      this.updateState({showDatePicker: true, isFocused: true} as BaseDatetimeState);\n      if (this.state.props.mode === 'date') {\n        this.updateState({showDatePickerModal: true} as BaseDatetimeState);\n      }\n      if (this.state.props.mode === 'time') {\n        this.updateState({showTimePickerModal: true} as BaseDatetimeState);\n      }\n      if (this.state.props.mode === 'datetime') {\n        this.updateState({showDatePickerModal: true} as BaseDatetimeState);\n      }\n      this.invokeEventCallback('onFocus', [null, this]);\n    }\n  }\n\n  validate(value: any) {\n    const validationObj = validateField(this.state.props, value);\n    this.setState({\n      isValid: validationObj.isValid,\n      errorType: validationObj.errorType\n    } as BaseDatetimeState)\n  }\n\n  componentWillUnmount() {\n    super.componentWillUnmount();\n    this.stopCurrentTimeMonitor();\n  }\n\n  renderWebWidget(props: WmDatetimeProps) {\n    return (<WebDatePicker\n      mode={this.state.props.mode}\n      locale={props.locale}\n      value={this.state.dateValue || new Date()}\n      onDateChange={(date: Date) => this.onDateChange(null as any, date)}\n      onDismiss={() =>\n        this.updateState({\n          isFocused: false,\n          showDatePicker: false\n        } as BaseDatetimeState, () => this.onBlur())}\n      minimumDate={props.mindate as Date}\n      maximumDate={props.maxdate as Date}/>);\n  }\n\n  renderNativeWidget(props: WmDatetimeProps, onDismiss?: Function) {\n    return (<DateTimePicker\n      mode={this.modes[0] as any}\n      {...getAccessibilityProps(AccessibilityWidgetType.DATE, {...this.state.props})}\n      value={this.state.dateValue || new Date()}\n      is24Hour={true}\n      display='default'\n      onChange={(event: DateTimePickerEvent, date?: Date) => {\n        if (date && this.state.props.mode === 'datetime' && this.modes[0] === 'time') {\n          const dateSelected = this.state.dateValue;\n          date = moment(date)\n            .set('month', dateSelected.getMonth())\n            .set('year', dateSelected.getFullYear())\n            .set('date', dateSelected.getDate())\n            .toDate();\n        }\n        this.onDateChange(event, date || this.state.dateValue);\n        if (this.modes.length <= 1) {\n          this.onBlur();\n          onDismiss && onDismiss();\n        }\n      }}\n      minimumDate={props.mindate as Date}\n      maximumDate={props.maxdate as Date}\n    />\n    );\n  }\n\n  renderNativeIOSWidget(props: WmDatetimeProps, onDismiss?: Function) {\n    let date_change : any = undefined;\n    return (<View style={this.styles.dialog}>\n      <DateTimePicker\n        mode={this.modes[0] as any}\n        value={this.state.dateValue || new Date()}\n        is24Hour={true}\n        display='spinner'\n        onChange={(event: DateTimePickerEvent, date?: Date) => {\n          if (date && this.state.props.mode === 'datetime' && this.modes[0] === 'time') {\n            const dateSelected = this.state.dateValue;\n            date = moment(date)\n              .set('month', dateSelected.getMonth())\n              .set('year', dateSelected.getFullYear())\n              .set('date', dateSelected.getDate())\n              .toDate();\n          }\n          date_change = date;\n        }}\n        minimumDate={props.mindate as Date}\n        maximumDate={props.maxdate as Date}\n      />\n      <View style={this.styles.actionWrapper}>\n        <WmButton styles={this.styles.selectBtn} caption='Select' onTap={() => {\n          this.onDateChange(null as any, date_change || this.state.dateValue || new Date());\n          if (this.modes.length <= 1) {\n            this.onBlur();\n            onDismiss && onDismiss();\n          }\n        }} />\n        <WmButton styles={this.styles.cancelBtn} caption='Cancel' onTap={() => {\n          this.modes.shift();\n          this.onDateChange(null as any, this.state.dateValue || undefined);\n          this.onBlur();\n          onDismiss && onDismiss();\n        }} />\n      </View>\n    </View>\n    );\n  }\n\n  renderNativeIOSWidgetWithModal(props: WmDatetimeProps) {\n    return (<ModalConsumer>{(modalService: ModalService) => {\n      this.nativeModalOptions.content = (<>\n        {this.renderNativeIOSWidget(props, () => modalService.hideModal(this.nativeModalOptions))}\n        </>);\n      this.nativeModalOptions.centered = true;\n      this.nativeModalOptions.onClose = () => {\n        this.onBlur();\n      };\n      modalService.showModal(this.nativeModalOptions);\n      return null;\n    }}</ModalConsumer>);\n  }\n\n  renderNativeWidgetWithModal(props: WmDatetimeProps) {\n    return (<ModalConsumer>{(modalService: ModalService) => {\n      this.nativeModalOptions.content = (<>\n        {this.renderNativeWidget(props, () => modalService.hideModal(this.nativeModalOptions))}\n        </>);\n      this.nativeModalOptions.centered = true;\n      this.nativeModalOptions.onClose = () => {\n        this.onBlur();\n      };\n      modalService.showModal(this.nativeModalOptions);\n      return null;\n    }}</ModalConsumer>);\n  }\n\n  addTouchableOpacity(props: WmDatetimeProps, children: React.JSX.Element, styles?: any, handleLayout?: any) : React.ReactNode{\n    const hint = children?.props?.hint;\n    const accessibilityProps = hint ? {accessible: true, accessibilityHint: hint} : {};\n\n    return (\n      <TouchableOpacity \n        {...this.getTestPropsForAction()} \n        {...accessibilityProps}\n        onLayout={handleLayout}\n        style={styles} onPress={() => {\n        if (!props.readonly) {\n          this.onFocus();\n        }\n        this.invokeEventCallback('onTap', [null, this]);\n      }}>\n        {children}\n      </TouchableOpacity>\n    );\n  }\n\n  getIcon() {\n    if (this.state.props.mode === 'time') {\n      return 'wm-sl-l sl-time'\n    }\n    return 'wm-sl-l sl-calendar';\n  }\n\n  public renderSkeleton(props: WmDatetimeProps): React.ReactNode {\n    return (\n      this.state.props.floatinglabel || this.state.displayValue || this.state.props.placeholder ? \n      <View style={{display:'flex',...this.styles.container,...this.styles.root}}>\n        {createSkeleton(this.theme, {} as WmSkeletonStyles, {\n        ...this.styles.skeleton.root\n      })}\n      {createSkeleton(this.theme, {} as WmSkeletonStyles, {\n        ...this.styles.skeleton.icon\n      })}\n      </View> : null\n    )}\n    \n  renderWidget(props: WmDatetimeProps) {\n    const is12HourFormat = props?.datepattern && /hh:mm(:ss|:sss)? a/.test(props.datepattern);\n    const is24Hour = is12HourFormat ? false : props.is24hour;\n    return ( \n        this.addTouchableOpacity(props, (\n        <View style={[this.styles.root, this.state.isValid ? {} : this.styles.invalid, this.state.isFocused ? this.styles.focused : null]}>\n          {this._background}\n            {props.floatinglabel ? (\n            <FloatingLabel\n              moveUp={!!(props.datavalue || this.state.isFocused)}\n              label={props.floatinglabel ?? props.placeholder} \n              style={{\n                ...(this.styles.floatingLabel || []),\n                ...(this.state.isFocused ? (this.styles.activeFloatingLabel || {}) : {})\n              }}\n              />\n          ) : null}\n            <View style={this.styles.container}>\n              {this.addTouchableOpacity(props, (\n                <Text style={[\n                  this.styles.text,\n                  this.state.displayValue ? {} : this.styles.placeholderText\n                ]}\n                {...this.getTestPropsForLabel()}>\n                  {this.state.displayValue \n                    || (props.floatinglabel ? ''  : this.state.props.placeholder)}\n                </Text>\n              ), [{ flex: 1}, this.isRTL?{flexDirection:'row', textAlign:'right'}:{}] )}\n              {(!props.readonly && props.datavalue &&\n                (<WmIcon iconclass=\"wi wi-clear\"\n                styles={{color: this.styles.text.color, ...this.styles.clearIcon}}\n                id={this.getTestId('clearicon')}\n                accessibilitylabel={`clear ${props?.mode}`}\n                onTap={() => {\n                  this.onDateChange(null as any, null as any);\n                  this.clearBtnClicked = true;\n                }}/>)) || null}\n              {this.addTouchableOpacity(props, (\n                <WmIcon iconclass={this.getIcon()} styles={{color: this.styles.text.color, ...this.styles.calendarIcon}} hint={props?.hint} id={this.getTestId('calendericon')}/>\n              ))}\n            </View>\n          {\n            this.state.showDatePicker\n            && ((Platform.OS === 'web' && this.renderWebWidget(props))\n              || (!props.iswheelpicker && Platform.OS === 'android' && this.renderNativeWidget(props))\n              || (!props.iswheelpicker && Platform.OS === 'ios' && this.renderNativeIOSWidgetWithModal(props)))\n          }\n          {(Platform.OS !== 'web' && props.iswheelpicker && this.state.showDatePickerModal) && (\n            <WmDatePickerModal\n              isVisible={this.state.showDatePickerModal}\n              onClose={() => this.updateState({showDatePickerModal: false} as BaseDatetimeState)}\n              minDate={props.mindate}\n              maxDate={props.maxdate}\n              selectedDate={this.state.dateValue}\n              onSelect={(date: Date) => {\n                this.onDateChange(null as any, date);\n                this.updateState({\n                  isFocused: false,\n                  showDatePickerModal: false\n                } as BaseDatetimeState, () => {\n                  setTimeout(() => {\n                    this.onBlur();\n                  }, 10);\n                  \n                  // * showing time picker after selecting date in datetime mode\n                  if (this.state.props.mode === \"datetime\") {\n                    this.setState({\n                      showTimePickerModal: true,\n                    })\n                  }\n                });\n              }}\n              onCancel={() => {\n                // this.onDateChange(null as any, this.state.dateValue || undefined);\n                this.updateState({\n                  isFocused: false,\n                  showDatePickerModal: false\n                } as BaseDatetimeState, () => this.onBlur());\n              }}\n              dateheadertitle={props.dateheadertitle}\n              dateconfirmationtitle={props.dateconfirmationtitle}\n              datecanceltitle={props.datecanceltitle}\n            />\n          )}\n          {(Platform.OS !== 'web' && props.iswheelpicker && this.state.showTimePickerModal) && (\n            <WmTimePickerModal\n              selectedDateTime={this.state.dateValue}\n              is24Hour={is24Hour}\n              isVisible={this.state.showTimePickerModal}\n              onClose={() => this.updateState({isFocused: false, showTimePickerModal: false} as BaseDatetimeState)}\n              onSelect={(time: Date) => {\n                this.onDateChange(null as any, time);\n                this.updateState({\n                  isFocused: false,\n                  showTimePickerModal: false\n                } as BaseDatetimeState, () =>   {\n                  setTimeout(() => {\n                    this.onBlur()\n                  }, 10);  \n                });\n              }}\n              onCancel={() => {\n                // this.onDateChange(null as any, this.state.dateValue || undefined);\n                this.updateState({\n                  isFocused: false,\n                  showTimePickerModal: false\n                } as BaseDatetimeState, () => {\n                  this.onBlur();\n                  this.modes.shift();\n                });\n              }}\n              timeheadertitle={props.timeheadertitle}\n              timeconfirmationtitle={props.timeconfirmationtitle}\n              timecanceltitle={props.timecanceltitle}\n            />\n          )}\n        </View>\n        ), {} , this.handleLayout)\n    );\n  }\n}\n\n", "wavemaker-rn-runtime/src/components/input/epoch/wheel-time-picker.component.tsx": "import React, { Component } from 'react';\nimport { PixelRatio, StyleSheet, View } from 'react-native';\nimport WmWheelScrollPicker from './wheelpicker/wheelpicker.component';\nimport {\n  get24Hours,\n  getDateTimeObject,\n  getHours,\n  getMinutes,\n  getTimeIndicators,\n} from '@wavemaker/app-rn-runtime/core/utils';\n\nexport class WmWheelTimePickerProps {\n  selectedTime?: Date = new Date();\n  is24Hour?: boolean = true;\n  onTimeChange?: (date: Date) => void;\n  itemHeight?: number = PixelRatio.roundToNearestPixel(50);\n  wrapperHeight?: number = PixelRatio.roundToNearestPixel(150);\n}\n\nexport class WmWheelTimePickerState {}\n\nexport class WmWheelTimePicker extends Component<\n  WmWheelTimePickerProps,\n  WmWheelTimePickerState,\n  any\n> {\n  itemHeight: number;\n  wrapperHeight: number;\n  selectedHourIndex: number = 0;\n  selectedMinuteIndex: number = 0;\n  selectedTimeIndicatorIndex: number = 0;\n\n  constructor(props: WmWheelTimePickerProps) {\n    super(props);\n    const selectedTime = props.selectedTime || new Date();\n    const meridiem = selectedTime.getHours() >= 12 ? 'PM' : 'AM';\n\n    this.itemHeight =\n      PixelRatio.roundToNearestPixel(this.props.itemHeight || 50) ||\n      PixelRatio.roundToNearestPixel(50);\n    this.wrapperHeight =\n      PixelRatio.roundToNearestPixel(this.props.wrapperHeight || 150) ||\n      PixelRatio.roundToNearestPixel(150);\n    this.selectedHourIndex = props.is24Hour\n      ? selectedTime.getHours()\n      : (selectedTime.getHours() % 12 || 12) - 1;\n    this.selectedMinuteIndex = selectedTime.getMinutes();\n    this.selectedTimeIndicatorIndex = meridiem === 'AM' ? 0 : 1;\n  }\n\n  handleValueChange = (\n    valueType: 'hour' | 'minute' | 'meridiem',\n    value: string | number,\n    index: number\n  ) => {\n    switch (valueType) {\n      case 'hour':\n        this.selectedHourIndex = index;\n        break;\n      case 'minute':\n        this.selectedMinuteIndex = index;\n        break;\n      case 'meridiem':\n        this.selectedTimeIndicatorIndex = index;\n        break;\n      default:\n        break;\n    }\n\n    const selectedTime = this.props.selectedTime || new Date();\n    const date = selectedTime.getDate();\n    const month = selectedTime.getMonth();\n    const year = selectedTime.getFullYear();\n\n    let selected24HourFormat;\n    if (!this.props.is24Hour) {\n      // * when time picker is in 12 hour format\n      const selected12HourFormat = Number(getHours()[this.selectedHourIndex]);\n      selected24HourFormat =\n        this.selectedTimeIndicatorIndex === 0\n          ? selected12HourFormat\n          : selected12HourFormat + 12;\n    } else {\n      // * when time picker is in 24 hour format\n      selected24HourFormat = Number(get24Hours()[this.selectedHourIndex]);\n    }\n\n    const selectedMinute = Number(getMinutes()[this.selectedMinuteIndex]);\n\n    const dateObj = getDateTimeObject(\n      date,\n      month,\n      year,\n      selected24HourFormat,\n      selectedMinute\n    );\n\n    this.props?.onTimeChange?.(dateObj);\n  };\n\n  render() {\n    return (\n      <View style={styles.root}>\n        <WmWheelScrollPicker\n          data={this.props.is24Hour ? get24Hours() : getHours()}\n          wrapperHeight={this.wrapperHeight}\n          itemHeight={this.itemHeight}\n          selectedIndex={this.selectedHourIndex}\n          onValueChange={(value: string | number, index: number) => {\n            this.handleValueChange('hour', value, index);\n          }}\n        />\n        <View style={styles.middle}>\n          <WmWheelScrollPicker\n            data={getMinutes()}\n            wrapperHeight={this.wrapperHeight}\n            itemHeight={this.itemHeight}\n            selectedIndex={this.selectedMinuteIndex}\n            onValueChange={(value: string | number, index: number) => {\n              this.handleValueChange('minute', value, index);\n            }}\n          />\n        </View>\n        {!this.props.is24Hour ? (\n          <WmWheelScrollPicker\n            data={getTimeIndicators()}\n            wrapperHeight={this.wrapperHeight}\n            itemHeight={this.itemHeight}\n            selectedIndex={this.selectedTimeIndicatorIndex}\n            onValueChange={(value: string | number, index: number) => {\n              this.handleValueChange('meridiem', value, index);\n            }}\n          />\n        ) : (\n          <></>\n        )}\n      </View>\n    );\n  }\n}\n\nexport default WmWheelTimePicker;\n\nconst styles = StyleSheet.create({\n  root: {\n    flexDirection: 'row',\n  },\n  middle: {\n    marginHorizontal: 15,\n  },\n});\n", "wavemaker-rn-runtime/src/components/input/epoch/wheel-date-picker.component.tsx": "import React, { Component } from 'react';\nimport { PixelRatio, StyleSheet, View } from 'react-native';\nimport WmWheelScrollPicker from './wheelpicker/wheelpicker.component'\nimport { getDateObject, getDates, getMonthIndex, getMonths, getYearRange ,getDaysInMonth} from '@wavemaker/app-rn-runtime/core/utils';\nimport moment from 'moment';\n\nexport class WmWheelDatePickerProps {\n  minDate?: Date | string;\n  maxDate?: Date | string;\n  selectedDate?: Date = new Date();\n  onDateChange?: (date: Date) => void;\n  itemHeight?: number = PixelRatio.roundToNearestPixel(50);\n  wrapperHeight?: number = PixelRatio.roundToNearestPixel(150);\n}\n\nexport const START_DATE = {\n  'date': 1,\n  'month': 0,\n  'year': 1950,\n};\n\nexport const END_DATE = {\n  'date': 31,\n  'month': 11,\n  'year': 2060,\n};\n\nexport class WmWheelDatePickerState {}\n\nexport class WmWheelDatePicker extends Component<\n  WmWheelDatePickerProps,\n  WmWheelDatePickerState,\n  any\n> {\n  itemHeight: number;\n  wrapperHeight: number;\n  selectedDateIndex: number = 0;\n  selectedMonthIndex: number = 0;\n  selectedYearIndex: number = 0;\n  dateData: number[] = [];\n  monthData: string[] = [];\n  yearData: number[] = [];\n  defaultSelectedDate: Date;\n  localSelectedDate: Date | string = '';\n  monthValue: number = 0;\n  yearValue: string = '';\n\n  constructor(props: WmWheelDatePickerProps) {\n    super(props);\n    const minDate = this.props.minDate ? new Date(this.props.minDate) : new Date(START_DATE.year, START_DATE.month, START_DATE.date);\n    const maxDate = this.props.maxDate ? new Date(this.props.maxDate) : new Date(END_DATE.year, END_DATE.month, END_DATE.date);\n    let selectedDate = this.props.selectedDate ? new Date(this.props.selectedDate) : new Date();\n\n    if (selectedDate < minDate) selectedDate = minDate;\n    if (selectedDate > maxDate) selectedDate = maxDate;\n\n    this.itemHeight =\n    PixelRatio.roundToNearestPixel(this.props.itemHeight || 50) || PixelRatio.roundToNearestPixel(50);\n    this.wrapperHeight =\n    PixelRatio.roundToNearestPixel(this.props.wrapperHeight || 150) || PixelRatio.roundToNearestPixel(150);\n\n    // * Initial values\n    this.defaultSelectedDate = selectedDate;\n    this.localSelectedDate = selectedDate;\n    this.monthValue = selectedDate.getMonth();\n    this.yearValue = selectedDate.getFullYear()?.toString();\n\n    const selectedYear = selectedDate.getFullYear();\n    const selectedMonth = selectedDate.getMonth();\n    const selectedDay = selectedDate.getDate();\n\n    // Generate valid year range\n    const minYear = minDate.getFullYear();\n    const maxYear = maxDate.getFullYear();\n    this.yearData = getYearRange(minYear, maxYear);\n    this.selectedYearIndex = this.yearData.indexOf(selectedYear);\n\n    // Generate valid months based on selected year\n    let minMonth = 0;\n    let maxMonth = 11;\n    if (selectedYear === minYear) minMonth = minDate.getMonth();\n    if (selectedYear === maxYear) maxMonth = maxDate.getMonth();\n    this.monthData = getMonths(minMonth, maxMonth);\n    this.selectedMonthIndex = this.monthData.indexOf(getMonths(0, 11)[selectedMonth]);\n\n    // Generate valid days based on selected year & month\n    let minDay = 1;\n    let maxDay = getDaysInMonth(selectedMonth + 1, selectedYear);\n    if (selectedYear === minYear && selectedMonth === minMonth) minDay = minDate.getDate();\n    if (selectedYear === maxYear && selectedMonth === maxMonth) maxDay = maxDate.getDate();\n    this.dateData = getDates(minDay, maxDay);\n    this.selectedDateIndex = this.dateData.indexOf(selectedDay);\n  }\n\ngetMinValue = (type: 'date' | 'month' | 'year') => {\n  if (!this.props.minDate) return START_DATE[type];\n\n  const minDate = new Date(this.props.minDate);\n  switch (type) {\n    case 'date':\n      return minDate.getDate();\n    case 'month':\n      return minDate.getMonth();\n    case 'year':\n      return minDate.getFullYear();\n    default:\n      return 0;\n  }\n};\n\ngetMaxValue = (type: 'date' | 'month' | 'year') => {\n  if (!this.props.maxDate) return END_DATE[type];\n\n  const maxDate = new Date(this.props.maxDate);\n  switch (type) {\n    case 'date':\n      return maxDate.getDate();\n    case 'month':\n      return maxDate.getMonth();\n    case 'year':\n      return maxDate.getFullYear();\n    default:\n      return 0;\n  }\n};\n\n\n  handleValueChange = (valueType: 'date' | 'month' | 'year', value: string | number, index: number) => {\n      let indexValue = Object.is(index,-0)? 0 : index;\n      switch (valueType) {\n        case 'date':\n          this.selectedDateIndex = indexValue;\n          break;\n        case 'month':\n          this.monthValue = getMonthIndex(value?.toString());\n          this.selectedMonthIndex = indexValue;\n          break;\n        case 'year':\n          this.selectedYearIndex = indexValue;\n          break;\n      }\n    \n      const minYear = this.getMinValue('year');\n      const maxYear = this.getMaxValue('year');\n      const selectedYear = getYearRange(minYear, maxYear)[this.selectedYearIndex];\n    \n      // Restrict months dynamically\n      let minMonth = 0;\n      let maxMonth = 11;\n      if (selectedYear === minYear) minMonth = this.getMinValue('month');\n      if (selectedYear === maxYear) maxMonth = this.getMaxValue('month');\n    \n      // Update month data dynamically\n      this.monthData = getMonths(minMonth, maxMonth);\n\n      // Ensure selected month is within range\n      let minDate = 1;\n      let maxDate: number = 31;\n      \n      if (this.monthValue > maxMonth) {\n        this.selectedMonthIndex = maxMonth;\n      }\n\n      maxDate = getDaysInMonth(\n        getMonthIndex(this.monthData[this.selectedMonthIndex]) + 1,\n        selectedYear\n      );\n\n      if (this.monthValue < minMonth) {\n        this.monthValue = minMonth;\n        maxDate = getDaysInMonth(this.monthValue + 1, selectedYear);\n        \n      }\n    \n      // Restrict days dynamically\n      const selectedMonth = this.selectedMonthIndex;\n      if (selectedYear === minYear && this.monthValue === minMonth) minDate = this.getMinValue('date');\n      \n      if (selectedYear === maxYear && selectedMonth === maxMonth) maxDate = this.getMaxValue('date');\n      \n      if(maxYear === minYear && this.monthValue === maxMonth) maxDate = this.getMaxValue('date');\n    \n      // Update date data dynamically\n      this.dateData = getDates(minDate, maxDate);\n    \n      // Ensure selected date is within range\n      if (this.selectedDateIndex > maxDate - 1) this.selectedDateIndex = maxDate - 1;\n    \n      const selectedDate = this.dateData[this.selectedDateIndex] || this.dateData[this.dateData.indexOf(this.selectedDateIndex+1)];;\n    \n      \n      // Create new selected date\n      const dateObj = getDateObject(selectedDate, getMonthIndex(this.monthData[this.selectedMonthIndex]), selectedYear);\n      this.localSelectedDate = dateObj;\n    \n      this.props?.onDateChange?.(this.localSelectedDate);\n    };\n    \n  render() {\n    return (\n      <View style={styles.root}>\n        <WmWheelScrollPicker\n          data={this.dateData}\n          wrapperHeight={this.wrapperHeight}\n          itemHeight={this.itemHeight}\n          selectedIndex={this.selectedDateIndex}\n          onValueChange={(value, index) =>\n            this.handleValueChange('date', value, index)\n          }\n        />\n        <View style={styles.middle}>\n          <WmWheelScrollPicker\n            data={this.monthData}\n            wrapperHeight={this.wrapperHeight}\n            itemHeight={this.itemHeight}\n            selectedIndex={this.selectedMonthIndex}\n            onValueChange={(value, index) => \n              this.handleValueChange('month', value, index)\n            }\n          />\n        </View>\n        <WmWheelScrollPicker\n          data={getYearRange(this.getMinValue('year'), this.getMaxValue('year'))}\n          wrapperHeight={this.wrapperHeight}\n          itemHeight={this.itemHeight}\n          selectedIndex={this.selectedYearIndex}\n          onValueChange={(value, index) => \n            this.handleValueChange('year', value, index)\n          }\n        />\n      </View>\n    );\n  }\n}\n\nexport default WmWheelDatePicker;\n\nconst styles = StyleSheet.create({\n  root: {\n    flexDirection: 'row',\n  },\n  middle: {\n    marginHorizontal: 15,\n  },\n});\n", "wavemaker-rn-runtime/src/components/input/epoch/date-picker.component.tsx": "import React, { ReactNode } from 'react';\nimport { View } from 'react-native';\nimport { DatePickerModalContent, TimePickerModal } from 'react-native-paper-dates';\nimport { BaseStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { ModalConsumer, ModalService, ModalOptions } from '@wavemaker/app-rn-runtime/core/modal.service';\nimport ThemeVariables from '@wavemaker/app-rn-runtime/styles/theme.variables';\n\nexport class DatePickerProps {\n    mode?: 'date' | 'time' | 'datetime' | string = 'datetime';\n    value?: Date = new Date();\n    minimumDate?: Date = null as any;\n    maximumDate?: Date = null as any;\n    onDateChange?: Function = null as any;\n    onDismiss?: Function = null as any;\n    locale: string = '';\n}\n\nexport class DatePickerState {\n    public value?: Date = null as any;\n    public modalOptions: ModalOptions = {} as any;\n    public showDatePicker = false;\n    public showTimePicker = false;\n}\n\ntype DatePickerStyles = BaseStyles & {\n    modal: AllStyle,\n    content: AllStyle\n};\n\nconst styles: DatePickerStyles = {\n    root: {},\n    text: {},\n    modal: {},\n    content: {\n        backgroundColor: ThemeVariables.INSTANCE.datepickerBgColor\n    }\n};\n\nexport default class DatePickerComponnent extends React.Component<DatePickerProps, DatePickerState, any> {\n    timemodal = null as any;\n    constructor(props: DatePickerProps) {\n        super(props);\n        this.state = {\n            showDatePicker: this.props.mode !== 'time',\n            showTimePicker: this.props.mode === 'time',\n            value: props.value,\n            modalOptions: {}\n        } as DatePickerState;\n    }\n\n    prepareModalOptions(content: ReactNode) {\n        const o = this.state.modalOptions;\n        o.content = content;\n        o.modalStyle = styles.modal;\n        o.centered = true;\n        return o;\n    }\n\n    public onDateChange(date: Date | undefined, modalService: ModalService) {\n        const old = this.state.value;\n        if (old && date) {\n            date.setHours(old.getHours());\n            date.setMinutes(old.getMinutes());\n        }\n        if (this.props.mode === 'date') {\n            this.setState({\n                value : date,\n                showDatePicker: false,\n                showTimePicker: false\n            }, () => {\n                this.props.onDateChange && this.props.onDateChange(this.state.value);\n                this.close(modalService);\n            });\n        } else if (date) {\n            this.setState({\n                value : date,\n                showDatePicker: false,\n                showTimePicker: true\n            }, () => {\n                modalService.refresh();\n            });\n        }\n    }\n\n    public onTimeChange(hours: number, minutes: number, modalService: ModalService) {\n        const date = this.state.value || new Date();\n        date.setHours(hours);\n        date.setMinutes(minutes);\n        this.setState({\n            value : date,\n            showDatePicker: false,\n            showTimePicker: false\n        }, () => {\n            this.props.onDateChange && this.props.onDateChange(this.state.value);\n            this.timemodal = null;\n            this.close(modalService);\n        });\n    }\n\n    prepareTimeModal(modalService: ModalService) {\n        if (!this.timemodal) {\n            this.timemodal = (\n            <View style={{height: 600, marginTop: 600}}>\n                {\n                    React.createElement(TimePickerModal, {\n                        hours : this.props.value?.getHours() || 0,\n                        minutes : this.props.value?.getMinutes() || 0,\n                        visible : true,\n                        onDismiss : () => this.close(modalService),\n                        onConfirm: (params) => {\n                            this.onTimeChange(params.hours, params.minutes, modalService);\n                        }\n                    })\n                }\n            </View>);\n        }\n        return this.timemodal;\n    }\n\n    close(modalService: ModalService) {\n        modalService.hideModal(this.state.modalOptions);\n        this.props.onDismiss && this.props.onDismiss();\n    }\n\n    render() {\n        return (this.state.showDatePicker || this.state.showTimePicker) ? (\n        <ModalConsumer>\n            {(modalService: ModalService) => {\n                modalService.showModal(this.prepareModalOptions(\n                    (<View style={this.state.showDatePicker ? styles.content: {}}>\n                        {this.state.showDatePicker && \n                            React.createElement(DatePickerModalContent, {\n                                mode: \"single\",\n                                date: this.props.value,\n                                onDismiss: () => this.close(modalService),\n                                onConfirm: (params) => this.onDateChange(params.date, modalService),\n                                validRange: {\n                                    startDate: this.props.minimumDate,\n                                    endDate: this.props.maximumDate\n                                },\n                                locale: this.props.locale})}\n                        {this.state.showTimePicker && this.prepareTimeModal(modalService)}\n                    </View>)\n                ));\n                return null;\n            }}\n        </ModalConsumer>): null;\n    }\n}\n", "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.component.tsx": "import WmDatetimeProps from './datetime.props';\nimport { DEFAULT_CLASS, } from './datetime.styles';\nimport BaseDatetime from '../base-datetime.component';\n\nexport default class WmDatetime extends BaseDatetime {\n\n  constructor(props: WmDatetimeProps) {\n    super(props, DEFAULT_CLASS, new WmDatetimeProps());\n  }\n\n  public getStyleClassName(): string | undefined {\n    const classes = [];\n    if (this.state.props.floatinglabel) {\n      classes.push('app-datetime-with-label'); \n    }\n    classes.push(super.getStyleClassName());\n    return classes.join(' ');\n  }\n\n  renderWidget(props: WmDatetimeProps) {\n    return super.renderWidget(props);\n  }\n}", "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.styles.ts": "import BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmIconStyles } from '@wavemaker/app-rn-runtime/components/basic/icon/icon.styles';\nimport { TextStyle, Platform, ViewStyle } from 'react-native';\nimport { WmButtonStyles } from '@wavemaker/app-rn-runtime/components/basic/button/button.styles';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmDatetimeStyles = BaseStyles & {\n    focused: AllStyle,\n    container: AllStyle,\n    placeholderText: TextStyle,\n    invalid: AllStyle,\n    clearIcon: WmIconStyles,\n    calendarIcon: WmIconStyles,\n    floatingLabel: TextStyle & ViewStyle,\n    activeFloatingLabel: AllStyle\n    actionWrapper: ViewStyle,\n    selectBtn: WmButtonStyles,\n    cancelBtn: WmButtonStyles,\n    dialog: AllStyle,\n    skeleton: WmSkeletonStyles;\n};\n\nexport const DEFAULT_CLASS = 'app-datetime';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmDatetimeStyles = defineStyles({\n        root: {\n            paddingTop: 8,\n            paddingBottom: 8,\n            paddingLeft: 16,\n            paddingRight: 16,\n            borderWidth: 1,\n            borderStyle: 'solid',\n            borderRadius: 6,\n            backgroundColor: themeVariables.inputBackgroundColor,\n            borderColor: themeVariables.inputBorderColor,\n            justifyContent: 'center',\n            width: '100%'\n        },\n        focused: {\n\n        },\n        invalid: {\n            borderBottomColor: themeVariables.inputInvalidBorderColor\n        },\n        placeholderText: {\n          color: themeVariables.inputPlaceholderColor\n        },\n        container: {\n            flexDirection: 'row',\n            alignItems: 'center'\n        },\n        text: {\n            fontSize: 16,\n            color: themeVariables.inputTextColor\n        },\n        calendarIcon: {\n            root: {\n                alignSelf: 'center'\n            },\n            icon: {\n                fontSize: 24\n            }\n        },\n        clearIcon:  {\n            root : {\n                alignSelf: 'center',\n                justifyContent: 'center',\n                marginRight: 4,\n                height: 24,\n                width: 24,\n                borderRadius: 16,\n                backgroundColor: themeVariables.inputDisabledBgColor\n            },\n            icon: {\n                fontSize: 16,\n                paddingRight: 0,\n                fontWeight: 'bold'\n            }\n        } as WmIconStyles,\n        dialog:{\n            minWidth: 320,\n            paddingTop: 24,\n            paddingBottom: 24,\n            paddingLeft: 24,\n            paddingRight: 24,\n            elevation: 6,\n            width: '90%',\n            maxHeight: themeVariables.maxModalHeight,\n            backgroundColor: themeVariables.dialogBackgroundColor,\n            borderRadius: 28\n        },\n        actionWrapper: {\n            flexDirection: 'row-reverse', \n            marginRight: 20,\n        },\n        selectBtn: {\n            root:{\n                paddingLeft: 12,\n                paddingRight: 12,\n            }\n        },\n        cancelBtn: {\n            root:{\n                paddingLeft: 12,\n                paddingRight: 12,\n            }\n        },\n        skeleton: {\n            root:{\n              height: 16,\n              borderRadius: 4,\n              marginRight:16,\n              width:'80%' \n            },\n            icon:{\n                width:32,\n                height:32,\n                borderRadius:4\n            }\n          } as any as WmSkeletonStyles,\n    }) as any as WmDatetimeStyles;\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n    addStyle(DEFAULT_CLASS + '-disabled', '', {\n        root : {\n        backgroundColor: themeVariables.inputDisabledBgColor\n        }\n    });\n    addStyle(DEFAULT_CLASS + '-rtl', '', Platform.OS==\"web\"?{\n        clearIcon: {\n        root: {\n            marginLeft: 4,\n            marginRight: 0\n        }\n    }\n  }:{});\n  addStyle(DEFAULT_CLASS + '-with-label', '', {\n    root:{\n        minHeight: 48,\n        paddingVertical: 16\n    },\n    floatingLabel: {\n        position: 'absolute',\n        top: 12,\n        left: 16,\n        fontSize: 14,\n        color: themeVariables.floatingLabelColor\n    },\n    activeFloatingLabel: {\n        color: themeVariables.activeFloatingLabelColor\n    }\n  } as any as WmDatetimeStyles);\n});", "wavemaker-rn-runtime/src/components/input/epoch/datetime/datetime.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { AccessibilityRole } from 'react-native';\n\nexport default class WmDatetimeProps extends BaseProps {\n  mode = 'datetime';\n  datavalue?: string | Date | number = undefined as any;\n  datepattern?: string = '';\n  outputformat?: string = 'timestamp';\n  mindate?: string | Date = undefined as any;\n  maxdate?: string | Date = undefined as any;\n  placeholder? = 'Select date time';\n  readonly? = false;\n  onFieldChange?: any;\n  locale: string = '';\n  timestamp?: any;\n  triggerValidation?: any;\n  floatinglabel?: string;\n  accessibilitylabel?: string = undefined;\n  hint?: string = undefined;\n  accessibilityrole?: AccessibilityRole;\n  accessibilitylabelledby?: string = undefined;\n  iswheelpicker?: boolean = true;\n  is24hour?: boolean = true;\n  dateheadertitle?: string = \"Select Date\";\n  dateconfirmationtitle?: string = \"Select\";\n  datecanceltitle?: string = \"Cancel\";\n  timeheadertitle?: string = \"Select Time\";\n  timeconfirmationtitle?: string = \"Select\";\n  timecanceltitle?: string = \"Cancel\";\n}\n", "wavemaker-rn-runtime/src/components/input/epoch/date/date.props.ts": "import WmDatetimeProps from '../datetime/datetime.props';\n\nexport default class WmDateProps extends WmDatetimeProps {\n  constructor() {\n    super();\n    this.mode = 'date';\n    this.placeholder = 'Select date';\n    this.datepattern = '';\n    this.outputformat = 'YYYY-MM-DD';\n  }\n}", "wavemaker-rn-runtime/src/components/input/epoch/date/date.component.tsx": "import WmDateProps from './date.props';\nimport { DEFAULT_CLASS } from './date.styles';\nimport BaseDatetime from '../base-datetime.component';\n\nexport default class WmDate extends BaseDatetime {\n\n  constructor(props: WmDateProps) {\n    super(props, DEFAULT_CLASS, new WmDateProps());\n  }\n\n  public getStyleClassName(): string | undefined {\n    const classes = [];\n    if (this.state.props.floatinglabel) {\n      classes.push('app-date-with-label'); \n    }\n    classes.push(super.getStyleClassName());\n    return classes.join(' ');\n  }\n\n  renderWidget(props: WmDateProps) {\n    return super.renderWidget(props);\n  }\n}\n", "wavemaker-rn-runtime/src/components/input/epoch/date/date.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { WmDatetimeStyles, DEFAULT_CLASS as DATE_TIME_DEFAUlT_CLASS } from '../datetime/datetime.styles';\nimport { Platform } from 'react-native';\n\nexport type WmDateStyles = WmDatetimeStyles;\n\nexport const DEFAULT_CLASS = 'app-date';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  addStyle(DEFAULT_CLASS, DATE_TIME_DEFAUlT_CLASS, {});\n  addStyle(DEFAULT_CLASS + '-disabled', '', {\n      root : {\n        backgroundColor: themeVariables.inputDisabledBgColor\n      }\n  });\n  addStyle(DEFAULT_CLASS + '-rtl', '', Platform.OS==\"web\"?{\n    clearIcon: {\n        root: {\n            marginLeft: 4,\n            marginRight: 0\n        }\n    }\n  }:{});\n  addStyle(DEFAULT_CLASS + '-with-label', '', {\n    root:{\n      minHeight: 48,\n      paddingVertical: 16\n    },\n    floatingLabel: {\n      position: 'absolute',\n      top: 12,\n      left: 16,\n      fontSize: 14,\n      color: themeVariables.floatingLabelColor\n    },\n    activeFloatingLabel: {\n      color: themeVariables.activeFloatingLabelColor\n    }\n  } as any as WmDatetimeStyles);\n});", "wavemaker-rn-runtime/src/components/input/epoch/time/time.props.ts": "import WmDatetimeProps from '../datetime/datetime.props';\n\nexport default class WmDateProps extends WmDatetimeProps {\n  public timepattern = '';\n  constructor() {\n    super();\n    this.mode = 'time';\n    this.placeholder = 'Select time';\n    this.datepattern = this.timepattern;\n    this.outputformat = 'HH:mm:ss';\n  }\n}", "wavemaker-rn-runtime/src/components/input/epoch/time/time.component.tsx": "import WmTimeProps from './time.props';\nimport { DEFAULT_CLASS, } from './time.styles';\nimport BaseDatetime from '../base-datetime.component';\nimport { DateTimePickerEvent } from '@react-native-community/datetimepicker';\n\nexport default class WmTime extends BaseDatetime {\n\n  constructor(props: WmTimeProps) {\n    super(props, DEFAULT_CLASS, new WmTimeProps());\n  }\n\n  public getStyleClassName(): string | undefined {\n    const classes = [];\n    if (this.state.props.floatinglabel) {\n      classes.push('app-time-with-label'); \n    }\n    classes.push(super.getStyleClassName());\n    return classes.join(' ');\n  }\n\n  onDateChange($event: DateTimePickerEvent, date?: Date): void {\n    super.onDateChange($event, date);\n  }\n\n  get timestamp() {\n    return this.state.dateValue;\n  }\n\n  renderWidget(props: WmTimeProps) {\n    return super.renderWidget(props);\n  }\n}", "wavemaker-rn-runtime/src/components/input/epoch/time/time.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { WmDatetimeStyles, DEFAULT_CLASS as DATE_TIME_DEFAUlT_CLASS } from '../datetime/datetime.styles';\nimport { Platform } from 'react-native';\n\nexport type WmTimeStyles = WmDatetimeStyles;\n\nexport const DEFAULT_CLASS = 'app-time';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  addStyle(DEFAULT_CLASS, DATE_TIME_DEFAUlT_CLASS, {});\n  addStyle(DEFAULT_CLASS + '-disabled', '', {\n      root : {\n        backgroundColor: themeVariables.inputDisabledBgColor\n      }\n  });\n  addStyle(DEFAULT_CLASS + '-rtl', '', Platform.OS==\"web\"?{\n    clearIcon: {\n        root: {\n            marginLeft: 4,\n            marginRight: 0\n        }\n    }\n  }:{});\n  addStyle(DEFAULT_CLASS + '-with-label', '', {\n    root:{\n      minHeight: 48,\n      paddingVertical: 16\n    },\n    floatingLabel: {\n        position: 'absolute',\n        top: 12,\n        left: 16,\n        fontSize: 14,\n        color: themeVariables.floatingLabelColor\n    },\n    activeFloatingLabel: {\n        color: themeVariables.activeFloatingLabelColor\n    }\n  } as any as WmDatetimeStyles);\n});", "wavemaker-rn-runtime/src/components/input/epoch/wheelpicker/wheelpicker.props.ts": "import { BaseProps } from \"@wavemaker/app-rn-runtime/core/base.component\";\nimport { PixelRatio } from \"react-native\";\n\nexport const defaultItemHeight = PixelRatio.roundToNearestPixel(50);\n\nexport default class WmWheelPickerProps extends BaseProps {\n  data: Array<string | number> = [];\n  wrapperHeight: number = PixelRatio.roundToNearestPixel(150);\n  itemHeight: number = defaultItemHeight;\n  selectedIndex: number = 0;\n  onValueChange?: (value: string | number, index: number) => void;\n}\n", "wavemaker-rn-runtime/src/components/input/epoch/wheelpicker/wheelpicker.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { TextStyle, ViewStyle } from 'react-native';\n\nexport type WmWheelPickerStyles = BaseStyles & {\n  center: ViewStyle;\n  selectedItemBg: ViewStyle;\n  itemBg: ViewStyle;\n  selectedItemText: TextStyle;\n  itemText: TextStyle;\n  disabled: ViewStyle;\n};\n\nexport const DEFAULT_CLASS = 'app-wheel-picker';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmWheelPickerStyles = defineStyles({\n        root: {\n          position: 'relative',\n          width: 100,\n          overflow: 'hidden',\n        },\n        text: {\n          fontSize: 16\n        },\n        gestureRoot: {\n          height: '100%',\n        },\n        center: {\n          flexDirection: 'row',\n          justifyContent: 'center',\n          alignItems: 'center',\n        },\n        selectedItemBg: {\n          pointerEvents: 'none',\n          position: 'absolute',\n          width: '100%',\n          borderTopColor: themeVariables.wheelHighlightBorder,\n          borderBottomColor: themeVariables.wheelHighlightBorder,\n          borderTopWidth: 2,\n          borderBottomWidth: 2,\n        },\n        itemBg: {\n          backgroundColor: 'transparent',\n        },\n        selectedItemText: {\n          fontSize: 18,\n          fontWeight: '600',\n          color: themeVariables.wheelSelectedTextColor,\n        },\n        itemText: {\n          fontSize: 17,\n          fontWeight: '400',\n          color: themeVariables.wheelTextColor,\n        },\n        disabled: {\n          pointerEvents: 'none'\n        }\n    }) as WmWheelPickerStyles;\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n    addStyle(DEFAULT_CLASS + '-disabled', '', {\n        root : {\n          opacity: 0.5\n        }\n    });\n});\n", "wavemaker-rn-runtime/src/components/input/epoch/wheelpicker/wheelpicker.component.tsx": "import React, {createRef} from 'react';\nimport {\n  NativeScrollEvent,\n  NativeSyntheticEvent,\n  Text,\n  View,\n} from 'react-native';\nimport { ScrollView } from 'react-native-gesture-handler';\nimport WmWheelPickerProps from './wheelpicker.props';\nimport { DEFAULT_CLASS, WmWheelPickerStyles } from './wheelpicker.styles';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport class WmWheelPickerState extends BaseComponentState<WmWheelPickerProps> {\n  selectedIndex: number = 0;\n}\n\nexport class WmWheelScrollPicker extends BaseComponent<WmWheelPickerProps, WmWheelPickerState,\n WmWheelPickerStyles> {\n  wheelPickerRef: any = null;\n\n  constructor(props: WmWheelPickerProps) {\n    super(props, DEFAULT_CLASS);\n\n    this.wheelPickerRef = createRef();\n  }\n\n  initialScrollTo() {\n    const props = this.props;\n    const y = props.itemHeight * props.selectedIndex;\n    this.wheelPickerRef?.current?.scrollTo?.({y: y, animated: false});\n    this.setState({\n      selectedIndex: props.selectedIndex || 0,\n    });\n  }\n\n  handleWheelScroll = (event: NativeSyntheticEvent<NativeScrollEvent>) => {\n    // console.log('scroll =>', event.nativeEvent.contentOffset);\n    const selectedIdx = Math.round(\n      event.nativeEvent.contentOffset.y / this.props.itemHeight,\n    );\n\n    this.setState({\n      selectedIndex: selectedIdx,\n    });\n  };\n\n  handleWheelMomentumEnd = () => {\n    const props = this.props;\n    const state = this.state;\n\n    const selectedData = props.data[state.selectedIndex];\n    this.props.onValueChange?.(selectedData, state.selectedIndex);\n  };\n\n  renderWidget(props: WmWheelPickerProps) {\n    const state = this.state;\n    const styles = this.styles;\n    const {data, wrapperHeight, itemHeight} = props;\n    const scrollOffset = (wrapperHeight - itemHeight) / 2;\n\n    return (\n      <View \n        style={[styles.root, {height: wrapperHeight}]}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        <ScrollView\n          ref={this.wheelPickerRef}\n          scrollEventThrottle={16}\n          contentContainerStyle={{paddingVertical: scrollOffset}}\n          showsVerticalScrollIndicator={false}\n          onLayout={() => this.initialScrollTo()}\n          onScroll={this.handleWheelScroll}\n          onMomentumScrollEnd={this.handleWheelMomentumEnd}\n          decelerationRate=\"fast\"\n          snapToInterval={itemHeight} // your snap points\n        >\n          {data.map((item, index) => {\n            const isSelected = index === state.selectedIndex;\n\n            return (\n              <View\n                key={`data_item_${index}`}\n                style={[styles.center, styles.itemBg, {height: itemHeight}]}>\n                <Text\n                  style={\n                    isSelected ? [styles.selectedItemText] : [styles.itemText]\n                  }>\n                  {item}\n                </Text>\n              </View>\n            );\n          })}\n        </ScrollView>\n        <View\n          style={[\n            styles.selectedItemBg,\n            {\n              height: itemHeight,\n              top: scrollOffset,\n            },\n          ]}\n        />\n      </View>\n    );\n  }\n}\n\nexport default WmWheelScrollPicker;\n", "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/date/date-picker-modal.props.ts": "import { BaseProps } from \"@wavemaker/app-rn-runtime/core/base.component\";\n\nexport default class WmDatePickerModalProps extends BaseProps {\n  isVisible: boolean = false;\n  minDate?: Date | string;\n  maxDate?: Date | string;\n  selectedDate?: any;\n  onClose?: () => void;\n  onSelect?: (date: Date) => void;\n  onCancel?: () => void;\n  dateheadertitle?: string = \"Select Date\";\n  dateconfirmationtitle?: string = \"Select\";\n  datecanceltitle?: string = \"Cancel\";\n}\n", "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/date/date-picker-modal.component.tsx": "import React from 'react';\nimport { Modal, Text, TouchableWithoutFeedback, View } from 'react-native';\nimport WmWheelDatePicker from '../../wheel-date-picker.component';\nimport WmButton from '../../../../basic/button/button.component';\nimport {\n  DEFAULT_CLASS,\n  WmDateTimePickerModalStyles,\n} from '../styles/datetime-picker-modal.styles';\nimport {\n  BaseComponent,\n  BaseComponentState,\n} from '@wavemaker/app-rn-runtime/core/base.component';\nimport WmDatePickerModalProps from './date-picker-modal.props';\n\nexport class WmDatePickerModalState extends BaseComponentState<WmDatePickerModalProps> {\n  selectedDate: Date = new Date();\n}\n\nexport class WmDatePickerModal extends BaseComponent<\n  WmDatePickerModalProps,\n  WmDatePickerModalState,\n  WmDateTimePickerModalStyles\n> {\n  constructor(props: WmDatePickerModalProps) {\n    super(props, DEFAULT_CLASS, new WmDatePickerModalProps());\n  }\n\n  renderWidget() {\n    const { isVisible, minDate, maxDate, onClose, onCancel, onSelect, dateheadertitle, dateconfirmationtitle, datecanceltitle } = this.props;\n    const { selectedDate } = this.state;\n    const { styles } = this;\n\n    return (\n      <Modal\n        animationType=\"fade\"\n        transparent={true}\n        visible={isVisible}\n        onRequestClose={onClose}\n        onDismiss={onClose}\n      >\n        <View style={styles.root} onLayout={(event) => this.handleLayout(event)}>\n          <TouchableWithoutFeedback style={styles.flex1} onPress={onClose}>\n            <View style={styles.flex1} />\n          </TouchableWithoutFeedback>\n          <View style={styles.container}>\n            <Text style={styles.header}>{dateheadertitle}</Text>\n            <WmWheelDatePicker\n              minDate={minDate}\n              maxDate={maxDate}\n              selectedDate={this.props.selectedDate || selectedDate}\n              onDateChange={(date) => {\n                this.setState({ selectedDate: date });\n              }}\n            />\n            <View style={styles.buttonWrapper}>\n              <WmButton\n                styles={styles.cancelBtn}\n                caption={datecanceltitle}\n                onTap={onCancel}\n              />\n              <WmButton\n                styles={styles.selectBtn}\n                caption={dateconfirmationtitle}\n                onTap={() => onSelect?.(selectedDate || this.props.selectedDate || new Date())}\n              />\n            </View>\n          </View>\n        </View>\n      </Modal>\n    );\n  }\n}\n\nexport default WmDatePickerModal;\n", "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/time/time-picker-modal.component.tsx": "import React from 'react';\nimport { Modal, Text, TouchableWithoutFeedback, View } from 'react-native';\nimport WmWheelTimePicker from '../../wheel-time-picker.component';\nimport WmButton from '../../../../basic/button/button.component';\nimport {\n  DEFAULT_CLASS,\n  WmDateTimePickerModalStyles,\n} from '../styles/datetime-picker-modal.styles';\nimport {\n  BaseComponent,\n  BaseComponentState,\n} from '@wavemaker/app-rn-runtime/core/base.component';\nimport WmTimePickerModalProps from './time-picker-modal.props';\n\nexport class WmTimePickerModalState extends BaseComponentState<WmTimePickerModalProps> {\n  selectedTime: Date = new Date();\n}\n\nexport class WmTimePickerModal extends BaseComponent<\n  WmTimePickerModalProps,\n  WmTimePickerModalState,\n  WmDateTimePickerModalStyles\n> {\n  constructor(props: WmTimePickerModalProps) {\n    super(props, DEFAULT_CLASS, new WmTimePickerModalProps());\n  }\n\n  renderWidget(props: WmTimePickerModalProps) {\n    const { is24Hour, isVisible, onClose, onCancel, onSelect, timeheadertitle, timeconfirmationtitle, timecanceltitle } = this.props;\n    const { selectedTime } = this.state;\n    const { styles } = this;\n\n    return (\n      <Modal\n        animationType=\"fade\"\n        transparent={true}\n        visible={isVisible}\n        onRequestClose={onClose}\n        onDismiss={onClose}\n      >\n        <View style={styles.root} onLayout={(event) => this.handleLayout(event)}>\n          <TouchableWithoutFeedback style={styles.flex1} onPress={onClose}>\n            <View style={styles.flex1} />\n          </TouchableWithoutFeedback>\n          <View style={styles.container}>\n            <Text style={styles.header}>{timeheadertitle}</Text>\n            <WmWheelTimePicker\n              selectedTime={this.props.selectedDateTime || selectedTime}\n              is24Hour={is24Hour}\n              onTimeChange={(time) => {\n                this.setState({ selectedTime: time });\n              }}\n            />\n            <View style={styles.buttonWrapper}>\n              <WmButton\n                styles={styles.cancelBtn}\n                caption={timecanceltitle}\n                onTap={onCancel}\n              />\n              <WmButton\n                styles={styles.selectBtn}\n                caption={timeconfirmationtitle}\n                onTap={() => onSelect?.(selectedTime || this.props.selectedDateTime || new Date().setSeconds(0))}\n              />\n            </View>\n          </View>\n        </View>\n      </Modal>\n    );\n  }\n}\n\nexport default WmTimePickerModal;\n", "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/time/time-picker-modal.props.ts": "import { BaseProps } from \"@wavemaker/app-rn-runtime/core/base.component\";\n\nexport default class WmTimePickerModalProps extends BaseProps {\n  isVisible: boolean = false;\n  selectedDateTime?: any;\n  is24Hour?: boolean = true;\n  onClose?: () => void;\n  onSelect?: (time: Date) => void;\n  onCancel?: () => void;\n  timeheadertitle?: string = \"Select Time\";\n  timeconfirmationtitle?: string = \"Select\";\n  timecanceltitle?: string = \"Cancel\";\n}\n", "wavemaker-rn-runtime/src/components/input/epoch/wheelpickermodal/styles/datetime-picker-modal.styles.ts": "import BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport {\n  BaseStyles,\n  defineStyles,\n} from '@wavemaker/app-rn-runtime/core/base.component';\nimport { TextStyle, ViewStyle } from 'react-native';\n\nexport type WmDateTimePickerModalStyles = BaseStyles & {\n  container: AllStyle;\n  header: TextStyle;\n  buttonWrapper: ViewStyle;\n  cancelBtn: AllStyle;\n  selectBtn: AllStyle;\n};\n\nexport const DEFAULT_CLASS = 'app-datetime-picker-modal';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmDateTimePickerModalStyles = defineStyles({\n    root: {\n      flex: 1,\n      backgroundColor: 'rgba(0, 0, 0, 0.5)',\n    },\n    text: {\n      fontSize: 16,\n    },\n    flex1: {\n      flex: 1,\n    },\n    container: {\n      backgroundColor: 'white',\n      paddingHorizontal: 20,\n      paddingTop: 40,\n      paddingBottom: 20,\n      borderTopLeftRadius: 20,\n      borderTopRightRadius: 20,\n      alignItems: 'center',\n    },\n    header: {\n      width: '100%',\n      textAlign: 'left',\n      fontSize: 20,\n      fontWeight: 'bold',\n      marginBottom: 20,\n    },\n    buttonWrapper: {\n      marginTop: 40,\n      marginBottom: 20,\n      flexDirection: 'row',\n      justifyContent: 'space-between',\n      gap: 20,\n    },\n    cancelBtn: {\n      root: {\n        flex: 1,\n        borderWidth: 1,\n        borderColor: themeVariables.wheelHighlightBorder,\n        borderRadius: 20,\n        minHeight: 40,\n      },\n      text: {\n        fontWeight: '600',\n      },\n    },\n    selectBtn: {\n      root: {\n        flex: 1,\n        backgroundColor: themeVariables.wheelHighlightBorder,\n        borderRadius: 20,\n        minHeight: 40,\n      },\n      text: {\n        color: 'white',\n        fontWeight: '600',\n      },\n    },\n  }) as WmDateTimePickerModalStyles;\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n});\n", "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.styles.ts": "import BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\nimport { WmIconStyles } from '@wavemaker/app-rn-runtime/components/basic/icon/icon.styles';\n\nexport type WmCheckboxsetStyles = BaseStyles & {\n  groupHeaderTitle: AllStyle;\n  item: AllStyle;\n  skeleton: WmSkeletonStyles;\n  checkicon: WmIconStyles;\n  checkedItem: AllStyle;\n  uncheckicon: WmIconStyles;\n};\n\nexport const DEFAULT_CLASS = 'app-checkboxset';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmCheckboxsetStyles = defineStyles({\n      root: {},\n      text: {\n        alignSelf: 'center',\n        fontFamily: themeVariables.baseFont,\n        fontSize: 16,\n        color: themeVariables.labelDefaultColor,\n        marginLeft: 8,\n      },\n    groupHeaderTitle: {\n      backgroundColor: themeVariables.groupHeadingBgColor,\n      fontSize: 16,\n      paddingLeft: 8,\n      paddingRight: 8,\n      lineHeight: 40,\n      fontFamily: themeVariables.baseFont\n    } as AllStyle,\n    checkedItem: {} as AllStyle,\n    selectedLabel: {} as AllStyle,\n    item: {\n      flexDirection: 'row',\n      alignContent: 'center',\n      marginRight: -20,\n      marginTop: 8\n    } as AllStyle,\n    skeleton: {\n      root: {\n        width: '100%',\n        height: 16\n      }\n    } as any as WmSkeletonStyles,\n    checkicon : {\n      root: {\n        width: 20,\n        height: 20,\n        borderRadius: 4,\n        backgroundColor: themeVariables.primaryColor,\n        justifyContent: 'center',\n        alignItems: 'center',\n        borderColor: themeVariables.checkedBorderColor,\n      },\n      text: {\n        fontSize: 18,\n      },\n      icon : {\n        color: themeVariables.checkedIconColor,\n        padding: 0\n      }\n  } as WmIconStyles,\n    uncheckicon : {\n      root: {\n        width: 20,\n        height: 20,\n        borderWidth: 2,\n        borderRadius: 4,\n        borderColor: themeVariables.uncheckedBorderColor,\n      },\n      text: {},\n      icon : {\n        color: 'transparent',\n      }\n  } as WmIconStyles,\n  });\n\n  addStyle(DEFAULT_CLASS + '-disabled', '', {\n    root: {\n      opacity: 0.8\n    },\n    text : {\n      color: themeVariables.checkedDisabledColor\n    }\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n});\n", "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.props.ts": "import BaseDatasetProps from '@wavemaker/app-rn-runtime/components/input/basedataset/basedataset.props';\n\nexport default class WmCheckboxsetProps extends BaseDatasetProps {\n  dataset: any = 'Option 1, Option 2, Option 3';\n  displayValue: any = '';\n  required: boolean = false;\n  itemsperrow =  {\n    xs: 1,\n    sm: 1,\n    md: 1,\n    lg: 1,\n };\n  renderitempartial?: (item: any, index: number, partialName: string)=> React.ReactNode;\n  numberofskeletonitems?: number | string\n}\n", "wavemaker-rn-runtime/src/components/input/checkboxset/checkboxset.component.tsx": "import React from 'react';\nimport { Text, View, TouchableOpacity, DimensionValue, Platform } from 'react-native';\nimport { ScrollView } from 'react-native-gesture-handler';\nimport { find, forEach, isEqual,  isEmpty } from 'lodash';\nimport WmCheckboxsetProps from './checkboxset.props';\nimport {\n  DEFAULT_CLASS,\n\n  WmCheckboxsetStyles,\n} from './checkboxset.styles';\nimport {\n  BaseDatasetComponent,\n  BaseDatasetState,\n} from '@wavemaker/app-rn-runtime/components/input/basedataset/basedataset.component';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility';\nimport { getNumberOfEmptyObjects } from '@wavemaker/app-rn-runtime/core/utils';\nimport WmLabel from '@wavemaker/app-rn-runtime/components/basic/label/label.component';\n\nexport class WmCheckboxsetState extends BaseDatasetState<WmCheckboxsetProps> {\n  isValid: boolean = true;\n  template: string = \"\";\n}\n\nexport default class WmCheckboxset extends BaseDatasetComponent<WmCheckboxsetProps, WmCheckboxsetState, WmCheckboxsetStyles> {\n  constructor(props: WmCheckboxsetProps) {\n    super(props, DEFAULT_CLASS, new WmCheckboxsetProps());\n  }\n\n  onPress(item: any) {\n    if (this.state.props.disabled || this.state.props.readonly) {\n      return;\n    }\n    this.invokeEventCallback('onTap', [null, this.proxy]);\n    item.selected = !item.selected;\n    const selectedValue: any = [];\n    const selectedItem = find(this.state.dataItems, d => isEqual(d.key, item.key));\n    const oldValue = this.state.props.datavalue;\n    selectedItem.selected = item.selected;\n    forEach(this.state.dataItems, (item) => {\n        if (item.selected) {\n          selectedValue.push(item.datafield);\n        }\n    });\n    this.validate(selectedValue);\n    this.updateState({ props: { datavalue: selectedValue }} as WmCheckboxsetState,\n      () => {\n        this.computeDisplayValue();\n        this.invokeEventCallback('onChange', [ undefined, this.proxy, selectedValue, oldValue ]);\n      });\n  }\n\n  renderChild(item: any, index: any,colWidth: DimensionValue) {\n    const props = this.state.props;\n    const displayText = item.displayexp || item.displayfield;\n    return (\n      <TouchableOpacity {...this.getTestPropsForAction(index + '')}\n        style={[this.styles.item, item.selected ? this.styles.checkedItem : null, {width: colWidth}]}\n        onPress={this.onPress.bind(this, item)} key={item.key} {...getAccessibilityProps(AccessibilityWidgetType.CHECKBOX, {hint: props?.hint, checked: item.selected})} accessibilityRole='checkbox' accessibilityLabel={`Checkbox for ${displayText}`}>\n        <WmIcon iconclass=\"wi wi-check\" styles={item.selected? this.styles.checkicon : this.styles.uncheckicon} disabled={props.readonly || props.disabled} id={this.getTestId('item'+index)}/>\n        {!isEmpty(this.state.template) && this.props.renderitempartial ?\n           this.props.renderitempartial(item.dataObject, index, this.state.template) :\n        <Text {...this.getTestPropsForLabel(index + '')} style={[this.styles.text, item.selected ? this.styles.selectedLabel: null]}>{displayText}</Text>}\n      </TouchableOpacity>)\n  }\n\n  computeDisplayValue() {\n    this.updateState({\n      props: {\n        displayValue: ((this.state.dataItems || [] as any)\n          .filter((item: any) => item.selected)\n          .map((item: any) => item.displayexp || item.displayfield)) || ''\n      }\n    } as WmCheckboxsetState);\n  }\n\n  updateDatavalue(value: any) {\n    this.updateState({ props: { datavalue: value }} as WmCheckboxsetState);\n    return Promise.resolve();\n  }\n\n  setTemplate(partialName: any) {\n    this.updateState({ template: partialName} as WmCheckboxsetState);\n  }\n\n  renderGroupby() {\n    const groupedData = this.state.groupedData;\n    return (\n      <View>\n        {groupedData && groupedData.length\n          ? groupedData.map((groupObj: any, index: any) => {\n            return(\n              <View key={groupObj.key}>\n                <Text style={this.styles.groupHeaderTitle}>{groupObj.key}</Text>\n                {this.renderCheckboxses(groupObj.data)}\n              </View>)\n          })\n          : null}\n      </View>\n    );\n  }\n\n  renderCheckboxses(items: any) {\n    const props = this.state.props;\n    const noOfColumns = props.itemsperrow.xs || 1;\n    const colWidth = Math.round(100/ noOfColumns) + '%' as DimensionValue;\n    return(<View style = {noOfColumns === 1 ? {} : {flexWrap: 'wrap', flexDirection: 'row'}}>\n      {items && items.length\n        ? items.map((item: any, index: any) => this.renderChild(item, index, colWidth))\n        : null}\n    </View>)\n  }\n\n  public renderSkeleton(props: WmCheckboxsetProps): React.ReactNode {\n    const noOfColumns = props.itemsperrow.xs || 1;\n    const colWidth = Math.round(100/ noOfColumns) + '%' as DimensionValue;\n\n    return [...getNumberOfEmptyObjects(props.numberofskeletonitems as number ?? 3)].map(_ => {\n      return <View style={[this.styles.item, {width: colWidth}]}>\n        <WmIcon styles={this.styles.checkicon}/>\n        <WmLabel styles={{ root: this.styles.text }}/>\n      </View>\n    })\n  }\n\n  renderWidget(props: WmCheckboxsetProps) {\n    const items = this.state.dataItems;\n    return (\n      <ScrollView style={this.styles.root} onLayout={(event) => this.handleLayout(event)}>\n        <ScrollView horizontal={true}\n          style={this.isRTL && Platform.OS == 'android' ? { transform: [{ scaleX: -1 }] } : {}}\n          contentContainerStyle={this.isRTL && Platform.OS == 'android' ? { transform: [{ scaleX: -1 }] } : {}}\n        >\n          {props.groupby && this.renderGroupby()}\n          {!props.groupby && this.renderCheckboxses(items)}\n        </ScrollView>\n      </ScrollView>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmCheckboxProps extends BaseProps {\n  caption: string = null as any;\n  datavalue = false;\n  checkedvalue: any = true;\n  uncheckedvalue: any = false;\n  readonly: boolean = null as any;\n  onFieldChange: any;\n  invokeEvent?: Function;\n  hint?: string = undefined;\n}\n", "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.styles.ts": "import BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\nimport { WmIconStyles } from '@wavemaker/app-rn-runtime/components/basic/icon/icon.styles';\n\nexport type WmCheckboxStyles = BaseStyles & {\n  skeleton: WmSkeletonStyles;\n  checkicon: WmIconStyles;\n  uncheckicon: WmIconStyles;\n  iconSkeleton: WmSkeletonStyles;\n  labelSkeleton: WmSkeletonStyles;\n};\n\nexport const DEFAULT_CLASS = 'app-checkbox';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmCheckboxStyles = defineStyles({\n        root: {\n          flexDirection: 'row',\n          alignContent: 'center',\n        },\n        text: {\n          alignSelf: 'center',\n          fontFamily: themeVariables.baseFont,\n          fontSize: 16,\n          color: themeVariables.labelDefaultColor,\n          marginLeft: 8\n        },\n        skeleton: {\n          root: {\n            width: 20,\n            height: 20,\n            borderRadius: 4,\n          },\n        } as any as WmSkeletonStyles,\n        iconSkeleton: {\n          root: {\n            width: 20,\n            height: 20,\n            borderRadius: 4,\n          }\n        } as any as WmSkeletonStyles,\n        labelSkeleton: {\n          root: {\n            width: 200,\n            borderRadius: 4,\n            height: 16\n          }\n        } as any as WmSkeletonStyles,\n        checkicon : {\n          root: {\n            width: 20,\n            height: 20,\n            borderRadius: 4,\n            backgroundColor: themeVariables.primaryColor,\n            justifyContent: 'center',\n            alignItems: 'center',\n            borderColor: themeVariables.checkedBorderColor,\n          },\n          text: {\n            fontSize: 18,\n          },\n          icon : {\n            color: themeVariables.checkedIconColor,\n            padding: 0\n          }\n      } as WmIconStyles,\n        uncheckicon : {\n          root: {\n            width: 20,\n            height: 20,\n            borderWidth: 2,\n            borderRadius: 4,\n            borderColor: themeVariables.uncheckedBorderColor,\n            backgroundColor: themeVariables.uncheckedBgColor,\n          },\n          text: {},\n          icon : {\n            color: 'transparent',\n          }\n      } as WmIconStyles,\n      checkedItem: {} as AllStyle,\n      selectedLabel: {} as AllStyle,\n      });\n\n\n    addStyle(DEFAULT_CLASS + '-disabled', '', {\n      root : {\n        opacity: 0.8\n      },\n      text : {\n        color: themeVariables.checkedDisabledColor\n      }\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n  });\n", "wavemaker-rn-runtime/src/components/input/checkbox/checkbox.component.tsx": "import React from 'react';\nimport { DimensionValue, Text, TouchableOpacity, View } from 'react-native';\n\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport {unStringify, validateField} from '@wavemaker/app-rn-runtime/core/utils';\n\nimport WmCheckboxProps from './checkbox.props';\nimport { DEFAULT_CLASS, WmCheckboxStyles } from './checkbox.styles';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility';\nimport { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\nimport WmLabel from '../../basic/label/label.component';\n\nexport class WmCheckboxState extends BaseComponentState<WmCheckboxProps> {\n  isChecked: boolean = false;\n  isValid: boolean = true;\n  errorType = '';\n}\n\nexport default class WmCheckbox extends BaseComponent<WmCheckboxProps, WmCheckboxState, WmCheckboxStyles> {\n\n  constructor(props: WmCheckboxProps) {\n    super(props, DEFAULT_CLASS, new WmCheckboxProps(), new WmCheckboxState());\n  }\n\n  setChecked(dataValue: any, checkedvalue: any) {\n    const value = unStringify(dataValue) === unStringify(checkedvalue, true);\n    this.updateState({ isChecked: value } as WmCheckboxState);\n  }\n\n  onPropertyChange(name: string, $new: any, $old: any) {\n    switch (name) {\n      case 'checkedvalue':\n        this.setChecked(this.state.props.datavalue, $new);\n        break;\n      case 'datavalue':\n        this.setChecked($new, this.state.props.checkedvalue);\n        break;\n    }\n  }\n\n  updateDatavalue(value: any) {\n    this.updateState({ props: { datavalue: value }} as WmCheckboxState);\n  }\n  validate(value: any) {\n    const validationObj = validateField(this.state.props, value);\n    this.updateState({\n      isValid: validationObj.isValid,\n      errorType: validationObj.errorType\n    } as WmCheckboxState);\n  }\n\n  onPress() {\n    if (this.state.props.disabled || this.state.props.readonly) {\n      return;\n    }\n    this.invokeEventCallback('onFocus', [null, this.proxy]);\n    this.invokeEventCallback('onTap', [null, this.proxy]);\n    const oldValue = this.state.props.datavalue;\n    const value = !this.state.isChecked;\n    this.validate(value);\n    this.updateState({ isChecked: value } as WmCheckboxState);\n    const dataValue = value === true ? this.state.props.checkedvalue : this.state.props.uncheckedvalue;\n    this.updateState({ props: { datavalue: dataValue } } as WmCheckboxState,\n      () => {\n        if (!this.props.onFieldChange) {\n          this.invokeEventCallback('onChange', [null, this.proxy, dataValue, oldValue]);\n        } else {\n          this.props.onFieldChange && this.props.onFieldChange('datavalue', dataValue, oldValue);\n        }\n        setTimeout(() => {\n          this.invokeEventCallback('onBlur', [ null, this.proxy ]);\n        }, 10);\n      });\n  }\n\n  public renderSkeleton(props: WmCheckboxProps): React.ReactNode {\n    return <View style={[this.styles.root, this.styles.skeleton.root]}>\n        <WmIcon styles={{ root: {...this.styles.checkicon, ...this.styles.iconSkeleton.root} }}/>\n        <WmLabel styles={{ root: {...this.styles.text, ...this.styles.labelSkeleton.root} }}/>\n      </View>\n  }\n\n  renderWidget(props: WmCheckboxProps) {\n    return (\n      <TouchableOpacity \n        {...this.getTestPropsForAction()} \n        style={[this.styles.root, this.state.isChecked ? this.styles.checkedItem : null]} \n        onPress={this.onPress.bind(this)} \n        {...getAccessibilityProps(AccessibilityWidgetType.CHECKBOX, {hint: props?.hint, checked: this.state.isChecked})} \n        accessibilityRole='checkbox' \n        accessibilityLabel={`Checkbox for ${props.caption}`}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n          {this._background}\n          <WmIcon iconclass=\"wi wi-check\" styles={this.state.isChecked ? this.styles.checkicon : this.styles.uncheckicon} disabled={props.readonly || props.disabled} id={this.getTestId('checkbox')}/>\n          <Text {...this.getTestPropsForLabel()} style={[this.styles.text, this.state.isChecked ? this.styles.selectedLabel: null]}>{props.caption}</Text>\n      </TouchableOpacity>\n    );\n  }\n}\n\n\n\n", "wavemaker-rn-runtime/src/components/input/slider/slider.component.tsx": "import React from 'react';\nimport { View, Text, LayoutChangeEvent, TouchableOpacity, Animated, Easing, Dimensions } from 'react-native';\nimport { debounce, isNumber, isNil, isArray, isString, last, isEqual } from 'lodash';\nimport { Gesture, GestureDetector, PanGesture } from 'react-native-gesture-handler';\nimport { BackgroundComponent } from '@wavemaker/app-rn-runtime/styles/background.component';\nimport WmTooltip from '@wavemaker/app-rn-runtime/components/basic/tooltip/tooltip.component';\n\nimport WmSliderProps from './slider.props';\nimport { DEFAULT_CLASS, WmSliderStyles } from './slider.styles';\nimport { isDefined, isWebPreviewMode } from '@wavemaker/app-rn-runtime/core/utils';\nimport { BaseDatasetComponent, BaseDatasetState } from '../basedataset/basedataset.component';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility';\n\nexport type SliderGestureType = 'track' | 'lowThumb' | 'highThumb';\n\nconst SCREEN_WIDTH = Dimensions.get(\"screen\").width;\n\nexport class WmSliderState extends BaseDatasetState<WmSliderProps> {\n  track?: {\n    top: number,\n    left: number,\n    width: number,\n    height: number\n  };\n}\n\ninterface Tick {\n  displayfield: string;\n  markValue: number;\n  datafield: any;\n  dataitem: any;\n}\n\nclass Scale {\n\n  public ticks = [] as Tick[];\n\n  static getInstanceWithTicks(ticks: Tick[]) {\n    const scale = new Scale();\n    scale.ticks = [...ticks];\n    return scale;\n  }\n\n  private constructor() {\n      \n  }\n\n  public getTickIndex(value: number) {\n      if (isString(value)) {\n        value = parseInt(value);\n      }\n      let markIndex = 0;\n      const i = this.ticks.findIndex((v, i) => v.markValue >= value);\n      if (i === 0) {\n          markIndex = 0;\n      } else if (i < 0 || i === this.ticks.length - 1) {\n          markIndex = this.ticks.length - 1;\n      } else if ((value - this.ticks[i - 1].markValue) < (this.ticks[i].markValue - this.ticks[i - 1].markValue)/2) {\n          markIndex = i - 1;\n      } else {\n          markIndex = i;\n      }\n      return markIndex;\n  }\n\n  public getMinTick() {\n    return this.ticks[0];\n  }\n\n  public getMaxTick() {\n    return last(this.ticks) || {} as Tick;\n  }\n\n  public getTick(value: number) {\n    return this.ticks[this.getTickIndex(value)];\n}\n\n  public clamp(value: number) {\n    const index = this.getTickIndex(value);\n    return this.ticks[index].markValue; \n  }\n\n  public transform(min: number, max: number) {\n      const thisMin = (this.ticks ? this.ticks[0]?.markValue : 0) || 0;\n      const thisMax = last(this.ticks)?.markValue;\n      const factor = thisMax ? (max - min)/(thisMax - thisMin) : 1;\n      const ticks = [] as Tick[];\n      this.ticks.forEach((v, i) => {\n        const markValue = Math.round(min + (v.markValue - this.ticks[0].markValue) * factor)\n        ticks[i] = {\n          displayfield: '' + markValue,\n          markValue: markValue,\n          datafield: markValue,\n          dataitem: markValue\n        };\n      });\n      return Scale.getInstanceWithTicks(ticks);\n  }\n}\n\nexport default class WmSlider extends BaseDatasetComponent<WmSliderProps, WmSliderState, WmSliderStyles> {\n  valueBeforeSlide: number = 0;\n  private position: any = new Animated.Value(0);\n  private highPosition: any = new Animated.Value(0);\n  private trackGesture = Gesture.Pan();\n  private knobGesture = Gesture.Pan();\n  private highKnobGesture = Gesture.Pan();\n  private scale: Scale = null as any;\n  private uiScale: Scale = null as any;\n\n  constructor(props: WmSliderProps) {\n    super(props, DEFAULT_CLASS, new WmSliderProps());\n    this.initScale();\n    this.configureGesture(this.trackGesture, 'track');\n    this.configureGesture(this.knobGesture, 'lowThumb');\n    this.configureGesture(this.highKnobGesture, 'highThumb');\n  }\n\n  getValueFromGesture(positionX: number) {\n    return this.scale?.ticks[this.uiScale.getTickIndex(positionX)].markValue || 0;\n  }\n\n  getPositionFromValue(value: number) {\n    return this.uiScale?.ticks[this.scale.getTickIndex(value)]?.markValue;\n  }\n\n  configureGesture(gesture: PanGesture, gestureType: SliderGestureType) {\n    gesture\n      .maxPointers(1)\n      .minDistance(0)\n      .onChange(e => {\n        const value = this.getValueFromGesture(e.absoluteX);\n        this.computePosition(value, gestureType);\n        this.forceUpdate();\n      })\n      .onEnd(e => {\n        if (this.state.track) {\n          const value = this.getValueFromGesture(e.absoluteX);\n          this.onSliderChange(value, gestureType);\n          this.forceUpdate();\n        }\n      })\n  }\n\n  getScaledDataValue() {\n    let dataValue = this.state.props.datavalue || this.getDataValue();\n    if (dataValue && this.scale) {\n      dataValue = isArray(dataValue) ? dataValue: [dataValue];\n      return dataValue.map((d: any) => this.scale?.ticks.find(t => t.datafield === d)?.markValue);\n    }\n    return dataValue;\n  }\n\n  getDataValue() {\n    let dataValue = this.props.datavalue;\n    if (isNil(this.props.datavalue)) {\n      const mid = Math.floor(this.scale.ticks.length / 2);\n      return mid > 0 ? \n        [this.scale.ticks[mid - 1]?.datafield || 0,\n        this.scale.ticks[mid]?.datafield || 100]\n        : [];\n    }\n    dataValue = isArray(dataValue) ? dataValue: [dataValue];\n    return dataValue.map((d: any) => this.scale.getTick(d)?.datafield);\n  }\n\n  initNumericSlider() {\n    const dataset = [];\n    const minValue = this.state.props.minvalue;\n    const maxValue = this.state.props.maxvalue;\n    const step = this.state.props.step;\n    if (isDefined(minValue) \n      && isDefined(maxValue)\n      && isDefined(step)) {\n      let nextMark = minValue;\n      while (nextMark <= maxValue) {\n        dataset.push(nextMark);\n        nextMark += step || 1;\n      }\n      this.updateState({\n        props: {\n          dataset: dataset\n        }\n      } as WmSliderState);\n    }\n  }\n\n  onPropertyChange(name: string, $new: any, $old: any) {\n    super.onPropertyChange(name, $new, $old);\n    switch(name) {\n      case 'maxvalue':\n      case 'minvalue': \n      case 'step': \n        if (this.state.props.datatype === 'number' && this.initialized) {\n          this.initNumericSlider();\n        }\n      case 'datavalue':\n        if (!isEqual($new, $old)) {\n          this.invokeEventCallback('onChange', [null, this, $new, $old]);\n        }\n        break;\n    }\n  }\n\n  onDataItemsUpdate() {\n    super.onDataItemsUpdate();\n    this.initScale();\n    this.computePosition(this.getScaledDataValue()?.[0] || 10, \"track\");\n  }\n\n  onSliderChange = debounce((value: number, gestureType: SliderGestureType) => {\n    const dataValue = this.getScaledDataValue();\n    const isRangeSlider = this.state.props.range && isArray(dataValue);\n\n    // * thumb value for low or high\n    const oldThumbValue =\n      gestureType === 'lowThumb'\n        ? dataValue || dataValue?.[0]\n        : dataValue?.[1];\n\n    let thumbDataValue = isRangeSlider\n      ? [dataValue[0], dataValue[1]]\n      : [value];\n    if (isRangeSlider) {\n      if (gestureType === 'lowThumb') {\n        const valueLowerThanHighThumb =\n          value > dataValue?.[1] ? dataValue?.[1] : value;\n\n        thumbDataValue = [valueLowerThanHighThumb, dataValue[1]];\n      } else if (gestureType === 'highThumb') {\n        const valueGreaterThanLowThumb =\n          value < dataValue[0] ? dataValue?.[0] : value;\n\n        thumbDataValue = [dataValue[0], valueGreaterThanLowThumb];\n      } else if (dataValue[1] && value > dataValue[1]) {\n        thumbDataValue = [dataValue[0], value];\n      } else {\n        thumbDataValue = [value, dataValue[1]];\n      }\n    }\n\n    // * new thumb value is different from old value\n    const dataset = thumbDataValue.map(v => this.scale.getTick(v).datafield);\n    this.updateState({\n      props: {\n        datavalue: dataset.length > 1 ? dataset : dataset[0]\n      },\n    } as WmSliderState);\n    this.props.onFieldChange &&\n      this.props.onFieldChange('datavalue', thumbDataValue, oldThumbValue);\n  }, 200);\n\n  initScale() {\n    const props = this.state.props;\n    const state = this.state;\n    this.scale = Scale.getInstanceWithTicks(\n      this.state.dataItems?.map((d: any, i: number) => ({\n        displayfield: d.displayexp || d.displayfield,\n        markValue: i + 1,\n        datafield: d.datafield,\n        dataitem: d         \n      }))\n    );\n    const width = state.track?.width || 0;\n    this.uiScale = this.scale.transform(0, width);\n  }\n\n  computePosition(from: number, gestureType: SliderGestureType) {\n    const state = this.state;\n    const datavalue = this.getScaledDataValue();\n  \n    // * single thumb slider\n    if (!state.props.range) {\n      const value = this.getPositionFromValue(from);\n      this.position?.setValue(isNaN(value) ? 0 : value);\n      return;\n    }\n\n    if (gestureType === 'highThumb') {\n      const value = this.getPositionFromValue(Math.max(datavalue[0], from));\n      this.highPosition?.setValue(value);\n    } else if (gestureType === 'lowThumb') {\n      const value = this.getPositionFromValue(Math.min(from, datavalue[1]));\n      this.position?.setValue(value);\n    } else {\n      /*\n       * gestureType: track\n       * initial position for low and high thumb\n       */\n      const lowPosition = this.getPositionFromValue(datavalue?.[0] || this.scale.getMinTick()?.datafield);\n      this.position?.setValue(lowPosition || 0);\n      const highPosition = this.getPositionFromValue(datavalue?.[1] || this.scale.getMaxTick()?.datafield);\n      this.highPosition?.setValue(highPosition || 0);\n    }\n  }\n\n  getTooltipLabel(value: any, initialValue: any, type: 'lowThumb' | 'highThumb') {\n    const props = this.props;\n    let tooltipValue = initialValue;\n    const updatedPositionInPx = Number(JSON.stringify(value));\n\n    if (updatedPositionInPx) {\n      tooltipValue = this.scale.ticks[this.uiScale.getTickIndex(updatedPositionInPx)].markValue;\n    }\n    const tick = this.scale?.getTick(tooltipValue);\n    // * getting custom tooltip label\n    if (tick && props.getToolTipExpression && this.initialized) {\n      return props.getToolTipExpression(tick.dataitem?.dataObject);\n    }\n    return tick?.displayfield;\n  }\n\n  onLayoutChange = (e: LayoutChangeEvent) => {\n    const layout = e.nativeEvent.layout;\n    this.updateState({\n      track: {\n        top: isWebPreviewMode() ? (layout as any).top : layout.y,\n        left: isWebPreviewMode() ? (layout as any).left : layout.x,\n        width: layout.width,\n        height: layout.height\n      }\n    } as WmSliderState, () => {\n      this.initScale();\n      this.computePosition(this.getScaledDataValue()[0], 'track');\n    });\n  }\n\n  componentDidMount(): void {\n    super.componentDidMount();\n    if (this.state.props.datatype === 'number') {\n      this.initNumericSlider();\n    }\n  }\n\n  renderToolTips(props: WmSliderProps) {\n    const sDataValue = this.getScaledDataValue();\n    const isRangeSlider = props.range && sDataValue.length > 1;\n    return (\n      <>\n      <WmTooltip\n        showTooltip={props.showtooltip}\n        text={this.getTooltipLabel(\n          this.position?._value,\n          sDataValue[0],\n          'lowThumb'\n        )}\n        tooltipStyle={[\n          {\n            transform: [\n              {\n                translateX: this.position,\n              },\n            ],\n          },\n          this.styles.tooltip,\n        ]}\n        tooltipLabelStyle={this.styles.tooltipLabel}\n        tooltipTriangleStyle={this.styles.tooltipTriangle}\n        direction={props.tooltipdirection}\n      >\n        <GestureDetector gesture={this.knobGesture}>\n          <Animated.View\n            style={[\n              this.styles.thumb,\n              {\n                transform: [\n                  {\n                    translateX: this.position,\n                  },\n                ],\n              },\n            ]}\n            accessible={true}\n            accessibilityLabel={(isRangeSlider && this.highPosition) ? 'Low thumb' : 'Thumb'}\n          >\n            <BackgroundComponent\n              size={(this.styles.thumb as any).backgroundSize}\n              position={(this.styles.thumb as any).backgroundPosition}\n              image={(this.styles.thumb as any).backgroundImage}\n              repeat={(this.styles.thumb as any).backgroundRepeat || 'no-repeat'}\n            ></BackgroundComponent>\n          </Animated.View>\n        </GestureDetector>\n      </WmTooltip>\n      {isRangeSlider && this.highPosition ? (\n        <WmTooltip\n          showTooltip={props.showtooltip}\n          text={this.getTooltipLabel(\n            this.highPosition._value,\n            sDataValue[1],\n            'highThumb'\n          )}\n          tooltipStyle={[\n            {\n              transform: [\n                {\n                  translateX: this.highPosition,\n                },\n              ],\n            },\n            this.styles.tooltip,\n          ]}\n          tooltipLabelStyle={this.styles.tooltipLabel}\n          tooltipTriangleStyle={this.styles.tooltipTriangle}\n          direction={props.tooltipdirection}\n        >\n          <GestureDetector gesture={this.highKnobGesture}>\n            <Animated.View\n              style={[\n                this.styles.thumb,\n                {\n                  transform: [\n                    {\n                      translateX: this.highPosition,\n                    },\n                  ],\n                }\n              ]}\n              accessible={true}\n              accessibilityLabel={'High thumb'}\n              >\n              <BackgroundComponent\n                size={(this.styles.thumb as any).backgroundSize}\n                position={(this.styles.thumb as any).backgroundPosition}\n                image={(this.styles.thumb as any).backgroundImage}\n                repeat={(this.styles.thumb as any).backgroundRepeat || 'no-repeat'}\n              />\n            </Animated.View>\n          </GestureDetector>\n        </WmTooltip>\n      ) : null}\n      </>\n    );\n  }\n\n  renderOldMarkerStyle(props: WmSliderProps) {\n    const sDataValue = this.getScaledDataValue();\n    const isRangeSlider = props.range && sDataValue.length > 1;\n    return (\n        <View\n          style={{ flexDirection: 'row', justifyContent: 'space-between' }}\n        >\n          <Text\n            {...this.getTestProps('min')}\n            style={[this.styles.text, this.styles.minimumValue]}\n          >\n            {this.scale?.ticks[0]?.displayfield}\n          </Text>\n          {isRangeSlider ? (\n            <></>\n          ) : (\n            <Text\n              {...this.getTestProps('value')}\n              style={[this.styles.text, this.styles.value]}\n            >\n              {this.scale?.ticks.find(t => t.datafield === props.datavalue)?.displayfield}\n            </Text>\n          )}\n          <Text\n            {...this.getTestProps('max')}\n            style={[this.styles.text, this.styles.maximumValue]}\n          >\n            {last(this.scale?.ticks)?.displayfield}\n          </Text>\n        </View>\n      );\n  }\n\n  renderMarkers(props: WmSliderProps) {\n    const width = this.state.track?.width || 0;\n    return (<View style={{ flexDirection: 'row' }}>\n      <View>\n        {width ? this.scale.ticks.map((t, i) => {\n          const markWidth = 10;\n          const stepwiseLeft = this.getPositionFromValue(t.markValue);\n          const labelText = t.displayfield;\n          return (\n            <View\n              key={i}\n              style={[\n                this.styles.markerWrapper,\n                {\n                  left: stepwiseLeft,\n                  bottom: markWidth / 2,\n                },\n              ]}\n            >\n              <Text\n                style={[\n                  this.styles.markerLabel,\n                  {\n                    bottom: markWidth / 2 + 10,\n                  },\n                  this.styles.markerLabelStyle,\n                  i === 0 ? this.styles.minimumValue : null,\n                  i === this.scale.ticks.length - 1 ? this.styles.maximumValue : null,\n                ]}\n              >\n                {labelText}\n              </Text>\n              <View\n                style={[\n                  this.styles.mark,\n                  {\n                    width: markWidth,\n                    height: markWidth,\n                    borderRadius: markWidth,\n                  },\n                  this.styles.markerStyle,\n                ]}\n              />\n            </View>\n          );\n        }) : null}\n      </View>\n    </View>);\n  }\n\n  renderTracks(props: WmSliderProps) {\n    const width = this.state.track?.width || 0;\n    const sDataValue = this.getScaledDataValue();\n    const isRangeSlider = props.range && sDataValue.length > 1;\n    return (\n      <GestureDetector gesture={this.trackGesture}>\n        <TouchableOpacity\n          activeOpacity={1}\n          style={[this.styles.track, this.styles.trackStyle]}\n          onLayout={this.onLayoutChange}\n          {...this.getTestProps()}\n          {...getAccessibilityProps(AccessibilityWidgetType.SLIDER, props)}\n        >\n          <Animated.View\n            style={[\n              isRangeSlider && this.highPosition\n                ? this.styles.maximumTrack\n                : this.styles.minimumTrack,\n              {\n                width: width,\n                transform: [\n                  {\n                    translateX: this.position.interpolate({\n                      inputRange: [0, width],\n                      outputRange: [-width, 0],\n                    }),\n                  },\n                ],\n              },\n              this.styles.minimumTrackStyle,\n            ]}\n          ></Animated.View>\n          <Animated.View\n            style={[\n              isRangeSlider && this.highPosition\n                ? this.styles.minimumTrack\n                : this.styles.maximumTrack,\n              {\n                width: width,\n                transform: [\n                  {\n                    translateX: this.position,\n                  },\n                ],\n              },\n              this.styles.activeTrackStyle,\n            ]}\n          ></Animated.View>\n          {isRangeSlider && this.highPosition ? (\n            <Animated.View\n              style={[\n                this.styles.maximumTrack,\n                {\n                  width: width,\n                  transform: [\n                    {\n                      translateX: this.highPosition,\n                    },\n                  ],\n                },\n                this.styles.maximumTrackStyle,\n              ]}\n            />\n          ) : null}\n        </TouchableOpacity>\n      </GestureDetector>\n    );\n  }\n\n  renderWidget(props: WmSliderProps) {\n    const sDataValue = this.getScaledDataValue();\n    return (\n      <View style={this.styles.root} onLayout={(event) => this.handleLayout(event)}>\n        {this._background}\n        {!props.showmarkers && !props.showtooltip? this.renderOldMarkerStyle(props) : null}\n        {this.renderTracks(props)}\n        <View style={{ flexDirection: 'row' }}>\n          {props.showmarkers ? this.renderMarkers(props) : null}\n          {this.renderToolTips(props)}\n        </View>\n      </View>\n    );\n  }\n}", "wavemaker-rn-runtime/src/components/input/slider/slider.props.ts": "import { TooltipDirection } from '../../basic/tooltip/tooltip.props';\nimport BaseDatasetProps from '../basedataset/basedataset.props';\n\nexport default class WmSliderProps extends BaseDatasetProps {\n    range?: boolean = false;\n    minvalue: number = 0;\n    maxvalue: number = 100;\n    step?: number = 1;\n    datatype: 'number' | 'dataset' = \"number\";\n    showmarkers = false;\n    showtooltip? = false;\n    tooltipdirection?: TooltipDirection = \"up\";\n    markerlabeltext?: Array<string | number> = [];\n    getToolTipExpression?: (item: number) => string;\n}\n", "wavemaker-rn-runtime/src/components/input/slider/slider.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { TextStyle, ViewStyle } from 'react-native';\n\nexport type WmSliderStyles = BaseStyles & {\n    minimumValue: TextStyle,\n    maximumValue: TextStyle,\n    value: TextStyle,\n    track: ViewStyle,\n    minimumTrack: ViewStyle,\n    maximumTrack: ViewStyle,\n    thumb: ViewStyle,\n    disabled: ViewStyle,\n    markerWrapper: ViewStyle,\n    markerLabel: TextStyle,\n    mark: ViewStyle,\n    trackStyle: ViewStyle,\n    markerStyle: ViewStyle,\n    markerLabelStyle: TextStyle,\n    minimumTrackStyle: ViewStyle,\n    maximumTrackStyle: ViewStyle,\n    activeTrackStyle: ViewStyle,\n    tooltip: ViewStyle;\n};\n\nexport const DEFAULT_CLASS = 'app-slider';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmSliderStyles = defineStyles({\n        root: {\n        },\n        text: {\n            fontSize: 16\n        },\n        minimumValue: {\n\n        },\n        maximumValue: {\n\n        },\n        value: {\n\n        },\n        track: {\n            position: 'relative',\n            height: 4,\n            flexDirection: 'row',\n            width: '100%',\n            minWidth: 160,\n            marginVertical: 8,\n            overflow: 'hidden',\n            borderRadius: 4\n        },\n        minimumTrack: {\n            position: 'absolute',\n            height: '100%',\n            width:  150,\n            backgroundColor: themeVariables.minimumTrackTintColor,\n            borderTopLeftRadius: 4,\n            borderBottomLeftRadius: 4,\n        },\n        maximumTrack: {\n            position: 'absolute',\n            height: '100%',\n            backgroundColor: themeVariables.maximumTrackTintColor,\n            flex: 1,\n            borderTopRightRadius: 4,\n            borderBottomRightRadius: 4,\n        },\n        thumb: {\n            height: 20,\n            width: 20,\n            position: 'absolute',\n            left: 0,\n            marginLeft: -10,\n            marginTop: -20,\n            borderRadius: 16,\n            backgroundColor: themeVariables.thumbTintColor,\n            backgroundSize: '100% 100%',\n            backgroundPosition: 'center'\n        },\n        disabled: {\n            pointerEvents: 'none'\n        },\n        markerWrapper: {\n            position: 'absolute',\n        },\n        markerLabel: {\n            position: 'absolute',\n            bottom: 15,\n        },\n        mark: {\n            position: 'absolute',\n            backgroundColor: 'rgba(0,0,0,0.2)',\n            bottom: 0,\n        },\n        trackStyle: {},\n        markerStyle: {},\n        markerLabelStyle: {},\n        minimumTrackStyle: {},\n        maximumTrackStyle: {},\n        activeTrackStyle: {},\n        tooltip: {},\n        tooltipLabel: {},\n        tooltipTriangle: {},\n    }) as WmSliderStyles;\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n    addStyle(DEFAULT_CLASS + '-disabled', '', {\n        root : {\n        opacity: 0.5\n        }\n    });\n});", "wavemaker-rn-runtime/src/components/input/baseinput/baseinput.props.ts": "import {AccessibilityRole} from \"react-native\";\nimport { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class BaseInputProps extends BaseProps {\n  autofocus: boolean = null as any;\n  // autocomplete: boolean = true;\n  autocomplete: string = \"username\";\n  autotrim: boolean = true;\n  datavalue: any;\n  hastwowaybinding = false;\n  maxchars: number = null as any;\n  readonly: boolean = null as any;\n  regexp: string = null as any;\n  type: string = 'text';\n  updateon: string = 'blur' as any;\n  required?: boolean = false as any;\n  checkFormField?: any;\n  onFieldChange?: any;\n  triggerValidation?: any;\n  accessibilitylabel?: string = undefined;\n  hint?: string = undefined;\n  accessibilityrole?: AccessibilityRole;\n  accessibilitylabelledby?: string = undefined;\n  maskchar: string = null as any;\n  displayformat: string = null as any;\n}\n", "wavemaker-rn-runtime/src/components/input/baseinput/baseinput.component.ts": "import { DEFAULT_CLASS } from '@wavemaker/app-rn-runtime/components/navigation/basenav/basenav.styles';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport BaseInputProps from './baseinput.props';\nimport { isString } from 'lodash';\nimport { BaseInputStyles } from './baseinput.styles';\nimport { Platform, TextInput } from 'react-native';\nimport { validateField } from '@wavemaker/app-rn-runtime/core/utils';\nimport Injector from '@wavemaker/app-rn-runtime/core/injector';\n\nexport class BaseInputState <T extends BaseInputProps> extends BaseComponentState<T> {\n  keyboardType: any = 'default';\n  isValid: boolean = true;\n  isInputFocused: boolean = false;\n  textValue: string = '';\n  isDefault = false;\n  errorType: string = '';\n}\nexport abstract class BaseInputComponent< T extends BaseInputProps, S extends BaseInputState<T>, L extends BaseInputStyles> extends BaseComponent<T, S, L> {\n  public widgetRef: TextInput | null = null;\n  isTouched: boolean = false;\n  private cursor: any = 0;\n  private timer: ReturnType<typeof setTimeout> | null = null;\n  constructor(props: T, public defaultClass: string = DEFAULT_CLASS, defaultProps?: T, defaultState?: S) {\n    super(props, defaultClass, defaultProps, defaultState);\n  }\n  public charlength:number = 0;\n\n  focus() {\n    this?.widgetRef?.focus();\n  }\n\n  blur() {\n    this?.widgetRef?.blur && this?.widgetRef?.blur();\n  }\n\n  onPropertyChange(name: string, $new: any, $old: any) {\n    switch (name) {\n      case 'type':\n        let keyboardType;\n        if (this.props.type === 'number') {\n          keyboardType = 'numeric';\n        } else if (this.props.type === 'tel') {\n          keyboardType = 'phone-pad';\n        } else if (this.props.type === 'email') {\n          keyboardType = 'email-address';\n        }\n        this.updateState({\n          keyboardType: keyboardType,\n        } as S);\n        break;\n      case 'datavalue':\n        this.updateState({\n            textValue: $new\n          } as S\n        );\n        \n        const isDefault = this.state.props.isdefault;\n        if (isDefault) {\n          this.updateState({ props: {isdefault: false} } as S, this.props.onFieldChange && this.props.onFieldChange.bind(this, 'datavalue', $new, $old, isDefault));\n        } else {\n          this.props.onFieldChange && this.props.onFieldChange('datavalue', $new, $old, isDefault);\n        }\n    }\n  }\n\n  onChange(event: any) {\n    if (this.state.props.updateon === 'default') {\n      this.updateDatavalue(event.target.value, event);\n    }else if(this.state.props.updateon === 'lazy') {\n      if(this.timer !== null) {\n        clearTimeout(this.timer);\n        this.timer = null;\n      }\n\n      this.timer = setTimeout(() => {\n        this.updateDatavalue(event.target.value, event);\n      }, 300)\n    }\n  }\n\n  onChangeText(value: any) {\n    this.charlength = value?.length;\n    if(this.state.props.updateon === 'lazy') {\n      if(this.timer !== null) {\n        clearTimeout(this.timer);\n        this.timer = null;\n      }\n\n      this.timer = setTimeout(() => {\n        this.updateState({\n          textValue: value\n        } as S, () => {\n          this.validate(value);\n          this.updateDatavalue(value, null);\n          }\n        );\n      }, 300)\n    }\n    else {\n      this.updateState({\n          textValue: value\n        } as S, () => {\n          if (this.state.props.updateon === 'default') {\n            this.validate(value);\n            this.updateDatavalue(value, null);\n          }\n        }\n      );\n    }\n  }\n\n  invokeChange(e: any) {\n    if (Platform.OS === 'web') {\n      this.cursor = e.target.selectionStart;\n      this.setState({ textValue: e.target.value });\n    }\n  }\n\n  updateDatavalue(value: any, event?: any, source?: any) {\n    const props = this.state.props;\n    const oldValue = props.datavalue;\n    if (value === oldValue) {\n      return;\n    }\n\n    // autotrim\n    if (props.autotrim && props.datavalue && isString(props.datavalue)) {\n      value = value.trim();\n    }\n    new Promise((resolve) => {\n      if (props.hastwowaybinding) {\n        this.setProp(\"datavalue\", value);\n        this.updateState({props: { \"datavalue\": value }} as S);\n        resolve(true);\n      } else {\n        this.updateState({\n          props: {\n            datavalue: value\n          }\n        } as S, () => resolve(true));\n      }\n    }).then(() => {\n      !this.props.onFieldChange && value !== oldValue && this.invokeEventCallback('onChange', [event, this.proxy, value, oldValue]);\n      if (source === 'blur') {\n        setTimeout(() => {\n          this.invokeEventCallback('onBlur', [event, this.proxy]);\n        }, 10);\n      }\n    })\n  }\n\n  onBlur(event: any) {\n    Injector.FOCUSED_ELEMENT.remove();\n    this.isTouched = true;\n    let newVal = this.state.textValue || '';\n    let oldVal = this.state.props.datavalue || '';\n    this.validate(newVal);\n    if (newVal === '' || newVal == undefined) {\n      setTimeout(() => {\n        this.props.triggerValidation && this.props.triggerValidation();\n      },10)\n    }\n    if (this.state.props.updateon === 'blur' || this.state.props.updateon === 'default') {\n      if (oldVal !== newVal && this.state.props.updateon === 'blur') {\n        this.updateDatavalue(newVal, event, 'blur');\n      } else {\n        this.invokeEventCallback('onBlur', [event, this.proxy]);\n      }\n      this.setState({ isInputFocused: false })\n    }\n  }\n\n  validate(value: any) {\n    const validationObj = validateField(this.state.props, value);\n    this.setState({\n      isValid: validationObj.isValid,\n      errorType: validationObj.errorType\n    } as S);\n  }\n\n  onFocus(event: any) {\n    // When input widgets are inside list widget and try to focus the field, list is selecting but unable to enter values in input fields\n    // because on tap event of list is triggering after 200ms timeout So added 250ms timeout here\n    setTimeout(() => {\n      Injector.FOCUSED_ELEMENT.set(this);\n      this.invokeEventCallback('onFocus', [ event, this.proxy]);\n      this.closestTappable?.triggerTap();\n    }, 250);\n    this.setState({ isInputFocused: true })\n  }\n\n  onKeyPress(event: any) {\n    this.invokeEventCallback('onKeypress', [ event, this.proxy]);\n  }\n}\n", "wavemaker-rn-runtime/src/components/input/baseinput/baseinput.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type BaseInputStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-baseinput';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: BaseInputStyles = defineStyles({\n    root: {},\n    text: {}\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n});\n", "wavemaker-rn-runtime/src/components/input/composite/composite.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmCompositeProps from './composite.props';\nimport { DEFAULT_CLASS, WmCompositeStyles } from './composite.styles';\n\nexport class WmCompositeState extends BaseComponentState<WmCompositeProps> {};\n\nconst POSITION_STYLES = {\n  'top': 'app-composite-top-caption',\n  'left': 'app-composite-left-caption',\n  'right': 'app-composite-right-caption'\n};\n\nexport default class WmComposite extends BaseComponent<WmCompositeProps, WmCompositeState, WmCompositeStyles> {\n\n  constructor(props: WmCompositeProps) {\n    super(props, DEFAULT_CLASS, new WmCompositeProps());\n  }\n\n  renderWidget(props: WmCompositeProps) {\n    const styles = this.theme.mergeStyle({}, \n      this.styles,\n      props.captionposition ? this.theme.getStyle(POSITION_STYLES[props.captionposition]) : {}\n    );\n    return (<View style={styles.root} onLayout={(event) => this.handleLayout(event)}>{this._background}{props.children}</View>); \n  }\n}\n", "wavemaker-rn-runtime/src/components/input/composite/composite.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type WmCompositeStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-composite';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmCompositeStyles = defineStyles({\n        root: {\n            flexDirection: 'row',\n            alignItems: 'flex-start'\n        },\n        text: {}\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n    addStyle('app-composite-left-caption', DEFAULT_CLASS,  {\n        root: {\n            flexDirection: 'row'\n        }\n    } as WmCompositeStyles);\n    addStyle('app-composite-right-caption', DEFAULT_CLASS,  {\n        root: {\n            flexDirection: 'row-reverse'\n        }\n    } as WmCompositeStyles);\n    addStyle('app-composite-top-caption', DEFAULT_CLASS, {\n        root: {\n            flexDirection: 'column'\n        }\n    } as WmCompositeStyles);\n});", "wavemaker-rn-runtime/src/components/input/composite/composite.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmCompositeProps extends BaseProps {\n    children: any;\n    captionposition: 'left' | 'right' | 'top' | undefined = undefined;\n}", "wavemaker-rn-runtime/src/components/input/number/number.styles.ts": "import BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmSkeletonStyles } from '../../basic/skeleton/skeleton.styles';\n\nexport type WmNumberStyles = BaseStyles & {\n  invalid: AllStyle;\n  focused: AllStyle;\n  placeholderText: AllStyle;\n  floatingLabel: AllStyle;\n  activeFloatingLabel: AllStyle;\n  skeleton: WmSkeletonStyles;\n  skeletonLabel: WmSkeletonStyles;\n};\n\nexport const DEFAULT_CLASS = 'app-number';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmNumberStyles = defineStyles<WmNumberStyles>({\n      root: {\n        minHeight: 42,\n        paddingTop: 8,\n        paddingBottom: 8,\n        borderWidth: 1,\n        borderStyle: 'solid',\n        borderColor: themeVariables.inputBorderColor,\n        backgroundColor: themeVariables.inputBackgroundColor,\n        borderRadius: 6,\n        paddingLeft: 16,\n        paddingRight: 16\n      },\n      text: {\n        fontSize: 16,\n        textAlign: 'left'\n      },\n      invalid: {\n        borderBottomColor: themeVariables.inputInvalidBorderColor\n      },\n      focused : {\n        borderColor: themeVariables.inputFocusBorderColor,\n      },\n      placeholderText: {\n        color: themeVariables.inputPlaceholderColor\n      },\n      floatingLabel: {},\n      activeFloatingLabel: {},\n      skeleton: {\n        root:{\n          borderRadius: 6,\n          paddingLeft: 16,\n          paddingRight: 16,\n          minHeight: 42,\n          paddingTop: 8,\n          paddingBottom: 8,\n          width: '100%',\n          height: 40,\n        },\n      } as any as WmSkeletonStyles,\n      skeletonLabel: {\n        root: {\n          bottom: 12,\n          left: 16,\n          width:80,\n          height:16,\n          borderRadius:4\n        }\n      } as any as WmSkeletonStyles\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n  addStyle(DEFAULT_CLASS + '-disabled', '', {\n      root : {\n        backgroundColor: themeVariables.inputDisabledBgColor\n      }\n  });\n  addStyle(DEFAULT_CLASS + '-rtl', '', {\n      root : {\n        textAlign: 'right'\n      }\n  });\n  addStyle(DEFAULT_CLASS + '-with-label', '', {\n    root: {\n      minHeight: 48\n    },\n    floatingLabel: {\n      position: 'absolute',\n      top: 12,\n      left: 16,\n      fontSize: 14,\n      color: themeVariables.floatingLabelColor\n    },\n    activeFloatingLabel: {\n      color: themeVariables.activeFloatingLabelColor\n    }\n  });\n});\n\n", "wavemaker-rn-runtime/src/components/input/number/number.component.tsx": "import React from 'react';\nimport { DimensionValue, LayoutChangeEvent, Platform, View } from 'react-native';\nimport { isNull } from 'lodash';\n\nimport WmNumberProps from './number.props';\nimport { DEFAULT_CLASS, WmNumberStyles } from './number.styles';\nimport { WMTextInput } from '@wavemaker/app-rn-runtime/core/components/textinput.component';\nimport {\n  BaseNumberComponent,\n  BaseNumberState\n} from '@wavemaker/app-rn-runtime/components/input/basenumber/basenumber.component';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility'; \nimport { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\nimport { WmSkeletonStyles } from '../../basic/skeleton/skeleton.styles';\n\nexport class WmNumberState extends BaseNumberState<WmNumberProps> {\n  keyboardType: any;\n}\n\nexport default class WmNumber extends BaseNumberComponent<WmNumberProps, WmNumberState, WmNumberStyles> {\n\n  constructor(props: WmNumberProps) {\n    super(props, DEFAULT_CLASS, new WmNumberProps(), new WmNumberState());\n  }\n\n  public getStyleClassName(): string | undefined {\n    const classes = [];\n    if (this.state.props.floatinglabel) {\n      classes.push('app-number-with-label'); \n    }\n    classes.push(super.getStyleClassName());\n    return classes.join(' ');\n  }\n\n  public renderTextSkeleton(): React.ReactNode { \n    return this.props.floatinglabel  ?   \n      <View style={{...this.styles.root}}>{createSkeleton(this.theme, {} as WmSkeletonStyles, {...this.styles.skeletonLabel.root})}</View>\n    :<>{createSkeleton(this.theme, {} as WmSkeletonStyles, {\n      ...this.styles.skeleton.root,\n    })}</> \n  }\n\n  renderWidget(props: WmNumberProps) {\n    let opts: any = {};\n    const valueExpr = Platform.OS === 'web' ? 'value' : 'defaultValue';\n    opts[valueExpr] = this.state.textValue?.toString() || '';\n    return (this._showSkeleton ? this.renderTextSkeleton() : \n    <WMTextInput\n      {...this.getTestPropsForInput()}\n      {...getAccessibilityProps(AccessibilityWidgetType.NUMBER, props)}\n      ref={(ref: any) => {this.widgetRef = ref;\n        // @ts-ignore\n        if (ref && !isNull(ref.selectionStart) && !isNull(ref.selectionEnd)) {\n          // @ts-ignore\n          ref.selectionStart = ref.selectionEnd = this.cursor;\n        }}}\n      {...opts}\n      floatingLabel={props.floatinglabel}\n      floatingLabelStyle={this.styles.floatingLabel}\n      activeFloatingLabelStyle={this.styles.activeFloatingLabel}\n      isInputFocused={ this.state.isInputFocused }\n      style={[this.styles.root, this.state.isValid ? {} : this.styles.invalid, this.state.isInputFocused ? this.styles.focused : {}]}\n      keyboardType=\"numeric\"\n      background={this._background}\n      placeholderTextColor={this.styles.placeholderText.color as any}\n      autoFocus={props.autofocus}\n      editable={props.disabled || props.readonly ? false : true}\n      placeholder={props.placeholder}\n      onBlur={(event)=>{this.onBlur.bind(this)(event, !!props.displayValue)}}\n      onFocus={this.onFocus.bind(this)}\n      onKeyPress={this.validateInputEntry.bind(this)}\n      onChangeText={(text) => {\n        this.onChangeText.bind(this)(text, 'number', !!props.displayValue);\n      }}\n      onChange={this.invokeChange.bind(this)}\n      allowContentSelection={this.styles.text.userSelect === 'text'}\n      customDisplayValue={props.displayValue}\n      handleLayout={(event: LayoutChangeEvent) => this.handleLayout(event)}\n    />);\n  }\n}\n", "wavemaker-rn-runtime/src/components/input/number/number.props.ts": "import BaseNumberProps from '@wavemaker/app-rn-runtime/components/input/basenumber/basenumber.props';\n\nexport default class WmNumberProps extends BaseNumberProps {\n  autofocus: boolean = null as any;\n  floatinglabel?: string;\n  placeholder: string = '';\n}\n", "wavemaker-rn-runtime/src/components/input/toggle/toggle.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { ViewStyle } from 'react-native';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmToggleStyles = BaseStyles & {\n  handle: ViewStyle,\n  skeleton: WmSkeletonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-toggle';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmToggleStyles = defineStyles({\n      root: {\n        width: 52,\n        height: 32,\n        flexDirection: 'row',\n        alignItems: 'center',\n        borderRadius: 18\n      },\n      text: {},\n      handle: {\n        width: 16,\n        height: 16,\n        borderRadius: 18,\n        marginLeft : 8,\n        marginRight: 0,\n        backgroundSize: '100% 100%',\n        backgroundPosition: 'center'\n      },\n      skeleton: {\n        root: {\n          width: 52,\n          height: 32,\n          borderRadius: 18,\n        }\n      } as WmSkeletonStyles\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n  addStyle(DEFAULT_CLASS + '-on', '', {\n    root : {\n      backgroundColor: themeVariables.toggleOnColor,\n    },\n    handle: {\n      backgroundColor: themeVariables.toggleHandleColor,\n    }\n  } as WmToggleStyles);\n  addStyle(DEFAULT_CLASS + '-off', '', {\n    root : {\n      backgroundColor: themeVariables.toggleOffColor,\n      borderColor: themeVariables.toggleOffBorderColor,\n      borderWidth: 2\n    },\n    handle: {\n      backgroundColor: themeVariables.toggleHandleDisableColor,\n    }\n  } as WmToggleStyles);\n  addStyle(DEFAULT_CLASS + '-rtl', '', {});\n  addStyle(DEFAULT_CLASS + '-disabled', '', {\n      root : {}\n  });\n});\n", "wavemaker-rn-runtime/src/components/input/toggle/toggle.props.ts": "import {AccessibilityRole} from 'react-native';\nimport { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmToggleProps extends BaseProps {\n  checkedvalue: any = true;\n  uncheckedvalue: any = false;\n  datavalue: any;\n  readonly? = false;\n  onFieldChange: any;\n  accessibilitylabel?: string = undefined;\n  hint?: string = undefined;\n  accessibilityrole?: AccessibilityRole = \"togglebutton\";\n  accessibilitylabelledby?: string = undefined;\n  invokeEvent?: Function;\n  skeletonheight?: string = null as any;\n  skeletonwidth?: string = null as any;\n}\n", "wavemaker-rn-runtime/src/components/input/toggle/toggle.component.tsx": "import React from 'react';\nimport { TouchableOpacity, Animated, Easing, LayoutChangeEvent, View, DimensionValue } from 'react-native';\n\nimport { BackgroundComponent } from '@wavemaker/app-rn-runtime/styles/background.component';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { unStringify, validateField} from '@wavemaker/app-rn-runtime/core/utils';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility'; \n\nimport WmToggleProps from './toggle.props';\nimport { DEFAULT_CLASS, WmToggleStyles } from './toggle.styles';\nimport { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\n\nexport class WmToggleState extends BaseComponentState<WmToggleProps> {\n  isSwitchOn: boolean = false;\n  isValid: boolean = true;\n  errorType = '';\n  viewWidth: number = 0;\n}\n\nexport default class WmToggle extends BaseComponent<WmToggleProps, WmToggleState, WmToggleStyles> {\n\n  private animationValue = new Animated.Value(0);\n  private scaleValue = new Animated.Value(1);\n\n  constructor(props: WmToggleProps) {\n    super(props, DEFAULT_CLASS, new WmToggleProps(), new WmToggleState());\n  }\n\n  onPropertyChange(name: string, $new: any, $old: any) {\n    switch (name) {\n      case 'datavalue':\n        let value =\n          unStringify($new) ===\n          unStringify(this.state.props.checkedvalue, true);\n        this.updateState({ isSwitchOn: value } as WmToggleState);\n        break;\n    }\n  }\n\n  updateDatavalue(value: any) {\n    this.updateState({ props: { datavalue: value }} as WmToggleState);\n  }\n\n  validate(value: any) {\n    const validationObj = validateField(this.state.props, value);\n    this.updateState({\n      isValid: validationObj.isValid,\n      errorType: validationObj.errorType\n    } as WmToggleState);\n  }\n\n  onToggleSwitch(value: any) {\n    const oldValue = this.state.props.datavalue;\n    this.validate(value);\n    this.updateState({ isSwitchOn: value } as WmToggleState);\n    const dataValue = value === true ? this.state.props.checkedvalue : this.state.props.uncheckedvalue;\n    Animated.sequence([\n      Animated.timing(this.scaleValue, {\n        toValue: 1.6,\n        duration: 300,\n        useNativeDriver: true,\n      }),\n      Animated.timing(this.animationValue, {\n        toValue: value ? 1 : 0,\n        duration: 300,\n        easing: Easing.linear,\n        useNativeDriver: true,\n      }),\n    ]).start(() => {\n      Animated.timing(this.scaleValue, {\n        toValue: value ? 1.5 : 1,\n        duration: 0,\n        useNativeDriver: true,\n      }).start();\n    });\n    // @ts-ignore\n    this.updateState({ props: { datavalue: dataValue } },\n      ()=> {\n        if (!this.props.onFieldChange) {\n          this.invokeEventCallback('onChange', [null, this.proxy, dataValue, oldValue]);\n        } else {\n          this.props.onFieldChange && this.props.onFieldChange('datavalue', dataValue, oldValue);\n        }\n        setTimeout(() => {\n          this.invokeEventCallback('onBlur', [ null, this.proxy ]);\n        }, 10);\n        \n      });\n  }\n\n  onLayoutChange(event: LayoutChangeEvent){\n    let width = event.nativeEvent.layout.width;\n    this.handleLayout(event)\n\n    this.setState({\n      viewWidth: width,\n    } as WmToggleState);\n  }\n\n  public renderSkeleton(props: WmToggleProps): React.ReactNode {\n      \n      return createSkeleton(this.theme, this.styles.skeleton, {\n        ...this.styles.skeleton.root,\n      });\n  }\n\n  renderWidget(props: WmToggleProps) {\n    const styles = this.theme.mergeStyle(this.styles, \n      this.theme.getStyle(this.state.isSwitchOn ? 'app-toggle-on' : 'app-toggle-off'));\n    return (\n      <TouchableOpacity \n      onLayout={(e) => {\n        this.onLayoutChange(e);\n      }}\n      {...getAccessibilityProps(AccessibilityWidgetType.TOGGLE, {...this.props, selected: this.state.isSwitchOn})}\n      onPress={() => {\n        if (this.props.disabled || this.props.readonly) {\n          return;\n        }\n        // Added setTimeout to smooth animation\n        setTimeout(() => {\n          this.invokeEventCallback('onFocus', [null, this]);\n          this.invokeEventCallback('onTap', [null, this]);\n        }, 500);\n        this.onToggleSwitch(!this.state.isSwitchOn);\n      }}{...this.getTestPropsForAction()}\n      style={styles.root}>\n       {styles.root.animation && styles.root.animation === 'none' ? (\n          <View style={styles.handle}>\n            <BackgroundComponent\n              size={styles.handle.backgroundSize || 'contain'}\n              position={styles.handle.backgroundPosition}\n              image={styles.handle.backgroundImage}\n              repeat={styles.handle.backgroundRepeat || 'no-repeat'}\n            />\n          </View>\n          ): ( <Animated.View\n            style={[\n              styles.handle,\n              {\n                transform: [\n                  {\n                    translateX: this.animationValue.interpolate({\n                      inputRange: [0, 1],\n                      // TODO Abdullah: add a test case for the below changes. Merging this to expo 52 release branch. \n                      outputRange: this.isRTL\n                        ? [0, -1 * (this.state.viewWidth - (this.styles.handle.width as number + 18))]\n                        : [0, this.state.viewWidth - (this.styles.handle.width as number + 18)],\n                    }),\n                  },\n                  { scale: this.scaleValue }\n                ],\n              },\n            ]}>\n            <BackgroundComponent\n              size={styles.handle.backgroundSize || 'contain'}\n              position={styles.handle.backgroundPosition}\n              image={styles.handle.backgroundImage}\n              repeat={styles.handle.backgroundRepeat || 'no-repeat'}\n            />\n          </Animated.View>)}\n      </TouchableOpacity>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/input/textarea/textarea.props.ts": "import BaseInputProps from '@wavemaker/app-rn-runtime/components/input/baseinput/baseinput.props';\n\nexport default class WmTextareaProps extends BaseInputProps {\n  floatinglabel?: string;\n  placeholder: string = 'Place your text';\n  skeletonheight?: string = null as any;\n  skeletonwidth?: string = null as any;\n  limitdisplaytext?: string = null as any;\n}\n", "wavemaker-rn-runtime/src/components/input/textarea/textarea.component.tsx": "import React from 'react';\nimport { DimensionValue, Platform,Text } from 'react-native';\nimport WmTextareaProps from './textarea.props';\nimport { DEFAULT_CLASS, WmTextareaStyles } from './textarea.styles';\nimport {\n  BaseInputComponent,\n  BaseInputState\n} from '@wavemaker/app-rn-runtime/components/input/baseinput/baseinput.component';\nimport { WMTextInput } from '@wavemaker/app-rn-runtime/core/components/textinput.component';\nimport { isNull } from 'lodash';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility'; \nimport { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\n\nexport class WmTextareaState extends BaseInputState<WmTextareaProps> {}\n\nexport default class WmTextarea extends BaseInputComponent<WmTextareaProps, WmTextareaState, WmTextareaStyles> {\n\n  constructor(props: WmTextareaProps) {\n    super(props, DEFAULT_CLASS, new WmTextareaProps(), new WmTextareaState());\n  }\n\n  public getStyleClassName(): string | undefined {\n    const classes = [];\n    if (this.state.props.floatinglabel) {\n      classes.push('app-textarea-with-label'); \n    }\n    classes.push(super.getStyleClassName());\n    return classes.join(' ');\n  }\n\n  public renderSkeleton(props: WmTextareaProps): React.ReactNode {\n    let skeletonWidth, skeletonHeight;\n    if(this.props.skeletonwidth == \"0\") {\n      skeletonWidth = 0\n    } else {\n      skeletonWidth = this.props.skeletonwidth || this.styles.root?.width\n    }\n\n    if(this.props.skeletonheight == \"0\") {\n      skeletonHeight = 0\n    } else {\n      skeletonHeight = this.props.skeletonheight || this.styles.root?.height;\n    }\n\n    return createSkeleton(this.theme, this.styles.skeleton, {\n      ...this.styles.root,\n      width: skeletonWidth as DimensionValue,\n      height: skeletonHeight as DimensionValue\n    });\n  }\n\n  renderWidget(props: WmTextareaProps) {\n    let opts: any = {};\n    const valueExpr = Platform.OS === 'web' ? 'value' : 'defaultValue';\n    opts[valueExpr] = this.state.textValue?.toString() || '';\n    return ( \n      <>\n    <WMTextInput\n      {...this.getTestPropsForInput()}\n      {...getAccessibilityProps(\n        AccessibilityWidgetType.TEXTAREA,\n        props\n      )}\n      ref={(ref: any) => {this.widgetRef = ref;\n        // @ts-ignore\n        if (ref && !isNull(ref.selectionStart) && !isNull(ref.selectionEnd)) {\n          // @ts-ignore\n          ref.selectionStart = ref.selectionEnd = this.cursor;\n        }}}\n      placeholderTextColor={this.styles.placeholderText.color as any}\n      isInputFocused={ this.state.isInputFocused }\n      style={[this.styles.root, this.styles.text, this.state.isValid ? {} : this.styles.invalid, this.state.isInputFocused ? this.styles.focused : {}]}\n      multiline={true}\n      numberOfLines={4}\n      background={this._background}\n      keyboardType={this.state.keyboardType}\n      {...opts}\n      floatingLabel={props.floatinglabel}\n      floatingLabelStyle={this.styles.floatingLabel}\n      activeFloatingLabelStyle={this.styles.activeFloatingLabel}\n      autoComplete={props.autocomplete ? 'username' : 'off'}\n      autoFocus={props.autofocus}\n      editable={props.disabled || props.readonly ? false : true}\n      maxLength={props.maxchars}\n      placeholder={props.placeholder || 'Place your text'}\n      onBlur={this.onBlur.bind(this)}\n      onFocus={this.onFocus.bind(this)}\n      onKeyPress={this.onKeyPress.bind(this)}\n      onChangeText={this.onChangeText.bind(this)}\n      onChange={this.invokeChange.bind(this)}\n      allowContentSelection={this.styles.text.userSelect === 'text'}\n      handleLayout={this.handleLayout}\n    />\n     { (props.maxchars && props.limitdisplaytext) && <Text\n        style={[\n          this.styles.helpText\n        ]} >     \n         {props.limitdisplaytext}     \n    </Text>}\n    </>);\n  }\n}\n", "wavemaker-rn-runtime/src/components/input/textarea/textarea.styles.ts": "import BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\nimport ThemeVariables from '@wavemaker/app-rn-runtime/styles/theme.variables';\n\nexport type WmTextareaStyles = BaseStyles & {\n  invalid: AllStyle;\n  focused: AllStyle;\n  placeholderText: AllStyle;\n  floatingLabel: AllStyle;\n  activeFloatingLabel: AllStyle;\n  skeleton: WmSkeletonStyles;\n  helpText:AllStyle;\n};\n\nexport const DEFAULT_CLASS = 'app-textarea';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmTextareaStyles = defineStyles({\n      root: {\n        padding:12,\n        borderWidth:1,\n        borderStyle: 'solid',\n        borderColor: themeVariables.inputBorderColor,\n        backgroundColor: themeVariables.inputBackgroundColor,\n        borderRadius: 6,\n        fontFamily: themeVariables.baseFont,\n        minHeight: 160,\n      },\n      text: {\n        fontSize: 16,\n        textAlignVertical: 'top'\n      },\n      floatingLabel: {},\n      activeFloatingLabel: {},\n      invalid: {\n        borderBottomColor: 'red'\n      },\n      focused : {\n        borderColor: themeVariables.inputFocusBorderColor,\n      },\n      placeholderText: {\n        color: themeVariables.inputPlaceholderColor\n      },\n      skeleton: {\n        root: {\n          width: '100%',\n          height: 84,\n          borderRadius: 4\n        }\n      } as any as WmSkeletonStyles,\n      helpText:{\n        marginTop:5,\n        textAlign:'right',\n        fontSize: 13,\n        color: ThemeVariables.INSTANCE.textAreaHelpTextColor\n      }\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n  addStyle(DEFAULT_CLASS + '-disabled', '', {\n      root : {\n        backgroundColor: themeVariables.inputDisabledBgColor\n      }\n  });\n  addStyle(DEFAULT_CLASS + '-rtl', '', {\n    root:{\n      textAlign: 'right'\n    }\n  })\n  addStyle(DEFAULT_CLASS + '-with-label', '', {\n    text:{\n      paddingTop: 24\n    },\n    floatingLabel: {\n      position: 'absolute',\n      top: 12,\n      left: 16,\n      fontSize: 14,\n      color: themeVariables.floatingLabelColor\n    },\n    activeFloatingLabel: {\n      color: themeVariables.activeFloatingLabelColor\n    }\n  })\n});", "wavemaker-rn-runtime/src/components/input/switch/switch.component.tsx": "import React, { useRef } from 'react';\nimport {DimensionValue, LayoutChangeEvent, Text, View} from \"react-native\";\nimport { isEqual, find } from 'lodash';\n\nimport WmSwitchProps from './switch.props';\nimport { DEFAULT_CLASS, WmSwitchStyles } from './switch.styles';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport { BaseDatasetComponent, BaseDatasetState } from '../basedataset/basedataset.component';\nimport { Tappable } from '@wavemaker/app-rn-runtime/core/tappable.component';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility';\nimport { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\nimport { WmSkeletonStyles } from '../../basic/skeleton/skeleton.styles';\n\nexport class WmSwitchState extends BaseDatasetState<WmSwitchProps> {}\n\nexport default class WmSwitch extends BaseDatasetComponent<WmSwitchProps, WmSwitchState, WmSwitchStyles> {\n  constructor(props: WmSwitchProps) {\n    super(props, DEFAULT_CLASS, new WmSwitchProps());\n  }\n\n  onChange(value: any) {\n    if (!value) {\n      return;\n    }\n    const oldVal = this.state.props.datavalue;\n    this.validate(value);\n    if (value === oldVal) {\n      return;\n    }\n    if (this.state.props.datafield === 'All Fields') {\n      const selectedItem = find(this.state.dataItems, (item) => isEqual(item.key, value));\n      value = selectedItem && selectedItem.dataObject;\n    }\n    // @ts-ignore\n    this.updateState({props: {datavalue: value}, isDefault: false},\n      () => {\n      if (!this.props.invokeEvent) {\n        this.invokeEventCallback('onChange', [undefined, this.proxy, value, oldVal]);\n      }\n      });\n  }\n\n  onTap(event: any, item: any) {\n    const value = this.state.props.datafield === 'All Fields' ? this.getItemKey(item.datafield) : item.datafield;\n    this.onChange(value);\n    this.invokeEventCallback('onTap', [ event, this.proxy ]);\n  }\n  renderChild(item: any, index: any) {\n    let btnClass = 'button';\n    const props = this.state.props;\n    if(index === 0) {\n      btnClass = 'firstButton';\n    } else if (index+1 === this.state.dataItems.length) {\n      btnClass = 'lastButton';\n    }\n    const displayText = item.displayexp || item.displayfield;\n    const isSelected = this.state.props.datafield === 'All Fields' ? isEqual(props.datavalue, item.datafield) : this.state.props.datavalue === item.datafield;\n    return (\n      <Tappable\n        disableTouchEffect={this.state.props.disabletoucheffect}\n        {...this.getTestPropsForAction('button'+index)}\n        accessibilityProps={{...getAccessibilityProps(AccessibilityWidgetType.SWITCH, {selected: isSelected, hint: props?.hint})}}\n        onTap={this.state.props.disabled ? undefined : this.onTap.bind(this, null, item)}\n        styles={[\n          this.styles.button,\n          this.styles[btnClass],\n          isSelected ? this.styles.selectedButton : null]}\n          key={item.key}>\n        {this.state.props.iconclass ?\n            (<WmIcon\n              id={this.getTestId('icon' + index)}\n              styles={this.styles.loadingIcon}\n              iconclass={item.icon}\n              caption={displayText}></WmIcon>)\n            : (<View>\n                {\n                  this._showSkeleton ? createSkeleton(this.theme, {} as WmSkeletonStyles, {\n                    ...this.styles.text,\n                    ...this.styles.textSkeleton.root\n                  }) : <Text\n                  {...this.getTestPropsForLabel('label' + index)}\n                  style={[ isSelected ?  this.styles.selectedButtonText : this.styles.text,\n                    {color: isSelected ? this.styles.selectedButton.color : this.styles.button.color }]}>\n                  {displayText}\n                </Text>\n                }\n              </View>)}\n      </Tappable>\n    );\n  };\n\n  renderItems() {\n    const items = this.state.dataItems;\n    if(this._showSkeleton) {\n      return [{}, {}, {}].map((item: any, index: any) => this.renderChild(item, index))\n    }\n    return items && items.length ?\n      items.map((item: any, index: any) => this.renderChild(item, index)): null\n  }\n\n  renderWidget(props: WmSwitchProps) {\n    return (<View style={this.styles.root} onLayout={(event) => this.handleLayout(event)}>\n      {this.renderItems()}\n    </View>);\n  }\n}\n", "wavemaker-rn-runtime/src/components/input/switch/switch.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\nimport BaseDatasetProps from '../basedataset/basedataset.props';\n\nexport default class WmSwitchProps extends BaseDatasetProps {\n  dataset: any = 'yes, no, maybe';\n  dataItems: any;\n  invokeEvent?: Function;\n}\n", "wavemaker-rn-runtime/src/components/input/switch/switch.styles.ts": "import BASE_THEME, {AllStyle} from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport {WmIconStyles} from \"@wavemaker/app-rn-runtime/components/basic/icon/icon.styles\";\nimport { Platform } from 'react-native';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmSwitchStyles = BaseStyles & {\n  loadingIcon: WmIconStyles,\n  button: AllStyle,\n  selectedButton: AllStyle,\n  selectedButtonText: AllStyle,\n  firstButton: AllStyle,\n  lastButton: AllStyle,\n  skeleton: WmSkeletonStyles,\n  textSkeleton: WmSkeletonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-switch';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmSwitchStyles = defineStyles<WmSwitchStyles>({\n      root: {\n        minHeight: 24,\n        padding: 4,\n        flexDirection: 'row'\n      },\n      text: {\n        fontWeight: '500',\n        fontSize: 16,\n        textTransform: 'uppercase',\n        userSelect: 'none',\n      },\n    loadingIcon: {\n      root: {\n        flex: 1,\n        alignSelf: 'center',\n        justifyContent: 'center',\n        fontSize: 16\n      },\n      text: {\n        color: themeVariables.listSubTitleColor\n      }\n    } as WmIconStyles,\n    button: {\n      backgroundColor: themeVariables.switchBgColor,\n      color: themeVariables.switchTextColor,\n      fontSize: 14,\n      minWidth: 64,\n      height: 40,\n      paddingLeft: 16,\n      paddingRight: 16,\n      borderTopLeftRadius: 0,\n      borderBottomLeftRadius: 0,\n      borderBottomRightRadius: 0,\n      borderTopRightRadius: 0,\n      borderColor: themeVariables.switchBorderColor,\n      borderWidth: 1,\n      borderRightWidth: 0,\n      fontWeight: '500',\n      fontFamily: themeVariables.baseFont,\n      justifyContent: 'center',\n      alignItems: 'center'\n    } as AllStyle,\n    selectedButton: {\n      color: themeVariables.switchActiveTextColor,\n      backgroundColor: themeVariables.switchActiveBgColor,\n      borderColor: themeVariables.switchBorderColor\n    } as AllStyle,\n    selectedButtonText: {\n      fontWeight: '500',\n      fontSize: 16,\n      textTransform: 'uppercase'\n    } as AllStyle,\n    firstButton: {\n      borderTopLeftRadius: 18,\n      borderBottomLeftRadius: 18,\n      borderTopRightRadius: 0,\n      borderBottomRightRadius: 0\n    } as AllStyle,\n    lastButton: {\n      borderTopLeftRadius: 0,\n      borderBottomLeftRadius: 0,\n      borderTopRightRadius: 18,\n      borderBottomRightRadius: 18,\n      borderRightWidth: 1\n    } as AllStyle,\n    skeleton: {\n      root: {\n        width:64,\n        height: 40,\n        paddingLeft: 16,\n        paddingRight: 16,\n      },\n    } as any as WmSkeletonStyles,\n    textSkeleton: {\n      root: {\n        width: 30,\n        height: 10,\n        borderRadius: 4\n      }\n    } as any as WmSkeletonStyles\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n  addStyle(DEFAULT_CLASS + '-disabled', '', {\n    root: {}\n  });\n  addStyle(DEFAULT_CLASS + '-rtl', '', Platform.OS==\"web\"?{\n    firstButton:{\n      borderTopLeftRadius: 0,\n      borderBottomLeftRadius: 0,\n      borderTopRightRadius: 6,\n      borderBottomRightRadius: 6,\n      borderRightWidth: 1,\n      borderLeftWidth: 0\n    } ,\n    lastButton:{\n      borderTopLeftRadius: 6,\n      borderBottomLeftRadius: 6,\n      borderTopRightRadius: 0,\n      borderBottomRightRadius: 0,\n      borderRightWidth: 0\n    }\n  }:{});\n  addStyle(DEFAULT_CLASS + '1-rtl', '', Platform.OS==\"web\"?{\n    firstButton:{\n      borderTopLeftRadius: 0,\n      borderBottomLeftRadius: 0,\n      borderTopRightRadius: 500,\n      borderBottomRightRadius: 500,\n      borderRightWidth: 0,\n      borderLeftWidth: 1\n    } ,\n    lastButton:{\n      flex: 1,\n      borderTopLeftRadius: 500,\n      borderBottomLeftRadius: 500,\n      borderTopRightRadius: 0,\n      borderBottomRightRadius: 0,\n      borderRightWidth: 1\n    }\n  }:{});\n  addStyle(DEFAULT_CLASS + '1', '', {\n    firstButton: {\n      borderTopLeftRadius: 500,\n      borderBottomLeftRadius: 500,\n      borderTopRightRadius: 0,\n      borderBottomRightRadius: 0\n    } as AllStyle,\n    lastButton: {\n      flex: 1,\n      borderTopLeftRadius: 0,\n      borderBottomLeftRadius: 0,\n      borderTopRightRadius: 500,\n      borderBottomRightRadius: 500\n    } as AllStyle\n  } as WmSwitchStyles);\n});\n", "wavemaker-rn-runtime/src/components/input/text/text.props.ts": "import BaseInputProps from \"@wavemaker/app-rn-runtime/components/input/baseinput/baseinput.props\";\n\nexport default class WmTextProps extends BaseInputProps {\n  floatinglabel?: string;\n  placeholder: string = 'Enter text';\n  skeletonheight?: string = null as any;\n  skeletonwidth?: string = null as any;\n  autocapitalize?: string = 'none';\n}\n", "wavemaker-rn-runtime/src/components/input/text/text.styles.ts": "import BASE_THEME, {AllStyle, Theme} from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport {ColorValue} from \"react-native\";\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmTextStyles = BaseStyles & {\n  invalid: AllStyle;\n  focused: AllStyle;\n  placeholderText: AllStyle;\n  floatingLabel: AllStyle;\n  activeFloatingLabel: AllStyle;\n  skeleton: WmSkeletonStyles;\n};\n\nexport const DEFAULT_CLASS = 'app-text';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmTextStyles = defineStyles({\n      root: {\n        minHeight: 42,\n        paddingTop: 8,\n        paddingBottom: 8,\n        borderWidth: 1,\n        paddingLeft: 16,\n        paddingRight: 16,\n        borderStyle: 'solid',\n        borderColor: themeVariables.inputBorderColor,\n        backgroundColor: themeVariables.inputBackgroundColor,\n        borderRadius: 6,\n        fontFamily: themeVariables.baseFont\n      },\n      text: {\n        fontSize: 16\n      },\n      invalid: {\n        borderBottomColor: themeVariables.inputInvalidBorderColor\n      },\n      focused : {\n        borderColor: themeVariables.inputFocusBorderColor,\n      },\n      placeholderText: {\n      color: themeVariables.inputPlaceholderColor\n      },\n      floatingLabel: {},\n      activeFloatingLabel: {},\n      skeleton: {\n        root: {\n          width: '100%',\n          height: 16,\n          borderRadius: 4\n        }\n      } as any as WmSkeletonStyles\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n  addStyle(DEFAULT_CLASS + '-disabled', '', {\n      root : {\n        backgroundColor: themeVariables.inputDisabledBgColor\n      }\n  });\n  addStyle(DEFAULT_CLASS + '-rtl', '', {\n      root:{\n        textAlign: 'right'\n      }\n  });\n  addStyle(DEFAULT_CLASS + '-with-label', '', {\n    root: {\n      minHeight: 48,\n    },\n    floatingLabel: {\n      position: 'absolute',\n      top: 12,\n      left: 16,\n      fontSize: 14,\n      color: themeVariables.floatingLabelColor\n    },\n    activeFloatingLabel: {\n      color: themeVariables.activeFloatingLabelColor\n    }\n  });\n});", "wavemaker-rn-runtime/src/components/input/text/text.component.tsx": "import React from 'react';\nimport { DimensionValue, Platform } from 'react-native';\n\nimport WmTextProps from './text.props';\nimport { DEFAULT_CLASS, WmTextStyles } from './text.styles';\nimport { WMTextInput } from '@wavemaker/app-rn-runtime/core/components/textinput.component';\nimport { BaseInputComponent, BaseInputState } from \"@wavemaker/app-rn-runtime/components/input/baseinput/baseinput.component\";\nimport { isNull } from 'lodash';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility'; \nimport { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\n\nexport class WmTextState extends BaseInputState<WmTextProps> {\n}\n\nexport default class WmText extends BaseInputComponent<WmTextProps, WmTextState, WmTextStyles> {\n\n  constructor(props: WmTextProps) {\n    super(props, DEFAULT_CLASS, new WmTextProps(), new WmTextState());\n  }\n\n  public getStyleClassName(): string | undefined {\n    const classes = [];\n    if (this.state.props.floatinglabel) {\n      classes.push('app-text-with-label'); \n    }\n    classes.push(super.getStyleClassName());\n    return classes.join(' ');\n  }\n\n  public renderSkeleton(props: WmTextProps): React.ReactNode { \n    let skeletonWidth, skeletonHeight;\n    \n    if(this.props.skeletonwidth == \"0\") {\n      skeletonWidth = 0\n    } else {\n      skeletonWidth = this.props.skeletonwidth || this.styles.root?.width\n    }\n\n    if(this.props.skeletonheight == \"0\") {\n      skeletonHeight = 0\n    } else {\n      skeletonHeight = this.props.skeletonheight || this.styles.root?.height;\n    }\n\n    return createSkeleton(this.theme, this.styles.skeleton, {\n      ...this.styles.root,\n      width: skeletonWidth as DimensionValue,\n      height: skeletonHeight as DimensionValue\n    })\n  }\n\n  renderWidget(props: WmTextProps) {\n    let opts: any = {};\n    const valueExpr = Platform.OS === 'web' ? 'value' : 'defaultValue';\n    opts[valueExpr] = this.state.textValue?.toString() || '';\n    return (\n        <WMTextInput\n          {...this.getTestPropsForInput()}\n          {...getAccessibilityProps(\n            AccessibilityWidgetType.TEXT,\n            props\n          )}\n          ref={(ref: any) => {this.widgetRef = ref;\n            // @ts-ignore\n          if (ref && !isNull(ref.selectionStart) && !isNull(ref.selectionEnd)) {\n            // @ts-ignore\n            ref.selectionStart = ref.selectionEnd = this.cursor;\n          }}}\n          {...opts}\n          floatingLabel={props.floatinglabel}\n          floatingLabelStyle={this.styles.floatingLabel}\n          activeFloatingLabelStyle={this.styles.activeFloatingLabel}\n          placeholderTextColor={this.styles.placeholderText.color as any}\n          isInputFocused={ this.state.isInputFocused }\n          style={[this.styles.root, this.styles.text, this.state.isValid ? {} : this.styles.invalid, this.state.isInputFocused ? this.styles.focused : {}]}\n          keyboardType={this.state.keyboardType}\n          autoComplete={props.autocomplete === \"true\" ? \"username\" : props.autocomplete === \"false\" ? \"off\" : props.autocomplete}\n          autoFocus={props.autofocus}\n          editable={props.disabled || props.readonly ? false : true}\n          secureTextEntry={props.type === 'password' && !props.maskchar ? true : false}\n          displayformat={props.displayformat}\n          background={this._background}\n          maskchar={props.maskchar}\n          maxLength={props.maxchars}\n          placeholder={props.placeholder}\n          onBlur={this.onBlur.bind(this)}\n          onFocus={this.onFocus.bind(this)}\n          onKeyPress={this.onKeyPress.bind(this)}\n          onChangeText={this.onChangeText.bind(this)}\n          onChange={this.invokeChange.bind(this)}\n          allowContentSelection={this.styles.text.userSelect === 'text'}\n          autoCapitalize={props.autocapitalize}\n          handleLayout={this.handleLayout}\n        />\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/input/select/select.props.ts": "import BaseDatasetProps from '@wavemaker/app-rn-runtime/components/input/basedataset/basedataset.props';\n\nexport default class WmSelectProps extends BaseDatasetProps {\n  placeholder: string = null as any;\n  displayValue = null as any;\n}\n", "wavemaker-rn-runtime/src/components/input/select/select.component.tsx": "import React from 'react';\nimport { Dimensions, LayoutChangeEvent, Text, View } from 'react-native';\nimport { ScrollView } from 'react-native-gesture-handler';\nimport { find, isEmpty, isString } from 'lodash';\n\nimport WmSelectProps from './select.props';\nimport { DEFAULT_CLASS, WmSelectStyles } from './select.styles';\nimport {\n  BaseDatasetComponent,\n  BaseDatasetState\n} from '@wavemaker/app-rn-runtime/components/input/basedataset/basedataset.component';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport { ModalConsumer, ModalOptions, ModalService } from '@wavemaker/app-rn-runtime/core/modal.service';\nimport WmButton from '@wavemaker/app-rn-runtime/components/basic/button/button.component';\nimport { Tappable } from '@wavemaker/app-rn-runtime/core/tappable.component';\nimport ThemeVariables from '@wavemaker/app-rn-runtime/styles/theme.variables';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility'; \nimport { BackgroundComponent } from '@wavemaker/app-rn-runtime/styles/background.component';\nimport { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\nimport { WmSkeletonStyles } from '../../basic/skeleton/skeleton.styles';\nimport { PopoverPosition } from '../../navigation/popover/popover.component';\n\nexport class WmSelectState extends BaseDatasetState<WmSelectProps> {\n  modalOptions = {} as ModalOptions;\n  isOpened: boolean = false;\n  selectedValue: any = '';\n  position={} as PopoverPosition;\n  selectWidth:number = 0;\n}\n\nexport default class WmSelect extends BaseDatasetComponent<WmSelectProps, WmSelectState, WmSelectStyles> {\n  constructor(props: WmSelectProps) {\n    super(props, DEFAULT_CLASS, new WmSelectProps(), new WmSelectState());\n  }\n  view: View = null as any;\n  public widgetRef: Text | null = null;\n  private isDefaultValue: boolean = true;\n\n  onPress(event: any) {\n    if (this.state.props.disabled) {\n      return;\n    }\n    if (!this.state.isOpened) {\n      this.showPopover();\n    }\n    this.invokeEventCallback('onFocus', [event, this.proxy]);\n  }\n\n  onPropertyChange(name: string, $new: any, $old: any): void {\n    super.onPropertyChange(name, $new, $old);\n      switch(name) {\n        case 'datavalue':\n          if (isNaN($new) && isEmpty($new)) {\n            this.updateState({\n              props: {\n                displayValue: this.state.props.placeholder || ''\n              }\n            } as WmSelectState);\n          }\n      }\n  }\n\n  private computePosition = (e: LayoutChangeEvent) => {\n    const position = {} as PopoverPosition;\n      const windowDimensions = Dimensions.get('window');\n      this.view.measure((x, y, width, height, px, py) => {\n        let popoverwidth = this.state.selectWidth as any;\n        if (popoverwidth && isString(popoverwidth)) { \n          popoverwidth = parseInt(popoverwidth);\n        }\n        this.isRTL ? position.right = px : position.left = px\n        \n        if (px + popoverwidth > windowDimensions.width) {\n          this.isRTL\n          ? (position.right = px + width - popoverwidth)\n          : (position.left = px + width - popoverwidth);\n        }\n        position.top = py + height;\n        this.updateState({position: position} as WmSelectState);\n      });\n  };\n\n  prepareModalOptions(content: React.ReactNode, styles: WmSelectStyles, modalService: ModalService) {\n    const o = this.state.modalOptions;\n    o.modalStyle = styles.modal;\n    o.contentStyle = {...styles.modalContent,...this.state.position};\n    o.content = content;\n    o.isModal = true;\n    o.centered = true;\n    o.onClose = () => {\n      this.hide = () => {};\n      if (this.isDefaultValue && this.state.props.displayValue === '') {\n        this.validate(this.state.props.displayValue);\n        setTimeout(() => {\n          this.props.triggerValidation && this.props.triggerValidation();\n        }, 0);\n      }\n      this.invokeEventCallback('onBlur', [{}, this.proxy]);\n      this.setState({ isOpened: false, modalOptions: {} as ModalOptions } as WmSelectState);\n    };\n    this.hide = () => modalService.hideModal(this.state.modalOptions);\n    return o;\n  }\n\n  public showPopover = () => {\n      this.updateState({ isOpened: true } as WmSelectState);\n  };\n\n  public hide = () => {};\n\n  focus() {\n    this?.widgetRef?.focus();\n  }\n\n  private renderSkeletonForText(){\n    return createSkeleton(this.theme, {} as WmSkeletonStyles, {\n      ...this.styles.textSkeleton.root\n    });\n  }\n\n  renderSelect() {\n    const props = this.state.props;\n    const select = this.styles.root as any;\n    return (\n      /*\n       * onLayout function is required.\n       * https://github.com/naoufal/react-native-accordion/pull/19/files\n       */\n      <View\n        style={[this.styles.root, this.state.isValid ? {} : this.styles.invalid, { backgroundColor: props.disabled ? this.styles.disabledText.backgroundColor : this.styles.root.backgroundColor}, \n          this._showSkeleton ? { justifyContent: 'space-between' } : {}]}\n        ref={(ref) => {\n          this.view = ref as View;\n        }}\n        onLayout={(event) => {this.updateState({selectWidth : event.nativeEvent.layout.width} as any)}}>\n          {select.backgroundImage ? (<BackgroundComponent\n            image={select.backgroundImage}\n            position={select.backgroundPosition || 'center'}\n            size={select.backgroundSize || 'contain'}\n            repeat={select.backgroundRepeat || 'no-repeat'}\n            resizeMode={select.backgroundResizeMode}\n            style={{borderRadius: this.styles.root.borderRadius}}\n          ></BackgroundComponent>) : null }\n          {this._showSkeleton && (this.state.props.displayValue || props.placeholder)? this.renderSkeletonForText() : <Text\n            style={[this.styles.text,\n              this.state.props.displayValue ? {} : {color: this.styles.placeholderText.color}]}\n            ref={(ref) => {\n              this.widgetRef = ref;\n            }}\n            {...this.getTestPropsForInput()}\n            {...getAccessibilityProps(\n              AccessibilityWidgetType.SELECT,\n              props\n            )}\n            onPress={this.onPress.bind(this)}>\n            {this.state.props.displayValue || props.placeholder || ' '}\n          </Text>}\n          <WmButton\n            styles={this._showSkeleton ? this.styles.arrowButtonSkeleton.root : this.styles.arrowButton}\n            iconclass={'wi wi-keyboard-arrow-down'}\n            onTap={this.onPress.bind(this)}\n            hint={props?.hint}\n          />\n      </View>\n    );\n  }\n\n  isSelected(item: any) {\n    const val = this.state.props.datafield === 'All Fields'  ? item.dataObject : item.datafield;\n    return this.state.props.datavalue === val;\n  }\n\n  onItemSelect(item: any, isPlaceholder?: boolean) {\n    this.isDefaultValue = false;\n    this.onChange(isPlaceholder ? '' : this.state.props.datafield === 'All Fields'  ? item.dataObject : item.datafield);\n    this.hide();\n  }\n\n  renderSelectItem(item: any, index: number, isPlaceholder: boolean, isLast: boolean) {\n    let selected = this.isSelected(item);\n    return (\n      <Tappable {...this.getTestPropsForAction('selectitem'+index)} onTap={this.onItemSelect.bind(this, item, isPlaceholder)} \n      accessibilityProps={{...getAccessibilityProps(\n        AccessibilityWidgetType.SELECT,\n        {...this.props, expanded: this.state.isOpened}\n      )}}\n      disableTouchEffect={this.state.props.disabletoucheffect}>\n        <View style={[this.styles.selectItem, isLast ?  this.styles.lastSelectItem  : null, selected ? this.styles.selectedItem : null ]}>\n          <Text  {...this.getTestPropsForLabel('label'+index)} style={[this.styles.selectItemText,  {color: isPlaceholder ? this.styles.placeholderText.color : selected ? this.styles.selectedItemText.color : this.styles.selectItemText.color}]}>\n            {isPlaceholder ? this.state.props.placeholder : (item.displayexp || item.displayfield)}\n          </Text>\n          <WmIcon id={this.getTestId('checkicon' + index)} iconclass='wi wi-check' styles={this.theme.mergeStyle(this.styles.checkIcon, {\n            root: {\n              opacity: !isPlaceholder && selected ?  1 : 0\n            }\n          })}></WmIcon>\n        </View>\n      </Tappable>\n    );\n  }\n\n  updateDefaultQueryModel() {\n    if (this.state.dataItems && this.state.dataItems.length && this.isDefaultValue) {\n      const selectedItem = find(this.state.dataItems, (item) => item.selected);\n      selectedItem && this.updateState({\n        props: {\n        displayValue: selectedItem.displayexp || selectedItem.displayfield || ''\n      }\n      } as WmSelectState);\n    }\n  }\n\n  componentDidMount() {\n    super.componentDidMount();\n    this.updateDefaultQueryModel();\n  }\n\n  onDataItemsUpdate() {\n    super.onDataItemsUpdate();\n    this.updateDefaultQueryModel();\n  }\n\n  renderWidget(props: WmSelectProps) {\n    let isDropdown = this.state.props.classname?.includes('select-dropdown');\n    const styles = this.theme.mergeStyle( this.styles,this.theme.getStyle('select-dropdown'));\n    if (isDropdown && this.state.selectWidth) {\n        styles.modalContent.width = this.styles.dropdown.width || this.state.selectWidth;\n    }\n    return (\n      <View \n        onLayout={(event) => {\n          isDropdown ? this.computePosition(event) : ()=>{}\n          this.handleLayout(event)\n        }}\n      >\n        {this._background}\n        {this.renderSelect()}\n        {this.state.isOpened ? (\n          <ModalConsumer>\n            {(modalService: ModalService) => {\n              const items = this.state.dataItems;\n              modalService.showModal(\n                this.prepareModalOptions(\n                  <ScrollView style={ isDropdown ?[{width : this.state.selectWidth},this.styles.dropdown]:{width: '100%', maxHeight: ThemeVariables.INSTANCE.maxModalHeight}} \n                  contentContainerStyle={this.styles.dropDownContent}>\n                    {props.placeholder ?\n                      <View key={props.name + '_placeholder'} style={this.styles.placeholderText}>\n                        {this.renderSelectItem({}, 0, true, false)}\n                      </View>\n                      : null}\n                      {items && items.map((item: any, index: number) => (\n                        <View key={item.key}>\n                          {this.renderSelectItem(item, index, false, index === items.length - 1)}\n                        </View>\n                      ))}\n                  </ScrollView>,\n                  isDropdown?styles:this.styles,\n                  modalService\n                )\n              );\n              return null;\n            }}\n          </ModalConsumer>\n        ) : null}\n      </View>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/input/select/select.styles.ts": "import BASE_THEME, {AllStyle} from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmButtonStyles } from '@wavemaker/app-rn-runtime/components/basic/button/button.styles';\nimport { Platform } from 'react-native';\nimport { WmIconStyles } from '@wavemaker/app-rn-runtime/components/basic/icon/icon.styles';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmSelectStyles = BaseStyles & {\n  arrowButton: WmButtonStyles;\n  modal: AllStyle;\n  modalContent: AllStyle;\n  checkIcon: WmIconStyles;\n  selectItem: AllStyle;\n  lastSelectItem: AllStyle,\n  selectItemText: AllStyle;\n  selectedItem: AllStyle;\n  selectedItemText: AllStyle;\n  dropDownContent: AllStyle;\n  disabledText: AllStyle;\n  placeholderText: AllStyle;\n  invalid: AllStyle;\n  skeleton: WmSkeletonStyles;\n  arrowButtonSkeleton: WmSkeletonStyles;\n  textSkeleton: WmSkeletonStyles;\n};\n\nexport const DEFAULT_CLASS = 'app-select';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmSelectStyles = defineStyles({\n    root: {\n      flexDirection: 'row',\n      padding: 12,\n      borderWidth: 1,\n      borderStyle: 'solid',\n      borderColor: themeVariables.inputBorderColor,\n      backgroundColor: themeVariables.inputBackgroundColor,\n      borderRadius: 6,\n      minWidth: 160,\n      alignItems: 'center'\n    },\n    invalid: {\n      borderBottomColor: themeVariables.inputInvalidBorderColor\n    },\n    text: {\n      fontSize: 16,\n      fontFamily: themeVariables.baseFont,\n      flex: 1,\n      color: themeVariables.inputTextColor\n    },\n    checkIcon: {\n      text: {\n        fontSize: 24,\n        color: themeVariables.primaryColor\n      }\n    } as WmIconStyles,\n    disabledText: {\n      backgroundColor : themeVariables.inputDisabledBgColor\n    },\n    modal: {\n      backgroundColor: 'rgba(0, 0, 0, 0.3)',\n      height: '100%'\n    },\n    modalContent: {\n      backgroundColor: themeVariables.inputBackgroundColor,\n      borderRadius: 6,\n      position: 'absolute',\n      borderWidth: 1,\n      borderStyle: 'solid',\n      borderColor: themeVariables.inputBorderColor,\n      width: '90%'\n    },\n    selectItem: {\n      width: '100%',\n      paddingHorizontal: 16,\n      paddingVertical: 8,\n      borderBottomWidth: 1,\n      borderBottomStyle: 'solid',\n      borderBottomColor: themeVariables.selecttemBorderColor,\n      flexDirection: 'row',\n      alignItems: 'center'\n    },\n    lastSelectItem: {\n      borderBottomWidth: 0\n    },\n    selectItemText: {\n      fontSize: 16,\n      fontFamily: themeVariables.baseFont,\n      color: themeVariables.selectItemTextColor,\n      flex: 1\n    },\n    selectedItem: {},\n    selectedItemText:{},\n    placeholderText: {\n      color: themeVariables.inputPlaceholderColor\n    },\n    dropDownContent: {},\n    arrowButton: {\n      root: {\n        borderRadius: 0,\n        paddingTop: 6,\n        paddingBottom: 6,\n        paddingLeft: 6,\n        paddingRight: 0,\n        minHeight: 0,\n        alignItems: 'center',\n        alignSelf: 'center',\n        justifyContent: 'center',\n        backgroundColor: 'transparent'\n      }\n    } as WmButtonStyles,\n    skeleton: {\n      root:{\n        minWidth: 0,\n        width:120,\n        height: 16,\n        borderRadius: 4,\n        marginRight:8,\n        padding:0\n      }\n    } as any as WmSkeletonStyles,\n    dropdown: {\n      backgroundColor: themeVariables.popoverBackgroundColor,\n      maxHeight: 240,\n      borderRadius:6\n  },\n    arrowButtonSkeleton: {\n      root: {\n        width: 24,\n        height: 24,\n        borderRadius: 12  \n      }\n    } as any as WmSkeletonStyles,\n    textSkeleton: {\n      root: {\n        width: 100,\n        height: 16,\n        borderRadius: 8  \n      }\n    } as any as WmSkeletonStyles\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n  addStyle(DEFAULT_CLASS + '-disabled', '', {\n      root : {\n        backgroundColor: themeVariables.inputDisabledBgColor\n      }\n  });\n  addStyle('select-dropdown', '', {\n    modal: {\n        backgroundColor: 'transparent',\n    },\n    dropdown: {\n        backgroundColor: themeVariables.transparent\n    },\n    modalContent: {\n        borderRadius: 6,\n        ...BASE_THEME.getStyle('elevate4').root,\n        shadowRadius: 8\n    }\n});\n  addStyle(DEFAULT_CLASS + '-rtl', '', Platform.OS==\"web\"?{\n    text:{\n      textAlign:'right',\n    }\n    ,selectItemText : {\n      textAlign : 'right'\n    }\n  }:{\n    text:{\n      textAlign:'left',\n    },\n    selectItemText : {\n      textAlign : 'left'\n    }\n  });\n});\n", "wavemaker-rn-runtime/src/components/input/currency/currency.component.tsx": "import React from 'react';\nimport { View, Text, Platform, DimensionValue } from 'react-native';\n\nimport WmCurrencyProps from './currency.props';\nimport { CURRENCY_INFO } from '@wavemaker/app-rn-runtime/core/currency-constants';\nimport { WMTextInput } from '@wavemaker/app-rn-runtime/core/components/textinput.component';\nimport { DEFAULT_CLASS, WmCurrencyStyles } from './currency.styles';\nimport {\n  BaseNumberComponent,\n  BaseNumberState\n} from '@wavemaker/app-rn-runtime/components/input/basenumber/basenumber.component';\nimport { isNull } from \"lodash\";\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility'; \nimport { countDecimalDigits, validateInputOnDevice } from '@wavemaker/app-rn-runtime/core/utils';\nimport { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\nimport { WmSkeletonStyles } from '../../basic/skeleton/skeleton.styles';\n\nexport class WmCurrencyState extends BaseNumberState<WmCurrencyProps> {\n  currencySymbol: any;\n}\n\nexport default class WmCurrency extends BaseNumberComponent<WmCurrencyProps, WmCurrencyState, WmCurrencyStyles> {\n\n  constructor(props: WmCurrencyProps) {\n    super(props, DEFAULT_CLASS, new WmCurrencyProps(), new WmCurrencyState());\n  }\n\n  onPropertyChange(name: string, $new: any, $old: any) {\n    super.onPropertyChange(name, $new, $old);\n    switch (name) {\n      case 'currency':\n        if ($new) {\n          this.updateState({\n            currencySymbol: CURRENCY_INFO[$new].symbol,\n          } as WmCurrencyState);\n        }\n        break;\n\n    }\n  }\n\n  public getStyleClassName(): string | undefined {\n    const classes = [];\n    if (this.state.props.floatinglabel) {\n      classes.push('app-currency-with-label'); \n    }\n    classes.push(super.getStyleClassName());\n    return classes.join(' ');\n  }\n\n  public renderTextSkeleton(props:any): React.ReactNode { \n    return this.props.floatinglabel  ?   <>{createSkeleton(this.theme, {} as WmSkeletonStyles, {...props})}</>\n    : <>{createSkeleton(this.theme, {} as WmSkeletonStyles, {\n      ...this.styles.skeleton.root,\n    })}</>\n  }\n\n  renderWidget(props: WmCurrencyProps) {\n    let opts: any = {};\n    const valueExpr = Platform.OS === 'web' ? 'value' : 'defaultValue';\n    opts[valueExpr] = this.state.textValue?.toString() || '';\n    return (<View style={this.styles.root} onLayout={(event) => this.handleLayout(event)}>\n      <View style={ (this._showSkeleton && !this.props.floatinglabel) ?  this.styles.skeletonLabelWrapper.root : this.styles.labelWrapper }>\n        {this._showSkeleton ? <>{this.renderTextSkeleton(this.styles.skeletonLabel.root)}</> :\n         <Text style={this.styles.label}>{this.state.currencySymbol}</Text>}\n      </View>\n      {this._showSkeleton ? <>{this.renderTextSkeleton(this.styles.skeletonTextInputWrapper.root)}</> :<View style={{flex: 1}}>\n      <WMTextInput\n        {...this.getTestPropsForInput()}\n        {...getAccessibilityProps(AccessibilityWidgetType.CURRENCY, props)}\n        ref={(ref: any) => {\n          this.widgetRef = ref;\n          // @ts-ignore\n          if (ref && !isNull(ref.selectionStart) && !isNull(ref.selectionEnd)) {\n            // @ts-ignore\n            ref.selectionStart = ref.selectionEnd = this.cursor;\n          }\n        }}\n        keyboardType=\"numeric\"\n        placeholderTextColor={this.styles.placeholderText.color as any}\n        isInputFocused={ this.state.isInputFocused }\n        style={[this.styles.input, this.styles.text, this.state.isValid ? {} : this.styles.invalid, this.state.isInputFocused ? this.styles.focused : {}]}\n        {...opts}\n        floatingLabel={props.floatinglabel}\n        floatingLabelStyle={this.styles.floatingLabel}\n        activeFloatingLabelStyle={this.styles.activeFloatingLabel}\n        editable={props.disabled || props.readonly ? false : true}\n        placeholder={props.placeholder}\n        background={this._background}\n        onBlur={this.onBlur.bind(this)}\n        onFocus={this.onFocus.bind(this)}\n        onKeyPress={this.validateInputEntry.bind(this)}\n        onChangeText={(text) => {\n          const {isValidText, validText} = validateInputOnDevice(text, \"currency\");\n          const decimalPlaces = props.decimalPlaces;\n          const decimalPlacesInNumber = countDecimalDigits(validText);\n          const restrictDecimalRegex = new RegExp(`(\\\\.\\\\d{${decimalPlaces}})\\\\d*`);\n          const updatedCurrencyText = validText.replace(restrictDecimalRegex, '$1');\n\n          if (!isValidText || decimalPlaces < decimalPlacesInNumber) {\n            (this.widgetRef as any)?.setNativeProps({ text: updatedCurrencyText });\n          }\n\n          this.onChangeText.bind(this)(updatedCurrencyText, 'currency');\n        }}\n        onChange={this.invokeChange.bind(this)}\n        allowContentSelection={this.styles.text.userSelect === 'text'}\n      />\n      </View> }\n    </View>);\n  }\n}\n", "wavemaker-rn-runtime/src/components/input/currency/currency.props.ts": "import BaseNumberProps from '@wavemaker/app-rn-runtime/components/input/basenumber/basenumber.props';\n\nexport default class WmCurrencyProps extends BaseNumberProps {\n  currency: any;\n  placeholder: string = '';\n  floatinglabel?: string;\n}\n", "wavemaker-rn-runtime/src/components/input/currency/currency.styles.ts": "import BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { Platform } from 'react-native';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmCurrencyStyles = BaseStyles & {\n  label: AllStyle;\n  invalid: AllStyle;\n  focused: AllStyle;\n  floatingLabel: AllStyle;\n  activeFloatingLabel: AllStyle;\n  placeholderText: AllStyle;\n  skeleton: WmSkeletonStyles;\n  skeletonLabel: WmSkeletonStyles;\n  skeletonTextInputWrapper:  WmSkeletonStyles;\n  skeletonLabelWrapper:  WmSkeletonStyles;\n};\n\nexport const DEFAULT_CLASS = 'app-currency';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmCurrencyStyles = defineStyles({\n      root: {\n        minHeight: 42,\n        borderWidth: 1,\n        borderStyle: 'solid',\n        borderColor: themeVariables.inputBorderColor,\n        backgroundColor: themeVariables.inputBackgroundColor,\n        borderRadius: 6,\n        flexDirection: 'row'\n      },\n      text: {\n        fontSize: 16\n      },\n      input : {\n        minHeight: 42,\n        paddingTop: 8,\n        paddingBottom: 8,\n        paddingLeft: 16,\n        paddingRight: 16,\n        flex: 1,\n        borderWidth: 1,\n        borderColor: themeVariables.transparent,\n        borderStyle: 'solid'\n      },\n      labelWrapper: {\n        minHeight: 42,\n        backgroundColor: themeVariables.primaryColor,\n        borderTopLeftRadius: 6,\n        borderBottomLeftRadius: 6,\n        width: 48,\n        paddingTop: 8,\n        paddingBottom: 8,\n        paddingLeft: 16,\n        paddingRight: 16,\n        display: 'flex',\n        justifyContent: 'center'\n      },\n      label: {\n        marginVertical: 0.7,\n        color: themeVariables.primaryContrastColor,\n        textAlignVertical: 'center',\n        textAlign: 'center',\n        fontWeight: 'bold',\n        fontFamily: themeVariables.baseFont,\n        fontSize: 16\n      },\n      invalid: {\n        borderBottomColor: themeVariables.inputInvalidBorderColor\n      },\n      focused : {\n        borderColor: themeVariables.inputFocusBorderColor,\n      },\n      placeholderText: {\n        color: themeVariables.inputPlaceholderColor\n      },\n      skeleton: {\n        root:{\n          borderRadius: 6,\n          paddingLeft: 16,\n          paddingRight: 16,\n          minHeight: 42,\n          paddingTop: 8,\n          paddingBottom: 8,\n          width: '100%',\n          height: 40\n        },\n      } as any as WmSkeletonStyles,\n      skeletonLabel: {\n        root: {\n          width:20,\n          height:28,\n          borderRadius:4,\n          display:'flex',\n          justifyContent:'center',\n          alignItems:'center'\n        }\n      } as any as WmSkeletonStyles,\n      skeletonTextInputWrapper: {\n        root: {\n          width:80,\n          height:16,\n          borderRadius:4,\n          marginLeft:16\n        }\n      } as any as WmSkeletonStyles,\n      skeletonLabelWrapper: {\n        root: {\n          minHeight:42,\n          width:'100%',\n          borderWidth:0,\n        }\n      } as any as WmSkeletonStyles,\n      floatingLabel: {},\n      activeFloatingLabel: {}\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n  addStyle(DEFAULT_CLASS + '-rtl', '', Platform.OS==\"web\"?{\n    labelWrapper:{\n      borderTopLeftRadius: 0,\n      borderBottomLeftRadius: 0,\n      borderTopRightRadius: 6,\n      borderBottomRightRadius: 6,\n    }\n  }:{});\n  addStyle(DEFAULT_CLASS + '-disabled', '', {\n      root : {\n        backgroundColor: themeVariables.inputDisabledBgColor\n      }\n  });\n  addStyle(DEFAULT_CLASS + '-with-label', '', {\n    root: {\n      minHeight: 48\n    },\n    floatingLabel: {\n      position: 'absolute',\n      top: 12,\n      left: 16,\n      fontSize: 14,\n      textAlign: 'left',\n      color: themeVariables.floatingLabelColor\n    },\n    activeFloatingLabel: {\n      color: themeVariables.activeFloatingLabelColor\n    }\n  });\n});", "wavemaker-rn-runtime/src/components/chart/staticdata.tsx": "import _ from \"lodash\";\n\nconst dataTypeJSON = ['Column', 'Line', 'Pie', 'Bar', 'Donut', 'Bubble']\n\nconst SAMPLE_DATA1 = {\n  'group1' : 'Europe',\n  'group2' : 'Asia',\n  'group3' : 'America',\n  'group4' : 'Australia'\n}\n\nconst SAMPLE_DATA = {\n    'group1' : '01/01/2001',\n    'group2' : '01/01/2002',\n    'group3' : '01/01/2003',\n};\nconst SAMPLE_DATA2 = {\n  'group1' : '78.6',\n  'group2' : '79',\n  'group3' : '80',\n  'group4' : '80.66'\n};\nexport const chartTypes = ['Column', 'Line', 'Area', 'Cumulative Line', 'Bar', 'Pie', 'Donut', 'Bubble']\n\nexport const isPieChart = (type: string) => type === 'Pie';\n\n// returns true if chart type is line\nexport const isLineChart = (type: string) => type === 'Line';\n\n// returns true if chart type is bar\nexport const isBarChart = (type: string) => type === 'Bar';\n\n// returns true if chart type is donut\nexport const isDonutChart = (type: string) => type === 'Donut';\n\n// returns true if chart type is bubble\nexport const isBubbleChart = (type: string) => type === 'Bubble';\n\nexport const isAreaChart = (type: string) => type === 'Area';\n\n// returns true if chart type is column\nexport const isColumnChart = (type: string) => type === 'Column';\n\nexport const isPieType = (type: string) => isPieChart(type) || isDonutChart(type);\n\n// The format of chart data is array of json objects in case of the following types of chart\nexport const isChartDataJSON = (type: any) => _.includes(dataTypeJSON, type) || !_.includes(chartTypes, type);\n\n\nexport const constructSampleData = (dataType: any, yaxisLength: any, shape: string) => {\n  let first_series = [],\n      second_series = [],\n      third_series = [],\n      first_series_array = [],\n      second_series_array = [],\n      third_series_array = [],\n      data: { values?:  { x: string | number; y?: string | number; size?: number; shape?: any; }[]  | number[][]; key: any; }[] | { x: any; y?: number;  }[] = [];\n  switch (dataType) {\n    case 'jsonFormat':\n      first_series = [\n          {'x': '01/01/2001', 'y': 4000000},\n          {'x': '01/01/2002', 'y': 1000000},\n          {'x': '01/01/2003', 'y': 5000000}\n      ];\n      second_series = [\n          {'x': '01/01/2001', 'y': 3000000},\n          {'x': '01/01/2002', 'y': 4000000},\n          {'x': '01/01/2003', 'y': 7000000}\n      ];\n      third_series = [\n          {'x': '01/01/2001', 'y': 2000000},\n          {'x': '01/01/2002', 'y': 8000000},\n          {'x': '01/01/2003', 'y': 6000000}\n      ];\n      data[0] = {\n          values: first_series,\n          key: SAMPLE_DATA.group1\n      };\n      if (yaxisLength >= 2) {\n          data[1] = {\n              values: second_series,\n              key: SAMPLE_DATA.group2\n          };\n      }\n      if (yaxisLength >= 3) {\n          data[2] = {\n              values: third_series,\n              key: SAMPLE_DATA.group3\n          };\n      }\n      break;\n    case 'arrayFormat':\n      first_series_array = [\n          [1, 4000000],\n          [2, 1000000],\n          [3, 5000000]\n      ];\n      second_series_array = [\n          [1, 3000000],\n          [2, 4000000],\n          [3, 7000000]\n      ];\n      third_series_array = [\n          [1, 2000000],\n          [2, 8000000],\n          [3, 6000000]\n      ];\n      data[0] = {\n          values: first_series_array,\n          key: SAMPLE_DATA.group1\n      };\n      if (yaxisLength >= 2) {\n          data[1] = {\n              values: second_series_array,\n              key: SAMPLE_DATA.group2\n          };\n      }\n      if (yaxisLength >= 3) {\n          data[2] = {\n              values: third_series_array,\n              key: SAMPLE_DATA.group3\n          };\n      }\n            break;\n            case 'columnChartFormat':\n              data = [\n                {'x': SAMPLE_DATA.group1, 'y': 3}\n            ];\n            break;\n            case 'barChartFormat':\n              data = [\n                {'x': SAMPLE_DATA.group1, 'y': 2000000},\n                {'x': SAMPLE_DATA.group2, 'y': 1000000},\n                {'x': SAMPLE_DATA.group3, 'y': 3000000}\n            ];\n            break;\n            case 'lineChartFormat':\n              data = [\n                {'x': SAMPLE_DATA1.group1, 'y': 2},\n                {'x': SAMPLE_DATA1.group2, 'y': 0},\n                {'x': SAMPLE_DATA1.group3, 'y': 3}\n            ];\n              break;\n              case 'bubbleFormat':\n                // shape = shape === 'random' ?  shapes[Math.floor(Math.random() * shapes.length)] : shape;\n                data = [\n                  {'x': SAMPLE_DATA2.group1, 'y': 1000000},\n                  {'x': SAMPLE_DATA2.group2, 'y': 2000000},\n                  {'x': SAMPLE_DATA2.group3, 'y': 3000000},\n                  {'x': SAMPLE_DATA2.group4, 'y': 4000000}\n              ];\n              break;\n                case 'pieChartFormat':\n                  data = [\n                      {'x': SAMPLE_DATA1.group1, 'y': 1000000},\n                      {'x': SAMPLE_DATA1.group2, 'y': 2000000},\n                      {'x': SAMPLE_DATA1.group3, 'y': 3000000},\n                      {'x': SAMPLE_DATA1.group4, 'y': 4000000}\n                  ];\n                  break;\n    \n  }\n  return data;\n\n};\n\nexport const getChartType = (widgetContext: { type: any; }) => {\n  const type = widgetContext.type;\n  if (isLineChart(type)) {\n      return 'lineChartFormat';\n  }\n  if (isAreaChart(type)) {\n    return 'lineChartFormat'; \n  }\n  if (isBarChart(type)) {\n    return 'barChartFormat'; \n  }\n  if (isColumnChart(type)) {\n    return 'columnChartFormat'; \n  }\n  if (isPieChart(type)) {\n      return 'pieChartFormat';\n  }\n  if (isBubbleChart(type)) {\n      return 'bubbleFormat';\n  }\n  if (isDonutChart(type)) {\n    return 'pieChartFormat';\n}\n  return isChartDataJSON(type) ? 'jsonFormat' : 'arrayFormat';\n};\n\n// Sample data to populate when no data is bound\nexport const getSampleData = (widgetContext: { yaxisdatakey: any; shape: any; }) => constructSampleData(getDataType(widgetContext), _.split(widgetContext.yaxisdatakey, ',').length, widgetContext.shape);\n\nfunction getDataType(widgetContext: { yaxisdatakey: any; shape: any; }): any {\n  throw new Error(\"Function not implemented.\");\n}\n", "wavemaker-rn-runtime/src/components/chart/basechart.styles.ts": "import { TextStyle, ViewStyle } from 'react-native';\nimport Color  from \"color\";\nimport BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { VictoryStyleObject } from \"victory-core\";\nimport { WmIconStyles } from '@wavemaker/app-rn-runtime/components/basic/icon/icon.styles';\nimport { WmSkeletonStyles } from '../basic/skeleton/skeleton.styles';\n\n\nexport type BaseChartComponentStyles = BaseStyles & {\n  title: TextStyle,\n  icon: WmIconStyles,\n  subHeading: TextStyle,\n  axis: VictoryStyleObject,\n  xAxis: VictoryStyleObject,\n  yAxis: VictoryStyleObject,\n  axisLabel: VictoryStyleObject,\n  xAxisLabel: VictoryStyleObject,\n  yAxisLabel: VictoryStyleObject,\n  ticks: VictoryStyleObject,\n  xTicks: VictoryStyleObject,\n  yTicks: VictoryStyleObject,\n  tickLabels: VictoryStyleObject,\n  xTickLabels: VictoryStyleObject,\n  yTickLabels: VictoryStyleObject,\n  grid: VictoryStyleObject,\n  xGrid: VictoryStyleObject,\n  yGrid: VictoryStyleObject,\n  legendText: TextStyle,\n  legenedDot: ViewStyle,\n  tooltipContainer: any,\n  tooltipPointer: any\n  tooltipXText: any,\n  tooltipYText: any,\n  bar: any;\n  centerLabel: VictoryStyleObject,\n  skeleton?: WmSkeletonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-chart';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: BaseChartComponentStyles = defineStyles({\n    root: {},\n    text: {},\n    icon: {\n      icon: {\n        fontSize: 20\n      }\n    } as WmIconStyles,\n    line: {\n      color: themeVariables.chartLineColor\n    },\n    title: {\n      color: themeVariables.chartTitleColor,\n      fontSize: 20,\n      lineHeight: 24,\n      paddingLeft: 10,\n    },\n    subHeading: {\n      fontSize: 12,\n      lineHeight: 16,\n      color: themeVariables.chartSubTitleColor\n    },\n    legendText: {},\n    legenedDot: {},\n    axis: {\n      stroke: Color(themeVariables.chartAxisColor).fade(0.3).rgb().toString()\n    } as any,\n    xAxis: {} as any,\n    yAxis: {} as any,\n    axisLabel: {} as any,\n    xAxisLabel: {} as any,\n    yAxisLabel: {} as any,\n    grid: {\n      stroke: Color(themeVariables.chartAxisColor).fade(0.8).rgb().toString(),\n      strokeDasharray: '16 4'\n    } as any,\n    xGrid: {} as any,\n    yGrid: {} as any,\n    ticks: {\n      stroke: Color(themeVariables.chartAxisColor).fade(0.8).rgb().toString(),\n    } as any,\n    xTicks: {} as any,\n    yTicks: {} as any,\n    tickLabels: {\n      stroke: Color(themeVariables.chartAxisColor).fade(0.8).rgb().toString(),\n    } as any,\n    xTickLabels: {} as any,\n    yTickLabels: {} as any,\n    barChart: {},\n    tooltipXText:{},\n    tooltipYText:{},\n    bar:{\n      borderTopLeftRadius: 0,\n      borderTopRightRadius: 0,\n      borderBottomLeftRadius: 0,\n      borderBottomRightRadius: 0\n    },\n    tooltipContainer: {\n      position: 'absolute', \n      backgroundColor: themeVariables.tooltipBgColor, \n      flex: 1, \n      minWidth: 100,\n      minHeight: 60,\n      opacity: 0.9, \n      borderRadius: 12, \n      justifyContent: 'center', \n      alignItems: 'center', \n      elevation: 2,\n      zIndex: 99\n    } as any,\n    tooltipPointer: {\n      position: 'absolute',\n      width: 0,\n      height: 0,\n      backgroundColor: themeVariables.transparent,\n      borderStyle: 'solid',\n      borderLeftWidth: 8,\n      borderRightWidth: 8,\n      borderBottomWidth: 12,\n      borderLeftColor: themeVariables.transparent,\n      borderRightColor: themeVariables.transparent,\n      borderBottomColor: themeVariables.tooltipBgColor,\n      overflow: 'hidden',\n    } as any,\n    centerLabel: {\n      color: themeVariables.chartTitleColor,\n      fontSize: 20,\n    },\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n});\n", "wavemaker-rn-runtime/src/components/chart/basechart.component.tsx": "import React from \"react\";\nimport { Dimensions, View, Text, LayoutChangeEvent} from 'react-native';\nimport moment from \"moment\";\nimport {forEach, get, isArray, isEmpty, isObject, maxBy, minBy, set, trim, orderBy} from \"lodash-es\";\nimport { ScatterSymbolType } from \"victory-core\";\nimport {VictoryAxis, VictoryLegend, VictoryLabel, VictoryVoronoiContainer, VictoryTooltip} from \"victory-native\";\n\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport WmIcon from \"@wavemaker/app-rn-runtime/components/basic/icon/icon.component\";\nimport ThemeFactory  from \"@wavemaker/app-rn-runtime/components/chart/theme/chart.theme\";\n\nimport BaseChartComponentProps from \"./basechart.props\";\nimport { DEFAULT_CLASS, BaseChartComponentStyles} from \"./basechart.styles\";\nimport _ from \"lodash\";\nimport { constructSampleData, getChartType } from \"./staticdata\";\nimport { isWebPreviewMode } from \"@wavemaker/app-rn-runtime/core/utils\";\nimport WmLottie from \"../basic/lottie/lottie.component\";\n\nexport class BaseChartComponentState <T extends BaseChartComponentProps> extends BaseComponentState<T> {\n  data: any = [];\n  content: any = null;\n  yAxis: Array<string> = [];\n  xaxisDatakeyArr: Array<any> = [];\n  legendData: any = [];\n  theme: any;\n  colors: any;\n  xLabel: string = '';\n  yLabel: string = '';\n  total: number = 0;\n  endAngle: number = 0;\n  loading: boolean = true;\n  chartHeight: number = 0;\n  chartWidth: number = 0;\n  totalHeight: number = 0;\n  chartMinY: number | undefined = undefined;\n  chartMinX: number | undefined = undefined;\n  chartMaxY: number | undefined = undefined;\n  chartMaxX: number | undefined = undefined;\n  tooltipXPosition = 0;\n  tooltipYPosition = 0;\n  tooltipXaxis = 0;\n  tooltipYaxis = 0;\n  tooltipoffsetx: number = 50;\n  tooltipoffsety: number = 80;\n  isTooltipOpen: boolean = false;\n  selectedItem: any = {}\n  template: string = \"\";\n}\n\nconst screenWidth = Dimensions.get(\"window\").width;\n\nconst shapes: {[key: string]: any} = {\n  'circle': 'circle',\n  'cross': 'cross',\n  'diamond': 'diamond',\n  'plus': 'plus',\n  'minus': 'minus',\n  'square': 'square',\n  'star': 'star',\n  'triangle-down': 'triangleDown',\n  'triangle-up': 'triangleUp',\n};\n\nconst SI_SYMBOL = [\"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\"];\n\nexport abstract class BaseChartComponent<T extends BaseChartComponentProps, S extends BaseChartComponentState<T>, L extends BaseChartComponentStyles> extends BaseComponent<T, S, L> {\n  protected screenWidth: number = screenWidth;\n  protected viewRef: React.RefObject<View>;\n  constructor(props: T, public defaultClass: string = DEFAULT_CLASS, defaultProps?: T, defaultState?: S) {\n    super(props, defaultClass, defaultProps, defaultState);\n    this.viewRef = React.createRef();\n    if (!props.theme) {\n      this.applyTheme(props);\n    }\n    this.subscribe('globaltouch', (event: any) => {\n      this.updateState({\n        isTooltipOpen: false\n      } as any)\n    });\n  }\n\n  componentDidMount() {\n    super.componentDidMount();\n  }\n\n  onViewLayoutChange = (e: LayoutChangeEvent) => {\n    let viewWidth = e.nativeEvent.layout.width;\n    let viewHeight = e.nativeEvent.layout.height;\n    \n    this.handleLayout(e)\n    \n    if (this?.state && viewWidth !== this.state.chartWidth) {\n      this.updateState({\n        chartWidth: Number(viewWidth),\n        totalHeight: Number(viewHeight)\n      } as any)\n    }\n  }\n\n\n  abbreviateNumber(number: any) {\n    if (typeof number !== 'number') {\n      return number;\n    }\n    const tier = Math.log10(Math.abs(number)) / 3 | 0;\n\n    if (tier == 0) {\n      return number;\n    }\n\n    // get suffix and determine scale\n    const suffix = SI_SYMBOL[tier];\n    const scale = Math.pow(10, tier * 3);\n\n    // scale the number\n    var scaled = number / scale;\n\n    // format number and add suffix\n    return scaled.toFixed(1) + suffix;\n  }\n\n  getLegendView(colorScale?: any) {\n    if (this.state.props.showlegend === 'hide') {\n      return null;\n    }\n    const props = this.state.props;\n    let top = props.showlegend === 'bottom' ? parseInt(this.styles.root.height as string) : 0;\n    if (top) {\n      top = top - (50); // remove legendHeight\n    }\n    const orientation = (props.showlegend === 'right' || props.showlegend === 'left') ? 'vertical' : 'horizontal';\n    return <VictoryLegend\n      colorScale={colorScale}\n      name={'legendData'}\n      orientation={orientation}\n      gutter={20}\n      data={this.state.legendData}\n      style={{ border: { stroke: 'none' } }}\n      borderPadding={{top: 30, left: 50}}\n      y={top}\n    />\n  }\n\n  getYScaleMinValue(value: number) {\n    const _min = Math.floor(value);\n    return Math.abs(value) - _min > 0 ? value - .1 : _min - 1;\n  };\n\n  setYAxisFormat(yVal: any, ynumberformat: string){\n    const matchFixed = ynumberformat.match(/\\.([0-9])f/);\n    const matchExponential = ynumberformat.match(/\\.([0-9])g/);\n    if (matchFixed) {\n        return yVal.toFixed(parseInt(matchFixed[1], 10));\n    } else if (matchExponential) {\n        return yVal.toExponential(parseInt(matchExponential[1], 10));\n    }\n    switch (ynumberformat) {\n      case '%':\n          return (yVal * 100).toFixed(0) + '%';\n      case 'Billion':\n          return (yVal / 1e9).toFixed(1) + 'B';\n      case 'Million':\n          return (yVal / 1e6).toFixed(1) + 'M';\n      case 'Thousand':\n          return (yVal / 1e3).toFixed(1) + 'K';\n      case ',r':\n          return yVal.toLocaleString();\n    }\n  }\n\n  // x axis with vertical lines having grid stroke colors\n  getXaxis() {\n    const minIndex = 0;\n    const maxIndex = this.state.xaxisDatakeyArr.length - 1;\n    const props = this.state.props;\n    const getTickValueLabel = props.xtickexpr as any;\n    let height = this.styles.root.height || 250;\n    let yaxislabeldistance = props.yaxislabeldistance ? props.yaxislabeldistance : height as number - 20;\n    if (height && typeof height === 'string') {\n      height = parseInt(height);\n    }\n    return <VictoryAxis crossAxis={false} label={(props.xaxislabel || props.xaxisdatakey || \"name\") + (props.xunits ? `(${props.xunits})` : '')}\n                        style={{\n                          axisLabel: this.theme.mergeStyle(this.styles.axisLabel, this.styles.yAxisLabel),\n                          grid: props.hidegridxaxis ?\n                              { stroke: null } :  this.theme.mergeStyle(this.styles.grid, this.styles.xGrid),\n                          axis: props.showxaxis === false ?\n                              { stroke: 'none' } :  this.theme.mergeStyle(this.styles.axis, this.styles.xAxis),\n                          ticks: this.theme.mergeStyle(this.styles.ticks, this.styles.xTicks),\n                          tickLabels: props.showxaxislabels === false ? {fill: 'none'} : this.theme.mergeStyle(this.styles.tickLabels, this.styles.xTickLabels)\n                        }}\n                        fixLabelOverlap= {props.autoadjustlabels?true:false}\n                        axisLabelComponent={<VictoryLabel y={yaxislabeldistance}/>}\n                        tickLabelComponent={<VictoryLabel y={props.offsetyaxis ? props.offsetyaxis : height as number - 30} angle={props.labelangle || 0}/>} theme={this.state.theme}\n                        tickCount={this.state.xaxisDatakeyArr.length} \n                        invertAxis={this.isRTL}\n                        tickFormat= {(d: number, i: number, ticks: any) => {\n                          if (getTickValueLabel) {\n                              return getTickValueLabel(this.state.xaxisDatakeyArr[d], i, (ticks || []).length);\n                          } else if (this.state.xaxisDatakeyArr) {\n                            return this.state.xaxisDatakeyArr[d];\n                          }\n                          return '';\n                        }}\n                        />;                    \n}            \n\n\n  /* y axis with horizontal lines having grid stroke colors*/\n  getYAxis() {\n    const props = this.state.props;\n    if (props.showyaxis === false) {\n      return null;\n    }\n    const getTickValueLabel = props.ytickexpr as any;\n    const ynumberformat = props.ynumberformat;\n    let xaxislabeldistance = props.xaxislabeldistance ? props.xaxislabeldistance : 20\n    return <VictoryAxis crossAxis={false} label={(props.yaxislabel || props.yaxisdatakey) + (props.yunits ? `(${props.yunits})` : '')}\n                        style={{\n                          axisLabel: this.theme.mergeStyle(this.styles.axisLabel, this.styles.yAxisLabel),\n                          grid: props.hidegridyaxis ? { stroke: null } : this.theme.mergeStyle(this.styles.grid, this.styles.yGrid),\n                          axis: props.showxaxis === false ?\n                          { stroke: 'none' } :  this.theme.mergeStyle(this.styles.axis, this.styles.yAxis),\n                          ticks: this.theme.mergeStyle(this.styles.ticks, this.styles.yTicks),\n                          tickLabels: props.showyaxislabels === false ? {fill: 'none'} : this.theme.mergeStyle(this.styles.tickLabels, this.styles.yTickLabels)\n                        }}\n                        fixLabelOverlap= {props.autoadjustlabels?true:false}\n                        axisLabelComponent={<VictoryLabel x={xaxislabeldistance}/>}\n                        tickLabelComponent={<VictoryLabel x={props.offsetxaxis ? props.offsetxaxis : 50}/>} \n                        theme={this.state.theme}\n                        tickFormat= {(d: number, i: number, ticks: any) => {\n                          if (getTickValueLabel) {\n                            return getTickValueLabel(d, i, (ticks || []).length);\n                          }\n                          if (ynumberformat) {\n                            return this.setYAxisFormat(d, ynumberformat);\n                          }\n                          return this.abbreviateNumber(d);\n                        }}\n                        orientation={this.isRTL?\"right\":\"left\"}\n                        dependentAxis />;\n  }\n  \n  setTooltipTemplate(partialName: any) {\n    this.updateState({ template: partialName} as any);\n  }\n\n  setTooltipPartialLayout(event: LayoutChangeEvent){\n    let tooltipLayout = event.nativeEvent.layout;\n    this.updateState({\n      tooltipoffsetx: tooltipLayout.width/2,\n      tooltipoffsety: tooltipLayout.height\n    } as any)\n  }\n  \n  renderPointer(){\n    return (\n      <View \n      style={[\n        {\n          transform: [\n            { rotate: '180deg' }\n          ],\n          bottom: -10,\n          left: this.state.tooltipoffsetx - this.styles.tooltipPointer.borderBottomWidth/2\n        },\n        this.styles.tooltipPointer\n      ]}\n    />\n    )\n  }\n\n  getTooltip() {\n    if(!this.state.props.tooltips){\n      return;\n    }\n    const ynumberformat = this.state.props.ynumberformat;\n    let yAxisData = ynumberformat ? this.setYAxisFormat(this.state.tooltipYaxis, ynumberformat) : this.state.tooltipYaxis;\n    return this.state.isTooltipOpen ? (\n      !isEmpty(this.state.template) && this.props.renderitempartial ?\n      <View onLayout={this.setTooltipPartialLayout.bind(this)} style={{ position: \"absolute\", top: this.state.tooltipYPosition as number, left: this.state.tooltipXPosition as number , zIndex: 99}}>\n           {this.props.renderitempartial(this.state.selectedItem, this.state.selectedItem.index, this.state.template)}\n           {this.renderPointer()}\n      </View> : (\n      <View style={[\n        { position: \"absolute\", top: this.state.tooltipYPosition as number, left: this.state.tooltipXPosition as number},\n        this.styles.tooltipContainer\n      ]}>\n        <Text style={[{ fontSize: 16, fontWeight: 'bold' },this.styles.tooltipXText]}>{this.state.tooltipXaxis}</Text>\n        <Text style={this.styles.tooltipXText}>{yAxisData}</Text>\n        {this.renderPointer()}\n      </View>)\n    ) : null;\n  }  \n\n  // X/Y Domain properties are supported only for Column and Area charts\n  isAxisDomainSupported(type: string) {\n    return type === 'Column'|| type === 'Area';\n  }\n\n  // Check whether X/Y Domain was set to Min and is supported for the present chart\n  isAxisDomainValid(axis: string) {\n    const props = this.state.props;\n    if (get(props, axis + 'domain') === 'Min' && (this.isAxisDomainSupported(props.type))) {\n      return true;\n    }\n    return false;\n  };\n\n// Check whether min and max values are finite or not\n  areMinMaxValuesValid(values: any) {\n    if (isFinite(values.min) && isFinite(values.max)) {\n      return true;\n    }\n    return false;\n  };\n\n  setDomainValues() {\n    let xDomainValues, yDomainValues;\n    if (this.state.data.length > 0) {\n      if (this.isAxisDomainValid('x') && typeof this.state.data[0].x === 'number') {\n        xDomainValues = this.getXMinMaxValues(this.state.data[0]);\n      }\n      if (this.isAxisDomainValid('y')) {\n        yDomainValues = this.getYMinMaxValues(this.state.data);\n      }\n      if (xDomainValues) {\n        this.updateState({\n          chartMinX: yDomainValues.min.x,\n          chartMaxX: yDomainValues.max.x\n        } as S)\n      }\n      let yMin;\n      if (yDomainValues) {\n        if (this.areMinMaxValuesValid({max: yDomainValues.max.y, min: yDomainValues.min.y})) {\n          yMin = this.getYScaleMinValue(yDomainValues.min.y);\n        }\n        this.updateState({\n          chartMinY: yMin ? yMin : yDomainValues.min.y,\n          chartMaxY: yDomainValues.max.y\n        } as S);\n      }\n    }\n  }\n\n  // Getting the min and max values among all the x values\n  getXMinMaxValues(datum: Array<{x: number, y: any}>) {\n    if (!datum) {\n      return;\n    }\n    const xValues: any = {};\n    /*\n     compute the min x valuex\n     eg: When data has objects\n        input: [{x:1, y:2}, {x:2, y:3}, {x:3, y:4}]\n        min x: 1\n     eg: When data has arrays\n        input: [[10, 20], [20, 30], [30, 40]];\n        min x: 10\n    */\n    xValues.min = minBy(datum, (dataObject: {x: any, y: any}) => dataObject.x) || {x: undefined};\n    /*\n     compute the max x value\n     eg: When data has objects\n        input: [{x:1, y:2}, {x:2, y:3}, {x:3, y:4}]\n        max x: 3\n     eg: When data has arrays\n        input: [[10, 20], [20, 30], [30, 40]];\n        max x: 30\n     */\n    xValues.max = maxBy(datum, (dataObject: {x: any, y: any}) => dataObject.x)|| {x: undefined};\n    return xValues;\n  }\n\n  // Getting the min and max values among all the y values\n  getYMinMaxValues(datum: Array<Array<{x: any, y: number}>>) {\n    const yValues: any = {},\n      minValues: any = [],\n      maxValues: any = [];\n    if (!datum) {\n      return;\n    }\n\n    /*\n     Getting the min and max y values among all the series of data\n     compute the min y value\n     eg: When data has objects\n        input: [[{x:1, y:2}, {x:2, y:3}, {x:3, y:4}], [{x:2, y:3}, {x:3, y:4}, {x:4, y:5}]]\n        min y values : '2'(among first set) & '3'(among second set)\n        max y values : '4'(among first set) & '5'(among second set)\n\n     eg: When data has arrays\n        input: [[[10, 20], [20, 30], [30, 40]], [[20, 30], [30, 40], [40, 50]]]\n        min y values : '20'(among first set) & '30'(among second set)\n        max y values : '40'(among first set) & '50'(among second set)\n     */\n\n    forEach(datum, data => {\n      if (data && !isEmpty(data)) {\n        minValues.push(minBy(data,  (dataObject: {x: any, y: any}) => { return dataObject.y }));\n        maxValues.push(maxBy(data,  (dataObject: {x: any, y: any}) => { return dataObject.y }));\n      }\n    });\n    // Gets the least and highest values among all the min and max values of respective series of data\n    yValues.min = minBy(minValues, (dataObject: {x: any, y: any}) => dataObject.y) || {y: undefined};\n    yValues.max = maxBy(maxValues, (dataObject: {x: any, y: any}) => dataObject.y) || {y: undefined};\n    return yValues;\n  }\n\n  setHeightWidthOnChart(cb?: () => void) {\n    let height = this.styles.root.height || 250;\n    let width = this.styles.root.width || screenWidth;\n    if (height && typeof height === 'string') {\n      height = parseInt(height);\n    }\n    if (width && typeof width === 'string') {\n      width = parseInt(width);\n    }\n    this.updateState({\n      chartHeight: height,\n      chartWidth: width\n    } as S, cb);\n  }\n\n  applyTheme(props: BaseChartComponentProps) {\n    let themeName = props.theme ? props.theme : (props.type === 'Pie' ? 'Azure' : 'Terrestrial');\n    let colorsToUse = [];\n    if (typeof props.customcolors === 'string' && !isEmpty(props.customcolors)) {\n      colorsToUse = props.customcolors.split(',').map(trim);\n    }\n    let themeToUse;\n    if (typeof themeName === 'string') {\n      if (!colorsToUse.length) {\n        colorsToUse = props.customcolors as string[];\n      }\n      if(props.customcolors===undefined) {\n        colorsToUse = ThemeFactory.getColorsObj(themeName);\n      }\n      themeToUse = ThemeFactory.getTheme(themeName, props.styles, colorsToUse);\n    } else if (typeof themeName === 'object') {\n      // if theme is passed as an object then use that custom theme.\n      themeToUse = props.theme;\n    }\n    this.updateState({\n      colors: colorsToUse,\n      theme: themeToUse\n    } as S);\n  }\n\n  prepareLegendData() {\n    const props = this.state.props;\n    if (this.state.yAxis) {\n      let ldata: any;\n      if (props.type === 'Stack') {\n        const data = orderBy(this.state.data[0], 'y', 'asc');\n        ldata = data.map((d: any) => {\n          return {\n            name: this.state.xaxisDatakeyArr[d.x]\n          }\n        });\n      } else {\n        ldata = this.state.yAxis.map((d: string) => {\n          return {\n            name: d\n          }\n        });\n      }\n\n      this.updateState({\n        legendData: ldata\n      } as S);\n    }\n  }\n\n  prepareEvents(name: string) {\n    return this.state.legendData.map((_: any, idx: number) => {\n      return {\n        childName: ['legend'],\n        target: 'data',\n        eventKey: String(idx),\n        eventHandlers: {\n          onClick: () => {\n            return [\n              {\n                childName: [name + '_' + idx],\n                target: 'data',\n                eventKey: 'all',\n                mutation: (props: any) => {\n                  return null;\n                }\n              }\n            ];\n          },\n          onMouseOver: () => {\n          },\n          onMouseOut: () => {\n          }\n        }\n      };\n    });\n  }\n\n  // If date string is bound to xaxis then we are pushing the x values as indexes.\n  getxAxisVal(dataObj: {[key: string] : any}, xKey: string, index: number, xaxisDatakeyArr: Array<any>) {\n    const value: any = get(dataObj, xKey);\n    if (moment(value).isValid() || isNaN(value) || typeof value === 'string' || typeof value === 'number') {\n      if (typeof value === \"string\"){\n        xaxisDatakeyArr.push(value.replace(\"\\\\n\",\"\\n\"));\n      }\n      else{\n        xaxisDatakeyArr.push(value);\n      }\n      return index;\n    }\n    return value;\n  }\n\n  prepareDataItems(dataset: any) {\n    const props = this.state.props;\n    let xaxis = props.xaxisdatakey;\n    let yaxis = props.yaxisdatakey;\n    let xaxisDatakeyArr: Array<any> = [];\n    let datasets: any = [];\n    if (dataset.length === 0) {\n      dataset = constructSampleData(getChartType(this.props), yaxis?.split(','), this.props.shape);\n      xaxis = \"x\";\n      yaxis = \"y\";\n    }\n    if (xaxis && yaxis) {\n      let yPts = yaxis.split(',');\n      yPts.forEach((y: any) => {\n        if (xaxis !== y) {\n          datasets.push(dataset.map((o: {[key: string] : any}, xindex: number) => {\n            const xVal = this.getxAxisVal(o, xaxis, xindex, xaxisDatakeyArr);\n            let yVal: string | number = get(o, y);\n            if (typeof yVal === 'string') {\n              yVal = parseFloat(yVal) || yVal;\n            }\n            let dataObj = {\n              x: xVal,\n              y: yVal,\n            };\n            if (props.bubblesize) {\n              set(dataObj, 'size', get(o, props.bubblesize, 5));\n            }\n            if (props.shape) {\n              set(dataObj, 'symbol', shapes[props.shape]);\n            }\n            return dataObj;\n          }));\n        }\n      });\n      // chartTransform\n      this.invokeEventCallback('onTransform', [undefined, this.proxy]);\n      if (props.type == 'Pie' || props.type === 'Donut') {\n        // for animation effect\n        setTimeout(() => {\n          this.updateState({\n            endAngle: 360,\n          } as S);\n        }, 500);\n      }\n      this.updateData(datasets, yPts, xaxisDatakeyArr);\n    }\n  }\n\n\n  protected renderLoadingIcon() {\n    const props = this.state.props;\n    return (<WmIcon id={this.getTestId('loadericon')} styles={this.styles.loadingIcon}\n    iconclass={props.loadingicon}\n    caption={props.loadingdatamsg}></WmIcon>);\n  }\n\n  updateData(datasets: any, yPts: any, xaxisDatakeyArr: Array<any>) {\n    const props = this.state.props;\n    this.updateState({\n      data: datasets as any,\n      yAxis: yPts,\n      xaxisDatakeyArr: xaxisDatakeyArr\n    } as S, () => {\n      this.prepareLegendData();\n      if (!props.labeltype || props.labeltype === 'percent') {\n        this.setTotal(this.state.data[0]);\n      }\n      if (this.isAxisDomainSupported(props.type) && (props.ydomain || props.xdomain)) {\n        this.setDomainValues();\n      }\n      this.updateState({\n        loading: false\n      } as S);\n    });\n  }\n\n  setTotal(data: Array<{x: any, y: number}>) {\n    let total = 0;\n    data.forEach((d: {x: any, y: any}) => {\n      total += d.y as number;\n    });\n    this.updateState({\n      total: total\n    } as S);\n  }\n\n  onPropertyChange(name: string, $new: any, $old: any) {\n    super.onPropertyChange(name, $new, $old);\n    const props = this.state.props;\n    let units = '';\n    switch(name) {\n      case 'customcolors':\n        if (isEmpty($new)) {\n          return;\n        }\n        if (typeof $new === 'string') {\n          $new = $new.split(',');\n        }\n        this.updateState({\n          colors: $new\n        } as S);\n        break;\n      case 'theme':\n        this.applyTheme(props);\n        break;\n      case 'dataset':\n        if (!isArray($new)) {\n          if (isObject($new) && !isEmpty($new)) {\n            $new = [$new];\n          } else {\n            $new = [];\n          }\n        }\n        $new && this.prepareDataItems($new);\n        break;\n      case 'xaxislabel':\n        if (props.xunits) {\n          units = ' (' + props.xunits + ')';\n        }\n        this.updateState({\n          xLabel: $new + units\n        } as S);\n        break;\n      case 'yaxislabel':\n        if (props.yunits) {\n          units = ' (' + props.yunits + ')';\n        }\n        this.updateState({\n          yLabel: $new + units\n        } as S);\n        break;\n    }\n  }\n\n  public renderSkeleton(props: T): React.ReactNode {\n    if(props.skeletonanimationresource) {\n      return <View style={[{width: '100%'}, this.styles?.root]}>\n      <WmLottie styles={{ content: {...this.styles?.root, ...this.styles?.skeleton?.root} }} source={props.skeletonanimationresource} loop={true} autoplay={true} speed={this.props.skeletonanimationspeed}/>\n    </View>\n    }\n    return null;\n  }\n}\nfunction getDataType(widgetContext: { yaxisdatakey: string | null | undefined; shape: any; }): any {\n  throw new Error(\"Function not implemented.\");\n}\n\n", "wavemaker-rn-runtime/src/components/chart/basechart.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { SkeletonAnimationProps } from '@wavemaker/app-rn-runtime/runtime/base-fragment.component';\nimport { AccessibilityRole } from 'react-native';\n\nexport default class BaseChartComponentProps extends SkeletonAnimationProps {\n  xaxisdatakey: string = '';\n  yaxisdatakey: string = '';\n  iconclass = '';\n  dataset: any;\n  type: string = '';\n  title: string = '';\n  subheading: string = '';\n  theme: string = '';\n  xaxislabel: string = '';\n  xunits: string = '';\n  staggerlabels: boolean = false;\n  yaxislabel: string = '';\n  yunits: string = '';\n  yaxislabeldistance?: number = undefined;\n  xaxislabeldistance?: number = undefined;\n  offsetxaxis?: number = undefined;\n  offsetyaxis?: number = undefined;\n  customcolors: string | Array<string> = '';\n  legendheight: number = 0;\n  labellegendheight: number = 0;\n  labeltype: 'percent' | 'value' | 'key-value' | 'key' = 'percent';\n  bubblesize: string= '';\n  shape: string = '';\n  loadingicon='fa fa-circle-o-notch fa-pulse';\n  loadingdatamsg = 'Loading...';\n  nodatamessage = 'No data found';\n  offsetbottom: number = 50;\n  offsettop: number = 70;\n  offsetleft: number = 65;\n  offsetright: number = 25;\n  showlegend: string = 'top';\n  showlabels: 'inside' | 'outside' | 'hide' = 'outside';\n  tooltips: boolean = true;\n  interpolation: string = 'linear';\n  highlightpoints: boolean = false;\n  showvalues: boolean = false;\n  showyaxis: boolean = true;\n  showxaxis: boolean = true;\n  ydomain: string = 'Min';\n  xdomain: string = 'Min';\n  labelangle: number = 0;\n  xtickexpr?: (item: any, index: number, length: number) => any;\n  ytickexpr?: (item: any, index: number, length: number) => any;\n  hidegridxaxis: boolean = false;\n  hidegridyaxis: boolean = false;\n  autoadjustlabels: boolean = false;\n  accessibilitylabel?: string = undefined;\n  hint?: string = undefined;\n  accessibilityrole?: AccessibilityRole;\n  renderitempartial?: (item: any, index: number, partialName: string)=> React.ReactNode;\n  ynumberformat?: string = '';\n  showxaxislabels: boolean = true;\n  showyaxislabels: boolean = true;\n}\n", "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport {BaseChartComponentStyles,  DEFAULT_CLASS as BASE_CHART_DEFAULT_CLASS } from '../basechart.styles';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmBubbleChartStyles = BaseStyles & BaseChartComponentStyles;\n\nexport const DEFAULT_CLASS = 'app-bubble-chart';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    addStyle(DEFAULT_CLASS, BASE_CHART_DEFAULT_CLASS , {\n        skeleton: {\n            root: {\n                height: 200\n            }\n        } as WmSkeletonStyles\n    });\n});\n", "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.props.ts": "import BaseChartComponentProps from \"@wavemaker/app-rn-runtime/components/chart/basechart.props\";\n\nexport default class WmBubbleChartProps extends BaseChartComponentProps {\n    onSelect?: any;\n}\n", "wavemaker-rn-runtime/src/components/chart/bubble-chart/bubble-chart.component.tsx": "import React from 'react';\nimport {Text, View, Platform} from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility'; \n\nimport WmBubbleChartProps from './bubble-chart.props';\nimport { DEFAULT_CLASS, WmBubbleChartStyles } from './bubble-chart.styles';\nimport {\n  BaseChartComponent,\n  BaseChartComponentState\n} from \"@wavemaker/app-rn-runtime/components/chart/basechart.component\";\nimport {VictoryAxis, VictoryChart, VictoryLegend, VictoryLine, VictoryScatter} from \"victory-native\";\nimport { ScatterSymbolType } from \"victory-core\";\nimport {Svg} from \"react-native-svg\";\nimport {get} from \"lodash-es\";\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport { isWebPreviewMode } from '@wavemaker/app-rn-runtime/core/utils';\n\nexport class WmBubbleChartState extends BaseChartComponentState<WmBubbleChartProps> {}\n\nexport default class WmBubbleChart extends BaseChartComponent<WmBubbleChartProps, WmBubbleChartState, WmBubbleChartStyles> {\n\n  constructor(props: WmBubbleChartProps) {\n    super(props, DEFAULT_CLASS, new WmBubbleChartProps(), new WmBubbleChartState());\n  }\n\n  onSelect(event: any, data: any){\n    if (!this.viewRef.current) return;\n    this.viewRef.current.measureInWindow((chartX: number, chartY: number) => {\n    let value = data.data[data.index].y;\n    let label = this.state.xaxisDatakeyArr[data.datum.x];\n    let selectedItem = this.props.dataset[data.index];\n    const nativeEvent = event.nativeEvent;\n    let tooltipX = nativeEvent.pageX - chartX;\n    let tooltipY = nativeEvent.pageY - chartY;\n    let selectedChartItem = [{series: 0, x: data.index, y: value,_dataObj: selectedItem},data.index];\n    this.updateState({\n      tooltipXaxis: label,\n      tooltipYaxis: value,\n      isTooltipOpen: true,\n      selectedItem: {...selectedItem, index: data.index},\n      tooltipXPosition: tooltipX - this.state.tooltipoffsetx, \n      tooltipYPosition: tooltipY - this.state.tooltipoffsety\n    } as WmBubbleChartState)\n    this.invokeEventCallback('onSelect', [event.nativeEvent, this.proxy, selectedItem, selectedChartItem ]);\n  });\n  }\n\n  renderWidget(props: WmBubbleChartProps) {\n    this.invokeEventCallback('onBeforerender', [this.proxy, null]);\n    if (!this.state.data?.length) {\n      return null;\n    }\n    return (<View\n      {...getAccessibilityProps(AccessibilityWidgetType.LINECHART, props)}\n      style={this.styles.root}\n      onLayout={this.onViewLayoutChange.bind(this)}\n    >\n      <View>\n        <View style={{flexDirection: 'row', alignItems: 'center'}}>\n          { props.iconclass ? (<WmIcon iconclass={props.iconclass} styles={this.styles.icon}></WmIcon>) : null }\n          <Text style={this.styles.title}>{props.title}</Text>\n        </View>\n        <Text style={this.styles.subHeading}>{props.subheading}</Text>\n      </View>\n      <View ref={this.viewRef}>\n      {this.getTooltip()}\n      <VictoryChart\n        theme={this.state.theme}\n        height={this.styles.root.height as number}\n        width={this.state.chartWidth || this.screenWidth}\n        padding={{ top: props.offsettop, bottom: props.offsetbottom, left: props.offsetleft, right: props.offsetright }}\n      >\n        <VictoryLegend\n          name={'legend'}\n          containerComponent={<Svg />}\n          orientation=\"horizontal\"\n          gutter={20}\n          data={[]}\n          theme={this.state.theme}\n        />\n        {this.getLegendView()}\n        {this.getXaxis()}\n        {this.getYAxis()}\n        {this.state.data.map((d: any, i: number) => {\n        return <VictoryScatter\n          colorScale={this.state.colors}\n          style={{\n            data: { fill: this.state.colors[i], opacity: ({ datum }: any) => datum.opacity }\n          }}\n          key={props.name + '_bubble_' + i}\n          name={props.name + '_bubble_' + i}\n          data={d}\n          size={5}\n          events={[{\n            target: 'data',\n            eventHandlers: Platform.OS == \"web\" ? {\n              onClick: this.onSelect.bind(this)\n            }:{\n              onPress: this.onSelect.bind(this)\n            }\n          }]}\n        />\n      })}\n      </VictoryChart></View></View>);\n  }\n}\n", "wavemaker-rn-runtime/src/components/chart/legend/legend.component.tsx": "import * as React from 'react';\nimport { TextStyle, View, Text, ViewStyle } from \"react-native\";\n\nexport interface LegendProps {\n    data : [{\n        name: string,\n        color: string\n    }];\n    dotStyle?: ViewStyle;\n    testStyle?: TextStyle;\n    orientation?: 'vertical' | 'horizontal';\n}\n\nexport const Legend = function(props: LegendProps) {\n    return (\n        <View style={[\n        props.orientation === 'vertical' ?  {\n            flexDirection: 'column',\n            justifyContent: 'center'\n        } : {\n            flexDirection: 'row',\n            justifyContent: 'center',\n            flexWrap: 'wrap'\n        }]}>\n            {props.data?.map(d => {\n                return (\n                <View key={d.name} style={{\n                    flexDirection: 'row',\n                    alignItems: 'center',\n                    padding: 4}}>\n                    <View style={[{\n                        width: 12,\n                        height: 12\n                    }, props.dotStyle, {\n                        backgroundColor: d.color\n                    }]}></View>\n                    <Text style={[{ \n                        paddingLeft: 4\n                    }, props.testStyle]}>{d.name}</Text>\n                </View>);\n            })}\n        </View>\n    );\n};", "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.component.tsx": "import React from 'react';\nimport { LayoutChangeEvent, View, Platform } from 'react-native';\nimport { Svg } from 'react-native-svg';\nimport { VictoryStack, VictoryBar, VictoryChart, VictoryPie, VictoryLegend, VictoryAxis } from 'victory-native';\nimport { Axis, Scale } from 'victory-core';\nimport { orderBy, cloneDeep, findIndex, isString} from 'lodash';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility';\nimport WmStackChartProps from './stack-chart.props';\nimport { DEFAULT_CLASS, WmStackChartStyles } from './stack-chart.styles';\nimport {\n  BaseChartComponent,\n  BaseChartComponentState\n} from '@wavemaker/app-rn-runtime/components/chart/basechart.component';\nimport { isWebPreviewMode } from '@wavemaker/app-rn-runtime/core/utils';\n\nexport class WmStackChartState extends BaseChartComponentState<WmStackChartProps> {\n  chartWidth = 0;\n}\n\nexport default class WmStackChart extends BaseChartComponent<WmStackChartProps, WmStackChartState, WmStackChartStyles> {\n  constructor(props: WmStackChartProps) {\n    super(props, DEFAULT_CLASS, new WmStackChartProps(), new WmStackChartState());\n  }\n\n  componentDidMount() {\n    super.componentDidMount();\n    this.setHeightWidthOnChart();\n  }\n\n  getNegativeValuesArray() {\n    let negativeValuesArray = cloneDeep(this.state.data[0]).filter((d: any) => d.y < 0);\n    negativeValuesArray = orderBy(negativeValuesArray, 'y', 'desc');\n    return negativeValuesArray;\n  }\n\n  getPositiveValuesArray() {\n    let positiveValuesArray = cloneDeep(this.state.data[0]).filter((d: any) => d.y > 0);\n    positiveValuesArray = orderBy(positiveValuesArray, 'y', 'asc');\n    return positiveValuesArray;\n  }\n\n  getData() {\n    const negativeValues = cloneDeep(this.getNegativeValuesArray());\n    return negativeValues.concat(cloneDeep(this.getPositiveValuesArray()));\n  }\n\n  updateColors() {\n   if (this.state.colors.length === 1 ) {\n       return this.state.colors[0];\n   } else {\n       let colorCodes = cloneDeep(this.state.colors);\n       if ( this.state.data.length > 0 ) {\n         const orderedData = this.getData();\n         this.state.data[0].map((d: any, i: number) => {\n           let index = findIndex(orderedData, d);\n           colorCodes[index] = this.state.colors[i];\n         })\n         return colorCodes;\n       }\n    }\n  }\n\n  getLegendColors(){\n    if (this.state.colors.length === 1 ) {\n      return this.state.colors[0];\n  } else {\n      let colorCodes = cloneDeep(this.state.colors);\n      if ( this.state.data.length > 0 ) {\n        const orderedData = orderBy(this.state.data[0], 'y', 'asc');;\n        this.state.data[0].map((d: any, i: number) => {\n          let index = findIndex(orderedData, d);\n          colorCodes[index] = this.state.colors[i];\n        })\n        return colorCodes;\n      }\n   }\n }\n\n  getBarChart(props: WmStackChartProps) {\n    if ( this.state.data.length > 0 ) {\n      const negativeValues = cloneDeep(this.getNegativeValuesArray());\n      const data = this.getData();\n      let currentValue = 0;\n      const yValues = data.map((d: any) => d.y);\n      const minValue = Math.min(...yValues);\n      const maxValue = Math.max(...yValues);\n\n      return data.map((d: any, i: number) => {\n        let cornerRadius: any;\n        if (d.y === minValue) {\n          cornerRadius = d.y > 0 ? { bottom: 10 } : { top: 10 };\n        } else if (d.y === maxValue) {\n          cornerRadius = d.y > 0 ? { top: 10 } : { bottom: 10 };\n        } else {\n          cornerRadius = 0;\n        }        \n        let d1: any = [];\n        d.index = d.x;\n        d.x = 0;\n        d.y = d.y - currentValue;\n        d1.push(d);\n        currentValue = d.y < 0 && i === negativeValues.length -1 ? 0 : d.y + currentValue;\n        return <VictoryBar key={props.name + '_' + i}\n                          cornerRadius={cornerRadius}\n                          barWidth={this.state.props.thickness}\n                          data={d1}\n                          events={[\n                            {\n                              target: 'data',\n                              eventHandlers: Platform.OS === 'web'\n                                ? { onClick: this.onSelect.bind(this) }\n                                : { onPress: this.onSelect.bind(this) }\n                            }\n                          ]}/>\n      });\n    }\n  }\n\n  private getColorCodes() {\n      const colors = cloneDeep(this.updateColors());\n      return isString(colors) ? [colors] : colors.reverse();\n  }\n\n  getArcChart(props: WmStackChartProps) {\n    if ( this.state.data.length > 0 ) {\n      let data = this.getData()\n      let negativeValues = cloneDeep(this.getNegativeValuesArray());\n      let currentValue = 0;\n      let prevValue = 0\n      data = data.map((d: any, i: number) => {\n        d.y = d.y - currentValue\n        prevValue = d.y\n        d.y = Math.abs(d.y)\n        d.index = d.x\n        currentValue = prevValue < 0 && i === negativeValues.length -1 ? 0 : prevValue + currentValue;\n        return d\n      })\n      data.reverse()\n      if(negativeValues.length > 1){\n        const portionToReverse = data.slice(-(negativeValues.length));\n        const reversedPortion = portionToReverse.reverse();\n        data = [...data.slice(0, -(negativeValues.length)), ...reversedPortion];\n      }\n      const radius = Math.min(this.state.chartWidth/2, this.state.chartHeight - 50);\n      const angles = data.map((d: any, i: number) => {\n        let total = data.reduce((sum: number, item: any) => sum + item.y, 0);\n        return Math.round((d.y / total) * 160);\n      });\n      let startAngle = 80\n      return data.map((d: any, i: number) => {\n        let d1: any = [];\n        d1.push(d);\n        if (i != 0) {\n          startAngle = startAngle - angles[i - 1] + (angles[i - 1] / 10)\n        }\n        return <VictoryPie key={props.name + '_' + i}\n                           radius={radius}\n                           colorScale={[this.state.colors[d.index], '#fff0']}\n                           startAngle={angles ? startAngle : -80}\n                           endAngle={-80}\n                           cornerRadius={100}\n                           standalone={false}\n                           origin={{x: (this.state.chartWidth/2), y: (this.state.chartHeight - 50)}}\n                           innerRadius={radius - this.state.props.thickness}\n                           labels={[]}\n                           events={[{\n                            target: 'data',\n                            eventHandlers: Platform.OS == \"web\" ? {\n                              onClick: this.onSelect.bind(this)\n                            }:{\n                              onPress: this.onSelect.bind(this)\n                            }\n                          }]}\n                           data={d1}/>\n      });\n    }\n  }\n\n  getArcAxis() {\n    const ticks = this.getTickValues();\n    const radius = Math.min(this.state.chartWidth/2, this.state.chartHeight-50);\n    const axisData: any = [];\n    ticks.forEach((d: any, i: any) => {\n      axisData.push({x:  `${this.state.props.yunits}${d}`, y: 1})\n    });\n    return <VictoryPie\n     style={{\n       labels: {\n         fontSize: 12, paddingLeft: 50, paddingRight: 80\n       }}\n     }\n      startAngle={-90}\n      endAngle={90}\n      standalone={false}\n      colorScale={['#fff0']}\n      origin={{x: (this.state.chartWidth/2 - 5), y: (this.state.chartHeight - 50)}}\n      labelRadius={radius - this.state.props.thickness - 20}\n      data={axisData}\n    />\n  }\n\n  onViewLayoutChange = (e: LayoutChangeEvent) => {\n    let viewWidth = e.nativeEvent.layout.width;\n\n    this.handleLayout(e)\n\n    this.updateState({\n      chartWidth: viewWidth\n    } as WmStackChartState);\n  }\n\n  getTickValues() {\n    let ticks: any = [];\n    if (this.state.data[0].length) {\n      let data = cloneDeep(this.state.data[0]);\n      const maxValue = Math.max(...data.map((o: any) => o.y ? o.y : 0));\n      const minValue = Math.min(...data.map((o: any) => o.y ? o.y : 0));\n      const scale = Scale.getBaseScale({}, 'x');\n      scale.domain([minValue > 0 ? 0 : minValue, maxValue]);\n      ticks = Axis.getTicks({}, scale);\n      ticks[ticks.length -1] = maxValue;\n      if ( minValue < 0 ) {\n        if (ticks[0] === 0) {\n          ticks.unshift(minValue);\n        } else {\n          ticks[0] = minValue;\n        }\n      } else {\n        ticks[0] = this.state.props.minvalue;\n      }\n    }\n    return ticks;\n  }\n\n  onSelect(event: any, data: any){\n    if (!this.viewRef.current) return;\n    this.viewRef.current.measureInWindow((chartX: number, chartY: number) => {\n    let props = this.state.props\n    let index = data.datum.index\n    let yaxisKey = props.yaxisdatakey;\n    let label = this.state.xaxisDatakeyArr[index];\n    let value = props.dataset[index][yaxisKey];\n    let selectedItem = props.dataset[index];\n    let selectedChartItem = [{series: 0, x: index, y: value,_dataObj: selectedItem}, index];\n    const nativeEvent = event.nativeEvent;\n    let tooltipX = nativeEvent.pageX - chartX;\n    let tooltipY = nativeEvent.pageY - chartY;\n    this.updateState({\n      tooltipXaxis: label,\n      tooltipYaxis: value,\n      isTooltipOpen: true,\n      selectedItem: {...selectedItem, index: index},\n      tooltipXPosition: tooltipX - this.state.tooltipoffsetx, \n      tooltipYPosition: tooltipY - this.state.tooltipoffsety\n    } as WmStackChartState)\n    this.invokeEventCallback('onSelect', [event.nativeEvent, this.proxy, selectedItem, selectedChartItem ]);\n  });\n  }\n\n  renderWidget(props: WmStackChartProps) {\n    this.invokeEventCallback('onBeforerender', [this.proxy, null]);\n    if (!this.state.data.length) {\n      return null;\n    }\n    let mindomain={x: this.props.xdomain === 'Min' ? this.state.chartMinX: undefined, y: this.props.ydomain === 'Min' ? this.state.chartMinY: undefined};\n    return (\n      <View\n        {...getAccessibilityProps(AccessibilityWidgetType.LINECHART, props)}\n        style={this.styles.root} onLayout={this.onViewLayoutChange}\n      >\n        {this.getTooltip()}{\n        props.viewtype === 'Bar' ?\n        <View ref={this.viewRef}>\n          <VictoryChart\n            theme={this.state.theme}\n            minDomain={mindomain}\n            height={this.styles.root.height as number}\n            width={this.styles.root.width as number || this.state.chartWidth || 200}\n            padding={{\n              top: props.offsettop,\n              bottom: props.offsetbottom,\n              left: props.offsetleft,\n              right: props.offsetright\n            }}\n            >\n            <VictoryLegend\n              name={'legend'}\n              containerComponent={<Svg />}\n              style={{title: {\n                fontFamily: \"'Helvetica Neue', 'Helvetica', sans-serif\",\n                fontSize: 18\n              }\n              }}\n              title={[props.title, props.subheading]}\n              orientation=\"horizontal\"\n              gutter={20}\n              data={[]}\n              theme={this.state.theme}\n            />\n            {this.getLegendView(this.getLegendColors())}\n            <VictoryAxis crossAxis\n                         style={{\n                           tickLabels: { fill: this.state.props.showyaxis === false ? 'transparent' : '#000000',  fontSize: 12, padding: this.state.props.thickness/2 + 5},\n                           axisLabel: { padding: (15 + this.state.props.thickness/2) },\n                           grid: {stroke: 'none'},\n                           axis: {stroke: 'none'},\n                           ticks: {stroke: 'none'}\n                         }}\n                         theme={this.state.theme}\n                         tickValues={this.getTickValues()}\n                         tickFormat={(t: any) => this.state.props.yunits ? `${this.abbreviateNumber(t)}${this.state.props.yunits}` : `${this.abbreviateNumber(t)}`} dependentAxis />\n            <VictoryStack\n              colorScale={this.updateColors()}\n              horizontal={true}\n            >\n              {\n                this.getBarChart(props)\n              }\n            </VictoryStack>\n          </VictoryChart>\n          </View>:\n          <View ref={this.viewRef}>\n          <Svg width={this.state.chartWidth} height={this.state.chartHeight}>\n            <VictoryLegend\n              name={'legend'}\n              containerComponent={<Svg />}\n              title={[props.title, props.subheading]}\n              orientation=\"horizontal\"\n              gutter={20}\n              data={[]}\n              theme={this.state.theme}\n            />\n            {this.getArcChart(props)}\n            {this.getArcAxis()}\n          </Svg>\n          </View>\n      }\n      </View>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.props.ts": "import BaseChartComponentProps from '@wavemaker/app-rn-runtime/components/chart/basechart.props';\n\nexport default class WmStackChartProps extends BaseChartComponentProps {\n  viewtype: string = 'Bar';\n  showlegend: string = 'left';\n  thickness: number = 30;\n  offsetleft: number = 25;\n  offsetright: number = 35;\n  onSelect?: any;\n  minvalue: number = 0;\n}\n", "wavemaker-rn-runtime/src/components/chart/stack-chart/stack-chart.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport {BaseChartComponentStyles, DEFAULT_CLASS as BASE_CHART_DEFAULT_CLASS } from '../basechart.styles';\n\nexport type WmStackChartStyles = BaseStyles & BaseChartComponentStyles;\n\nexport const DEFAULT_CLASS = 'app-stack-chart';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  addStyle(DEFAULT_CLASS, BASE_CHART_DEFAULT_CLASS, {});\n});\n", "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.component.tsx": "import React from 'react';\nimport { LayoutChangeEvent, View, Text, Platform } from 'react-native';\nimport { Svg } from 'react-native-svg';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility'; \n\nimport { VictoryLabel, VictoryPie } from 'victory-native';\n\nimport WmPieChartProps from './pie-chart.props';\nimport { DEFAULT_CLASS, WmPieChartStyles } from './pie-chart.styles';\n\nimport { formatCompactNumber, isWebPreviewMode } from '@wavemaker/app-rn-runtime/core/utils';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport {\n  BaseChartComponent,\n  BaseChartComponentState\n} from '@wavemaker/app-rn-runtime/components/chart/basechart.component';\nimport WmDonutChartProps from '@wavemaker/app-rn-runtime/components/chart/donut-chart/donut-chart.props';\nimport { Legend } from '../legend/legend.component';\n\n\nexport class WmPieChartState extends BaseChartComponentState<WmPieChartProps> {\n  chartWidth = 0;\n  totalHeight = 0;\n  infoHeight = 10;\n  legendWidth = 0;\n  legendHeight = 0;\n  opacity = 0;\n}\n\nexport default class WmPieChart extends BaseChartComponent<WmPieChartProps, WmPieChartState, WmPieChartStyles> {\n\n  constructor(props: WmPieChartProps) {\n    super(props, DEFAULT_CLASS, props.type === 'Donut' ? new WmDonutChartProps() : new WmPieChartProps(), new WmPieChartState());\n  }\n\n  componentDidMount() {\n    super.componentDidMount();\n  }\n\n  onViewLayoutChange = (e: LayoutChangeEvent) => {\n    let viewWidth = e.nativeEvent.layout.width;\n\n    this.handleLayout(e)\n\n    this.updateState({\n      chartWidth: viewWidth,\n      totalHeight: e.nativeEvent?.layout.height\n    } as WmPieChartState)\n  }\n\n  onInfoViewLayoutChange = (e: LayoutChangeEvent) => {\n    this.updateState({\n      infoHeight: e.nativeEvent?.layout.height,\n      opacity: 1\n    } as WmPieChartState);\n  }\n\n  onLegendViewLayoutChange = (e: LayoutChangeEvent) => {\n    this.updateState({\n      legendWidth: e.nativeEvent?.layout.width,\n      legendHeight: e.nativeEvent?.layout.height\n    } as WmPieChartState);\n  }\n\n  getLabel(d: {x: any, y: any}, props: WmPieChartProps): string {\n      switch(props.labeltype) {\n        case 'percent': {\n          return Math.round(d.y * 100 /this.state.total) + '%';\n        }\n        case 'key': {\n          return this.state.xaxisDatakeyArr[d.x];\n        }\n        case 'value': {\n          return formatCompactNumber(d.y);\n        }\n        case 'key-value': {\n          return this.state.xaxisDatakeyArr[d.x] + ' ' + d.y;\n        }\n      }\n  }\n\n  onSelect(event: any, data: any){\n    if (!this.viewRef.current) return;\n    this.viewRef.current.measureInWindow((chartX: number, chartY: number) => {\n    let value = data.slice.value;\n    let label = this.state.xaxisDatakeyArr[data.datum.x];\n    let selectedItem = this.props.dataset[data.index];\n    let selectedChartItem = data.slice;\n    selectedChartItem[\"data\"] = {x: label, y: value, color: data.style.fill, _dataObj: selectedItem}\n    const nativeEvent = event.nativeEvent;\n    let tooltipX = nativeEvent.pageX - chartX;\n    let tooltipY = nativeEvent.pageY - chartY;\n    this.updateState({\n      tooltipXaxis: label,\n      tooltipYaxis: value,\n      isTooltipOpen: true,\n      selectedItem: {...selectedItem, index: data.index },\n      tooltipXPosition: tooltipX - this.state.tooltipoffsetx, \n      tooltipYPosition: tooltipY - this.state.tooltipoffsety\n    } as any);\n    this.invokeEventCallback('onSelect', [event.nativeEvent, this.proxy, selectedItem, selectedChartItem ]);\n    });\n  }\n\n  renderWidget(props: WmPieChartProps) {\n    this.invokeEventCallback('onBeforerender', [this.proxy, null]);\n    if (!this.state.data.length) {\n      return null;\n    }   \n    const pieData = this.state.data[0];\n    const chartWidth = this.state.chartWidth \n      - (props.showlegend === 'right' ? this.state.legendWidth : 0);\n    const chartHeight = (this.styles.root.height ? this.state.totalHeight : chartWidth) \n      - this.state.infoHeight \n      - (props.showlegend === 'right' ? 0 : this.state.legendHeight);\n    let radius = (Math.min(chartWidth, chartHeight) - 40)/ 2;\n    let innerRadius = props.donutratio * radius;\n    let styleProp = {};\n    let labelRadius;\n    if (props.showlabels === 'hide') {\n      styleProp={labels: { display: \"none\" }};\n    } else if (props.showlabels === 'inside') {\n      labelRadius = radius/2;\n    } else {\n      labelRadius = radius + 8;\n    }\n    const origin = {x: (chartWidth/2), y: (chartHeight/2)};\n    const orientation = props.showlegend === 'right' ? 'vertical' : 'horizontal';\n    let legendData = pieData.map((d: {x: any, y: any}, index: number) => {\n      return {\n        name: this.state.xaxisDatakeyArr[d.x],\n        color: this.state.colors[index % (this.state.colors.length)]\n      };\n    });\n    return (\n      <View style={[{opacity: this.state.opacity}, this.styles.root]}\n        {...getAccessibilityProps(AccessibilityWidgetType.LINECHART, props)}\n        onLayout={this.onViewLayoutChange}\n        key={`${props.title}_pie_chart`}\n        >\n        <View onLayout={this.onInfoViewLayoutChange}>\n          <View style={{flexDirection: 'row', alignItems: 'center'}}>\n            {props.iconclass ? (<WmIcon iconclass={props.iconclass} styles={this.styles.icon}></WmIcon>) : null }\n            <Text style={this.styles.title}>{props.title}</Text>\n          </View>\n          <Text style={this.styles.subHeading}>{props.subheading}</Text>\n        </View>\n        {props.showlegend === 'top' ? \n          (<View onLayout={this.onLegendViewLayoutChange}>\n            <Legend data={legendData}\n              testStyle={this.styles.legendText}\n              dotStyle={this.styles.legenedDot}></Legend>\n          </View>) : null }\n        <View style={{flexDirection: 'row', justifyContent: 'center', alignItems: 'center'}}>\n        {this.getTooltip()}\n          <View style={{flex: 1}} ref={this.viewRef}>\n            {chartWidth ? (\n            <Svg\n              width={chartWidth}\n              height={chartHeight}\n            >\n              <VictoryPie\n                style={styleProp}\n                standalone={false}\n                colorScale={this.state.colors}\n                labels={({datum}) => this.getLabel(datum, props)}\n                endAngle={this.state.endAngle || 0}\n                radius={radius}\n                innerRadius={innerRadius}\n                theme={this.state.theme}\n                key={props.name}\n                name={props.name}\n                data={this.isRTL?pieData.toReversed():pieData}\n                origin={origin}\n                labelPlacement={props.labelplacement}\n                labelRadius={labelRadius}\n                events={[{\n                  target: 'data',\n                  eventHandlers: Platform.OS == \"web\" ? {\n                    onClick: this.onSelect.bind(this)\n                  }:{\n                    onPress: this.onSelect.bind(this)\n                  }\n                }]}\n              />\n              <VictoryLabel\n                textAnchor=\"middle\"\n                style={{ ...this.styles.centerLabel, fill: this.styles.centerLabel.color }}\n                x={origin.x} y={origin.y}\n                text={props.centerlabel}\n              />\n            </Svg>) : null}\n          </View>\n          {props.showlegend === 'right' ? \n            (<View style={{maxWidth: '50%'}} onLayout={this.onLegendViewLayoutChange}>\n              <Legend data={legendData}\n                testStyle={this.styles.legendText}\n                dotStyle={this.styles.legenedDot}\n                orientation='vertical'></Legend>\n            </View>) : null }\n        </View>\n        {props.showlegend === 'bottom' ? \n          (<View onLayout={this.onLegendViewLayoutChange}>\n            <Legend data={legendData}\n              testStyle={this.styles.legendText}\n              dotStyle={this.styles.legenedDot}></Legend>\n          </View>) : null }\n      </View>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.props.ts": "import BaseChartComponentProps from '@wavemaker/app-rn-runtime/components/chart/basechart.props';\nimport { VictorySliceLabelPlacementType } from 'victory-pie';\n\nexport default class WmPieChartProps extends BaseChartComponentProps {\n  donutratio: number = 0;\n  labelplacement: VictorySliceLabelPlacementType = 'vertical';\n  centerlabel = '';\n  onSelect?: any;\n}\n", "wavemaker-rn-runtime/src/components/chart/pie-chart/pie-chart.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport {BaseChartComponentStyles, DEFAULT_CLASS as BASE_CHART_DEFAULT_CLASS } from '../basechart.styles';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmPieChartStyles = BaseStyles & BaseChartComponentStyles;\n\nexport const DEFAULT_CLASS = 'app-pie-chart';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    addStyle(DEFAULT_CLASS, BASE_CHART_DEFAULT_CLASS, {\n        skeleton: {\n            root: {\n                height: 200\n            }\n        } as WmSkeletonStyles\n    });\n});\n", "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport {BaseChartComponentStyles, DEFAULT_CLASS as BASE_CHART_DEFAULT_CLASS} from '../basechart.styles';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmBarChartStyles = BaseStyles & BaseChartComponentStyles;\n\nexport const DEFAULT_CLASS = 'app-bar-chart';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    addStyle(DEFAULT_CLASS, BASE_CHART_DEFAULT_CLASS, {\n        style: {\n            root: {\n                height: 200\n            }\n        } as WmSkeletonStyles\n    });\n});\n", "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.component.tsx": "import React from 'react';\nimport { View, Text, Platform, LayoutChangeEvent } from 'react-native';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility'; \nimport {\n  VictoryChart,\n  VictoryBar,\n  VictoryLegend,\n  VictoryStack,\n  VictoryGroup\n} from \"victory-native\";\n\nimport {\n  BaseChartComponent,\n  BaseChartComponentState\n} from \"@wavemaker/app-rn-runtime/components/chart/basechart.component\";\nimport WmBarChartProps from './bar-chart.props';\nimport { DEFAULT_CLASS, WmBarChartStyles } from './bar-chart.styles';\nimport WmIcon from \"@wavemaker/app-rn-runtime/components/basic/icon/icon.component\";\nimport { min } from 'moment';\nimport { isWebPreviewMode } from '@wavemaker/app-rn-runtime/core/utils';\n\nexport class WmBarChartState extends BaseChartComponentState<WmBarChartProps> {}\n\nexport default class WmBarChart extends BaseChartComponent<WmBarChartProps, WmBarChartState, WmBarChartStyles> {\n\n  constructor(props: WmBarChartProps) {\n    super(props, DEFAULT_CLASS, new WmBarChartProps(), new WmBarChartState());\n  }\n\n  labelFn(data: any): string | number | string[] | number[] | null {\n    return this.abbreviateNumber(data.datum.y);\n  }\n\n  getBarChart(props: WmBarChartProps) {\n  return this.state.data.map((d: any, i: number) => {\n    return <VictoryBar key={props.name + '_' + i}\n        horizontal={props.horizontal} labels={props.showvalues ? this.labelFn.bind(this) : undefined}\n        data={this.isRTL?d.toReversed():d}\n        height={100}\n        alignment='start'\n        style={props.customcolors?{\n          data: {\n            fill: ({ datum }) => this.state.colors[datum.x] ?? this.state.colors[datum.x % this.state.colors.length]\n          }\n        }:{}}\n        cornerRadius={{topLeft: this.styles.bar.borderTopLeftRadius, topRight: this.styles.bar.borderTopRightRadius, bottomLeft: this.styles.bar.borderBottomLeftRadius, bottomRight: this.styles.bar.borderBottomRightRadius}}\n        events={[{\n          target: 'data',\n          eventHandlers: Platform.OS == \"web\" ? {\n            onClick: this.onSelect.bind(this)\n          }:{\n            onPress: this.onSelect.bind(this)\n          }\n        }]}\n        {...(props.barwidth ? { barWidth: props.barwidth } : {})} />\n    });\n  }\n\nonSelect(event: any, data: any){\n  if (!this.viewRef.current) return;\n  this.viewRef.current.measureInWindow((chartX: number, chartY: number) => {\n  let value = data.data[data.index].y;\n  let label = this.state.xaxisDatakeyArr[data.datum.x];\n  let selectedItem = this.props.dataset[data.index];\n  const nativeEvent = event.nativeEvent;\n  let tooltipX = nativeEvent.pageX - chartX;\n  let tooltipY = nativeEvent.pageY - chartY;\n    let selectedChartItem = [{series: 0, x: data.index, y: value,_dataObj: selectedItem},data.index];\n    this.updateState({\n      tooltipXaxis: label,\n      tooltipYaxis: value,\n      isTooltipOpen: true,\n      selectedItem: {...selectedItem, index: data.index},\n      tooltipXPosition: tooltipX - this.state.tooltipoffsetx, \n      tooltipYPosition: tooltipY - this.state.tooltipoffsety\n    } as WmBarChartState)\n  this.invokeEventCallback('onSelect', [event.nativeEvent, this.proxy, selectedItem, selectedChartItem ]);\n  });\n}\n\n  renderWidget(props: WmBarChartProps) {\n    this.invokeEventCallback('onBeforerender', [this.proxy, null]);\n    if (!this.state.data.length) {\n      return null;\n    }\n    let mindomain={x: this.props.xdomain === 'Min' ? this.state.chartMinX: undefined, y: this.props.ydomain === 'Min' ? this.state.chartMinY: undefined};\n    return (<View\n      {...getAccessibilityProps(AccessibilityWidgetType.LINECHART, props)}\n      style={this.styles.root}\n      onLayout={this.onViewLayoutChange.bind(this)}\n    >\n      <View>\n          <View style={{flexDirection: 'row', alignItems: 'center'}}>\n            {props.iconclass ? (<WmIcon iconclass={props.iconclass} styles={this.styles.icon}></WmIcon>) : null }\n            <Text style={this.styles.title}>{props.title}</Text>\n          </View>\n          <Text style={this.styles.subHeading}>{props.subheading}</Text>\n        </View>\n      <View ref={this.viewRef}>\n      {this.getTooltip()}\n      <VictoryChart theme={this.state.theme}\n                          height={(this.styles.root.height) as number}\n                          width={this.state.chartWidth || this.screenWidth}\n                          minDomain={mindomain}\n                          padding={{ top: props.offsettop, bottom: props.offsetbottom, left: props.offsetleft, right: props.offsetright }}>\n      {this.getLegendView()}\n      {this.getXaxis()}\n      {this.getYAxis()}\n      {\n        props.viewtype === 'Stacked' ? <VictoryStack colorScale={this.state.colors}>\n          {\n            this.getBarChart(props)\n          }\n        </VictoryStack> : <VictoryGroup colorScale={this.state.colors}  offset={10} >\n          {\n            this.getBarChart(props)   \n          }\n        </VictoryGroup>\n      }\n    </VictoryChart></View></View>);\n  }\n}\n", "wavemaker-rn-runtime/src/components/chart/bar-chart/bar-chart.props.ts": "import BaseChartComponentProps from \"@wavemaker/app-rn-runtime/components/chart/basechart.props\";\n\nexport default class WmBarChartProps extends BaseChartComponentProps {\n  horizontal?: boolean = true;\n  viewtype: string = 'Grouped';\n  onSelect?: any;\n  barwidth?: number;\n}\n", "wavemaker-rn-runtime/src/components/chart/column-chart/column-chart.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { DEFAULT_CLASS as BASE_CHART_DEFAULT_CLASS } from '../basechart.styles';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmColumnChartStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-column-chart';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    addStyle(DEFAULT_CLASS, BASE_CHART_DEFAULT_CLASS, {\n        skeleton: {\n            root: {\n                height: 200\n            }\n        } as WmSkeletonStyles\n    });\n});\n", "wavemaker-rn-runtime/src/components/chart/column-chart/column-chart.props.ts": "import WmBarChartProps from \"@wavemaker/app-rn-runtime/components/chart/bar-chart/bar-chart.props\";\n\nexport default class WmColumnChartProps extends WmBarChartProps {\n}\n", "wavemaker-rn-runtime/src/components/chart/column-chart/column-chart.component.tsx": "import React from 'react';\n\nimport WmColumnChartProps from './column-chart.props';\nimport WmBarChart, {WmBarChartState} from \"@wavemaker/app-rn-runtime/components/chart/bar-chart/bar-chart.component\";\n\nexport class WmColumnChartState extends WmBarChartState {}\n\nexport default class WmColumnChart extends WmBarChart {\n\n  constructor(props: WmColumnChartProps) {\n    super(props)\n  }\n}\n", "wavemaker-rn-runtime/src/components/chart/theme/chart.theme.ts": "import { assign } from \"lodash\";\nimport { VictoryThemeDefinition } from \"victory-core\";\nimport ThemeVariables from '@wavemaker/app-rn-runtime/styles/theme.variables';\n\nconst themes: {[key:string]: any} = {\n  'Terrestrial': {\n    colors: ['#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78', '#2ca02c', '#98df8a', '#d62728', '#ff9896', '#9467bd', '#c5b0d5', '#8c564b', '#c49c94', '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7', '#bcbd22', '#dbdb8d', '#17becf', '#9edae5', '#ccc'],\n    tooltip: {\n      'backgroundColor': '#de7d28',\n      'textColor': '#FFFFFF'\n    }\n  },\n  'Annabelle': {\n    colors: ['#393b79', '#5254a3', '#6b6ecf', '#9c9ede', '#637939', '#8ca252', '#b5cf6b', '#cedb9c', '#8c6d31', '#bd9e39', '#e7ba52', '#e7cb94', '#843c39', '#ad494a', '#d6616b', '#e7969c', '#7b4173', '#a55194', '#ce6dbd', '#de9ed6', '#ccc'],\n    tooltip: {\n      'backgroundColor': '#2e306f',\n      'textColor': '#FFFFFF'\n    }\n  },\n  'Azure': {\n    colors: ['#3182bd', '#6baed6', '#9ecae1', '#c6dbef', '#e6550d', '#fd8d3c', '#fdae6b', '#fdd0a2', '#31a354', '#74c476', '#a1d99b', '#c7e9c0', '#756bb1', '#9e9ac8', '#bcbddc', '#dadaeb', '#636363', '#969696', '#bdbdbd', '#d9d9d9', '#ccc'],\n    tooltip: {\n      'backgroundColor': '#3182bd',\n      'textColor': '#FFFFFF'\n    }\n  },\n  'Retro': {\n    colors: ['#0ca7a1', '#ffa615', '#334957', '#acc5c2', '#988f90', '#8accc9', '#515151', '#f27861', '#36c9fd', '#794668', '#0f709d', '#0d2738', '#44be78', '#4a1839', '#6a393f', '#557d8b', '#6c331c', '#1c1c1c', '#861500', '#09562a', '#ccc'],\n    tooltip: {\n      'backgroundColor': '#80513a',\n      'textColor': '#FFFFFF'\n    }\n  },\n  'Mellow': {\n    colors: ['#f0dcbf', '#88c877', '#aeb918', '#2e2c23', '#ddddd2', '#dfe956', '#4c963b', '#5d3801', '#e1eec3', '#cd8472', '#fcfab3', '#9a4635', '#9295ad', '#2e3f12', '#565677', '#557d8b', '#4f4d02', '#0c0c1b', '#833324', '#24120e', '#ccc'],\n    tooltip: {\n      'backgroundColor': '#7c9e73',\n      'textColor': '#FFFFFF'\n    }\n  },\n  'Orient': {\n    colors: ['#a80000', '#cc6c3c', '#f0e400', '#000084', '#fccc6c', '#009c6c', '#cc309c', '#78cc00', '#fc84e4', '#48e4fc', '#4878d8', '#186c0c', '#606060', '#a8a8a8', '#000000', '#d7d7d7', '#75a06e', '#190d0b', '#888888', '#694b84', '#ccc'],\n    tooltip: {\n      'backgroundColor': '#c14242',\n      'textColor': '#FFFFFF'\n    }\n  },\n  'GrayScale': {\n    colors: ['#141414', '#353535', '#5b5b5b', '#848484', '#a8a8a8', '#c3c3c3', '#e0e0e0', '#c8c8c8', '#a5a5a5', '#878787', '#656565', '#4e4e4e', '#303030', '#1c1c1c', '#4f4f4f', '#3b3b3b', '#757575', '#606060', '#868686', '#c1c1c1', '#ccc'],\n    tooltip: {\n      'backgroundColor': '#575757',\n      'textColor': '#FFFFFF'\n    }\n  },\n  'Flyer': {\n    colors: ['#3f454c', '#5a646e', '#848778', '#cededf', '#74c4dd', '#0946ed', '#380bb1', '#000ff0', '#f54a23', '#1db262', '#bca3aa', '#ffa500', '#a86b32', '#63a18c', '#56795e', '#934343', '#b75f5f', '#752d2d', '#4e1111', '#920606', '#ccc'],\n    tooltip: {\n      'backgroundColor': '#47637c',\n      'textColor': '#FFFFFF'\n    }\n  },\n  'Luminosity': {\n    colors: ['#FFFFFF', '#e4e4e4', '#00bcd4', '#f0dd2f', '#00aabf', '#018376', '#e91e63', '#39e5d4', '#ff6d6d', '#00ff76', '#ff9800', '#969696', '#ff4200', '#e00000', '#95cbe5', '#5331ff', '#fff4a7', '#e7a800', '#0061e4', '#d5e7ff', '#ccc'],\n    tooltip: {\n      'backgroundColor': '#47637c',\n      'textColor': '#FFFFFF'\n    }\n  }\n}\n\nclass ThemeFactory {\n  getColorsObj(themeName: string) {\n    return themes[themeName].colors;\n  }\n\n  getTheme(name: string, styles?: any, customColors?: Array<string>) {\n    const colorsToUse = this.getColorsObj(name);\n    const [c1, c2, c3, c4, c5, c6, c7, c8, c9, c10] = colorsToUse;\n    let colors = [\n      c1,\n      c2,\n      c3,\n      c4,\n      c5,\n      c6,\n    ];\n    if (customColors && customColors.length) {\n      colors = customColors;\n    }\n    const gridColor = colorsToUse[colorsToUse.length - 1];\n    let textColorFromProps;\n    if (styles) {\n      textColorFromProps = styles.text.color;\n    }\n\n    // Typography\n    const sansSerif = \"'Helvetica Neue', 'Helvetica', sans-serif\";\n    const letterSpacing = \"normal\";\n    const fontSize = 12;\n\n    // Layout\n    const padding = 8;\n    const baseProps = {\n      width: 250,\n      height: 250,\n      padding: 50,\n    };\n\n    // Labels\n    const baseLabelStyles = {\n      fontFamily: sansSerif,\n      fontSize,\n      letterSpacing,\n      padding,\n      fill: textColorFromProps || ThemeVariables.INSTANCE.defaultTextColor,\n      stroke: \"transparent\",\n      strokeWidth: 0,\n    };\n\n    const centeredLabelStyles = assign({ textAnchor: \"middle\" }, baseLabelStyles);\n\n    // Strokes\n    const strokeDasharray = \"10, 5\";\n    const strokeLinecap = \"round\";\n    const strokeLinejoin = \"round\";\n\n    const baseChartTheme: VictoryThemeDefinition = {\n      area: assign(\n        {\n          style: {\n            data: {\n              fill: c1,\n              fillOpacity: 0.9\n            },\n            labels: baseLabelStyles,\n          },\n        },\n        baseProps,\n      ),\n      axis: assign(\n        {\n          style: {\n            axis: {\n              fill: \"transparent\",\n              stroke: textColorFromProps || ThemeVariables.INSTANCE.chartAxisColor,\n              strokeWidth: 2,\n              strokeLinecap,\n              strokeLinejoin,\n            },\n            axisLabel: assign({}, centeredLabelStyles, {\n              padding: 30,\n              stroke: \"transparent\",\n              fontSize: 15\n            }),\n            grid: {\n              fill: \"none\",\n              stroke: gridColor,\n              strokeDasharray,\n              strokeLinecap,\n              strokeLinejoin,\n              pointerEvents: \"painted\",\n            },\n            ticks: {\n              fill: \"transparent\",\n              size: 5,\n              stroke: ThemeVariables.INSTANCE.chartAxisPointColor,\n              strokeWidth: 1,\n              strokeLinecap,\n              strokeLinejoin,\n            },\n            tickLabels: assign({}, baseLabelStyles, {\n              fill: textColorFromProps || ThemeVariables.INSTANCE.defaultTextColor,\n            }),\n          },\n        },\n        baseProps,\n      ),\n      polarDependentAxis: assign({\n        style: {\n          ticks: {\n            fill: \"transparent\",\n            size: 1,\n            stroke: \"transparent\",\n          },\n        },\n      }),\n      bar: assign(\n        {\n          style: {\n            data: {\n              fill: c1,\n              padding,\n              strokeWidth: 0,\n            },\n            labels: baseLabelStyles,\n          },\n        },\n        baseProps,\n      ),\n      boxplot: assign(\n        {\n          style: {\n            max: { padding, stroke: c9, strokeWidth: 1 },\n            maxLabels: assign({}, baseLabelStyles, { padding: 3 }),\n            median: { padding, stroke: c9, strokeWidth: 1 },\n            medianLabels: assign({}, baseLabelStyles, { padding: 3 }),\n            min: { padding, stroke: c9, strokeWidth: 1 },\n            minLabels: assign({}, baseLabelStyles, { padding: 3 }),\n            q1: { padding, fill: c9 },\n            q1Labels: assign({}, baseLabelStyles, { padding: 3 }),\n            q3: { padding, fill: c9 },\n            q3Labels: assign({}, baseLabelStyles, { padding: 3 }),\n          },\n          boxWidth: 20,\n        },\n        baseProps,\n      ),\n      candlestick: assign(\n        {\n          style: {\n            data: {\n              stroke: c9,\n            },\n            labels: assign({}, baseLabelStyles, { padding: 5 }),\n          },\n          candleColors: {\n            positive: \"#ffffff\",\n            negative: c9,\n          },\n        },\n        baseProps,\n      ),\n      chart: baseProps,\n      errorbar: assign(\n        {\n          borderWidth: 8,\n          style: {\n            data: {\n              fill: \"transparent\",\n              opacity: 1,\n              stroke: c9,\n              strokeWidth: 2,\n            },\n            labels: baseLabelStyles,\n          },\n        },\n        baseProps,\n      ),\n      group: assign(\n        {\n          colorScale: colors,\n        },\n        baseProps,\n      ),\n      histogram: assign(\n        {\n          style: {\n            data: {\n              fill: c9,\n              stroke: c10,\n              strokeWidth: 2,\n            },\n            labels: baseLabelStyles,\n          },\n        },\n        baseProps,\n      ),\n      legend: {\n        colorScale: colors,\n        gutter: 10,\n        orientation: \"vertical\",\n        titleOrientation: \"top\",\n        style: {\n          data: {\n            type: \"circle\",\n          },\n          border: { stroke: 'none' }, // ThemeVariables.INSTANCE.chartLegendBorder\n          labels: baseLabelStyles,\n          title: assign({}, baseLabelStyles, { padding: 5, fontSize: ThemeVariables.INSTANCE.heading4FontSize }),\n        },\n      },\n      line: assign(\n        {\n          style: {\n            data: {\n              fill: \"transparent\",\n              opacity: 1,\n              stroke: c1,\n              strokeWidth: 2,\n            },\n            labels: baseLabelStyles,\n          },\n        },\n        baseProps,\n      ),\n      pie: assign(\n        {\n          colorScale: colors,\n          style: {\n            data: {\n              padding,\n              stroke: '#ffffff',\n              strokeWidth: 1,\n            },\n            labels: assign({}, baseLabelStyles, { padding: 20 }),\n          },\n        },\n        baseProps,\n      ),\n      scatter: assign(\n        {\n          style: {\n            data: {\n              fill: c1,\n              opacity: 1,\n              stroke: \"transparent\",\n              strokeWidth: 1,\n            },\n            labels: baseLabelStyles,\n          },\n        },\n        baseProps,\n      ),\n      stack: assign(\n        {\n          colorScale: colors,\n        },\n        baseProps,\n      ),\n      tooltip: {\n        style: assign({}, baseLabelStyles, { padding: 0, pointerEvents: \"none\" }),\n        flyoutStyle: {\n          stroke: c10,\n          strokeWidth: 1,\n          fill: \"#f0f0f0\",\n          pointerEvents: \"none\",\n        },\n        flyoutPadding: 5,\n        cornerRadius: 5,\n        pointerLength: 10,\n      },\n      voronoi: assign(\n        {\n          style: {\n            data: {\n              fill: \"transparent\",\n              stroke: \"transparent\",\n              strokeWidth: 0,\n            },\n            labels: assign({}, baseLabelStyles, {\n              padding: 5,\n              pointerEvents: \"none\",\n            }),\n            flyout: {\n              stroke: c10,\n              strokeWidth: 1,\n              fill: \"#f0f0f0\",\n              pointerEvents: \"none\",\n            },\n          },\n        },\n        baseProps,\n      ),\n    };\n    return baseChartTheme;\n  }\n}\n\nexport default new ThemeFactory();\n", "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.props.ts": "import BaseChartComponentProps from \"@wavemaker/app-rn-runtime/components/chart/basechart.props\";\n\nexport default class WmAreaChartProps extends BaseChartComponentProps {\n    linethickness: number = 2;\n    onSelect?: any;\n}\n", "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.component.tsx": "import React from 'react';\nimport Color from \"color\";\nimport { LayoutChangeEvent, View, Text, Platform } from 'react-native';\nimport { Defs, LinearGradient, Stop, Svg } from 'react-native-svg';\nimport { VictoryArea, VictoryLine, VictoryChart, VictoryLegend, VictoryStack, VictoryScatter, VictoryGroup } from \"victory-native\";\nimport { InterpolationPropType } from 'victory-core';\nimport WmAreaChartProps from './area-chart.props';\nimport { DEFAULT_CLASS, WmAreaChartStyles } from './area-chart.styles';\nimport {\n  BaseChartComponent,\n  BaseChartComponentState\n} from \"@wavemaker/app-rn-runtime/components/chart/basechart.component\";\nimport WmIcon from \"@wavemaker/app-rn-runtime/components/basic/icon/icon.component\";\n\nimport ThemeVariables from '@wavemaker/app-rn-runtime/styles/theme.variables';\nimport { isNil, isNumber } from 'lodash-es';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility'; \nimport { isWebPreviewMode } from '@wavemaker/app-rn-runtime/core/utils';\n\nexport class WmAreaChartState extends BaseChartComponentState<WmAreaChartProps> {\n  chartWidth = 0;\n}\n\nexport default class WmAreaChart extends BaseChartComponent<WmAreaChartProps, WmAreaChartState, WmAreaChartStyles> {\n\n  constructor(props: WmAreaChartProps) {\n    super(props, DEFAULT_CLASS, new WmAreaChartProps(), new WmAreaChartState());\n  }\n\n  onViewLayoutChange = (e: LayoutChangeEvent) => {\n    let viewWidth = e.nativeEvent.layout.width;\n\n    this.handleLayout(e);\n\n    this.updateState({\n      chartWidth: viewWidth\n    } as WmAreaChartState)\n  }\n\n  onSelect(event: any, data: any){\n    if (!this.viewRef.current) return;\n    this.viewRef.current.measureInWindow((chartX: number, chartY: number) => {\n    let value = data.data[data.index].y;\n    let label = this.state.xaxisDatakeyArr[data.datum.x];\n    let selectedItem = this.props.dataset[data.index];\n    const nativeEvent = event.nativeEvent;\n    let tooltipX = nativeEvent.pageX - chartX;\n    let tooltipY = nativeEvent.pageY - chartY;\n    let selectedChartItem = [{series: 0, x: data.index, y: value,_dataObj: selectedItem},data.index];\n    this.updateState({\n      tooltipXaxis: label,\n      tooltipYaxis: value,\n      isTooltipOpen: true,\n      selectedItem: {...selectedItem, index: data.index},\n      tooltipXPosition: tooltipX - this.state.tooltipoffsetx, \n      tooltipYPosition: tooltipY - this.state.tooltipoffsety\n    } as WmAreaChartState)\n    this.invokeEventCallback('onSelect', [event.nativeEvent, this.proxy, selectedItem, selectedChartItem ]);\n  });\n  }\n\n  renderWidget(props: WmAreaChartProps) {\n    this.invokeEventCallback('onBeforerender', [this.proxy, null]);\n    if (!this.state.data?.length) {\n      return null;\n    }\n    let mindomain={\n      x: props.xdomain === 'Min' ? this.state.chartMinX: undefined,\n      y: props.ydomain === 'Min' ? this.state.chartMinY: undefined\n    };\n    const chartName = this.props.name ?? 'nonameAreachart';\n    let gradientStop = '100%';\n    if (isNumber(this.state.chartMaxY) && isNumber(this.state.chartMinY) && this.state.chartMaxY > 0) {\n      gradientStop = (this.state.chartMaxY - this.state.chartMinY) * 100 / this.state.chartMaxY + '%';\n    }\n    return (\n      <View\n        {...getAccessibilityProps(AccessibilityWidgetType.LINECHART, props)}\n        style={this.styles.root}\n        onLayout={this.onViewLayoutChange.bind(this)}\n        key={`${props.title}_area_chart`}\n      >\n        <View>\n          <View style={{flexDirection: 'row', alignItems: 'center'}}>\n            {props.iconclass ? (<WmIcon iconclass={props.iconclass} styles={this.styles.icon}></WmIcon>) : null }\n            <Text style={this.styles.title}>{props.title}</Text>\n          </View>\n          <Text style={this.styles.subHeading}>{props.subheading}</Text>\n        </View>\n        {this.state.chartWidth ? \n        (\n          <View ref={this.viewRef}>\n          {this.getTooltip()}\n          <VictoryChart\n            theme={this.state.theme}\n            height={this.styles.root.height as number}\n            width={this.state.chartWidth || 120}\n            padding={{ top: props.offsettop, bottom: props.offsetbottom, left: props.offsetleft, right: props.offsetright }}\n            minDomain={mindomain}\n          > \n            {this.getLegendView()}\n            {this.getXaxis()}\n            {this.getYAxis()}\n            <VictoryStack>\n            {\n              this.state.data.map((d: any, i: number) => {\n                return <VictoryGroup key={props.name + '_area_group_' + i}>\n                  <Defs>\n                    <LinearGradient id={`${chartName}Gradient${i}`} x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">\n                      <Stop offset=\"0%\" stopColor={Color(this.state.colors[i]).lighten(0.2).rgb().toString()}/>\n                      <Stop offset={gradientStop} stopColor={Color(this.state.colors[i]).lighten(0.6).rgb().toString()}/>\n                    </LinearGradient>\n                  </Defs>\n                  <VictoryArea\n                    interpolation={props.interpolation as InterpolationPropType}\n                    key={props.name + '_' + i}\n                    name={props.name + '_' + i}\n                    style={{\n                      data: {\n                        fill: `url(#${chartName}Gradient${i})`,\n                        stroke: this.state.colors[i],\n                        strokeWidth: props.linethickness,\n                      }\n                    }}\n                    data={this.isRTL?d.toReversed():d}\n                  />\n                    <VictoryScatter\n                      size={5}\n                      key={props.name + '_scatter' + i}\n                      style={{\n                        data: props.highlightpoints ? {fill: this.state.colors[i], opacity: 0.8}:{opacity: 0}\n                      }}        \n                      data={this.isRTL?d.toReversed():d}\n                      events={[{\n                        target: 'data',\n                        eventHandlers: Platform.OS == \"web\" ? {\n                          onClick: this.onSelect.bind(this)\n                        }:{\n                          onPress: this.onSelect.bind(this)\n                        }\n                      }]}\n                      />\n                </VictoryGroup>\n              })\n            }\n            </VictoryStack>\n          </VictoryChart>\n          </View>\n        )\n      : null}\n    </View>);\n  }\n}\n", "wavemaker-rn-runtime/src/components/chart/area-chart/area-chart.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport {BaseChartComponentStyles, DEFAULT_CLASS as BASE_CHART_DEFAULT_CLASS } from '../basechart.styles';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmAreaChartStyles = BaseStyles & BaseChartComponentStyles;\n\nexport const DEFAULT_CLASS = 'app-area-chart';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    addStyle(DEFAULT_CLASS, BASE_CHART_DEFAULT_CLASS, {\n        skeleton: {\n            root: {\n                height: 200\n            }\n        } as WmSkeletonStyles\n    });\n});\n", "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.component.tsx": "import React from 'react';\nimport { Text, View, Platform, LayoutChangeEvent } from 'react-native';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility'; \nimport {\n  VictoryChart,\n  VictoryLine,\n  VictoryScatter,\n  VictoryGroup,\n} from 'victory-native';\n\nimport WmLineChartProps from './line-chart.props';\nimport { DEFAULT_CLASS, WmLineChartStyles } from './line-chart.styles';\nimport {\n  BaseChartComponent,\n  BaseChartComponentState\n} from \"@wavemaker/app-rn-runtime/components/chart/basechart.component\";\nimport ThemeVariables from '@wavemaker/app-rn-runtime/styles/theme.variables';\nimport {InterpolationPropType} from \"victory-core\";\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport { isWebPreviewMode } from '@wavemaker/app-rn-runtime/core/utils';\n\nexport class WmLineChartState extends BaseChartComponentState<WmLineChartProps> {}\n\nexport default class WmLineChart extends BaseChartComponent<WmLineChartProps, WmLineChartState, WmLineChartStyles> {\n\n  constructor(props: WmLineChartProps) {\n    super(props, DEFAULT_CLASS, new WmLineChartProps(), new WmLineChartState());\n  }\n  \n  onSelect(event: any, data: any){\n    if (!this.viewRef.current) return;\n    this.viewRef.current.measureInWindow((chartX: number, chartY: number) => {\n    let value = data.data[data.index].y;\n    let label = this.state.xaxisDatakeyArr[data.datum.x];\n    let selectedItem = this.props.dataset[data.index];\n    const nativeEvent = event.nativeEvent;\n    let tooltipX = nativeEvent.pageX - chartX;\n    let tooltipY = nativeEvent.pageY - chartY;\n    let selectedChartItem = [{series: 0, x: data.index, y: value,_dataObj: selectedItem},data.index];\n    this.updateState({\n      tooltipXaxis: label,\n      tooltipYaxis: value,\n      isTooltipOpen: true,\n      selectedItem: {...selectedItem, index: data.index},\n      tooltipXPosition: tooltipX - this.state.tooltipoffsetx, \n      tooltipYPosition: tooltipY - this.state.tooltipoffsety\n    } as WmLineChartState)\n    this.invokeEventCallback('onSelect', [event.nativeEvent, this.proxy, selectedItem, selectedChartItem ]);\n  });\n  }\n\n\n\n  renderWidget(props: WmLineChartProps) {\n    this.invokeEventCallback('onBeforerender', [this.proxy, null]);\n    if (!this.state.data?.length) {\n      return null;\n    }\n    return (\n    <View style={this.styles.root} {...getAccessibilityProps(AccessibilityWidgetType.LINECHART, props)} onLayout={this.onViewLayoutChange}>\n      <View>\n        <View style={{flexDirection: 'row', alignItems: 'center'}}>\n          { props.iconclass ? (<WmIcon iconclass={props.iconclass} styles={this.styles.icon}></WmIcon>) : null }\n          <Text style={this.styles.title}>{props.title}</Text>\n        </View>\n        <Text style={this.styles.subHeading}>{props.subheading}</Text>\n      </View>\n      <View ref={this.viewRef}>\n      {this.getTooltip()}\n      <VictoryChart\n        theme={this.state.theme}\n        height={(this.styles.root.height) as number}\n        width={this.state.chartWidth || this.screenWidth}\n        padding={{ top: props.offsettop, bottom: props.offsetbottom, left: props.offsetleft, right: props.offsetright }}\n      >\n        {this.getLegendView()}\n        {this.getXaxis()}\n        {this.getYAxis()}\n        {this.state.data.map((d: any, i: number) => {\n          return <VictoryGroup key={props.name + '_line_group_' + i}>\n            <VictoryLine interpolation={props.interpolation as InterpolationPropType}  key={props.name + '_line_' + i}\n              name={props.name + '_' + i}\n              standalone={true}\n              style={{\n                data: {\n                  stroke: (this.state.colors[i] || ThemeVariables.INSTANCE.chartLineColor),\n                  strokeWidth: props.linethickness,\n                }\n              }}       \n              data={this.isRTL?d.toReversed():d}\n            />\n          \n              <VictoryScatter size={5} key={props.name + '_scatter' + i}\n                  style={{\n                    data: (props.highlightpoints || this.state.data.length === 1) ? {fill: this.state.colors[i], opacity: 0.8} : {opacity:0}\n                  }}\n                  data={this.isRTL?d.toReversed():d}\n                  events={[{\n                    target: 'data',\n                    eventHandlers: Platform.OS == \"web\" ? {\n                      onClick: this.onSelect.bind(this)\n                    }:{\n                      onPress: this.onSelect.bind(this)\n                    }\n                  }]}\n              />\n            </VictoryGroup>\n        })}\n      </VictoryChart>\n      </View>\n    </View>);\n  }\n}\n", "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.props.ts": "import BaseChartComponentProps from \"@wavemaker/app-rn-runtime/components/chart/basechart.props\";\nexport default class WmLineChartProps extends BaseChartComponentProps {\n  linethickness: number = 2;\n  onSelect?: any;\n  skeletonheight?: string = null as any;\n  skeletonwidth?: string = null as any;\n}\n", "wavemaker-rn-runtime/src/components/chart/line-chart/line-chart.styles.ts": "import BASE_THEME, {AllStyle} from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport {BaseChartComponentStyles, DEFAULT_CLASS as BASE_CHART_DEFAULT_CLASS } from '../basechart.styles';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmLineChartStyles = BaseStyles & BaseChartComponentStyles;\n\nexport const DEFAULT_CLASS = 'app-line-chart';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    addStyle(DEFAULT_CLASS, BASE_CHART_DEFAULT_CLASS, {\n        skeleton: {\n            root: {\n                height: 200\n            } \n        } as WmSkeletonStyles\n    });\n});\n\n", "wavemaker-rn-runtime/src/components/chart/donut-chart/donut-chart.component.tsx": "import React from 'react';\n\nimport WmDonutChartProps from './donut-chart.props';\nimport WmPieChart from \"@wavemaker/app-rn-runtime/components/chart/pie-chart/pie-chart.component\";\n\n\nexport default class WmDonutChart extends WmPieChart {\n\n  constructor(props: WmDonutChartProps) {\n    super(props);\n  }\n}\n", "wavemaker-rn-runtime/src/components/chart/donut-chart/donut-chart.props.ts": "import WmPieChartProps from \"@wavemaker/app-rn-runtime/components/chart/pie-chart/pie-chart.props\";\n\nexport default class WmDonutChartProps extends WmPieChartProps {\n  donutratio: number = 0.5;\n}\n", "wavemaker-rn-runtime/src/components/chart/donut-chart/donut-chart.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport {BaseChartComponentStyles,  DEFAULT_CLASS as BASE_CHART_DEFAULT_CLASS } from '../basechart.styles';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmDonutChartStyles = BaseStyles & BaseChartComponentStyles;\n\nexport const DEFAULT_CLASS = 'app-donut-chart';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    addStyle(DEFAULT_CLASS, BASE_CHART_DEFAULT_CLASS, {\n        skeleton: {\n            root: {\n                height: 200\n            }\n        } as WmSkeletonStyles\n    });\n});\n", "wavemaker-rn-runtime/src/components/basic/animatedview.component.tsx": "import React from 'react';\nimport * as Animatable from 'react-native-animatable';\nimport { initializeRegistryWithDefinitions } from 'react-native-animatable';\nimport { View, ViewProps, ViewStyle } from 'react-native';\n\nexport default class AnimatedviewProps {\n  entryanimation?: string = null as any;\n  children?: any;\n  duration?: number = null as any;\n  delay?: number = null as any;\n  iterationCount?:any;\n  style?: any;\n  exitanimation?: string = null as any;\n  accessibilityProps?: any;\n  onLayout?: any;\n}\n\nconst AnimationMap: any = {\n  bounce: 'bounce',\n  flash: 'flash',\n  pulse: 'pulse',\n  rotate: 'rotate',\n  rubberBand: 'rubberBand',\n  shake: 'shake',\n  swing: 'swing',\n  tada: 'tada',\n  wobble: 'wobble',\n  bounceIn: 'bounceOut',\n  bounceInDown: 'bounceOutUp',\n  bounceInLeft: 'bounceOutRight',\n  bounceInRight: 'bounceOutLeft',\n  bounceInUp: 'bounceOutDown',\n  fadeIn: 'fadeOut',\n  fadeInDown: 'fadeOutUp',\n  fadeInDownBig: 'fadeOutUpBig',\n  fadeInLeft: 'fadeOutRight',\n  fadeInLeftBig: 'fadeOutRightBig',\n  fadeInRight: 'fadeOutLeft',\n  fadeInRightBig: 'fadeOutLeftBig',\n  fadeInUp: 'fadeOutDown',\n  fadeInUpBig: 'fadeOutDownBig',\n  flipInX: 'flipOutX',\n  flipInY: 'flipOutY',\n  lightSpeedIn: 'lightSpeedOut',\n  slideInDown: 'slideOutUp',\n  slideInLeft: 'slideOutRight',\n  slideInRight: 'slideOutLeft',\n  slideInUp: 'slideOutDown',\n  zoomIn: 'zoomOut',\n  zoomInDown: 'zoomOutUp',\n  zoomInLeft: 'zoomOutRight',\n  zoomInRight: 'zoomOutLeft',\n  zoomInUp: 'zoomOutDown'\n};\n\nconst CustomAnimationMap: any = {\n  flipInY: {\n    0: {\n        transform: [{rotateY: \"0deg\"}]\n    },\n    1: {\n        transform: [{rotateY: \"360deg\"}]\n    }\n  },\n  flipInX: {\n    0: {\n        transform: [{rotateX: \"0deg\"}]\n    },\n    1: {\n        transform: [{rotateX: \"360deg\"}]\n    }\n  },\n  flipOutY: {\n    0: {\n        transform: [{rotateY: \"3600deg\"}]\n    },\n    1: {\n        transform: [{rotateY: \"0deg\"}]\n    }\n  },\n  flipOutX: {\n    0: {\n        transform: [{rotateX: \"360deg\"}]\n    },\n    1: {\n        transform: [{rotateX: \"0deg\"}]\n    }\n  },\n  slideInDown : {\n    from: { translateY: -20 },\n    to: { translateY: 0 }\n  },\n  slideInUp : {\n    from: { translateY: 20 },\n    to: { translateY: 0 }\n  },\n  slideOutUp: {\n    from: { translateY: 0 },\n    to: { translateY: -20 }\n  },\n  slideOutDown : {\n    from: { translateY: 0 },\n    to: { translateY: 20 }\n  },\n  fadeInDown: {\n    from: { opacity: 0, translateY: -20 },\n    to: { opacity: 1, translateY: 0 }\n  },\n  fadeInUp: {\n    from: { opacity: 0, translateY: 20 },\n    to: { opacity: 1, translateY: 0 }\n  },\n  fadeOutDown: {\n    from: { opacity: 1, translateY: 0 },\n    to: { opacity: 0, translateY: 20 }\n  },\n  fadeOutUp: {\n    from: { opacity: 1, translateY: 0 },\n    to: { opacity: 0, translateY: -20 }\n  }\n};\n\nexport class Animatedview extends React.Component<AnimatedviewProps> {\n  static defaultProps: AnimatedviewProps = {\n    duration: 200,\n  };\n\n  private view: Animatable.View = null as any;\n\n  constructor(props: AnimatedviewProps) {\n    super(props);\n    initializeRegistryWithDefinitions(CustomAnimationMap);\n  }\n\n  triggerEntry() {\n    return (this as any).view.animate(this.props.entryanimation, this.props.duration).then((endState: any) => endState.finished)\n  }\n\n  triggerExit() {\n    if (!this.view) {\n      return;\n    }\n    if (this.props.exitanimation) {\n      return (this as any).view.animate(this.props.exitanimation, this.props.duration, 1).then((endState: any) => endState.finished)\n    } else {\n      return (this as any).view.animate(AnimationMap[this.props.entryanimation || ''], this.props.duration, 1).then((endState: any) => endState.finished)\n    }\n  }\n\n  // @ts-ignore\n  handleViewRef = (ref: Animatable.View<ViewProps, ViewStyle>) => this.view = ref;\n\n  render() {\n    return this.props.entryanimation ? (\n     <Animatable.View\n        animation={this.props.entryanimation}\n        duration={this.props.duration}\n        delay={this.props.delay}\n        useNativeDriver={true}\n        style={this.props.style}\n        iterationCount={this.props.iterationCount}\n        ref={this.handleViewRef}\n        {...this.props.accessibilityProps}\n        testID=\"animatableView\"\n        onLayout={(e)=>this.props.onLayout && this.props.onLayout(e, this.view)}\n       >\n        {this.props.children}\n      </Animatable.View>\n    ): (<View \n          style={this.props.style} \n          {...this.props.accessibilityProps} \n          testID=\"non_animatableView\"\n          ref={this.handleViewRef}\n          onLayout={(e)=>this.props.onLayout && this.props.onLayout(e, this.view)}\n       >\n          {this.props.children}\n        </View>\n      );\n  }\n}\n", "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.styles.ts": "import Color from 'color';\nimport BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type WmProgressCircleStyles = BaseStyles & {\n    progressCircle : AllStyle,\n    progressValue: AllStyle,\n    subTitle: AllStyle\n};\n\nexport const DEFAULT_CLASS = 'app-progress-circle';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmProgressCircleStyles = defineStyles({\n        root: {},\n        text: {},\n        progressCircle: {},\n        progressValue: {\n            height: 16,\n        },\n        subTitle: {\n            fontFamily: themeVariables.baseFont,\n            fontSize: 12,\n            color: themeVariables.labelTextMutedColor\n        }\n    } as WmProgressCircleStyles);\n\n    const getStyle = (color: string) => ({\n        progressCircle: {\n            backgroundColor: Color(color).fade(0.8).rgb().toString(),\n            borderColor: color,\n            borderStyle: 'solid',\n            borderWidth: 1\n        },\n        progressValue: {\n            backgroundColor: color\n        }\n    } as WmProgressCircleStyles);\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n    addStyle('app-default-progress-circle', '', getStyle(themeVariables.progressCircleDefaultColor));\n    addStyle('app-success-progress-circle', '', getStyle(themeVariables.progressCircleSuccessColor));\n    addStyle('app-info-progress-circle', '', getStyle(themeVariables.progressCircleInfoColor));\n    addStyle('app-danger-progress-circle', '', getStyle(themeVariables.progressCircleDangerColor));\n    addStyle('app-warning-progress-circle', '', getStyle(themeVariables.progressCircleWarningColor));\n    addStyle('app-progress-circle1', '', {\n        progressCircle: {\n            backgroundColor: themeVariables.transparent\n        },\n        progressValue: {\n            height: 8,\n            //@ts-ignore\n            buttStyle: 'round'\n        }\n    });\n    addStyle('app-progress-circle2', '', {\n        progressCircle: {\n            backgroundColor: themeVariables.defaultColorE\n        },\n        progressValue: {\n            height: 8,\n            //@ts-ignore\n            buttStyle: 'round'\n        }\n    });\n    addStyle('app-progress-circle3', '', {\n        root: {\n            transform: [{rotateY: '180deg'}]\n        },\n        text: {\n            transform: [{rotateY: '180deg'}]\n        },\n        subTitle: {\n            transform: [{rotateY: '180deg'}]\n        },\n        progressCircle: {\n            backgroundColor: themeVariables.defaultColorE\n        },\n        progressValue: {\n            height: 8,\n            //@ts-ignore\n            buttStyle: 'round'\n        }\n    });\n});", "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.component.tsx": "import React from 'react';\nimport { LayoutChangeEvent, View, Text } from 'react-native';\nimport { isNumber } from 'lodash';\nimport { AnimatedCircularProgress } from 'react-native-circular-progress';\nimport { Tappable } from '@wavemaker/app-rn-runtime/core/tappable.component';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility';\n\nimport WmProgressCircleProps from './progress-circle.props';\nimport { DEFAULT_CLASS, WmProgressCircleStyles } from './progress-circle.styles';\n\n\nexport class WmProgressCircleState extends BaseComponentState<WmProgressCircleProps> {\n  radius = 10;\n}\n\nexport default class WmProgressCircle extends BaseComponent<WmProgressCircleProps, WmProgressCircleState, WmProgressCircleStyles> {\n\n  constructor(props: WmProgressCircleProps) {\n    super(props, DEFAULT_CLASS, new WmProgressCircleProps(), new WmProgressCircleState());\n  }\n\n  onLayout(e: LayoutChangeEvent) {\n    const width = e.nativeEvent.layout.width;\n    const height = e.nativeEvent.layout.height;\n    let radius = this.state.radius;\n    if (!width) {\n      radius = height;\n    } else if (!height) {\n      radius = width;\n    } else {\n      radius = Math.min(width, height);\n    }\n    \n    this.handleLayout(e)\n\n    this.updateState({\n      radius: radius\n    } as WmProgressCircleState);\n  }\n\n  renderWidget(props: WmProgressCircleProps) {\n    let value = 0;\n    if (isNumber(props.datavalue) && isNumber(props.minvalue) && isNumber(props.maxvalue)) {\n      value = (+props.datavalue - (+props.minvalue)) / (+props.maxvalue - (+props.minvalue)) * 100;\n    }\n    const styles = this.theme.mergeStyle(this.theme.getStyle(`app-${props.type}-progress-circle`), this.styles);\n    const showText = props.captionplacement !== 'hidden';\n    return (\n    <View style={styles.root} onLayout={this.onLayout.bind(this)} {...getAccessibilityProps(AccessibilityWidgetType.PROGRESSCIRCLE, props)} {...this.getTestPropsForAction('progresscircle')}>\n      {this._background}\n      <Tappable target={this} styles={{root:{width: '100%', height: '100%'}}} disableTouchEffect={this.state.props.disabletoucheffect}>\n        <AnimatedCircularProgress\n          fill={value}\n          width={styles.progressValue.height}\n          backgroundWidth={styles.progressValue.height}\n          rotation={0}\n          tintColor={styles.progressValue.backgroundColor}\n          lineCap={styles.progressValue.buttStyle || \"butt\"}\n          backgroundColor={styles.progressCircle.backgroundColor}\n          size={this.state.radius}>\n            {(fill) => (<View style={{alignItems: 'center'}}>\n                          <Text style={styles.text} {...this.getTestPropsForLabel('title')}>{ showText ? props.title || value : '' }</Text>\n                          {showText && props.subtitle ? (<Text style={styles.subTitle} {...this.getTestPropsForLabel('subtitle')}>{ props.subtitle }</Text>) : null}\n                        </View>)}  \n        </AnimatedCircularProgress>\n      </Tappable>\n    </View>); \n  }\n}\n", "wavemaker-rn-runtime/src/components/basic/progress-circle/progress-circle.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { AccessibilityRole } from 'react-native';\nexport default class WmProgressCircleProps extends BaseProps {\n  type: 'default' | 'success' | 'info' | 'warning' | 'error' = 'default';\n  datavalue: number = 30;\n  minvalue: number = 0;\n  maxvalue: number = 100;\n  captionplacement: string = 'inside';\n  title: string = '';\n  subtitle: string = '';\n  accessibilitylabel?: string = undefined;\n  accessibilityrole?: AccessibilityRole = 'progressbar';\n}", "wavemaker-rn-runtime/src/components/basic/video/video.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { AccessibilityRole } from 'react-native';\nexport default class WmVideoProps extends BaseProps {\n    autoplay = false;\n    controls = false;\n    loop = false;\n    mp4format: string = null as any;\n    muted = false;\n    oggformat: string = null as any;\n    subtitlelang = 'en';\n    subtitlesource: string = null as any;\n    videoposter = 'resources/images/imagelists/default-image.png';\n    showdefaultvideoposter = true;\n    videopreload = 'none';\n    videosupportmessage = 'Your browser does not support the video tag.';\n    webmformat: string = null as any;\n    accessibilitylabel?: string = undefined;\n    hint?: string = undefined;\n    accessibilityrole?: AccessibilityRole;\n    onFullscreenEnter: (() => void) | null = null;\n    onFullscreenExit: (() => void) | null = null;\n    requiresLinearPlayback: boolean = true;\n    isLive: boolean = false;\n    playing: boolean = false;\n    showNowPlayingNotification: boolean = false;\n    allowsPictureInPicture: boolean = false;\n}", "wavemaker-rn-runtime/src/components/basic/video/video.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmSkeletonStyles } from '../skeleton/skeleton.styles';\nimport { WmPictureStyles } from '../picture/picture.styles';\nimport { ViewStyle } from 'react-native';\n\nexport type WmVideoStyles = BaseStyles & {\n    skeleton: WmSkeletonStyles;\n    playIconContainer: ViewStyle;\n};\n\nexport const DEFAULT_CLASS = 'app-video';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles = defineStyles<WmVideoStyles>({\n        root: {\n            height: 300,\n            width : \"100%\"\n        },\n        text: {},\n        skeleton: {\n            root: {\n                height: 300,\n                width : \"100%\"    \n            }\n        } as any as WmSkeletonStyles,\n        playIconContainer: {\n            position: 'absolute', \n            top: 0, \n            bottom: 0, \n            left: 0, \n            right: 0, \n            height: '100%', \n            width: '100%',\n            backgroundColor: 'rgba(0,0,0,0.1)',\n            display: 'flex',\n            justifyContent: 'center',\n            alignItems: 'center'\n} \n    });\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/basic/video/video.component.tsx": "import React from 'react';\nimport { View, Image, TouchableWithoutFeedback, Platform, Text } from 'react-native';\nimport { VideoView, createVideoPlayer } from 'expo-video';\nimport {\n  BaseComponent,\n  BaseComponentState,\n} from '@wavemaker/app-rn-runtime/core/base.component';\nimport WmVideoProps from './video.props';\nimport { DEFAULT_CLASS, WmVideoStyles } from './video.styles';\nimport {\n  AccessibilityWidgetType,\n  getAccessibilityProps,\n} from '@wavemaker/app-rn-runtime/core/accessibility';\nimport { isFullPathUrl } from '@wavemaker/app-rn-runtime/core/utils';\nimport { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\n\nexport class WmVideoState extends BaseComponentState<WmVideoProps> {\n  isVideoReady: boolean = false;\n  playStarted: boolean = false;\n  videoPosterDismissed: boolean = false;\n}\n\nexport default class WmVideo extends BaseComponent<\n  WmVideoProps,\n  WmVideoState,\n  WmVideoStyles\n> {\n  private player: any;\n\n  constructor(props: WmVideoProps) {\n    super(props, DEFAULT_CLASS, new WmVideoProps(), new WmVideoState());\n  }\n\n  getSource(path: string) {\n    if (!path) {\n      return null;\n    }\n    const resource = this.loadAsset && this.loadAsset(path);\n    if (isFullPathUrl(resource as string)) {\n      return {\n        uri: resource as string,\n      };\n    }\n    return resource || {\n      uri: ''\n    };\n  }\n\n  renderVideoPoster(props: WmVideoProps) {\n    const accessibilityImageProps = {...props, \n      accessibilitylabel : `${props.accessibilitylabel}_poster`,\n      hint: `${props.hint}_poster`,\n      accessibilityrole: `${props.accessibilityrole}_poster`,\n    }\n    return (\n      <TouchableWithoutFeedback onPress={() => this.player.play()}>\n        <Image\n          {...this.getTestProps('video_poster')}\n          style={{\n            position: 'absolute',\n            top: 0,\n            bottom: 0,\n            left: 0,\n            right: 0,\n            width: '100%',\n            height: '100%',\n          }}\n          resizeMode={'cover'}\n          source={this.getSource(props.videoposter) as any}\n          {...getAccessibilityProps(AccessibilityWidgetType.PICTURE, accessibilityImageProps)}\n        />\n      </TouchableWithoutFeedback>\n    );\n  }\n\n\n  public renderSkeleton(props: WmVideoProps): React.ReactNode {\n    return createSkeleton(this.theme, this.styles.skeleton, {\n      ...this.styles.root,\n    });\n  }\n\n  public playingStatusChange(isPlaying: boolean) {\n    if (!this.state.playStarted) {\n      this.updateState({\n        playStarted: this.state.props.autoplay || isPlaying,\n      } as WmVideoState);\n    }\n  }\n\n  playerReadyStatusChange(statusObj: any) {\n    const videoReady = statusObj.status === 'readyToPlay'\n    if (this.state.props.autoplay && videoReady) {\n        this.player.play();\n    }\n    this.updateState({\n      isVideoReady: videoReady,\n    } as WmVideoState);\n  }\n\n  initializeProps(){\n    const {\n      loop,\n      muted,\n      showNowPlayingNotification,\n    } = this.state.props\n\n    this.player.muted = muted; \n    this.player.loop = loop; \n    this.player.showNowPlayingNotification = showNowPlayingNotification; \n  }\n\n  componentDidMount(): void {\n    super.componentDidMount();\n    const { mp4format, webmformat, autoplay } = this.state.props;\n    const videoSource = this.getSource(mp4format || webmformat) ;\n\n    this.player = createVideoPlayer(videoSource);\n    this.player.addListener(\n      'playingChange',\n      this.playingStatusChange.bind(this)\n    );\n    this.player.addListener(\n      'statusChange',\n      this.playerReadyStatusChange.bind(this)\n    ); \n    this.initializeProps()\n  }\n\n  onPlayIconTap() {\n    this.updateState({\n      videoPosterDismissed: true\n    } as WmVideoState)\n    this.player.play()\n  }\n\n  componentWillUnmount(): void {\n    super.componentWillUnmount();\n    this.player.removeListener('playingChange', this.playingStatusChange);\n    this.player.removeListener('statusChange', this.playerReadyStatusChange);\n    this.player.release();\n  }\n\n  renderWidget(props: WmVideoProps) {\n    const {\n      allowsPictureInPicture,\n      videoposter,\n      onFullscreenEnter,\n      onFullscreenExit,\n      requiresLinearPlayback,\n      showdefaultvideoposter\n    } = props;\n\n    const { playStarted } = this.state;\n    const isPlaying = playStarted || this.state.props.autoplay;\n    const showOverlay = !showdefaultvideoposter && !this.state.videoPosterDismissed\n\n    return (\n      <View \n        style={this.styles.root}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        {this._background}\n        <VideoView\n          {...getAccessibilityProps(AccessibilityWidgetType.VIDEO, props)}\n          style={{ width: '100%', height: '100%', flex: 1 }}\n          player={this.player}\n          nativeControls={props.controls || showOverlay}\n          contentFit={'contain'}\n          testID={this.getTestId('video')}\n          allowsPictureInPicture={allowsPictureInPicture}\n          onFullscreenEnter={onFullscreenEnter}\n          onFullscreenExit={onFullscreenExit}\n          requiresLinearPlayback={requiresLinearPlayback}\n        />\n        {!isPlaying && videoposter && showdefaultvideoposter ? (\n          this.renderVideoPoster(props)\n        ) : (\n          <></>\n        )}\n        {\n          !isPlaying && !showdefaultvideoposter && !this.state.videoPosterDismissed ? (\n            <View style={this.styles.playIconContainer}>\n              <TouchableWithoutFeedback style={{width: 80, height: 80 }} onPress={this.onPlayIconTap.bind(this)}>\n                {Platform.OS === 'android' ? <Image\n                {...this.getTestProps('video_play_button')}\n                style={{\n                  width: 80, \n                  height: 80,\n                }}\n                resizeMode={'contain'}\n                source={this.getSource('resources/images/imagelists/play.png') as any}\n              /> : <Text style={{ fontSize: 80, fontWeight: 'bold', color: 'white'}} >\u25b6</Text> } \n              </TouchableWithoutFeedback>\n            </View>            \n          ) : (\n            <></>\n          )\n        }\n      </View>\n    );\n  }\n}", "wavemaker-rn-runtime/src/components/basic/tooltip/tooltip.props.ts": "import { BaseProps } from \"@wavemaker/app-rn-runtime/core/base.component\";\nimport { ReactElement } from \"react\";\nimport { TextStyle, ViewStyle } from \"react-native\";\n\nexport type TooltipDirection = 'up' | 'down' | 'left' | 'right';\n\nexport default class WmTooltipProps extends BaseProps {\n  showTooltip?: boolean = false;\n  text: string | number = \"\";\n  tooltipStyle?: any;\n  tooltipLabelStyle?: TextStyle | TextStyle[];\n  tooltipTriangleStyle?: ViewStyle | ViewStyle[];\n  direction?: TooltipDirection = \"up\";\n  children?: ReactElement;\n};\n", "wavemaker-rn-runtime/src/components/basic/tooltip/tooltip.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { ViewStyle } from 'react-native';\n\nexport type WmTooltipStyles = BaseStyles & {\n  tooltip: ViewStyle;\n  triangle: ViewStyle;\n};\n\nexport const DEFAULT_CLASS = 'app-tooltip';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmTooltipStyles = defineStyles({\n    root: {\n      position: 'relative',\n    },\n    text: {\n      fontSize: 16\n    },\n    tooltip: {\n      position: 'absolute',\n      left: -30,\n      minWidth: 60,\n      minHeight: 25,\n      paddingHorizontal: 10,\n      borderRadius: 20,\n      backgroundColor: 'lightblue',\n      justifyContent: 'center',\n      alignItems: 'center',\n  \n      // * shadow\n      shadowColor: '#000',\n      shadowOffset: {\n        width: 0,\n        height: 1,\n      },\n      shadowOpacity: 0.22,\n      shadowRadius: 2.22,\n  \n      elevation: 3,\n    },\n    triangle: {\n      position: 'absolute',\n      width: 0,\n      height: 0,\n      backgroundColor: 'transparent',\n      borderStyle: 'solid',\n      borderLeftWidth: 8,\n      borderRightWidth: 8,\n      borderBottomWidth: 12,\n      borderLeftColor: 'transparent',\n      borderRightColor: 'transparent',\n      borderBottomColor: 'lightblue',\n      overflow: 'hidden',\n    },\n  })\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/basic/tooltip/tooltip.component.tsx": "import React from 'react';\nimport { Animated, Text, View } from \"react-native\";\nimport { BaseComponent, BaseComponentState } from \"@wavemaker/app-rn-runtime/core/base.component\";\nimport WmTooltipProps from \"./tooltip.props\";\nimport { DEFAULT_CLASS, WmTooltipStyles } from \"./tooltip.styles\";\n\n// * default tooltip direction - up\nconst directionConfig = {\n  up: { rotate: '180deg', styles: {top: -60}, triangleStyles: {bottom: -10} },\n  down: { rotate: '0deg', styles: {bottom: -40}, triangleStyles: {top: -10} },\n  left: { rotate: '90deg', styles: {left: -40}, triangleStyles: {right: -10} },\n  right: { rotate: '-90deg', styles: {right: -40}, triangleStyles: {left: -10} },\n};\n\nexport class WmTooltipState extends BaseComponentState<WmTooltipProps> {}\n\nexport default class WmTooltip extends BaseComponent<WmTooltipProps, WmTooltipState, WmTooltipStyles> {\n  constructor(props: WmTooltipProps) {\n    super(props, DEFAULT_CLASS, new WmTooltipProps());\n  }\n  \n  renderWidget(props: WmTooltipProps) {\n    return (\n      <View \n        style={this.styles.root}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n      {props.showTooltip ? (\n        <Animated.View\n          style={[\n            this.styles.tooltip,\n            props.direction\n              ? { ...directionConfig[props.direction].styles }\n              : { top: -60 },\n            props.tooltipStyle,\n          ]}\n        >\n          <Text style={[props.tooltipLabelStyle]}>{props.text}</Text>\n          <View\n            style={[\n              this.styles.triangle,\n              {\n                transform: [\n                  {\n                    rotate: props.direction\n                      ? directionConfig[props.direction].rotate\n                      : '180deg',\n                  },\n                ],\n              },\n              props.direction\n                ? { ...directionConfig[props.direction].triangleStyles }\n                : { bottom: -10 },\n              props.tooltipTriangleStyle,\n              { borderBottomColor: props.tooltipStyle?.backgroundColor || this.styles.tooltip.backgroundColor }\n            ]}\n          />\n        </Animated.View>\n      ) : null}\n      {props.children}\n    </View>\n    )\n  }\n};\n", "wavemaker-rn-runtime/src/components/basic/buttongroup/buttongroup.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmButtongroupProps extends BaseProps {\n  children?: any;\n  vertical: boolean = null as any;\n  skeletonheight?: string = null as any;\n  skeletonwidth?: string = null as any;\n}\n", "wavemaker-rn-runtime/src/components/basic/buttongroup/buttongroup.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmButtonStyles } from '../button/button.styles';\nimport { WmSkeletonStyles } from '../skeleton/skeleton.styles';\n\nexport type WmButtongroupStyles = BaseStyles & {\n  skeleton: WmSkeletonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-buttongroup';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmButtongroupStyles = defineStyles({\n      root: {\n        flexDirection: 'row',\n        alignSelf: 'flex-start',\n        alignItems: 'center',\n        borderRadius: 100,\n        borderWidth: 1,\n        borderStyle: 'solid',\n        borderColor: themeVariables.buttonGrpBorderColor,\n        backgroundColor: themeVariables.buttonGrpBgColor,\n        overflow: 'hidden'\n      }, \n      text: {},\n      skeleton: {\n        root : {\n          width: '100%',\n          height: 48,\n          borderRadius: 4,\n          borderColor: themeVariables.buttonGrpBorderColor\n        }\n      } as any as WmSkeletonStyles\n  });\n\n\n  addStyle('btn-group-child', '', {\n    root: {\n      borderTopWidth: 0,\n      borderBottomWidth: 0,\n      borderLeftWidth: 1,\n      borderRightWidth: 0,\n      borderRadius: 0,\n      backgroundColor: 'transparent',\n      flex: 1,\n      borderColor: themeVariables.buttonGrpBorderColor,\n    },\n  } as WmButtonStyles);\n  addStyle('btn-group-first-child', '', {\n    root: {\n      borderLeftWidth: 0,\n      borderTopLeftRadius: 28,\n      borderBottomLeftRadius: 28,\n      backgroundColor: 'transparent',\n      borderColor: themeVariables.buttonGrpBorderColor\n    }\n  } as WmButtonStyles);\n  addStyle('btn-group-last-child', '', {\n    root: {\n      borderRightWidth: 0,\n      borderTopRightRadius: 28,\n      borderBottomRightRadius: 28,\n      backgroundColor: 'transparent',\n      borderColor: themeVariables.buttonGrpBorderColor\n    }\n  } as WmButtonStyles);\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n});\n", "wavemaker-rn-runtime/src/components/basic/buttongroup/buttongroup.component.tsx": "import React from 'react';\nimport { DimensionValue, View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmButtongroupProps from './buttongroup.props';\nimport { DEFAULT_CLASS, WmButtongroupStyles } from './buttongroup.styles';\nimport WmSkeleton, { createSkeleton } from '../skeleton/skeleton.component';\n\nexport class WmButtongroupState extends BaseComponentState<WmButtongroupProps> {}\n\nexport default class WmButtongroup extends BaseComponent<WmButtongroupProps, WmButtongroupState, WmButtongroupStyles> {\n\n  constructor(props: WmButtongroupProps) {\n    super(props, DEFAULT_CLASS, new WmButtongroupProps());\n  }\n\n  public renderSkeleton(props: WmButtongroupProps){\n    return createSkeleton(this.theme, this.styles.skeleton, {\n      ...this.styles.root,\n      width: (this.props.skeletonwidth || this.styles.root.width) as DimensionValue,\n      height: (this.props.skeletonheight || this.styles.root.height) as DimensionValue\n    });\n  }\n\n  renderWidget(props: WmButtongroupProps) {\n    return (\n      <View \n        style={[this.styles.root, {flexDirection: props.vertical ? 'column': 'row'}]}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        {this._background}\n        {props.children}\n      </View>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.styles.ts": "import BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { TextStyle, ViewStyle } from 'react-native';\n\nexport type WmSkeletonStyles = BaseStyles & {\n    animatedView: AllStyle;\n    gradient: AllStyle;\n    gradientForeground: ViewStyle;\n    text: TextStyle\n};\n\nexport const DEFAULT_CLASS = 'app-skeleton';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles = defineStyles<WmSkeletonStyles>({\n        root: {\n            backgroundColor: themeVariables.skeletonBgColor,\n            overflow: 'hidden',\n        },\n        text: {},\n        animatedView: {\n            flex: 1,\n            width: 60,\n            backgroundColor: themeVariables.skeletonAnimatedBgColor,\n            height: '100%',\n            marginTop: -10,\n            marginBottom: -10,\n            padding: 0\n        },\n        gradient: {\n            width: '100%',\n            padding: 0,\n            margin: 0,\n            height: '100%',\n            shadowColor: themeVariables.skeletonGradientShadowColor,\n            shadowOffset: { width: 0, height: 10 },\n            elevation: 5,\n            shadowOpacity: 0.4,\n            opacity: 0.6,\n            backgroundColor: themeVariables.skeletonGradientBgColor\n        },\n        gradientForeground: {\n            backgroundColor: themeVariables.skeletonGradientForegroundColor\n        },\n\n    });\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\nexport default class WmSkeletonProps extends BaseProps {\n    children?: React.ReactNode | null = null;\n}", "wavemaker-rn-runtime/src/components/basic/skeleton/skeleton.component.tsx": "import React from 'react';\nimport { View, Animated, Easing, StyleSheet, LayoutChangeEvent, ColorValue, ViewStyle } from 'react-native';\nimport { LinearGradient } from 'expo-linear-gradient';\n\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { AllStyle, Theme } from '@wavemaker/app-rn-runtime/styles/theme';\n\nimport WmSkeletonProps from './skeleton.props';\nimport { DEFAULT_CLASS, WmSkeletonStyles } from './skeleton.styles';\nimport { isUndefined } from 'lodash-es';\n\nexport class WmSkeletonState extends BaseComponentState<WmSkeletonProps> {\n  layout = {\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0,\n  };\n  animate = false;\n}\n\ntype WrapperStyle = AllStyle | any\n\nclass AnimationRunner {\n  private time: number = 1000;\n  public speed = 1;\n  private counter = 0;\n  private animationValue = new Animated.Value(0.2);\n\n  public run() {\n    if (this.counter == 0) {\n      return;\n    }\n    Animated.timing(this.animationValue, {\n      duration: this.time * this.speed,\n      toValue: 1,\n      useNativeDriver: true,\n      easing: Easing.linear,\n    }).start((event) => {\n      if (event.finished) {\n        this.animationValue.setValue(0)\n        this.run();\n      }\n    });\n  }\n\n  public start() {\n    this.counter++;\n    if (this.counter == 1) {\n      this.run();\n    }\n  }\n\n  public stop() {\n    this.counter = Math.max(--this.counter, 0);\n  }\n\n  public getValue() {\n    return this.animationValue;\n  }\n}\n\nexport default class WmSkeleton extends BaseComponent<WmSkeletonProps, WmSkeletonState, WmSkeletonStyles> {\n\n  private skeletonloaderRef: any = null;\n  private animationRunner = new AnimationRunner();\n\n  constructor(props: WmSkeletonProps) {\n    super(props, DEFAULT_CLASS, new WmSkeletonProps(), new WmSkeletonState());\n  }\n\n  componentDidMount(): void {\n    super.componentDidMount();\n    this.animationRunner.start();\n  }\n\n  componentWillUnmount(): void {\n    super.componentWillUnmount();\n    this.animationRunner.stop();\n  }\n\n  onLayoutChange = (event: LayoutChangeEvent) => {\n    this.skeletonloaderRef?.measure((x: number, y: number, width: number, height: number, px: number, py: number) => {\n      let layout = {\n        left: px,\n        top: py,\n        width: width,\n        height: height,\n      };\n      this.setState({\n        layout: {\n          ...layout as any\n        }, animate: true\n      });\n    });\n  }\n\n  renderWidget(props: WmSkeletonProps) {\n    let outpuRange = [-this.state.layout.width-this.state.layout.left, this.state.layout.width + this.state.layout.height];\n    let deg = -20;\n    let translateX = this.animationRunner.getValue().interpolate({\n      inputRange: [0, 1],\n      outputRange: [-50, 400]\n    });\n    return (\n      <View ref={(ref) => { this.skeletonloaderRef = ref; }} onLayout={this.onLayoutChange}\n        style={this.styles.root} >\n        {props.children}\n        {this.state.animate ?\n          <Animated.View\n            style={[\n              StyleSheet.absoluteFill,\n              this.styles.animatedView,\n              { \n                transform: [\n                  { translateX },\n                  { rotate: deg + 'deg' }\n                ]\n              }]}>\n            <LinearGradient\n              start={{ x: 0, y: 0 }}\n              end={{ x: 1, y: 0 }}\n              colors={[this.styles.gradientForeground.backgroundColor?.toString() as string,\n              this.styles.gradient.backgroundColor?.toString() as string,\n              this.styles.gradientForeground.backgroundColor?.toString() as string]}\n              locations={[0, 0.5, 1]}\n              style={[this.styles.gradient, {backgroundColor: this.styles.animatedView.backgroundColor}]} />\n          </Animated.View> : null}\n      </View>);\n  }\n}\n\nexport const createSkeleton = (theme: Theme, skeletonStyles: WmSkeletonStyles, wrapper: WrapperStyle, children?: React.ReactNode) => {\n  const style = {} as ViewStyle;\n  const addStyleProp = (propName: any) => {\n    if (!isUndefined((wrapper as any)[propName])) {\n      (style as any)[propName] = (wrapper as any)[propName];\n    }\n  };\n  addStyleProp('width');\n  addStyleProp('height');\n  addStyleProp('borderRadius');\n  addStyleProp('borderRadius');\n  addStyleProp('marginTop');\n  addStyleProp('marginBottom');\n  addStyleProp('marginLeft');\n  addStyleProp('marginRight');\n  return(<WmSkeleton styles={theme.mergeStyle(skeletonStyles, {root: style})} children={children}/>);\n};\n", "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { AccessibilityRole } from 'react-native';\nexport default class WmProgressBarProps extends BaseProps {\n  type: 'default' | 'success' | 'info' | 'warning' | 'error' = 'default';\n  datavalue: number = 30;\n  minvalue: number = 0;\n  maxvalue: number = 100;\n  accessibilitylabel?: string = undefined;\n  accessibilityrole?: AccessibilityRole = 'progressbar';\n}", "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { ProgressBar } from 'react-native-paper';\nimport { LinearGradient as ExpoLinearGradient } from 'expo-linear-gradient';\nimport { Tappable } from '@wavemaker/app-rn-runtime/core/tappable.component';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility';\n\nimport WmProgressBarProps from './progress-bar.props';\nimport { DEFAULT_CLASS, WmProgressBarStyles } from './progress-bar.styles';\nimport { parseProgressBarLinearGradient } from '@wavemaker/app-rn-runtime/core/utils';\n\nexport class WmProgressBarState extends BaseComponentState<WmProgressBarProps> {}\n\nexport default class WmProgressBar extends BaseComponent<WmProgressBarProps, WmProgressBarState, WmProgressBarStyles> {\n\n  constructor(props: WmProgressBarProps) {\n    super(props, DEFAULT_CLASS, new WmProgressBarProps());\n  }\n\n  renderWidget(props: WmProgressBarProps) {\n    let value = (props.datavalue - props.minvalue) / (props.maxvalue - props.minvalue);\n    const styles = this.theme.mergeStyle(this.theme.getStyle(`app-${props.type}-progress-bar`), this.styles);\n    const {hasLinearGradient, color1, color2, start, end} = parseProgressBarLinearGradient(styles?.root?.progressBar?.backgroundColor as string);\n    const gradientColors: [string, string, ...string[]] = [color1, color2];\n    const valuePercent = `${Math.round(value * 100)}%`;\n\n    return (\n    <View \n      style={styles.root}\n      onLayout={(event) => this.handleLayout(event)}\n    >\n      {this._background}\n      <Tappable target={this} styles={{root:{width: '100%', height: '100%'}}} disableTouchEffect={this.state.props.disabletoucheffect}>\n        <ProgressBar\n          {...this.getTestPropsForAction('progressbar')}\n          {...getAccessibilityProps(AccessibilityWidgetType.PROGRESSBAR, props)}\n          animatedValue={value}\n          color={styles.progressValue.color}\n          style={[styles.progressBar, {height: styles.root.height || styles.progressBar.height}]}></ProgressBar>\n          {hasLinearGradient ? (\n            <ExpoLinearGradient\n              colors={gradientColors}\n              start={start}\n              end={end}\n              style={[\n                {\n                  width: valuePercent as any,\n                  height: styles.root.height || styles.progressBar.height,\n                  position: 'absolute',\n                  borderRadius: styles?.progressBar?.borderRadius || 0,\n                },\n              ]}\n            />\n          ) : (\n            <></>\n          )}\n      </Tappable>\n    </View>); \n  }\n\n}", "wavemaker-rn-runtime/src/components/basic/progress-bar/progress-bar.styles.ts": "import Color from 'color';\nimport BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { Platform } from 'react-native';\n\nexport type WmProgressBarStyles = BaseStyles & {\n    progressBar : AllStyle,\n    progressValue: AllStyle\n};\n\nexport const DEFAULT_CLASS = 'app-progress-bar';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmProgressBarStyles = defineStyles({\n        root: {},\n        text: {},\n        progressBar: {\n            height: 4\n        },\n        progressValue: {}\n    });\n\n    const getStyle = (color: string) => ({\n        progressBar: {\n            backgroundColor: Color(color).alpha(0.2).rgb().toString()\n        },\n        progressValue: {\n            color: color\n        }\n    } as WmProgressBarStyles);\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n    addStyle('app-default-progress-bar', '', getStyle(themeVariables.progressBarDefaultColor));\n    addStyle('app-success-progress-bar', '', getStyle(themeVariables.progressBarSuccessColor));\n    addStyle('app-info-progress-bar', '', getStyle(themeVariables.progressBarInfoColor));\n    addStyle('app-danger-progress-bar', '', getStyle(themeVariables.progressBarDangerColor));\n    addStyle('app-warning-progress-bar', '', getStyle(themeVariables.progressBarWarningColor));\n});", "wavemaker-rn-runtime/src/components/basic/picture/picture.props.ts": "import { AccessibilityRole, ImageResizeMode } from 'react-native';\nimport { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmPictureProps extends BaseProps {\n  animation?: string = null as any;\n  animationdelay?: number = null as any;\n  picturesource?: string = null as any;\n  pictureplaceholder?: string = null as any;\n  shape?: string = null as any;\n  isSvg?: string = null as any;\n  resizemode?: ImageResizeMode = 'stretch' as any;\n  skeletonheight?: string = null as any;\n  skeletonwidth?: string = null as any;\n  accessibilitylabel?: string = undefined;\n  hint?: string = undefined;\n  accessibilityrole?: AccessibilityRole = 'image';\n  fastload?: boolean = false;\n  aspectratio?: string | number | null = null;\n}\n", "wavemaker-rn-runtime/src/components/basic/picture/picture.component.tsx": "import React from 'react';\nimport {  DimensionValue, Image, LayoutChangeEvent, View } from 'react-native';\nimport {Image as EXPOImage} from 'expo-image';\nimport { isNumber } from 'lodash-es';\nimport { Tappable } from '@wavemaker/app-rn-runtime/core/tappable.component';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport ImageSizeEstimator from '@wavemaker/app-rn-runtime/core/imageSizeEstimator';\nimport { isFullPathUrl } from '@wavemaker/app-rn-runtime/core/utils';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility';\n\nimport WmPictureProps from './picture.props';\nimport { DEFAULT_CLASS, WmPictureStyles } from './picture.styles';\nimport { Animatedview } from '@wavemaker/app-rn-runtime/components/basic/animatedview.component';\nimport WmSkeleton, { createSkeleton } from '../skeleton/skeleton.component';\n\nexport class WmPictureState extends BaseComponentState<WmPictureProps> {\n  naturalImageWidth: number = 0;\n  naturalImageHeight: number = 0;\n  imageWidth: number = 0;\n  imageHeight: number = 0;\n  originalContainerWidth: number = 0;\n  originalContainerHeight: number = 0;\n}\n\nexport default class WmPicture extends BaseComponent<WmPictureProps, WmPictureState, WmPictureStyles> {\n\n  private _pictureSource = null as any;\n  private _picturePlaceHolder = null as any;\n\n  // The below property will be used to track and remove the calculateImageSize listenrs of individual picturesource\n  private _cleanupTracker = {} as any\n\n  constructor(props: WmPictureProps) {\n    super(props, DEFAULT_CLASS, new WmPictureProps());\n  }\n\n  loadImage(image: string | undefined) {\n    if (!image || !this.loadAsset) {\n      return null;\n    }\n    const imageSrc = this.loadAsset(image) as any;\n    if (imageSrc && typeof imageSrc === 'object' && typeof imageSrc.default === 'function') {\n      return null;\n    }\n    // if(this.state.props.aspectratio) {\n    //   return imageSrc;\n    // }\n    if (isNumber(imageSrc)) {\n      const {width, height} = Image.resolveAssetSource(imageSrc);\n      this.updateState({\n        naturalImageWidth: width,\n        naturalImageHeight: height\n      } as WmPictureState);\n    } else if (imageSrc !== null) {\n      const cancel = ImageSizeEstimator.getSize(imageSrc, (width: number, height: number) => {\n        this.updateState({\n          naturalImageWidth: width,\n          naturalImageHeight: height\n        } as WmPictureState);\n        this.cleanup.splice(this.cleanup.indexOf(cancel), 1);\n      });\n      if(this.props.picturesource && this._cleanupTracker[this.props.picturesource]) {\n        this._cleanupTracker[this.props.picturesource].push(cancel)\n      } else if(this.props.picturesource && !this._cleanupTracker[this.props.picturesource]) {\n        this._cleanupTracker[this.props.picturesource] = [];\n        this._cleanupTracker[this.props.picturesource].push(cancel)\n      }\n      this.cleanup.push(cancel);\n    }\n    return imageSrc;\n  }\n\n    // Check if the image source prop is changed from previous update to remove all listeners\n  componentDidUpdate(prevProps: Readonly<WmPictureProps>, prevState: Readonly<WmPictureState>, snapshot?: any): void {\n    if(this.state.props.picturesource !== prevProps.picturesource) {\n      if(prevProps.picturesource && this._cleanupTracker[prevProps.picturesource]) {\n        this._cleanupTracker[prevProps.picturesource].forEach((func: any) => {\n          func();\n        });  \n        this._cleanupTracker[prevProps.picturesource] = []\n        delete this._cleanupTracker[prevProps.picturesource] \n      }\n    }\n    super.componentDidUpdate(prevProps, prevState)\n  }\n\n\n  onPropertyChange(name: string, $new: any, $old: any) {\n    switch(name) {\n      case 'picturesource':\n        this._pictureSource = null;\n      case 'pictureplaceholder':\n        this._picturePlaceHolder = null;\n        break;\n    }\n  }\n\n  onViewLayoutChange = (e: LayoutChangeEvent) => {\n    let imageWidth = e.nativeEvent.layout.width;\n    let imageHeight = e.nativeEvent.layout.height;\n    if (!imageWidth && !imageHeight) {\n      return;\n    }\n    if (!this.styles?.root.height\n        || (typeof this.styles?.root.height === 'string'\n          && !this.styles?.root.height.includes('%'))) {\n        imageHeight = 0;\n    }\n    if(this.state.props.aspectratio && !imageHeight && imageWidth) {\n      imageHeight = imageWidth / parseFloat(this.state.props.aspectratio as string)\n    } else if (this.state.props.aspectratio && !imageWidth && imageHeight) {\n      imageWidth = imageWidth * parseFloat(this.state.props.aspectratio as string)\n    } else if (imageWidth && !imageHeight) {\n      imageHeight = imageWidth * this.state.naturalImageHeight / this.state.naturalImageWidth;\n    } else if (imageHeight && !imageWidth) {\n      imageWidth = imageHeight * this.state.naturalImageWidth / this.state.naturalImageHeight;\n    }\n    this.updateState({\n      imageWidth: imageWidth,\n      imageHeight: imageHeight,\n      originalContainerWidth: this.styles.root.width ? e.nativeEvent.layout.width : 0,\n      originalContainerHeight: this.styles.root.height ? e.nativeEvent.layout.height: 0\n    } as WmPictureState);\n  };\n\n  createShape(shape: string | undefined, imageWidth?: number | string): WmPictureStyles {\n    if (shape) {\n      switch(shape) {\n        case 'circle':\n          return {\n            picture: {\n              borderRadius: isNumber(imageWidth) ? imageWidth / 2 : 4\n            }\n          } as WmPictureStyles;\n        case 'rounded' :\n          return (this.theme.getStyle('rounded-image') as WmPictureStyles);\n        case 'thumbnail' :\n          return (this.theme.getStyle('thumbnail-image') as WmPictureStyles);\n      }\n    }\n    return {} as WmPictureStyles;\n  }\n\n  getElementToShow(props: WmPictureProps, imgSrc: any, shapeStyles: WmPictureStyles) {\n    let elementToshow, source;\n    if (imgSrc && typeof imgSrc === 'object' && typeof imgSrc?.default === 'function') {\n      let imgStyle : any = {};\n      if (props.resizemode === 'contain') {\n        imgStyle['width'] = '100%';\n        imgStyle['height'] = '100%';\n      }\n      elementToshow = React.createElement(imgSrc?.default, imgStyle);\n    //} else if (!isWebPreviewMode() && props.isSvg) {\n    //  svg from uri\n    //  elementToshow = <SvgUri testID={this.getTestId('picture')} width={this.styles.root.width as NumberProp} height={this.styles.root.height as NumberProp} uri={imgSrc}/>;\n    } else if (isFullPathUrl(imgSrc)) {\n      source = {\n        uri: imgSrc\n      };\n    } else {\n      source = imgSrc;\n    }\n    if (this.state.naturalImageWidth || this.state.props.aspectratio) {\n      elementToshow = (\n        // * INFO: if any issue arises like freezing of application because of \n        // * rendering large number of images, check the cache policy.\n        <EXPOImage\n          cachePolicy='memory-disk' \n          {...this.getTestProps('picture')}\n          style={[this.styles.picture, shapeStyles.picture, (props.fastload || this.state.imageWidth) ? {opacity: 1} : {opacity: 0} ]}\n          contentFit={props.resizemode}\n          source={source}\n          {...getAccessibilityProps(AccessibilityWidgetType.PICTURE, props)}\n        />\n      );\n    }\n    return elementToshow;\n  }\n\n  public renderSkeleton(props: WmPictureProps){\n    const imageWidth = this.state.imageWidth;\n    const imageHeight = this.state.imageHeight;\n    const shapeStyles = this.createShape(this.props.shape, imageWidth);\n    const skeletonWidth = this.props.skeletonwidth || this.styles.root?.width || shapeStyles.root?.width || shapeStyles.picture?.width || imageWidth;\n    const skeletonHeight = this.props.skeletonheight || this.styles.root?.height || shapeStyles.root?.height || shapeStyles.picture?.height || imageHeight;\n    return createSkeleton(this.theme, this.styles.skeleton, {\n      ...this.styles.root,\n      borderRadius:  this.props.shape == 'circle' && this.styles.root?.width ? 25 : shapeStyles.picture?.borderRadius || shapeStyles.root?.borderRadius || this.styles.root?.borderRadius || 4,\n      width: skeletonWidth as DimensionValue,\n      height: skeletonHeight as DimensionValue\n    });\n  }\n\n  showImage = (imageElement: any, props: WmPictureProps) => {\n    return imageElement;\n  }\n\n\n    //TODO: remove the re calculation logic later. Keeping it as an extra safety.  \n    calculateBasedOnaspectratio(): {imageWidth: number, imageHeight: number} | null  {\n      if(this.state.props.aspectratio) {\n        if(this.state.originalContainerWidth) {\n          return {\n            imageHeight: this.state.originalContainerWidth / parseFloat(this.state.props.aspectratio as string),\n            imageWidth: this.state.originalContainerWidth\n          }\n        } else if(this.state.originalContainerHeight) {\n          return {\n            imageHeight: this.state.originalContainerHeight, \n            imageWidth: this.state.originalContainerHeight * parseFloat(this.state.props.aspectratio as string),\n          }\n        }\n      }\n      return null\n    }\n    \n    //TODO: remove the re calculation logic later. Keeping it as an extra safety.  \n    calculateBasedOnNaturalDimensions(): {imageWidth: number, imageHeight: number} | null {\n      // No need to calculate width & height if the user already passign them explicitly from props.  \n      const widthAndHeightExistsInProps = this.styles.root.width && this.styles.root.height\n      if(!this.state.props.aspectratio && !widthAndHeightExistsInProps) {\n        if(this.state.originalContainerWidth) {\n          return {\n            imageHeight: this.state.originalContainerWidth * this.state.naturalImageHeight / this.state.naturalImageWidth,\n            imageWidth: this.state.originalContainerWidth\n          }\n        } else if(this.state.originalContainerHeight) {\n          return {\n            imageHeight: this.state.originalContainerHeight, \n            imageWidth: this.state.originalContainerHeight * this.state.naturalImageWidth / this.state.naturalImageHeight\n          }\n        }\n      }\n      return null\n    }\n  \n\n  renderWidget(props: WmPictureProps) {\n    let imageWidth = this.state.imageWidth;\n    let imageHeight = this.state.imageHeight;\n\n\n    //TODO: remove the re calculation logic later. Keeping it as an extra safety.  \n    const aspectDimensions = this.calculateBasedOnaspectratio();\n    const naturalDimensions = this.calculateBasedOnNaturalDimensions();\n    if(aspectDimensions) {\n      const dimensions = aspectDimensions as {imageWidth: number, imageHeight: number}\n      imageWidth = dimensions.imageWidth;\n      imageHeight = dimensions.imageHeight\n    } else if(naturalDimensions) {\n      const dimensions = naturalDimensions as {imageWidth: number, imageHeight: number}\n      imageHeight = dimensions.imageHeight\n      imageWidth = dimensions.imageWidth\n    }\n    const shapeStyles = this.createShape(props.shape, imageWidth);\n    this._pictureSource =  this._pictureSource || this.loadImage(props.picturesource);\n    this._picturePlaceHolder = props.fastload ? \n      (this._pictureSource || this._picturePlaceHolder || this.loadImage(props.pictureplaceholder)) :\n      (this._picturePlaceHolder || this.loadImage(props.pictureplaceholder));\n    const imgSrc: any = this._pictureSource || this._picturePlaceHolder;\n    let elementToshow;\n    if (imgSrc) {\n      elementToshow = this.getElementToShow(props, imgSrc, shapeStyles);\n    }\n    return imgSrc && (this.state.naturalImageWidth || props.isSvg || props.aspectratio) ? (\n      <View \n      style={[{\n        width: imageWidth,\n        height: imageHeight\n      }, this.styles.root, shapeStyles.root, shapeStyles.picture]}\n      onLayout={(event) => this.handleLayout(event)}\n    >\n        {this._background}\n      <View style={[{overflow: 'hidden', width: '100%',\n        height: '100%'}]} onLayout={this.onViewLayoutChange}>\n        <Tappable\n          disableTouchEffect={this.state.props.disabletoucheffect}\n          {...this.getTestPropsForAction()}\n          rippleColor={this.styles.root.rippleColor}\n          target={this} styles={{width: imageWidth ? null : '100%', height: imageHeight ? null : '100%'}}>\n          <Animatedview entryanimation={props.animation} delay={props.animationdelay} style={[{\n                height: imageHeight,\n                width: imageWidth,\n                borderRadius: shapeStyles.picture?.borderRadius\n              }]}>\n                {this.showImage(elementToshow, props)}\n            </Animatedview>\n          </Tappable>\n        </View>\n      </View>\n    ): null;\n  }\n}\n", "wavemaker-rn-runtime/src/components/basic/picture/picture.styles.ts": "import { ImageStyle, ViewStyle } from 'react-native';\nimport BASE_THEME  from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmSkeletonStyles } from '../skeleton/skeleton.styles';\n\nexport type WmPictureStyles = BaseStyles & {\n  picture: ImageStyle & ViewStyle,\n  skeleton: WmSkeletonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-picture';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmPictureStyles = defineStyles({\n    root: {\n      overflow: 'hidden',\n      width: 270,\n      rippleColor: themeVariables.transparent\n    },\n    text: {},\n    picture: {\n      width: '100%',\n      height: '100%'\n    },\n    skeleton: {\n      root: {\n        width: '100%',\n        height: 128\n      }\n    } as any as WmSkeletonStyles\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n  addStyle('rounded-image', '', {\n    picture: {\n      borderRadius: 6\n    }\n  } as WmPictureStyles);\n  addStyle('thumbnail-image', '', {\n    root: {\n      backgroundColor: themeVariables.pictureThumbBgColor,\n      borderWidth: 1,\n      borderStyle: 'solid',\n      borderColor: themeVariables.pictureThumbBorderColor,\n      borderRadius: 6,\n      paddingTop: 8,\n      paddingBottom: 8,\n      paddingLeft: 8,\n      paddingRight: 8\n    }\n  } as WmPictureStyles);\n});\n", "wavemaker-rn-runtime/src/components/basic/label/label.component.tsx": "import React from 'react';\nimport { DimensionValue, LayoutChangeEvent, Text, View,Platform } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { Tappable } from '@wavemaker/app-rn-runtime/core/tappable.component';\nimport NavigationService, { NavigationServiceConsumer } from '@wavemaker/app-rn-runtime/core/navigation.service';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility';\n\nimport WmLabelProps from './label.props';\nimport { DEFAULT_CLASS, WmLabelStyles } from './label.styles';\nimport { isNil, toString } from 'lodash-es';\nimport { Animatedview } from '@wavemaker/app-rn-runtime/components/basic/animatedview.component';\nimport WmSkeleton, { createSkeleton } from '../skeleton/skeleton.component';\nimport { LinearGradient } from 'expo-linear-gradient';\nimport MaskedView from '@react-native-masked-view/masked-view';\nimport { parseLinearGradient } from '@wavemaker/app-rn-runtime/core/utils';\n\n\ntype PartType = {\n  text?: string,\n  link?: string,\n};\n\nexport class WmLabelState extends BaseComponentState<WmLabelProps> {\n  parts: PartType[] = []\n}\n\nexport default class WmLabel extends BaseComponent<WmLabelProps, WmLabelState, WmLabelStyles> {\n\n  constructor(props: WmLabelProps) {\n    super(props, DEFAULT_CLASS, new WmLabelProps(), new WmLabelState());\n  }\n\n  private getAsterisk() {\n    return <Text style={this.styles.asterisk}>*</Text>;\n  }\n\n  public onPropertyChange(name: string, $new: any, $old: any): void {\n    super.onPropertyChange(name, $new, $old);\n\n    switch (name) {\n      case \"caption\":\n        this.updateState({\n          parts: this.parseCaption(String($new))\n        } as WmLabelState);\n        break;\n    }\n  }\n  private getMultilineSkeleton(width: any, height: any) {\n    const styles = {\n      borderRadius: 4,\n      marginBottom: 10,\n      height: height\n    };\n    return createSkeleton(this.theme, this.styles.skeleton, {\n      ...styles,\n      width: width,\n      height: height\n    });\n  }\n\n  parseCaption(caption: string) {\n    if (!caption) {\n      return [];\n    }\n    caption += '';\n    caption = caption.replace(/\\s*\\(\\s*\\$event,\\s*\\$widget\\s*\\)\\s*/, '');\n    caption = caption.replace(/\\(\\s*\\)/, '(#/__EMPTY__)');\n    const pattern = /\\[([^\\]]+)\\]\\(([^)]*)\\)/g;\n    const linkRegex = /^(((http|https):\\/\\/)|javascript:|#).+$/;\n    const captionSplit = caption.split(pattern);\n\n    let parts = [];\n\n    for (let i = 0; i < captionSplit.length; i++) {\n      const isLink = linkRegex.test(captionSplit[i]);\n      let part: PartType = {};\n\n      const isNextTextALink = linkRegex.test(captionSplit[i + 1]);\n      if (isLink) {\n        part.text = captionSplit[i - 1] ?? '';\n        part.link = captionSplit[i] === '#/__EMPTY__' ? '' : captionSplit[i];\n      } else {\n        part.text = isNextTextALink ? \"\" : captionSplit[i];\n      };\n      if (part.text || part.link) {\n        parts.push(part);\n      }\n    }\n\n    return parts;\n  }\n\n  public renderSkeleton(props: WmLabelProps) {\n\n    let skeletonWidth, skeletonHeight;\n    if (this.props.skeletonwidth == \"0\") {\n      skeletonWidth = 0\n    } else {\n      skeletonWidth = this.props.skeletonwidth || this.styles.root?.width\n    }\n\n    if (this.props.skeletonheight == \"0\") {\n      skeletonHeight = 0\n    } else {\n      skeletonHeight = this.props.skeletonheight || this.styles.root?.height || this.styles.text.fontSize;\n    }\n\n    if (this.props.multilineskeleton) {\n      return (<View style={{\n        width: skeletonWidth as DimensionValue\n      }}>\n        {this.getMultilineSkeleton('100%', skeletonHeight)}\n        {this.getMultilineSkeleton('70%', skeletonHeight)}\n        {this.getMultilineSkeleton('40%', skeletonHeight)}\n      </View>)\n    }\n    else {\n      return createSkeleton(this.theme, this.styles.skeleton, {\n        ...this.styles.root,\n        width: skeletonWidth as DimensionValue,\n        height: skeletonHeight as DimensionValue\n      });\n    }\n  }\n\n  private renderLabelTextContent(navigationService: NavigationService, isHidden: boolean = false, hasLinearGradient: boolean = false) {\n    //gradient text support for web\n    const gradientTextWebStyle = {\n      backgroundImage: (this.styles?.text.color as string),\n      color: 'transparent',\n      backgroundClip: 'text',\n    }\n    const showWebTextGradient = (hasLinearGradient && Platform.OS === 'web');\n\n    // Shared styles\n    const baseStyle = this.styles.text;\n    const hiddenStyle = isHidden ? { opacity: 0 } : {};\n    const gradientStyle = showWebTextGradient ? gradientTextWebStyle : {};\n\n    // Determine if it's a single part\n    const isSinglePart = this.state.parts.length <= 1;\n\n    // Compose final style\n    const combinedTextStyle = isSinglePart\n      ? { ...baseStyle, ...hiddenStyle, ...gradientStyle }\n      : {\n          flexWrap: 'wrap',\n          textAlign: baseStyle.textAlign,\n          ...hiddenStyle,\n          ...gradientStyle,\n        };\n\n\n\n    return (\n      <Text style={combinedTextStyle}\n        {...this.state.parts.length <= 1 ? this.getTestPropsForLabel('caption') : {}}\n        {...getAccessibilityProps(AccessibilityWidgetType.LABEL, this.state.props)}\n        numberOfLines={this.state.props.nooflines} ellipsizeMode=\"tail\">\n        {(this.state.parts?.length === 1 && !(this.state.parts[0].link && this.state.parts[0].text )) ? toString(this.state.props.caption) : this.state.parts?.map((part, index) => {\n          const isLink = !isNil(part.link);\n          return (\n            <Text\n              key={`part_${index}`}\n              style={[\n                this.styles.text,\n                isLink ? this.styles.link.text : null,\n                this.state.props.isValid ? null : { color: 'red' }\n              ]}\n              {...this.getTestPropsForLabel(isLink ? `link_${index}` : `caption_${index}`)}\n              selectable={this.styles.text.userSelect === 'text'}\n              onPress={() => {\n                if (part.link) {\n                  if (part.link.startsWith('http:')\n                    || part.link.startsWith('https:')\n                    || part.link.startsWith('#')) {\n                    navigationService.openUrl(part.link, '_blank');\n                  } else if (part.link.startsWith('javascript:')) {\n                    const eventName = part.link.substring(11);\n                    this.invokeEventCallback(eventName, [null, this.proxy]);\n                  }\n                }\n                this.invokeEventCallback('onTap', [null, this.proxy]);\n              }}\n            // {...getAccessibilityProps(AccessibilityWidgetType.LABEL, props)}\n            >\n              {toString(part.text)}\n            </Text>\n          );\n        })}\n        {this.state.props.required && this.getAsterisk()}\n      </Text>\n    )\n\n  }\n  renderWidget(props: WmLabelProps) {\n    const linkStyles = this.theme.mergeStyle({ text: this.styles.text }, this.styles.link);\n    const { hasLinearGradient, start, end, gradientColors,colorStops } = parseLinearGradient((this.styles?.text.color) as string);\n    \n    \n\n\n    return !isNil(props.caption) ? (\n      <Animatedview\n        entryanimation={props.animation}\n        delay={props.animationdelay}\n        style={this.styles.root}\n        onLayout={(event: LayoutChangeEvent) => this.handleLayout(event)}\n      >\n        {this._background}\n        <NavigationServiceConsumer>\n          {(navigationService: NavigationService) => {\n            return (<Tappable target={this} disableTouchEffect={this.state.props.disabletoucheffect} >\n              {hasLinearGradient ? <MaskedView\n                maskElement={this.renderLabelTextContent(navigationService, false, hasLinearGradient)}\n              >\n                <LinearGradient colors={gradientColors} start={start} end={end}  locations={colorStops.length > 0 ? colorStops : undefined}>\n                  {this.renderLabelTextContent(navigationService, true)}\n                </LinearGradient>\n              </MaskedView> : this.renderLabelTextContent(navigationService)}\n            </Tappable>)\n          }}\n        </NavigationServiceConsumer>\n      </Animatedview>\n    ) : null;\n  }\n}\n", "wavemaker-rn-runtime/src/components/basic/label/label.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { AccessibilityRole } from 'react-native';\nexport default class WmLabelProps extends BaseProps {\n    animation?: string = null as any;\n    animationdelay?: number = null as any;\n    caption?: string = 'Label';\n    required?: boolean = null as any;\n    isValid?: boolean = true;\n    wrap?: boolean = true;\n    nooflines?: any = undefined;\n    skeletonheight?: string = null as any;\n    skeletonwidth?: string = null as any;\n    multilineskeleton?: boolean = false;\n    accessibilitylabel?: string = undefined;\n    hint?: string = undefined;\n    accessibilityrole?: AccessibilityRole = 'text';\n    onTap?: Function = null as any;\n}\n", "wavemaker-rn-runtime/src/components/basic/label/label.styles.ts": "import BASE_THEME, { AllStyle }  from '@wavemaker/app-rn-runtime/styles/theme';\nimport { deepCopy } from '@wavemaker/app-rn-runtime/core/utils';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmSkeletonStyles } from '../skeleton/skeleton.styles';\nimport { WmAnchorStyles } from '../anchor/anchor.styles';\n\nexport type WmLabelStyles = BaseStyles & {\n  asterisk: AllStyle,\n  skeleton: WmSkeletonStyles \n  link: WmAnchorStyles\n};\n\nexport const DEFAULT_CLASS = 'app-label';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmLabelStyles = defineStyles({\n    root: {\n      alignSelf: 'flex-start',\n    },\n    text: {\n        fontSize: 16,\n        color: themeVariables.labelDefaultColor\n      },\n      asterisk: {\n        color: themeVariables.labelAsteriskColor,\n        marginLeft: 2\n      },\n      skeleton: {\n        root:{\n          width: '100%',\n          height: 16,\n          borderRadius: 4,\n        }\n      } as any as WmSkeletonStyles,\n      link: {\n        text: {\n          textDecorationLine: 'underline'\n        }\n      } as WmAnchorStyles\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n  addStyle(DEFAULT_CLASS + '-rtl', '', {\n    root : {\n      flexDirection: 'row',\n      textAlign: 'right'\n    }\n  });\n  const getLabelStyles = (color: string, textColor: string): WmLabelStyles => {\n    return {\n      root: {\n        backgroundColor: color,\n        paddingLeft: 32,\n        paddingTop: 16,\n        paddingRight: 32,\n        paddingBottom: 16,\n        borderRadius: 6\n      },\n      text: {\n        color: textColor,\n        fontWeight: 'bold'\n      }\n    } as WmLabelStyles;\n  };\n\n  addStyle('label-danger', '', getLabelStyles(themeVariables.labelDangerColor, themeVariables.labelDangerContrastColor));\n  addStyle('label-default', '', getLabelStyles(themeVariables.labelDefaultColor, themeVariables.labelDefaultContrastColor));\n  addStyle('label-info', '', getLabelStyles(themeVariables.labelInfoColor, themeVariables.labelInfoContrastColor));\n  addStyle('label-primary', '', getLabelStyles(themeVariables.labelPrimaryColor, themeVariables.labelPrimaryContrastColor));\n  addStyle('label-success', '', getLabelStyles(themeVariables.labelSuccessColor, themeVariables.labelSuccessContrastColor));\n  addStyle('label-warning', '', getLabelStyles(themeVariables.labelWarningColor, themeVariables.labelWarningContrastColor));\n  addStyle('label-test', '', getLabelStyles('yellow', 'red'));\n  addStyle('label-test1', '', getLabelStyles('blue', 'orange'));\n  addStyle('label-test111', '', getLabelStyles('grey', 'red'));\n  addStyle('label-test11112', '', getLabelStyles('green', 'yellow'));\n  addStyle('label-test12311', '', getLabelStyles('violet', 'pink'));\n  addStyle('label-test9', '', getLabelStyles('green', 'blue'));\n\n  const getTextStyles = (color: string) => {\n    return {\n      text: {\n        color: color\n      }\n    } as WmLabelStyles;\n  };\n\n  addStyle('text-danger', '', getTextStyles(themeVariables.labelTextDangerColor));\n  addStyle('text-info', '', getTextStyles(themeVariables.labelTextInfoColor));\n  addStyle('text-primary', '', getTextStyles(themeVariables.labelTextPrimaryColor));\n  addStyle('text-success', '', getTextStyles(themeVariables.labelTextSuccessColor));\n  addStyle('text-warning', '', getTextStyles(themeVariables.labelTextWarningColor));\n  addStyle('text-center', '', {\n    root: {\n      textAlign: 'center'\n    }\n  } as WmLabelStyles);\n  addStyle('text-left', '', {\n    root: {\n      textAlign: 'left'\n    }\n  } as WmLabelStyles);\n  addStyle('text-right', '', {\n    root: {\n      textAlign: 'right'\n    }\n  } as WmLabelStyles);\n\n\n  const getHeadingStyles = (fontSize: number, overrides?: WmLabelStyles) => {\n    return deepCopy({\n      text: {\n        fontWeight: '400',\n        fontSize: fontSize,\n        margin: 4,\n        color: themeVariables.labelHeaderColor\n      }\n    } as WmLabelStyles, overrides);\n  };\n  addStyle('h1', '', getHeadingStyles(themeVariables.heading1FontSize, {text: {fontWeight: 'bold'}} as WmLabelStyles));\n  addStyle('h2', '', getHeadingStyles(themeVariables.heading2FontSize, {text: {fontWeight: '500'}} as WmLabelStyles));\n  addStyle('h3', '', getHeadingStyles(themeVariables.heading3FontSize));\n  addStyle('h4', '', getHeadingStyles(themeVariables.heading4FontSize));\n  addStyle('h5', '', getHeadingStyles(themeVariables.heading5FontSize));\n  addStyle('h6', '', getHeadingStyles(themeVariables.heading6FontSize));\n  addStyle('media-heading', '', {\n    text : {\n      fontSize: 16\n    }\n  } as WmLabelStyles);\n  addStyle('text-muted', '', {\n    text : {\n      color: themeVariables.labelTextMutedColor\n    }\n  } as WmLabelStyles);\n  addStyle('p', '', {\n    text : {\n      fontSize: 12\n    }\n  } as WmLabelStyles);\n});\n", "wavemaker-rn-runtime/src/components/basic/message/message.component.tsx": "import React from 'react';\nimport { View, Text, LayoutChangeEvent } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmMessageProps from './message.props';\nimport { DEFAULT_CLASS, WmMessageStyles } from './message.styles';\nimport WmIcon from '../icon/icon.component';\nimport WmButton from '../button/button.component';\nimport { Animatedview } from '@wavemaker/app-rn-runtime/components/basic/animatedview.component';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility';\n\nexport class WmMessageState extends BaseComponentState<WmMessageProps> {}\n\nconst MESSAGE_ICONS = {\n  'success': 'wm-sl-l sl-check',\n  'warning': 'wm-sl-l sl-alarm-bell',\n  'error': 'fa fa-times-circle',\n  'info': 'wi wi-info',\n  'loading': 'fa fa-spinner fa-spin'\n};\n\nconst DEFAULT_TITLE = {\n  'success': 'Success',\n  'warning': 'Warning',\n  'error': 'Error',\n  'info': 'Info',\n  'loading': 'Processing'\n} as any;\n\nexport default class WmMessage extends BaseComponent<WmMessageProps, WmMessageState, WmMessageStyles> {\n\n  constructor(props: WmMessageProps) {\n    super(props, DEFAULT_CLASS, new WmMessageProps());\n  }\n\n  showMessage() {\n    this.updateState({\n      props: {\n        show: true\n      }\n    } as WmMessageState);\n  }\n\n  hideMessage() {\n    this.updateState({\n      props: {\n        show: false\n      }\n    } as WmMessageState);\n  }\n\n  close = () => {\n    this.updateState({props: {\n      show : false\n    }}, () => this.invokeEventCallback('onClose', [null, this]));\n  }\n\n  renderWidget(props: WmMessageProps) {\n    const styles = this.theme.mergeStyle(this.theme.getStyle(`${props.type}-${props.variant}-message`), this.styles);\n    return (\n    <Animatedview \n      entryanimation={props.animation} \n      delay={props.animationdelay} \n      style={styles.root}\n      onLayout={(event: LayoutChangeEvent) => this.handleLayout(event)}\n    >\n      {this._background}\n      <WmIcon\n        id={this.getTestId('icon')}\n        iconclass={props.type && MESSAGE_ICONS[props.type]}\n        styles={styles.icon}></WmIcon>\n      <View style={styles.message}>\n        <Text {...this.getTestPropsForLabel('title')} style={styles.title} {...getAccessibilityProps(AccessibilityWidgetType.MESSAGE, props)}>{props.title || DEFAULT_TITLE[props.type || '']}</Text>\n        <Text {...this.getTestPropsForLabel('caption')} style={styles.text} {...getAccessibilityProps(AccessibilityWidgetType.MESSAGE, props)}>{props.caption}</Text>\n      </View>\n      {props.hideclose ? null : (\n        <WmButton\n          id={this.getTestId('close')}\n          iconclass={props.closeiconclass || \"wi wi-close\"}\n          styles={styles.closeBtn}\n          onTap={this.close}></WmButton>\n      )}\n    </Animatedview>);\n  }\n}\n", "wavemaker-rn-runtime/src/components/basic/message/message.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { AccessibilityRole } from 'react-native';\nexport default class WmMessageProps extends BaseProps {\n  animation?: string = 'fadeIn';\n  animationdelay?: number = null as any;\n  title?: string = '';\n  variant?: string = 'dark'\n  caption? = 'Message';\n  type?: 'success' | 'warning' | 'error' | 'info' | 'loading' = 'success';\n  hideclose? = false;\n  accessibilitylabel?: string = undefined;\n  hint?: string = undefined;\n  accessibilityrole?: AccessibilityRole = 'alert';\n  onClose?: () => void;\n  closeiconclass?: string = 'wi wi-close';\n}\n", "wavemaker-rn-runtime/src/components/basic/message/message.styles.ts": "import BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmIconStyles } from '@wavemaker/app-rn-runtime/components/basic/icon/icon.styles';\nimport { WmButtonStyles } from '@wavemaker/app-rn-runtime/components/basic/button/button.styles';\nimport { Platform } from 'react-native';\n\nexport type WmMessageStyles = BaseStyles & {\n    message: AllStyle,\n    icon: WmIconStyles\n    closeBtn: WmButtonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-message';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmMessageStyles = defineStyles({\n        root: {\n            flexDirection: 'row',\n            paddingTop: 8,\n            paddingBottom: 8,\n            paddingLeft: 8,\n            paddingRight: 8,\n            borderRadius: 6,\n            alignItems: 'center',\n            borderWidth: 1,\n            borderStyle: 'solid'\n        },\n        message: {\n            flex: 1,\n            flexDirection: 'column',\n            justifyContent: 'flex-start',\n            alignContent: 'center',\n            paddingLeft: 16\n        },\n        title: {\n            fontWeight: 'bold',\n            fontSize: 14,\n            paddingBottom: 4\n        },\n        text: {\n            fontSize: 12\n        },\n        icon: {\n            root: {\n                alignItems: 'flex-start',\n                fontSize: 20\n            }\n        } as WmIconStyles,\n        closeBtn: {\n            root: {\n                borderRadius: 0,\n                paddingLeft: 8,\n                paddingHorizontal: 0,\n                paddingRight: 0,\n                alignSelf: 'center'\n            },\n            icon: {\n                text: {\n                    fontSize: 16\n                }\n            }\n        } as WmButtonStyles\n    }) as WmMessageStyles;\n\n    const getStyle = (bgColor: string, \n        closeBtnColor: string,\n        iconcolor: string,\n        textcolor: string,\n        titleColor: string,\n        borderColor = themeVariables.transparent) => {\n        return {\n            root: {\n                backgroundColor: bgColor,\n                borderColor: borderColor\n            },\n            message: {\n                color: textcolor\n            },\n            title: {\n                color: titleColor\n            },\n            text: {\n                color: textcolor\n            },\n            icon: {\n                root: {\n                    color: iconcolor\n                }\n            } as WmIconStyles,\n            closeBtn: {\n                icon: {\n                    root : {\n                        color: closeBtnColor,\n                    }\n                }\n            } as WmButtonStyles\n        } as WmMessageStyles;\n    };\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n    addStyle(DEFAULT_CLASS + '-rtl', '', Platform.OS==\"web\"?{\n        title:{\n            textAlign:'right',\n        },\n        text:{\n            textAlign:'right',\n        },\n        message:{\n            paddingRight: 16\n        }\n    }:{\n        title:{\n            textAlign:'left',\n        },\n        text:{\n            textAlign:'left',\n        },\n        message:{\n            paddingRight: 16\n        }\n    });\n    addStyle('success-dark-message', '', getStyle(\n        themeVariables.messageSuccessColor,\n        themeVariables.defaultColorF,\n        themeVariables.defaultColorF,\n        themeVariables.defaultColorF,\n        themeVariables.defaultColorF,\n    ));\n    addStyle('error-dark-message', '', getStyle(\n        themeVariables.messageErrorColor,\n        themeVariables.defaultColorF,\n        themeVariables.defaultColorF,\n        themeVariables.defaultColorF,\n        themeVariables.defaultColorF,\n    ));\n    addStyle('warning-dark-message', '', getStyle(\n        themeVariables.messageWarningColor,\n        themeVariables.defaultColorF,\n        themeVariables.defaultColorF,\n        themeVariables.defaultColorF,\n        themeVariables.defaultColorF\n    ));\n    addStyle('info-dark-message', '', getStyle(\n        themeVariables.messageInfoColor,\n        themeVariables.defaultColorF,\n        themeVariables.defaultColorF,\n        themeVariables.defaultColorF,\n        themeVariables.defaultColorF,\n    ));\n    addStyle('loading-dark-message', '', getStyle(\n        themeVariables.messageLoadingColor,\n        themeVariables.defaultColorF,\n        themeVariables.defaultColorF,\n        themeVariables.defaultColorF,\n        themeVariables.defaultColorF,\n    ));\n\n\n    addStyle('success-light-message', '', getStyle(\n        themeVariables.defaultColorF,\n        themeVariables.defaultColor6,\n        themeVariables.messageSuccessColor,\n        themeVariables.defaultColor6,\n        themeVariables.defaultColor1,\n        themeVariables.defaultColorD\n    ));\n    addStyle('error-light-message', '', getStyle(\n        themeVariables.defaultColorF,\n        themeVariables.defaultColor6,\n        themeVariables.messageErrorColor,\n        themeVariables.defaultColor6,\n        themeVariables.defaultColor1,\n        themeVariables.defaultColorD\n    ));\n    addStyle('warning-light-message', '', getStyle(\n        themeVariables.defaultColorF,\n        themeVariables.defaultColor6,\n        themeVariables.messageWarningColor,\n        themeVariables.defaultColor6,\n        themeVariables.defaultColor1,\n        themeVariables.defaultColorD\n    ));\n    addStyle('info-light-message', '', getStyle(\n        themeVariables.defaultColorF,\n        themeVariables.defaultColor6,\n        themeVariables.messageInfoColor,\n        themeVariables.defaultColor6,\n        themeVariables.defaultColor1,\n        themeVariables.defaultColorD\n    ));\n    addStyle('loading-light-message', '', getStyle(\n        themeVariables.defaultColorF,\n        themeVariables.defaultColor6,\n        themeVariables.messageLoadingColor,\n        themeVariables.defaultColor6,\n        themeVariables.defaultColor1,\n        themeVariables.defaultColorD\n    ));\n});", "wavemaker-rn-runtime/src/components/basic/spinner/spinner.styles.ts": "import { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport BASE_THEME, { NamedStyles, AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { WmIconStyles } from '@wavemaker/app-rn-runtime/components/basic/icon/icon.styles';\nimport { WmPictureStyles } from '@wavemaker/app-rn-runtime/components/basic/picture/picture.styles';\n\nexport type WmSpinnerStyles = BaseStyles & {\n  icon: WmIconStyles\n  image: WmPictureStyles\n  lottie: AllStyle\n};\n\nexport const DEFAULT_CLASS = 'app-spinner';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmSpinnerStyles = defineStyles({\n    root: {\n      flexDirection: 'row',\n      justifyContent: 'center',\n      alignItems: 'center'\n    },\n    text: {\n      fontSize: 16,\n      paddingLeft: 8\n    },\n    icon: {\n      text: {\n        fontSize: 48,\n        width: 4,\n        color: themeVariables.spinnerIconColor\n      }\n    } as WmIconStyles,\n    image: {} as WmPictureStyles,\n    lottie: {\n      position: 'absolute',\n      width: 150,\n      height: 150,\n      alignSelf: 'center',\n      justifyContent: 'center'\n    }\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n  addStyle(DEFAULT_CLASS + '-rtl', '', {\n    root : {\n      textAlign: 'right'\n    },\n    text: {\n      paddingRight: 8\n    }\n  });\n});\n", "wavemaker-rn-runtime/src/components/basic/spinner/spinner.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmSpinnerProps extends BaseProps {\n  caption: string = 'Loading...';\n  iconclass?: string = 'fa fa-circle-o-notch fa-spin';\n  iconsize? = 0;\n  image?: string = null as any;\n  imageheight?: string = null as any;\n  imagewidth?: number = 20;\n  lottie?: string = null as any;\n}\n", "wavemaker-rn-runtime/src/components/basic/spinner/spinner.component.tsx": "import React from 'react';\nimport { Text, View, Platform } from 'react-native';\nimport Color from \"color\";\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmSpinnerProps from './spinner.props';\nimport { DEFAULT_CLASS, WmSpinnerStyles } from './spinner.styles';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport WmPicture from '@wavemaker/app-rn-runtime/components/basic/picture/picture.component';\nimport LottieView from 'lottie-react-native';\nimport ThemeVariables from '@wavemaker/app-rn-runtime/styles/theme.variables';\n\nexport class WmSpinnerState extends BaseComponentState<WmSpinnerProps> {\n\n}\n\nexport default class WmSpinner extends BaseComponent<WmSpinnerProps, WmSpinnerState, WmSpinnerStyles> {\n\n  constructor(props: WmSpinnerProps) {\n    super(props, DEFAULT_CLASS, new WmSpinnerProps());\n  }\n\n  private prepareIcon(props: any) {\n    return (<WmIcon\n      id={this.getTestId('icon')}\n      styles={this.styles.icon}\n      iconclass={props.iconclass + ' fa-spin'} iconsize={props.iconsize}></WmIcon>);\n  }\n\n  private prepareImage(props: any) {\n    return (<WmPicture\n        id={this.getTestId('picture')}\n        styles={this.styles.image}\n        picturesource={props.image}></WmPicture>);\n  }\n\n  private recursiveSearch = (obj: any, colors: any) => {\n    obj && Object.keys(obj).forEach(key => {\n        let value = obj[key];\n        let ind = Math.floor(Math.random() * (0 - colors.length ) + colors.length);\n        if (key == \"nm\" && (value.toLowerCase().includes('fill ') || value.toLowerCase().includes('stroke '))) {\n            if (obj[\"c\"] && obj[\"c\"][\"k\"] \n              && (obj[\"c\"][\"k\"].length == 4\n                || (obj[\"c\"][\"k\"].length ==3 \n                  && typeof obj[\"c\"][\"k\"][0] == 'number'))) {\n                obj[\"c\"][\"k\"] = colors[ind];\n            }\n            else {\n                if (obj[\"c\"] && obj[\"c\"][\"k\"]){\n                    for (let shape in obj[\"c\"][\"k\"]) {\n                      if(obj[\"c\"][\"k\"][shape] && obj[\"c\"][\"k\"][shape][\"s\"]){\n                        obj[\"c\"][\"k\"][shape][\"s\"] = colors[ind];\n                      }\n                    }\n                }\n            }\n        } else if (typeof value === 'object') {\n            this.recursiveSearch(value, colors);\n        }\n      });\n      return obj;\n  };\n\n  private toRgbArray(color: Color) {\n    return [\n      color.red()/255,\n      color.green()/255,\n      color.blue()/255,\n      1\n    ]\n  }\n\n  private addClasstoLottie(lottiePath: any) {\n    let primaryColor = Color(ThemeVariables.INSTANCE.primaryColor);\n    let colors = [this.toRgbArray(primaryColor), \n      this.toRgbArray(primaryColor.darken(0.2)), \n      this.toRgbArray(primaryColor.darken(0.4)), \n      this.toRgbArray(primaryColor.darken(0.6)), \n      this.toRgbArray(primaryColor.darken(0.8))];\n    return this.recursiveSearch(lottiePath.json, lottiePath.loader == 'circleSpinner' ? [colors[0]] : colors);\n  }\n\n  private prepareLottie(props: any) {\n    let Lottie = Platform.OS == 'web' ? require('react-lottie-player') : null;\n    Lottie = Lottie?.default || Lottie;\n    return (\n      Platform.OS == 'web' ? <Lottie animationData={this.addClasstoLottie(props.lottie)} loop={true} play={true} style={this.styles.lottie} /> : <LottieView\n        {...this.getTestProps('loader')}\n        source={this.addClasstoLottie(props.lottie)}\n        resizeMode='contain'\n        autoPlay={true}\n        loop={true}\n        style={this.styles.lottie}\n      />\n    )\n  }\n\n  renderWidget(props: WmSpinnerProps) {\n    return (\n      <View \n        style={this.styles.root}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        {this._background}\n        {props.lottie ? this.prepareLottie(props) : props.image ? this.prepareImage(props) : this.prepareIcon(props)}\n        {props.caption ? <Text {...this.getTestPropsForLabel()} style={this.styles.text}>{props.caption}</Text> : null}\n      </View>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/basic/search/search.styles.ts": "import { Platform, TextStyle } from 'react-native';\nimport BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmButtonStyles } from '@wavemaker/app-rn-runtime/components/basic/button/button.styles';\nimport { WmSkeletonStyles } from '../skeleton/skeleton.styles';\n\nexport type WmSearchStyles = BaseStyles & {\n  focusedText: TextStyle,\n  modal: AllStyle;\n  modalContent: AllStyle;\n  searchItem: AllStyle;\n  dropDownContent: AllStyle;\n  searchItemText: AllStyle;\n  clearButton: WmButtonStyles;\n  searchButton: WmButtonStyles;\n  searchInputWrapper: AllStyle;\n  placeholderText: AllStyle;\n  invalid: AllStyle;\n  skeleton: WmSkeletonStyles;\n};\n\nexport const DEFAULT_CLASS = 'app-search';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmSearchStyles = defineStyles({\n      root: {\n        flexDirection: 'row',\n        borderRadius: 28,\n      },\n      text: {\n        minHeight: 56,\n        paddingTop: 8,\n        paddingBottom: 8,\n        paddingLeft: 24,\n        paddingRight: 14,\n        width: '100%',\n        borderWidth: 1,\n        borderRightWidth: 0,\n        borderTopLeftRadius: 28,\n        borderBottomLeftRadius: 28,\n        borderColor: themeVariables.searchBorderColor,\n        backgroundColor: themeVariables.searchBgContainerColor,\n      },\n    invalid: {\n      borderBottomColor: themeVariables.inputInvalidBorderColor,\n    },\n      focusedText : {\n        borderBottomLeftRadius: 28,\n      },\n    modal: {\n      backgroundColor: themeVariables.transparent,\n      height: '100%'\n    },\n    modalContent: {\n      backgroundColor: themeVariables.searchBgContainerColor,\n      borderRadius: 6,\n      position: 'absolute',\n      borderStyle: 'solid',\n      borderColor: themeVariables.searchBorderColor,\n      width: '90%'\n    },\n      dropDownContent: {\n          width: '100%'\n      },\n      searchInputWrapper: {\n        flexDirection: 'row',\n        alignItems: 'center',\n        justifyContent: 'center',\n        flex: 1\n      },\n      clearButton: {\n        root: {\n          marginLeft: -40,\n          padding: 0,\n          width: 36,\n          alignItems: 'center',\n          alignSelf: 'center',\n          justifyContent: 'center',\n          backgroundColor: 'transparent'\n        }\n      } as WmButtonStyles,\n      searchButton: {\n        root: {\n          alignItems: 'center',\n          justifyContent: 'center',\n          borderRadius: 0,\n          borderTopRightRadius: 28,\n          borderBottomRightRadius: 28,\n          backgroundColor: themeVariables.searchButtonColor,\n          height: 56,\n          rippleColor: themeVariables.rippleColor\n        },\n        icon: {\n          icon: {\n            fontSize: 24,\n            color: themeVariables.searchButtonTextColor,\n            marginRight: 4\n          }\n        }\n      } as WmButtonStyles,\n      searchItem: {\n        width: '100%',\n        marginBottom: 4,\n        paddingHorizontal: 16,\n        paddingVertical: 8,\n        borderBottomColor: themeVariables.searchItemBorderColor,\n        flexDirection: 'row',\n        alignItems: 'center',\n        color: themeVariables.searchItemTextColor\n      },\n      searchItemText: {\n        fontSize: 16,\n        paddingLeft: 8,\n        fontFamily: themeVariables.baseFont\n      },\n      dataCompleteItem: {\n          root: {\n            backgroundColor: themeVariables.searchDataCompleteItemBgColor,\n            justifyContent: 'center',\n            padding: 8\n          },\n          text: {\n            fontSize: 12,\n            textDecorationLine: 'none',\n            color: themeVariables.searchItemTextColor\n          }\n      },\n      placeholderText: {\n        color: themeVariables.inputPlaceholderColor\n      },\n      skeleton: {\n        root: {\n          height: 56\n        }\n      } as any as WmSkeletonStyles\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n  addStyle(DEFAULT_CLASS + '-disabled', '', {\n      text : {\n        backgroundColor: themeVariables.inputDisabledBgColor\n      }\n  });\n\n  addStyle(DEFAULT_CLASS + '-rtl', '', Platform.OS=='web' || Platform.OS=='android' ?{\n    text : {\n      textAlign: 'right',\n      borderWidth: 1,\n      borderRightWidth: 1,\n      borderLeftWidth: 0,\n      borderTopLeftRadius: 0,\n      borderBottomLeftRadius: 0,\n      borderTopRightRadius: 28,\n      borderBottomRightRadius: 28,\n    },\n    searchButton: {\n      root: {\n        borderTopRightRadius: 0,\n        borderBottomRightRadius: 0,\n        borderTopLeftRadius: 28,\n        borderBottomLeftRadius: 28,\n      },\n    },\n    clearButton: {\n      root: {\n        left: 0,\n        position: 'absolute',\n        marginLeft: 0\n      }\n    } as WmButtonStyles,\n  }:{\n    text : {\n      textAlign: 'right',\n      borderTopLeftRadius: 0,\n      borderBottomLeftRadius: 0,\n      borderTopRightRadius: 28,\n      borderBottomRightRadius: 28,\n      borderRightWidth: 1,\n      borderLeftWidth: 0,\n    }\n  });\n\n  addStyle('app-autocomplete', '', {\n    text: {\n      borderRightWidth: 1,\n      borderTopRightRadius: 4,\n      borderBottomRightRadius: 4,\n    }\n  } as WmSearchStyles);\n});\n", "wavemaker-rn-runtime/src/components/basic/search/search.component.tsx": "import React from 'react';\nimport { DimensionValue, Keyboard, Platform, Text, TextInput, View } from 'react-native';\nimport { ScrollView } from 'react-native-gesture-handler';\nimport { find, isNull } from 'lodash';\n\nimport WmSearchProps from './search.props';\nimport { DEFAULT_CLASS, WmSearchStyles } from './search.styles';\nimport { ModalConsumer, ModalOptions, ModalService} from \"@wavemaker/app-rn-runtime/core/modal.service\";\nimport { DataProvider } from '@wavemaker/app-rn-runtime/components/basic/search/local-data-provider';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility'; \n\nimport {\n  BaseDatasetComponent,\n  BaseDatasetState\n} from '@wavemaker/app-rn-runtime/components/input/basedataset/basedataset.component';\nimport WmAnchor from '@wavemaker/app-rn-runtime/components/basic/anchor/anchor.component';\nimport WmPicture from '@wavemaker/app-rn-runtime/components/basic/picture/picture.component';\nimport { Tappable } from '@wavemaker/app-rn-runtime/core/tappable.component';\nimport WmButton from '@wavemaker/app-rn-runtime/components/basic/button/button.component';\nimport { get, isArray, isEmpty, isObject } from \"lodash-es\";\nimport { AssetProvider } from '@wavemaker/app-rn-runtime/core/asset.provider';\nimport { createSkeleton } from '../skeleton/skeleton.component';\n\nexport class WmSearchState extends BaseDatasetState<WmSearchProps> {\n  isOpened: boolean = false;\n  modalOptions = {} as ModalOptions;\n  template: string = \"\";\n  position = {\n    top: 0,\n    left: 0\n  } as DropdownPosition;\n  data: any = [];\n}\n\nexport interface DropdownPosition {\n  top?: number;\n  bottom?: number;\n  left?: number;\n  right?: number;\n}\n\nexport default class WmSearch extends BaseDatasetComponent<WmSearchProps, WmSearchState, WmSearchStyles> {\n  view: View = null as any;\n  private prevDatavalue: any;\n  private queryModel: any;\n  private searchInputWidth: any;\n  private isDefaultQuery: boolean = true;\n  private dataProvider: DataProvider;\n  public widgetRef: TextInput | null = null;\n  private cursor: any = 0;\n  private isFocused: boolean = false;\n  private updateRequired: any;\n  private timer: ReturnType<typeof setTimeout> | null = null;\n\n  constructor(props: WmSearchProps) {\n    super(props, DEFAULT_CLASS, new WmSearchProps(), new WmSearchState());\n    this.dataProvider = new DataProvider();\n    if (this.props.datavalue) {\n      this.updateState({\n        props: {\n          query: this.props.datavalue\n        }\n      } as WmSearchState);\n    }\n  }\n\n  computePosition = () => {\n    return new Promise<void>((resolve) => {\n      const position = {} as DropdownPosition;\n      this.view.measure((x = 0, y = 0, width = 0, height = 0, px = 0, py = 0) => {\n        position.left = px;\n        position.top = py + height;\n        this.updateState({ position: position } as WmSearchState, resolve);\n      });\n    });\n  }\n\n  clearSearch() {\n    this.invokeEventCallback('onClear', [null, this]);\n    this.hide();\n    this.updateState({\n      props: {\n        query: ''\n      },\n      dataItems: this.state.dataItems ? this.state.dataItems.map((item: any) => {\n        item.selected = false;\n        return item;\n      }) : []\n    } as WmSearchState, () => {\n      if (this.state.props.type === 'autocomplete') {\n        this.updateFilteredData('');\n      }\n    });\n  }\n\n  updateFilteredData(queryText: string = '') {\n    const props = this.state.props;\n    const filterOptions = {\n      query: queryText,\n      props: props,\n      entries: this.state.dataItems\n    };\n    let filteredData: Array<any> = [];\n    if (props.minchars && queryText.length < props.minchars) {\n      filteredData = [];\n    } else if (props.type === 'search' && !queryText) {\n      filteredData = [];\n    } else {\n      if (this.props.searchkey && this.updateRequired === undefined) {\n        this.updateRequired = this.dataProvider.init(this);\n      }\n      // for service variables invoke the variable with params.\n      if (this.props.searchkey && this.updateRequired && this.state.props.query !== queryText) {\n        this.dataProvider.invokeVariable(this, queryText).then((response: any) => {\n          if (response) {\n            response = response.dataSet;\n            if (isEmpty(response)) {\n              filteredData = [];\n            } else {\n              if (isObject(response) && !isArray(response)) {\n                response = [response];\n              }\n              this.setDataItems(response);\n            }\n          }\n        }, () => {});\n        return;\n      }\n      filteredData = this.dataProvider?.filter(filterOptions);\n    }\n    this.updateState({\n      props: { result: filteredData?.map( (item: any) => item.dataObject), query: queryText },\n      data: filteredData,\n    } as WmSearchState);\n    if (!this.state.isOpened && this.isFocused && filteredData.length > 0 ) {\n      if(this.styles.modal.display !== \"none\"){\n       this.showPopover && this.showPopover();\n      }\n    }\n  }\n\n  focus() {\n    this?.widgetRef?.focus();\n  }\n\n  handleChange = (value: any) => {\n    this.isDefaultQuery = false;\n    const prevQuery = this.state.props.query;\n    if (this.state.props.searchon === 'onsearchiconclick') {\n      this.updateState({\n        props: {result: [], query: value},\n        data: []\n      } as WmSearchState);\n    } else {\n      this.updateFilteredData(value);\n    }\n    if (value === '') {\n      this.validate(value);\n      this.updateState({\n        props: {\n          datavalue: '',\n        },\n      } as WmSearchState);\n      if (value === prevQuery) {\n        return;\n      }\n    }\n    setTimeout(() => {\n      if (this.props.invokeEvent) {\n        this.props.invokeEvent('onChange', [undefined, this.proxy, value, prevQuery]);\n      }\n       this.invokeEventCallback('onChange', [ undefined, this.proxy, value, prevQuery ]);\n    }, 300);\n  }\n\n  onChange(value: any) {\n    if(this.state.props.debouncetime && this.state.props.debouncetime > 0) {\n      if(this.timer !== null) {\n        clearTimeout(this.timer);\n        this.timer = null;\n      }\n\n      this.timer = setTimeout(() => {\n        this.handleChange(value)\n      }, this.state.props.debouncetime)\n    } else {\n      this.handleChange(value);\n    }\n  }\n\n  invokeChange(e: any) {\n    if (Platform.OS === 'web') {\n      this.cursor = e.target.selectionStart;\n      this.updateState({ props: { query: e.target.value } } as WmSearchState);\n    }\n  }\n\n  onFocus() {\n    this.isFocused = true;\n    if (\n      !(this.state.props.disabled || this.state.props.readonly) &&\n      this.state.props.type === 'autocomplete'\n    ) {\n      this.cursor = this.state.props.query?.length || 0;\n      this.updateFilteredData(this.state.props.query || '');\n    }\n    this.invokeEventCallback('onFocus', [null, this]);\n  }\n\n  onBlur() {\n    this.isFocused = false;\n    this.validate(this.state.props.datavalue);\n    if (!this.state.props.datavalue) {\n      setTimeout(() => {\n        this.props.triggerValidation && this.props.triggerValidation();\n      })\n    }\n    this.invokeEventCallback('onBlur', [null, this]);\n  }\n\n  public showPopover = () => {\n    this.computePosition().then(() => {\n      this.updateState({ isOpened: true } as WmSearchState);\n    });\n  };\n\n  public hide = () => {};\n\n  prepareModalOptions(content: React.ReactNode, styles: WmSearchStyles, modalService: ModalService) {\n    const o = this.state.modalOptions;\n    const modalContentSTyles = {\n      width: this.searchInputWidth - 2 * (styles.modalContent.borderWidth || 0),\n      left: (this.state.position.left || 0) + 2 * (styles.modalContent.borderWidth || 0) };\n    o.modalStyle = {...styles.modal};\n    o.contentStyle = {...styles.modalContent, ...this.state.position, ...modalContentSTyles};\n    o.content = content;\n    o.isModal = true;\n    o.onClose = () => {\n      this.hide = () => {};\n      Keyboard.dismiss();\n      if (this.state.isOpened) {\n        this.setState({isOpened: false, modalOptions: {} as ModalOptions} as WmSearchState);\n      }\n    };\n    this.hide = () => {\n      modalService.hideModal(this.state.modalOptions);\n      if (this.state.isOpened) {\n        this.setState({ isOpened: false, modalOptions: {} as ModalOptions } as WmSearchState);\n      }\n    }\n    return o;\n  }\n\n  searchIconPress() {\n    this.isFocused = false;\n    if (this.state.props.searchon === 'onsearchiconclick') {\n      this.updateFilteredData(this.state.props.query);\n    } else {\n      this.onItemSelect(this.state.data[0]);\n    }\n\n    if (get(this.props, 'formfield')) {\n      // @ts-ignore\n      // @ts-ignore\n      this.props.invokeEvent('onSubmit', [null, this]);\n    } else {\n      this.invokeEventCallback('onSubmit', [null, this]);\n    }\n  }\n\n  onItemSelect(item: any) {\n    this.isFocused = false;\n    this.updateState({ props: {\n        query: item.displayexp || item.displayfield\n      }\n    } as WmSearchState);\n    this.validate(item.datafield);\n    this.updateDatavalue(item.datafield);\n    this.prevDatavalue = item.datafield;\n    this.queryModel = item;\n    if (get(this.props, 'formfield')) {\n      // @ts-ignore\n      this.props.invokeEvent('onSelect', [null, this, item.datafield]);\n      // @ts-ignore\n      this.props.invokeEvent('onSubmit', [null, this]);\n    } else {\n      this.invokeEventCallback('onSelect', [null, this, item.datafield]);\n      this.invokeEventCallback('onSubmit', [null, this]);\n    }\n    this.hide();\n  }\n\n  public renderSkeleton(props: WmSearchProps): React.ReactNode {\n  \n    const rootStyle = {\n      ...this.styles.searchInputWrapper, \n      ...this.styles.root, \n      ...this.styles.text\n    }\n\n    return createSkeleton(this.theme, this.styles.skeleton, rootStyle)\n  }\n\n  renderSearchBar() {\n    const props = this.state.props;\n    let opts: any = {};\n    const valueExpr = Platform.OS === 'web' ? 'value' : 'defaultValue';\n    opts[valueExpr] = this.state.props.query || '';\n    return(\n      /*\n       * onLayout function is required.\n       * https://github.com/naoufal/react-native-accordion/pull/19/files\n       */\n      <View style={this.styles.root} ref={ref => {this.view = ref as View}} onLayout={() => {}}>\n        <View style={this.styles.searchInputWrapper}>\n          <TextInput style={[this.styles.text, this.state.isValid ? {} : this.styles.invalid, this.state.isOpened && this.state.dataItems?.length > 0? this.styles.focusedText : null]}\n           ref={ref => {this.widgetRef = ref;\n             // @ts-ignore\n             if (ref && !isNull(ref.selectionStart) && !isNull(ref.selectionEnd)) {\n               // @ts-ignore\n               ref.selectionStart = ref.selectionEnd = this.cursor;\n             }}}\n            {...this.getTestPropsForInput()}\n            {...getAccessibilityProps(AccessibilityWidgetType.SEARCH, props)}\n            placeholderTextColor={this.styles.placeholderText.color as any}\n            placeholder={props.placeholder || 'Search'}\n            autoFocus={props.autofocus}\n            editable={props.disabled || props.readonly ? false : true}\n            onChangeText={this.onChange.bind(this)}\n            onChange={this.invokeChange.bind(this)}\n            onFocus={this.onFocus.bind(this)}\n            onLayout={e => {this.searchInputWidth = e.nativeEvent.layout.width}}\n            onBlur={this.onBlur.bind(this)}\n            {...opts}>\n         </TextInput>\n         {(props.showclear && !(this.state.props.disabled || this.state.props.readonly)) && this.state.props.query ? <WmButton onTap={this.clearSearch.bind(this)}\n                   id={this.getTestId('clear')}\n            styles={this.styles.clearButton} iconclass={props.clearsearchiconclass || 'wi wi-clear'}></WmButton> : null}\n       </View>\n        {props.showSearchIcon && props.type === 'search' ? <WmButton styles={this.styles.searchButton}\n                  id={this.getTestId('search')}\n          iconclass={props.searchiconclass || props.iconclass} onTap={this.searchIconPress.bind(this)}></WmButton> : null}\n      </View>\n    );\n  }\n\n  reset() {\n    if (this.state.props.query) {\n      this.updateState({\n        props: {\n          query: ''\n        }\n      } as WmSearchState);\n    }\n  }\n\n  renderSearchItem(item: any, index: number) {\n    const props = this.state.props;\n    const imageStyles = { root: {height:props.imagewidth, width:props.imagewidth}}\n    return (\n      <Tappable onTap={this.onItemSelect.bind(this, item)} {...this.getTestProps(`action${index}`)} disableTouchEffect={this.state.props.disabletoucheffect}>\n        <View  style={this.styles.searchItem}>\n          {!isEmpty(this.state.template) && this.props.renderitempartial ?\n           this.props.renderitempartial(item.dataObject, index, this.state.template) : (<>\n          <WmPicture id={this.getTestId(`picture${index}`)} styles={imageStyles} name={props.name + '_image'}  picturesource={item.imgSrc}></WmPicture>\n          <Text {...this.getTestPropsForLabel(index + '')} style={this.styles.searchItemText}>{item.displayexp || item.displayfield}</Text>\n          </>)}\n        </View>\n      </Tappable>\n    );\n  }\n\n  updateDefaultQueryModel() {\n    if (this.state.dataItems && this.state.dataItems.length && this.isDefaultQuery) {\n        const selectedItem = find(this.state.dataItems, (item) => item.selected);\n        this.updateState({ props: {\n            query: selectedItem ? (selectedItem.displayexp || selectedItem.displayfield) : ''\n          }\n        } as WmSearchState);\n    }\n  }\n\n  onDataItemsUpdate() {\n    super.onDataItemsUpdate();\n    this.isFocused && this.state.dataItems.length && this.updateFilteredData(this.state.props.query);\n    this.updateDefaultQueryModel();\n  }\n\n  componentDidMount(): void {\n    super.componentDidMount();\n    this.updateDefaultQueryModel();\n  }\n\n  onPropertyChange(name: string, $new: any, $old: any) {\n    switch (name) {\n      case 'dataset':\n        if (!isEmpty($new) && isObject($new) && !isArray($new)) {\n          $new = [$new];\n          this.updateState({\n            props: {\n              dataset: $new\n            }\n          } as WmSearchState);\n        }\n        break;\n    }\n    super.onPropertyChange(name, $new, $old);\n  }\n\n  setTemplate(partialName: any) {\n    this.updateState({ template: partialName} as WmSearchState);\n  }\n\n  renderWidget(props: WmSearchProps) {\n    const result = this.state.data;\n    return (\n      <View\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        {this.renderSearchBar()}\n        {this.state.isOpened ? (\n          <ModalConsumer>\n            {(modalService: ModalService) => {\n              modalService.showModal(this.prepareModalOptions((\n                <ScrollView style={{width: '100%', maxHeight: 200}} contentContainerStyle={this.styles.dropDownContent}>\n                    <AssetProvider value={this.loadAsset}>\n                    {result && result.map((item: any, index: any) => (\n                      <View key={item.key}>\n                        {\n                          (!props.limit) || (props.limit && index+1 <= props.limit) ?\n                            this.renderSearchItem(item, index)\n                            : null\n                        }\n                        {\n                          index === result.length - 1 ?\n                          <WmAnchor caption={props.datacompletemsg} styles={this.styles.dataCompleteItem}></WmAnchor> : null\n                        }\n                      </View>\n                    ))}\n                    </AssetProvider>\n                </ScrollView>\n              ), this.styles, modalService));\n              return null;\n            }}\n          </ModalConsumer>) : null}\n      </View>\n\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/basic/search/local-data-provider.ts": "import { filter, includes, values, isNumber, split, toLower, get, toString, isArray, isObject, isString } from 'lodash';\nimport { BaseComponent } from \"@wavemaker/app-rn-runtime/core/base.component\";\n\nexport class DataProvider {\n  private localDataProvider = new LocalDataProvider();\n\n  // check if the variable is of type service variable and whether update is required.\n  init(self: BaseComponent<any, any, any>) {\n    let response = self.invokeEventCallback('isUpdateRequired', []);\n    return response;\n  }\n\n  // setting the inputFields and invoking the variable\n  invokeVariable(self: BaseComponent<any, any, any>, query: string): Promise<any> {\n    let paramsObj: {[key: string] : any} | null = null;\n    self.props?.searchkey && self.props.searchkey.split(',').forEach((k: string) => {\n      if (!paramsObj) {\n        paramsObj = {};\n      }\n      paramsObj[k] = query\n    });\n    let invokeEvent = get(self.props, 'formfield') ? self.props.invokeEvent : self.invokeEventCallback;\n    if (invokeEvent) {\n      return invokeEvent.call(self, 'onQuerySearch', [paramsObj]);\n    }\n    return Promise.resolve();\n  }\n\n  filter(config: any, cb? : () => void | null) {\n    const props = config.props;\n    if (props.searchkey) {\n      const keys = split(props.searchkey, ',');\n      if (keys.length && cb) {\n        cb();\n        return;\n      }\n    }\n    return this.localDataProvider.filter(config);\n  }\n}\n\nexport class LocalDataProvider {\n\n  private applyFilter(entry: any, queryText: any) {\n    entry = isNumber(entry) ? entry.toString() : entry;\n    return includes(entry, queryText);\n  }\n\n  filter(config: any) {\n    const entries = config.entries;\n    let queryText = config.query;\n    const props = config.props;\n    let filteredData;\n    const casesensitive = false;\n\n    /**\n     * If searchkey is defined, then check for match string against each item in the dataset with item's field name as the searchkey\n     * return the filtered data containing the matching string.\n     */\n    if (props.searchkey) {\n      const keys = split(props.searchkey, ',');\n\n      if (!entries.length) {\n        return [];\n      }\n\n      let entryObj = entries[0];\n      entryObj = entryObj.hasOwnProperty('dataObject') ? entryObj['dataObject'] : entryObj;\n      const entryKeys = Object.keys(entryObj);\n      const hasEntry = keys.find(k => {\n        if (k.includes('.')) {\n          k = split(k, '.')[0]\n        }\n        return entryKeys.includes(k)\n      });\n\n      if (!hasEntry) {\n        // widget bound to query variable, searchkey is query or path params and not the key from the entry obj\n        return entries;\n      }\n\n      filteredData = filter(entries, (item: any) => {\n        return keys.some(key => {\n          let a = get(item.dataObject, key),\n            b = queryText;\n          if (!casesensitive) {\n            a = toLower(toString(a));\n            b = toLower(toString(b));\n          }\n          return this.applyFilter(a, b);\n        });\n      });\n    } else {\n      // local search on data with array of objects.\n      // Iterate over each item and return the filtered data containing the matching string.\n      if (isArray(entries) && isObject(entries[0])) {\n        filteredData = filter(entries, (entry: any) => {\n          let a = isString(entry.dataObject) ? entry.dataObject : values(entry.dataObject).join(' ');\n          if (!casesensitive) {\n            a = toLower(a);\n            queryText = toLower(queryText);\n          }\n          return this.applyFilter(a, queryText);\n        });\n      } else {\n        filteredData = filter(entries, (entry: any) => {\n          if (!casesensitive) {\n            entry = toLower(entry);\n            queryText = toLower(queryText);\n          }\n          return this.applyFilter(entry, queryText);\n        });\n      }\n    }\n    return filteredData;\n\n  }\n}\n", "wavemaker-rn-runtime/src/components/basic/search/search.props.ts": "import BaseDatasetProps from '@wavemaker/app-rn-runtime/components/input/basedataset/basedataset.props';\nimport {BaseComponent} from \"@wavemaker/app-rn-runtime/core/base.component\";\nimport { AccessibilityRole } from 'react-native';\n\nexport default class WmSearchProps extends BaseDatasetProps {\n  autofocus: boolean = false;\n  query?: string = '';\n  searchkey?: any;\n  type: 'search' | 'autocomplete' = 'search';\n  datacompletemsg?: string = 'No more data to load';\n  placeholder?: string = 'Search';\n  limit?: number = null as any;\n  minchars?: number = null as any;\n  imagewidth?: any = 32;\n  imageheight?: any = 32;\n  searchon?: string = 'typing';\n  onSubmit?: any;\n  onChange?: Function = null as any;\n  result?: any;\n  showclear: boolean = false;\n  showSearchIcon: boolean = true; // internal property\n  invokeEvent?: Function;\n  formFieldInstance?: BaseComponent<any, any, any>;\n  accessibilitylabel?: string = undefined;\n  hint?: string = undefined;\n  accessibilityrole?: AccessibilityRole = 'search';\n  renderitempartial?: (item: any, index: number, partialName: string)=> React.ReactNode;\n  skeletonheight?: string = null as any;\n  skeletonwidth?: string = null as any;\n  iconclass?: string = 'wm-sl-l sl-search';\n  clearsearchiconclass?: string = 'wi wi-clear';\n  searchiconclass?: string = undefined;\n  debouncetime?: number = 0;\n}\n", "wavemaker-rn-runtime/src/components/basic/audio/audio.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmSliderStyles } from '../../input/slider/slider.styles';\nimport { WmIconStyles } from '../icon/icon.styles';\nimport Color from 'color';\nimport { WmSkeletonStyles } from '../skeleton/skeleton.styles';\n\nexport type WmAudioStyles = BaseStyles & {\n    playIcon: WmIconStyles\n    pauseIcon: WmIconStyles\n    muteIcon: WmIconStyles\n    unmuteIcon: WmIconStyles\n    slider: WmSliderStyles\n    textSkeleton: WmSkeletonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-audio';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles = defineStyles<WmAudioStyles>({\n        root: {\n            backgroundColor: themeVariables.defaultColorF,\n            flexDirection: 'row',\n            justifyContent: 'space-between',\n            alignItems: 'center',\n            paddingHorizontal: 16,\n            paddingVertical: 8,\n            borderRadius: 64,\n            minWidth: 300\n        },\n        text: {\n            color: themeVariables.defaultColor3,\n            paddingHorizontal: 8\n        },\n        playIcon: {\n            icon: {\n                color: themeVariables.defaultColor3\n            }\n        },\n        pauseIcon: {\n            icon: {\n                color: themeVariables.defaultColor3\n            }\n        },\n        muteIcon: {\n            icon: {\n                color: themeVariables.defaultColor3\n            }\n        },\n        unmuteIcon: {\n            icon: {\n                color: themeVariables.defaultColor3\n            }\n        },\n        slider: {\n            root: {\n                flex: 1\n            },\n            text: {\n                display: 'none'\n            },\n            minimumTrack: {\n                backgroundColor: themeVariables.defaultColor3\n            },\n            maximumTrack: {\n                backgroundColor: Color(themeVariables.defaultColor3).lighten(0.8).rgb().toString()\n            },\n            thumb: {\n                backgroundColor: themeVariables.defaultColor3\n            }\n        } as WmSliderStyles,\n        textSkeleton: {\n            root: {\n                width: 200,\n                height: 16,\n                borderRadius: 4\n            }\n          } as any as WmSkeletonStyles\n    } as WmAudioStyles);\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/basic/audio/audio.component.tsx": "import React from 'react';\nimport { DimensionValue, Platform, Text, View } from 'react-native';\nimport Slider from '@react-native-community/slider';\nimport { isString } from 'lodash-es';\nimport { Audio } from 'expo-av';\nimport { Sound } from 'expo-av/build/Audio';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport WmAudioProps from './audio.props';\nimport { DEFAULT_CLASS, WmAudioStyles } from './audio.styles';\nimport WmIcon from '../icon/icon.component';\nimport { isWebPreviewMode } from '@wavemaker/app-rn-runtime/core/utils';\nimport { createSkeleton } from '../skeleton/skeleton.component';\nimport { WmSkeletonStyles } from '../skeleton/skeleton.styles';\n\nexport class WmAudioState extends BaseComponentState<WmAudioProps> {\n  playing = false;\n  currentTime = 0;\n  totalTime = 0;\n}\n\nexport default class WmAudio extends BaseComponent<WmAudioProps, WmAudioState, WmAudioStyles> {\n\n  private loading = false;\n  private sound: Sound = null as any;\n  private timer: any;\n  private offsetTime = 0;\n\n  constructor(props: WmAudioProps) {\n    super(props, DEFAULT_CLASS, new WmAudioProps(), new WmAudioState());\n  }\n\n  onPropertyChange(name: string, $new: any, $old: any): void {\n      super.onPropertyChange(name, $new, $old);\n      switch(name) {\n        case 'mp3format': {\n          if (this.initialized) {\n            Promise.resolve()\n              .then(() => this.sound?.unloadAsync())\n              .then(() => {\n                this.sound = null as any;\n                this.onSeekChange(0);\n                if (this.state.playing \n                  || this.state.props.autoplay) {\n                  this.play();\n                }\n              });\n          }\n        }\n        break;\n        case 'autoplay':\n          if (this.initialized && $new) {\n            this.play();\n          }\n      }\n  }\n\n  getSource() {\n    const source = this.loadAsset \n      && this.state.props.mp3format\n      && this.loadAsset(this.state.props.mp3format as string);\n    if (isString(source)) {\n      return {\n        uri: source\n      };\n    }\n    return source;\n  }\n\n  addPadding(str: string, maxLen: number,  pad = '0'): string {\n    if (str.length < maxLen) {\n      return this.addPadding(pad + str, maxLen, pad);\n    }\n    return str;\n  }\n\n  formatTime(v: number) {\n    const t = v/60;\n    const mins =  Math.floor(t);\n    const seconds = Math.round((t - mins) * 60);\n    return this.addPadding(mins+ '', 2) + ':' + this.addPadding(seconds+ '', 2);\n  }\n\n  setTimer() {\n    this.cancelTimer();\n    this.timer = setInterval(() => {\n      if (this.state.currentTime >= this.state.totalTime) {\n        if (this.state.props.loop) {\n          this.replay();\n        } else {\n          this.stop();\n        }\n        return;\n      }\n      this.setState({\n        currentTime:  Math.max(this.offsetTime + this.state.currentTime + 1, 0)\n      } as WmAudioState);\n      this.offsetTime = 0;\n    }, 1000);\n  }\n\n  cancelTimer() {\n    clearInterval(this.timer);\n  }\n\n  stop() {\n    this.pause();\n    this.sound?.unloadAsync();\n    this.sound = null as any;\n    this.cancelTimer();\n    this.offsetTime = 0;\n    this.updateState({\n      currentTime: 0\n    } as WmAudioState);\n  }\n\n  replay() {\n    this.updateState({\n      currentTime: 0\n    } as WmAudioState, () => {\n      this.sound.replayAsync();\n    });\n  }\n\n  play() {\n    if (isWebPreviewMode() \n      || this.loading\n      || (this.state.playing && this.sound)) {\n      return;\n    }\n    if (this.sound) {\n      this.sound.playAsync();\n      this.setTimer();\n      this.updateState({\n        playing: true\n      } as WmAudioState);\n    } else {\n      this.loading = true;\n      const source = this.getSource();\n      source && Audio.Sound.createAsync(source, {\n        isMuted: this.state.props.muted\n      })\n        .then((res) => {\n          this.sound = res.sound;\n          this.sound.playAsync();\n          this.sound.getStatusAsync().then((status: any) => {\n            this.updateState({\n              currentTime: 0,\n              totalTime: Math.round(status['durationMillis']/1000)\n            } as WmAudioState, () => this.setTimer());\n          });\n          this.updateState({\n            playing: true\n          } as WmAudioState);\n        }).catch(() => {}).then(() => {\n          this.loading = false;\n        });\n    }\n  }\n\n  pause() {\n    this.cancelTimer();\n    this.sound?.pauseAsync().then(() => {\n      this.updateState({\n        playing: false\n      } as WmAudioState);\n    })\n  }\n\n  mute() {\n    this.sound.setStatusAsync({\n      isMuted: true\n    }).then(() => {\n      this.updateState({\n        props: {\n          muted: true\n        }\n      } as WmAudioState);\n    });\n  }\n\n  unmute() {\n    this.sound.setStatusAsync({\n      isMuted: false\n    }).then(() => {\n      this.updateState({\n        props: {\n          muted: false\n        }\n      } as WmAudioState);\n    });\n  }\n\n  onSeekChange(time: number) {\n    if (time !== this.state.currentTime) {\n      this.offsetTime = time - this.state.currentTime;\n      this.sound?.setPositionAsync(time * 1000);\n    }\n  }\n\n  componentDidMount(): void {\n    super.componentDidMount();\n    //without settimeout, app is crashing with errors\n    setTimeout(() => {\n      if (this.state.props.autoplay) {\n        this.play();\n      }\n    }, 1000);\n  }\n\n  componentWillUnmount(): void {\n    super.componentWillUnmount();\n    this.stop();\n  }\n\n  public renderTextSkeleton(): React.ReactNode {\n      return (\n        createSkeleton(this.theme, {} as WmSkeletonStyles, {\n          ...this.styles.text,\n          ...this.styles.textSkeleton.root\n        })\n      )\n  } \n  renderWidget(props: WmAudioProps) {\n    return props.controls ? (\n      <View \n        style={this.styles.root}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        {this._background}\n        {!this.state.playing ? (<WmIcon \n          id={this.getTestId('play')}\n          name={props.name + \"_play\"}\n          styles={this.styles.playIcon}\n          iconclass=\"wi wi-play-arrow fa-2x\"\n          onTap={() => this.play()}></WmIcon>) : (\n        <WmIcon name={props.name + \"_pause\"}\n          id={this.getTestId('pause')}\n          iconclass=\"wi wi-pause fa-2x\"\n          styles={this.styles.pauseIcon}\n          onTap={() => this.pause()}></WmIcon>)}\n        {\n          this._showSkeleton ? this.renderTextSkeleton() : \n          <>\n            <Text style={this.styles.text}>\n            {`${this.formatTime(this.state.currentTime)} / ${this.formatTime(this.state.totalTime)}`}\n            </Text>\n            <Slider\n            testID={this.getTestId('slider')}\n            step={1}\n            style={{flex: 1}}\n            value={this.state.currentTime}\n            disabled={isWebPreviewMode()}\n            onValueChange={this.onSeekChange.bind(this)}\n            minimumValue={0}\n            inverted={this.isRTL && (Platform.OS==\"android\" || Platform.OS==\"web\")}\n            maximumValue={this.state.totalTime || 1}\n            thumbTintColor={this.styles.slider.thumb.backgroundColor as string}\n            minimumTrackTintColor={this.styles.slider.minimumTrack.backgroundColor as string}\n            maximumTrackTintColor={this.styles.slider.maximumTrack.backgroundColor as string}\n            />\n          </>\n        }\n        {!props.muted ? (<WmIcon name={props.name + \"_mute\"}\n          id={this.getTestId('mute')}\n          iconclass=\"wi wi-volume-up fa-2x\"\n          styles={this.styles.muteIcon}\n          onTap={() => this.mute()}></WmIcon>) :\n        (<WmIcon name={props.name + \"_unmute\"}\n          id={this.getTestId('unmute')}\n          iconclass=\"wi wi-volume-off fa-2x\"\n          styles={this.styles.unmuteIcon}\n          onTap={() => this.unmute()}></WmIcon>)}\n      </View>) : null; \n  }\n}\n", "wavemaker-rn-runtime/src/components/basic/audio/audio.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmAudioProps extends BaseProps {\n    mp3format? = '';\n    controls = false;\n    autoplay = false;\n    loop = false;\n    muted = false;\n}", "wavemaker-rn-runtime/src/components/basic/button/button.component.tsx": "import React from 'react';\nimport { DimensionValue, LayoutChangeEvent, Text, View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { Tappable } from '@wavemaker/app-rn-runtime/core/tappable.component';\nimport { Badge } from 'react-native-paper';\n\nimport WmButtonProps from './button.props';\nimport { DEFAULT_CLASS, WmButtonStyles } from './button.styles';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport { Animatedview } from '@wavemaker/app-rn-runtime/components/basic/animatedview.component';\nimport { createSkeleton } from '../skeleton/skeleton.component';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility';\n\nexport class WmButtonState extends BaseComponentState<WmButtonProps> {\n\n}\n\nexport default class WmButton extends BaseComponent<WmButtonProps, WmButtonState, WmButtonStyles> {\n\n  constructor(props: WmButtonProps) {\n    super(props, DEFAULT_CLASS, new WmButtonProps());\n  }\n\n  private prepareIcon({\n    iconclass,\n    iconurl,\n    hint,\n    name,\n    iconsize,\n    iconheight,\n    iconmargin,\n    iconwidth,\n  }: any) {\n    return iconclass || iconurl\n      ? (<WmIcon\n          id={this.getTestId('icon')}\n          hint={hint}\n          styles={this.styles.icon}\n          name={`${name}_icon`}\n          iconclass={iconclass}\n          iconsize={iconsize}\n          iconurl={iconurl}\n          iconheight={iconheight}\n          iconmargin={iconmargin}\n          iconwidth={iconwidth}\n        />): null;\n  }\n\n  private prepareBadge(props: any) {\n    //@ts-ignore\n    return (<Badge style={this.styles.badge} {...this.getTestProps('badge')}>{props.badgevalue}</Badge>);\n  }\n\n  public renderSkeleton(prop: WmButtonProps) {\n    let skeletonWidth, skeletonHeight;\n    if(this.props.skeletonwidth == \"0\") {\n      skeletonWidth = 0\n    } else {\n      skeletonWidth = this.props.skeletonwidth || this.styles.root?.width\n    }\n\n    if(this.props.skeletonheight == \"0\") {\n      skeletonHeight = 0\n    } else {\n      skeletonHeight = this.props.skeletonheight || this.styles.root?.height;\n    }\n    \n    return createSkeleton(this.theme, this.styles.skeleton, {\n      ...this.styles.root,\n      width: skeletonWidth as DimensionValue,\n      height: skeletonHeight as DimensionValue\n    });\n  }\n\n  renderWidget(props: WmButtonProps) {\n    return (\n      <>\n      <Animatedview entryanimation={props.animation} delay={props.animationdelay}\n        onLayout={(event: LayoutChangeEvent) => this.handleLayout(event)}\n        style={[\n          this.styles.root,\n          {\n            paddingTop: 0,\n            paddingBottom: 0,\n            paddingLeft: 0,\n            paddingRight: 0,\n            overflow: 'hidden',\n            flexDirection: 'column'\n          },\n          this.styles.root.height == \"100%\" ? {flex: 1}:{}\n        ]}\n        // accessibilityProps={{...getAccessibilityProps(\n        //   AccessibilityWidgetType.BUTTON,\n        //   props\n        // )}}\n        >\n        {this._background}\n        <Tappable\n          disableTouchEffect={this.state.props.disabletoucheffect}\n          styles={{\n            paddingTop: this.styles.root.paddingTop,\n            paddingBottom: this.styles.root.paddingBottom,\n            paddingLeft: this.styles.root.paddingLeft,\n            paddingRight: this.styles.root.paddingRight,\n            width: '100%',\n            height: this.styles.root.height ? '100%' : null,\n            justifyContent: 'center',\n          }}\n          rippleColor = {this.styles.root.rippleColor}\n          target={this}\n          {...this.getTestPropsForAction()}\n          accessibilityProps={{...getAccessibilityProps(\n            AccessibilityWidgetType.BUTTON,\n            props\n          )}}>\n          <View\n            style={[\n              this.styles.content,\n              { flexDirection: props.iconposition === 'top' ? 'column' : 'row' }\n            ]}>\n            {props.iconposition === 'top' && this.prepareIcon(props)}\n            {props.iconposition === 'left' && this.prepareIcon(props)}\n            {props.caption ? (\n              <Text\n                style={this.styles.text}\n                {...this.getTestPropsForLabel('caption')}\n                importantForAccessibility={'no'}\n                // accessibilityLabel={`${props.caption}`}\n              >\n                {props.caption}\n              </Text>\n            ) : null}\n            {props.iconposition === 'right' && this.prepareIcon(props)}\n          </View>\n        </Tappable>\n      </Animatedview>\n      {props.badgevalue && this.prepareBadge(props)}\n      </>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/basic/button/button.props.ts": "import {AccessibilityRole} from 'react-native';\nimport { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmButtonProps extends BaseProps {\n    animation?: string = null as any;\n    animationdelay?: number = null as any;\n    caption?: string = null as any;\n    badgevalue?: string = null as any;\n    iconclass?: string = null as any;\n    iconposition? = 'left';\n    onTap?: Function = null as any;\n    iconsize?:number = 0;\n    skeletonheight?: string = null as any;\n    skeletonwidth?: string = null as any;\n    iconurl?: string = null as any;\n    iconheight?: number = null as any;\n    iconwidth?: number = null as any;\n    iconmargin?: number = null as any;\n    accessibilitylabel?: string = undefined;\n    hint?: string = undefined;\n    accessibilityrole?: AccessibilityRole = \"button\";\n}\n", "wavemaker-rn-runtime/src/components/basic/button/button.styles.ts": "import BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmIconStyles } from '../icon/icon.styles';\nimport { WmSkeletonStyles } from '../skeleton/skeleton.styles';\n\nexport type WmButtonStyles = BaseStyles & {\n  content: AllStyle,\n  badge: AllStyle,\n  icon: WmIconStyles,\n  skeleton: WmSkeletonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-button';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmButtonStyles = defineStyles<WmButtonStyles>({\n      root: {\n          minHeight: 40,\n          borderRadius: 32,\n          paddingTop: 12,\n          paddingBottom: 12,\n          paddingLeft: 24,\n          paddingRight: 24,\n          alignSelf: 'flex-start',\n          rippleColor: themeVariables.rippleColor\n      },\n      content: {\n        flexDirection: 'row',\n        alignItems: 'center',\n        justifyContent: 'center'\n      },\n      text: {\n        fontSize: 14,\n        fontFamily: themeVariables.baseFont,\n        fontWeight: '500',\n        textAlign: 'center',\n        textTransform: 'capitalize',\n      },\n      badge: {\n        backgroundColor: themeVariables.buttonBadgeBackgroundColor,\n        color: themeVariables.buttonBadgeTextColor,\n        alignSelf: 'flex-end',\n        position: 'relative',\n        bottom: 60 ,\n        marginRight: 18,\n        borderWidth: 1,\n        borderStyle: 'solid',\n      },\n      icon: {\n        root : {\n          alignSelf: 'auto',\n          paddingLeft: -8,\n          paddingRight: -8\n        },\n        icon: {},\n        text: {\n          paddingRight: themeVariables.buttonTextPadding,\n          fontSize: 16\n        }\n      } as WmIconStyles,\n      skeleton: {\n        root: {\n          width: 96,\n          height: 48,\n          borderRadius: 4\n        }\n      } as WmSkeletonStyles\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n  addStyle(DEFAULT_CLASS + '-disabled', '', {\n    root : {\n      opacity: 0.5\n    }\n  });\n\n  const getButtonStyles = (bgColor: string, color: string, borderColor = bgColor) => {\n    return {\n      root: {\n        borderWidth: 1,\n        borderColor: borderColor,\n        borderStyle: 'solid',\n        backgroundColor: bgColor\n      },\n      text: {\n        color: color\n      },\n      badge: {\n        backgroundColor: color,\n        color: bgColor,\n        borderColor: bgColor\n      },\n      icon: {\n        text: {\n          color: color\n        }\n      }\n    } as WmButtonStyles;\n  }\n\n  const linkBtnStyle = getButtonStyles(themeVariables.buttonLinkColor, themeVariables.buttonLinkTextColor );\nconst buttonWithOnlyLabel = getButtonStyles(themeVariables.buttonLinkColor, themeVariables.buttonLinkTextColor );\n\n  linkBtnStyle.root.paddingVertical = 4;\n  linkBtnStyle.text.textDecorationColor = themeVariables.buttonLinkTextColor;\n  linkBtnStyle.text.textDecorationLine = 'underline';\n  linkBtnStyle.text.textDecorationStyle = 'solid';\n\n  addStyle('btn-default', '', getButtonStyles(themeVariables.buttonDefaultColor, themeVariables.buttonDefaultTextColor, themeVariables.buttonBorderColor));\n  addStyle('btn-info', '', getButtonStyles(themeVariables.buttonInfoColor, themeVariables.buttonInfoTextColor));\n  addStyle('btn-primary', '', getButtonStyles(themeVariables.buttonPrimaryColor, themeVariables.buttonPrimaryTextColor));\n  addStyle('btn-secondary', '', getButtonStyles(themeVariables.buttonSecondaryColor, themeVariables.buttonSecondaryTextColor, themeVariables.buttonSecondaryTextColor));\n  addStyle('btn-danger', '', getButtonStyles(themeVariables.buttonDangerColor, themeVariables.buttonDangerTextColor));\n  addStyle('btn-success', '', getButtonStyles(themeVariables.buttonSuccessColor, themeVariables.buttonSuccessTextColor));\n  addStyle('btn-warning', '', getButtonStyles(themeVariables.buttonWarningColor, themeVariables.buttonWarningTextColor));\n  addStyle('btn-link', '', linkBtnStyle);\n  addStyle('btn-only-label', '', buttonWithOnlyLabel);\n  addStyle('btn-dark', '', getButtonStyles(themeVariables.buttonDarkColor, themeVariables.buttonDarkTextColor));\n  addStyle('btn-light', '', getButtonStyles(themeVariables.buttonLightColor, themeVariables.buttonLightTextColor));\n  addStyle('fab-btn', 'btn-primary', {\n    root : {\n      ...BASE_THEME.getStyle('elevate2').root,\n      position: 'fixed' as any,\n      bottom: 160,\n      right: 48,\n      width: 56,\n      height: 56,\n      borderRadius: 56,\n      justifyContent: 'center',\n      alignItems: 'center'\n    },\n    text: {\n      marginLeft: 0,\n      marginRight: 0\n    },\n    icon: {\n      icon: {\n        fontSize: 24\n      }\n    } as WmIconStyles\n  } as WmButtonStyles);\n  addStyle('mini-fab-btn', 'fab-btn', {\n    root : {\n      width: 40,\n      height: 40\n    }\n  } as WmButtonStyles);\n});\n", "wavemaker-rn-runtime/src/components/basic/lottie/lottie.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmLottieProps extends BaseProps {\n  speed  = 1;\n  autoplay = false;\n  loop = false;\n  source: string = '';\n}", "wavemaker-rn-runtime/src/components/basic/lottie/lottie.styles.ts": "import BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type WmLottieStyles = BaseStyles & {\n    content: AllStyle,\n};\n\nexport const DEFAULT_CLASS = 'app-lottie';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles = defineStyles<WmLottieStyles>({\n        root: {},\n        text: {},\n        content: {\n            height: 64,\n            width: '100%'\n        }\n    });\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/basic/lottie/lottie.component.tsx": "import React from 'react';\nimport axios from 'axios';\nimport { Platform, View } from 'react-native';\nimport LottieView from 'lottie-react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmLottieProps from './lottie.props';\nimport { DEFAULT_CLASS, WmLottieStyles } from './lottie.styles';\n\nexport class WmLottieState extends BaseComponentState<WmLottieProps> {\n  animationData: any;\n  isCompleted = false;\n}\n\nexport default class WmLottie extends BaseComponent<WmLottieProps, WmLottieState, WmLottieStyles> {\n\n  private lottie = React.createRef<LottieView>();\n\n  constructor(props: WmLottieProps) {\n    super(props, DEFAULT_CLASS, new WmLottieProps(), new WmLottieState());\n  }\n  \n  play() {\n    if (this.lottie.current) {\n      if (this.state.isCompleted) {\n        this.reset();\n      } else {\n        this.lottie.current.play();\n        this.invokeEventCallback('onPlay', [null, this.proxy]);\n      }\n    }\n  }\n\n  pause() {\n    if (this.lottie.current) {\n      this.lottie.current.pause();\n      this.invokeEventCallback('onPause', [null, this.proxy]);\n    }\n  }\n\n  reset() {\n    if (this.lottie.current) {\n      if (this.lottie.current.reset) {\n        this.lottie.current.reset();\n        this.lottie.current.play();\n      } else if((this.lottie.current as any).goToAndPlay) {\n        (this.lottie.current as any).goToAndPlay(0);\n      } else {\n        return;\n      }\n      this.invokeEventCallback('onPlay', [null, this.proxy]);\n      this.updateState({\n        isCompleted: false\n      } as WmLottieState);\n    }\n    \n  }\n\n  private onReady() {\n    this.invokeEventCallback('onReady', [null, this.proxy]);\n    if (this.state.props.autoplay) {\n      this.invokeEventCallback('onPlay', [null, this.proxy]);\n    }\n  }\n\n  private loadAnimationData() {\n    if (this.state.animationData || ! this.loadAsset) {\n      return;\n    }\n    if (Platform.OS == 'web') {\n      const url = this.loadAsset(this.state.props.source) as string;\n      axios.get(url).then(({data}) => {\n        this.updateState({\n          animationData: data\n        } as WmLottieState, () => this.onReady());\n      });\n    } else {\n      this.updateState({\n        animationData: this.loadAsset(this.state.props.source)\n      } as WmLottieState, () => this.onReady());\n    }\n  }\n\n  onPropertyChange(name: string, $new: any, $old: any): void {\n    super.onPropertyChange(name, $new, $old);\n    switch(name) {\n      case 'src':\n        this.loadAnimationData();\n        break;\n      case 'loop':\n        if (this.initialized && \n          !this.state.isCompleted && \n          ($new || this.state.props.autoplay)) {\n          setTimeout(() => this.reset(), 200);\n        }\n        break;\n    }\n  }\n\n  componentDidMount(): void {\n    super.componentDidMount();\n    this.loadAnimationData();\n  }\n\n  private renderWebLottie(props: WmLottieProps) {\n    let Lottie = Platform.OS == 'web' ? require('react-lottie-player') : null;\n    Lottie = Lottie?.default || Lottie;\n    return (<Lottie \n      animationData={this.state.animationData}\n      ref= {this.lottie}\n      loop={props.loop}\n      play={props.autoplay}\n      speed={props.speed}\n      style={this.styles.content}\n      onComplete={() => {\n        this.updateState({\n          isCompleted: true\n        } as WmLottieState);\n        this.invokeEventCallback('onComplete', [null, this.proxy]);\n      }}/>);\n  }\n\n  private renderNativeLottie(props: WmLottieProps) {\n    return (\n      <LottieView\n          source={this.state.animationData}\n          ref= {this.lottie}\n          autoPlay={props.autoplay}\n          speed={props.speed}\n          loop={props.loop}\n          style={this.styles.content}\n          onAnimationFinish={() => {\n            this.updateState({\n              isCompleted: true\n            } as WmLottieState);\n            this.invokeEventCallback('onComplete', [null, this.proxy]);\n          }}\n        />\n    );\n  }\n\n  renderWidget(props: WmLottieProps) {\n    return (\n      <View \n        style={this.styles.root}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        {this._background}\n        {this.state.animationData ? \n          (Platform.OS == 'web' ?  this.renderWebLottie(props) : this.renderNativeLottie(props)) \n          : null \n        }\n      </View>); \n  }\n}\n", "wavemaker-rn-runtime/src/components/basic/anchor/anchor.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { AccessibilityRole } from 'react-native';\nexport default class WmAnchorProps extends BaseProps {\n    animation?: string = null as any;\n    animationdelay?: number = null as any;\n    caption? = 'Link';\n    hyperlink?: string = null as any;\n    encodeurl?: boolean = false;\n    badgevalue?: string = null as any;\n    width?: string = null as any;\n    height?: string = null as any;\n    iconclass?: string = null as any;\n    iconposition?: string = 'left';\n    target?: string = '_blank';\n    onTap?: any;\n    skeletonwidth?: number;\n    skeletonheight?: number;\n    iconurl?: string = null as any;\n    iconheight?: number = null as any;\n    iconwidth?: number = null as any;\n    iconmargin?: number = null as any;\n    accessibilitylabel?: string = undefined;\n    hint?: string = undefined;\n    accessibilityrole?: AccessibilityRole = 'link';\n    nooflines?: any = undefined;\n}\n", "wavemaker-rn-runtime/src/components/basic/anchor/anchor.component.tsx": "import React from 'react';\nimport { LayoutChangeEvent, Text } from 'react-native';\nimport { Badge } from 'react-native-paper';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { SyntheticEvent, Tappable } from '@wavemaker/app-rn-runtime/core/tappable.component';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport { encodeUrl } from '@wavemaker/app-rn-runtime/core/utils';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility';\nimport NavigationService, { NavigationServiceConsumer } from '@wavemaker/app-rn-runtime/core/navigation.service';\n\nimport WmAnchorProps from './anchor.props';\nimport { DEFAULT_CLASS, WmAnchorStyles } from './anchor.styles';\nimport { Animatedview } from '@wavemaker/app-rn-runtime/components/basic/animatedview.component';\nimport { createSkeleton } from '../skeleton/skeleton.component';\n\nexport class WmAnchorState extends BaseComponentState<WmAnchorProps> {\n\n}\n\nexport default class WmAnchor extends BaseComponent<WmAnchorProps, WmAnchorState, WmAnchorStyles> {\n\n  constructor(props: WmAnchorProps) {\n    super(props, DEFAULT_CLASS, new WmAnchorProps());\n  }\n\n  onTap(navigationService: NavigationService, e: SyntheticEvent) {\n    const props = this.state.props;\n    if (props.hyperlink) {\n      const link = props.encodeurl ? encodeUrl(props.hyperlink) : props.hyperlink;\n      navigationService.openUrl(link, {\n        target: this.state.props.target\n      });\n    }\n    this.invokeEventCallback('onTap', [e, this.proxy]);\n  }\n\n  public renderSkeleton(props: WmAnchorProps){\n    return createSkeleton(this.theme, this.styles.skeleton, {\n      ...this.styles.root,\n      width: this.props.skeletonwidth || this.styles.root.width,\n      height: this.props.skeletonheight || this.styles.root.height\n    });\n  }\n  \n  renderBadge() {\n    const { badgevalue } = this.props;\n    if(this._showSkeleton) {\n      return createSkeleton(this.theme, this.styles.badgeSkeleton, {\n        ...this.styles.badge,\n       // marginTop: -50\n      })\n    }\n    return badgevalue != undefined ? (<Badge style={this.styles.badge}>{badgevalue}</Badge>): null;\n  }\n\n  renderWidget(props: WmAnchorProps) {\n      const {\n        iconclass,\n        iconurl,\n        name,\n        iconheight,\n        iconmargin,\n        iconwidth,\n        badgevalue,\n      } = props;\n\n    if (this.styles.icon && this.styles.icon.text) {\n      this.styles.icon.text.color = this.styles.text.color;\n    }\n\n    const icon = (iconclass || iconurl) && (\n      <WmIcon\n        id={this.getTestId('icon')}\n        styles={this.styles.icon}\n        hint={props?.hint}\n        name={name + '_icon'}\n        iconclass={iconclass}\n        iconurl={iconurl}\n        iconheight={iconheight}\n        iconmargin={iconmargin}\n        iconwidth={iconwidth}\n      />\n    );\n    return (\n      <NavigationServiceConsumer>\n        {(navigationService: NavigationService) =>\n          (<Animatedview \n            entryanimation={props.animation} \n            delay={props.animationdelay} \n            style={{width: this.styles.root.width, height: this.styles.root.height, justifyContent: 'center'}}\n            onLayout={(event: LayoutChangeEvent) => this.handleLayout(event)}\n          >\n            <Tappable {...this.getTestPropsForAction()} target={this} styles={[this.styles.root, this.styles.root.width && this.styles.root.height ? { width: '100%', height: '100%'} : null, {flexDirection: props.iconposition === 'top' ? 'column': 'row'}]}\n              onTap={props.hyperlink || props.onTap ? (e: SyntheticEvent) => this.onTap(navigationService, e) : undefined}\n              disableTouchEffect={this.state.props.disabletoucheffect}>\n              {this._background}\n              {props.iconposition === 'top' && icon}\n              {props.iconposition === 'left' && icon}\n              {props.caption ? (<Text style={this.styles.text}\n              {...this.getTestPropsForLabel('caption')}\n              {...getAccessibilityProps(AccessibilityWidgetType.ANCHOR, props)}\n              numberOfLines={props.nooflines}>{props.caption}</Text>) : null}\n              {props.iconposition === 'right' && icon}\n              {this.renderBadge()}\n            </Tappable>\n          </Animatedview>)\n      }\n      </NavigationServiceConsumer>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/basic/anchor/anchor.styles.ts": "import Color from 'color';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmIconStyles } from '@wavemaker/app-rn-runtime/components/basic/icon/icon.styles';\nimport BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { WmSkeletonStyles } from '../skeleton/skeleton.styles';\n\nexport type WmAnchorStyles = BaseStyles & {\n    badge: AllStyle,\n    icon: WmIconStyles\n    skeleton: WmSkeletonStyles\n    badgeSkeleton: WmSkeletonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-anchor';\n\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmAnchorStyles = defineStyles({\n        root: {\n            color: themeVariables.linkDefaultColor,\n            flexDirection: 'row',\n            alignItems: 'center',\n            overflow: 'visible'\n        },\n        text: {\n            paddingLeft: 8,\n            paddingRight: 8,\n            color: themeVariables.linkDefaultColor,\n            fontSize: 18, \n            textDecorationLine: 'underline',\n        },\n        badge: {\n            backgroundColor: Color(themeVariables.linkDefaultColor).fade(0.8).rgb().toString(),\n            color: themeVariables.linkDefaultColor,\n            alignSelf: 'flex-start',\n            marginTop: -12,\n            marginLeft: 0,\n            fontWeight: 'bold'\n        },\n        icon: {\n            root : {\n                alignSelf: 'center'\n            },\n            text: {\n                fontSize: 16,\n                paddingRight: themeVariables.anchorTextPadding,\n                color: themeVariables.linkDefaultColor\n            }\n        } as WmIconStyles,\n        skeleton: {\n            root: {\n                width: '100%',\n                height: 20,\n                borderRadius: 4\n            }\n        } as any as WmSkeletonStyles,\n        badgeSkeleton: {\n            root: {\n            }\n          }  as WmSkeletonStyles\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n    addStyle(DEFAULT_CLASS + '-rtl', '', {\n        text: {\n            paddingRight: 8\n        }\n    });\n\n    const getLinkStyles = (color: string) => {\n        return {\n            root: {\n                color: color\n            },\n            text: {\n                color: color\n            },\n            icon: {\n                text: {\n                    color: color\n                }\n            },\n            badge: {\n                backgroundColor: Color(color).fade(0.8).rgb().toString(),\n                color: color,\n            }\n        } as WmAnchorStyles;\n    };\n\n    addStyle('link-primary', '', getLinkStyles(themeVariables.linkPrimaryColor));\n    addStyle('link-secondary', '', getLinkStyles(themeVariables.linkSecondaryColor));\n    addStyle('link-success', '', getLinkStyles(themeVariables.linkSuccessColor));\n    addStyle('link-danger', '', getLinkStyles(themeVariables.linkDangerColor));\n    addStyle('link-warning', '', getLinkStyles(themeVariables.linkWarningColor));\n    addStyle('link-info', '', getLinkStyles(themeVariables.linkInfoColor));\n    addStyle('link-light', '', getLinkStyles(themeVariables.linkLightColor));\n    addStyle('link-dark', '', getLinkStyles(themeVariables.linkDarkColor));\n});\n", "wavemaker-rn-runtime/src/components/basic/icon/icon.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { AccessibilityRole } from 'react-native';\nexport default class WmIconProps extends BaseProps {\n  animation?: string = null as any;\n  animationdelay?: number = null as any;\n  iterationcount?: any;\n  iconclass?: string = 'wm-sl-l sl-user';\n  iconposition? = 'left';\n  caption? = '';\n  iconsize? = 0;\n  onTap?: Function;\n  skeletonheight?: string = null as any;\n  skeletonwidth?: string = null as any;\n  iconurl?: string = null as any;\n  iconheight?: number = null as any;\n  iconwidth?: number = null as any;\n  iconmargin?: number = null as any;\n  accessibilitylabel?: string = undefined;\n  hint?: string = undefined;\n  accessibilityrole?: AccessibilityRole;\n}\n", "wavemaker-rn-runtime/src/components/basic/icon/icon.styles.ts": "import BASE_THEME, { AllStyle }  from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmSkeletonStyles } from '../skeleton/skeleton.styles';\n\nexport type WmIconStyles = BaseStyles & {\n    icon?: AllStyle,\n    skeleton: WmSkeletonStyles\n};\nexport const DEFAULT_CLASS = 'app-icon';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmIconStyles = defineStyles({\n        root: {\n            flexDirection: 'row',\n            alignSelf: 'flex-start',\n            alignItems: 'center'\n        },\n        icon: {\n            paddingLeft: 0,\n            paddingRight: 8\n        },\n        text: {\n            paddingLeft: 8\n        },\n        skeleton:{\n            root: {\n                width: 32,\n                height: 32,\n                borderRadius: 4\n            }\n        } as WmSkeletonStyles\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n    addStyle(DEFAULT_CLASS + '-rtl', '', {\n        text: {\n            paddingRight: 8        \n        }\n    });\n});\n", "wavemaker-rn-runtime/src/components/basic/icon/icon.component.tsx": "import React from 'react';\nimport { Animated, DimensionValue, Easing, Text, Image, View, LayoutChangeEvent } from 'react-native';\nimport { FontAwesome } from '@expo/vector-icons';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { isFullPathUrl } from '@wavemaker/app-rn-runtime/core/utils';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility';\n\nimport WmIconProps from './icon.props';\nimport { DEFAULT_CLASS, WmIconStyles } from './icon.styles';\nimport WavIcon from './wavicon/wavicon.component';\nimport StreamlineLightIcon from './streamline-light-icon/streamline-light-icon.component';\nimport StreamlineRegularIcon from './streamline-regular-icon/streamline-regular-icon.component';\nimport { Tappable } from '@wavemaker/app-rn-runtime/core/tappable.component';\nimport { Animatedview } from '@wavemaker/app-rn-runtime/components/basic/animatedview.component';\nimport WmSkeleton, { createSkeleton } from '../skeleton/skeleton.component';\n\ninterface IconDef {\n  isFontAwesome: boolean;\n  isWavIcon: boolean;\n  isStreamlineLightIcon: boolean;\n  isStreamlineRegularIcon: boolean;\n  type: string;\n  rotate: string;\n  size: number;\n  animation: string;\n}\n\nconst ICON_SIZES = new Map([\n  ['fa-lg', 24],\n  ['fa-2x', 36],\n  ['fa-3x', 48],\n  ['fa-4x', 60],\n  ['fa-5x', 72]\n]);\n\nconst ICON_ROTATTION = new Map([\n  ['fa-rotate-90', '90deg'],\n  ['fa-rotate-180', '180deg'],\n  ['fa-rotate-270', '270deg']\n]);\n\nexport class WmIconState extends BaseComponentState<WmIconProps> {\n  public iconDef = {} as IconDef;\n}\n\nexport default class WmIcon extends BaseComponent<WmIconProps, WmIconState, WmIconStyles> {\n  spinValue = new Animated.Value(0);\n  pulseValue = new Animated.Value(0);\n  public stopAnimation = true;\n  private _iconSource = null as any;\n\n  constructor(props: WmIconProps) {\n    super(props, DEFAULT_CLASS, new WmIconProps());\n  }\n\n  getIconDef(iconClass: string): IconDef {\n    const iconDef = {\n      rotate: '0'\n    } as IconDef;\n    const splits = iconClass.split(' ');\n    iconDef.isFontAwesome = !!splits.find(v => v === 'fa');\n    iconDef.isStreamlineLightIcon = !!splits.find(v => v === 'wm-sl-l');\n    iconDef.isStreamlineRegularIcon = !!splits.find(v => v === 'wm-sl-r');\n    if (iconDef.isFontAwesome) {\n      iconDef.type = splits.find(v => v.startsWith('fa-'))?.substring(3) || '';\n    } else if (iconDef.isStreamlineLightIcon) {\n      iconDef.type = splits.find(v => v.startsWith('sl-'))?.substring(3) || '';\n    } else if (iconDef.isStreamlineRegularIcon) {\n      iconDef.type = splits.find(v => v.startsWith('sl-'))?.substring(3) || '';\n    } else {\n      iconDef.isWavIcon = !iconDef.isFontAwesome && !!splits.find(v => v === 'wi');\n      iconDef.type = (iconDef.isWavIcon && splits.find(v => v.startsWith('wi-'))?.substring(3)) || '';\n    }\n    if (iconClass.indexOf('fa-spin') >= 0) {\n      iconDef.animation = 'spin';\n    } else if (iconClass.indexOf('fa-pulse') >= 0) {\n      iconDef.animation = 'pulse';\n    }\n    iconDef.size = splits.map(v => ICON_SIZES.get(v)).find(v => !!v) || 12;\n    iconDef.rotate = splits.map(v => ICON_ROTATTION.get(v)).find(v => !!v) || '0deg';\n    return iconDef;\n  }\n\n  private spin () {\n    if (this.stopAnimation) {\n      return;\n    }\n    this.spinValue.setValue(0);\n    Animated.timing(\n      this.spinValue,\n      {\n        toValue: 1,\n        duration: 1000,\n        easing: Easing.linear,\n        useNativeDriver: true\n      }\n    ).start(() => this.spin());\n  }\n\n  componentDidMount() {\n    super.componentDidMount();\n    this.spin();\n  }\n\n  componentWillUnmount(): void {\n      super.componentWillUnmount();\n      this.stopAnimation = true;\n  }\n\n  onPropertyChange(name: string, $new: any, $old: any) {\n    super.onPropertyChange(name, $new, $old);\n    switch(name) {\n      case 'iconclass':\n        $new && this.updateState({iconDef: this.getIconDef($new)} as WmIconState);\n        break;\n    }\n  }\n\n  private getCustomIcon(props: WmIconProps, style: any) {\n    const customIcon = this.theme.mergeStyle({}, this.theme.getStyle(props?.iconclass || '')?.icon || this.styles.icon);\n    const customIconContent = customIcon?.content;\n    if (customIconContent) {\n      delete customIcon.content;\n      return (<Text\n        style={[style, customIcon.fontFamily ? {fontFamily: customIcon.fontFamily}: null]}>\n          {decodeURIComponent(customIconContent)}\n      </Text>);\n    }\n    return null;\n  }\n\n  public renderSkeleton(props: WmIconProps) {\n    let skeletonWidth = (this.props.skeletonwidth || this.props.iconsize || this.styles.root.width) as DimensionValue;\n    let skeletonHeight =  (this.props.skeletonheight || this.props.iconsize || this.styles.root.height) as DimensionValue\n\n    if(this.props.skeletonheight == \"0\") {\n      skeletonWidth = 0\n    }\n    \n    if(this.props.skeletonheight == \"0\") {\n      skeletonHeight = 0\n    }\n    \n    return createSkeleton(this.theme, this.styles.skeleton, {\n      ...this.styles.root,\n      width: skeletonWidth,\n      height: skeletonHeight\n    });\n  }\n\n  getElementToShow(props: WmIconProps, iconSrc: any) {\n\n    const { iconmargin, iconheight, iconwidth } = props;\n    let width, height;\n    let elementToshow, source;\n\n    if (iconwidth) width = iconwidth;\n    else if (iconheight) width = iconheight;\n    else width = 12;\n    if (iconheight) height = iconheight;\n    else if (iconwidth) height = iconwidth;\n    else height = 12;\n\n    if (isFullPathUrl(iconSrc)) {\n      source = {\n        uri: iconSrc\n      };\n    } else {\n      source = iconSrc;\n    }\n    elementToshow = <Image testID={this.getTestId('icon')}\n      style={{\n        margin: iconmargin ?? 0,\n        height: height,\n        width: width\n      }}\n      source={source}/>;\n    return elementToshow;\n  }\n\n  loadIcon(iconImage: string | undefined) {\n    if (!iconImage || !this.loadAsset) {\n      return null;\n    }\n    const iconImageSrc = this.loadAsset(iconImage);\n    if (iconImageSrc && typeof iconImageSrc !== 'function') {\n      return iconImageSrc;\n    }\n    return null;\n  }\n\n  renderIcon(props: WmIconProps) {\n    let iconJsx = null;\n    this._iconSource =  this._iconSource || this.loadIcon(props.iconurl);\n    const iconSrc: any = this._iconSource\n    if (iconSrc) {\n      return this.getElementToShow(props, iconSrc);\n    }\n    const iconDef = this.state.iconDef;\n    if (!iconDef) {\n      return null;\n    }\n    const { root, text, icon } = this.styles;\n    const style = [{ color: root.color || text.color },\n    icon,\n    { transform: [{ rotate: iconDef.rotate }] }];\n\n    const customIcon = this.getCustomIcon(props, style);\n    const iconSize = props.iconsize || this.styles.root.fontSize || this.styles.text.fontSize || iconDef.size;\n    if (props.show && iconDef && iconDef.isFontAwesome) {\n      //@ts-ignore type information is not matching\n      iconJsx = (<FontAwesome name={customIcon ? '' : iconDef.type}\n        style={style}\n        size={iconSize}\n        {...this.getTestProps('icon')}>\n          {customIcon}\n        </FontAwesome>);\n    } else if (props.show && iconDef) {\n      let WMCustomIcon = WavIcon as unknown;\n      if (iconDef.isStreamlineLightIcon) {\n        WMCustomIcon = StreamlineLightIcon;\n      } else if (iconDef.isStreamlineRegularIcon) {\n        WMCustomIcon = StreamlineRegularIcon;\n      } else if (!iconDef.isWavIcon && !customIcon && !this.styles.icon?.fontFamily) {\n        return null;\n      }\n      //@ts-ignore type information is not matching\n      iconJsx = WMCustomIcon ? (<WMCustomIcon name={customIcon ? '' : iconDef.type}\n        style={style}\n        size={iconSize}\n        {...this.getTestProps('icon')}>\n        {customIcon}\n      </WMCustomIcon>) : null;\n    }\n    if (iconJsx && iconDef.animation === 'spin') {\n      const rotate = this.spinValue.interpolate({ inputRange: [0, 1], outputRange: ['0deg', '360deg']});\n      const animation = { transform: [{ rotate }] };\n      this.stopAnimation = false;\n      return (<Animated.View style={animation}>{iconJsx}</Animated.View>);\n    } else if (iconJsx && iconDef.animation === 'pulse') {\n      const opacity = this.spinValue.interpolate({ inputRange: [0, 1], outputRange: [0, 1]});\n      const animation = { opacity: opacity };\n      this.stopAnimation = false;\n      return (<Animated.View style={animation}>{iconJsx}</Animated.View>);\n    } else {\n      this.stopAnimation = true;\n    }\n    return (\n      <View\n        // {...getAccessibilityProps(AccessibilityWidgetType.ICON, this.props)}\n      >\n        {iconJsx}\n      </View>\n    );\n  }\n\n  renderWidget(props: WmIconProps) {\n    let icon = this.renderIcon(props);\n    let iterationCount: any = props.iterationcount ? (props.iterationcount != 'infinite' ? parseInt(props.iterationcount): 'infinite') : undefined;\n    return (\n      <Tappable \n        target={this} \n        rippleColor = {this.styles.root.rippleColor} \n        {...this.getTestPropsForAction()} \n        accessibilityProps={{...getAccessibilityProps(AccessibilityWidgetType.ICON, props)}} \n        disableTouchEffect={this.state.props.disabletoucheffect}\n        onLayout={(event: LayoutChangeEvent) => this.handleLayout(event)}\n      >\n        <Animatedview entryanimation={props.animation} delay={props.animationdelay} style={this.styles.root} iterationCount={iterationCount}>\n          {this._background}\n          {(props.iconposition === 'left' && icon) || null}\n          {(props.caption && (<Text {...this.getTestPropsForLabel('caption')}style={this.styles.text} accessibilityRole={props?.accessibilityrole ? props?.accessibilityrole : 'text'}>{props.caption}</Text>)) || null}\n          {(props.iconposition === 'right' && icon) || null}\n        </Animatedview>\n      </Tappable>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/basic/icon/wavicon/wavicon.component.tsx": "\n/*******************************************************\n * Don't make any changes.\n * This is a generated file.\n * See wavicon.generator.js\n ********************************************************/\n\nimport font from './wavicon.ttf';\nimport createIconSet from '@expo/vector-icons/build/createIconSet';\n\nexport const glyphMap: any = {\n    \"3d-rotation\": \"\uf101\",\n    \"ac-unit\": \"\uf102\",\n    \"access-alarm\": \"\uf103\",\n    \"access-alarms\": \"\uf104\",\n    \"access-time\": \"\uf105\",\n    \"accessibility\": \"\uf106\",\n    \"accessible\": \"\uf107\",\n    \"account-balance-wallet\": \"\uf108\",\n    \"account-balance\": \"\uf109\",\n    \"account-box\": \"\uf10a\",\n    \"account-circle\": \"\uf10b\",\n    \"adb\": \"\uf10c\",\n    \"add-a-photo\": \"\uf10d\",\n    \"add-alarm\": \"\uf10e\",\n    \"add-alert\": \"\uf10f\",\n    \"add-box\": \"\uf110\",\n    \"add-circle-outline\": \"\uf111\",\n    \"add-circle\": \"\uf112\",\n    \"add-location\": \"\uf113\",\n    \"add-shopping-cart\": \"\uf114\",\n    \"add-to-photos\": \"\uf115\",\n    \"add-to-queue\": \"\uf116\",\n    \"add\": \"\uf117\",\n    \"adjust\": \"\uf118\",\n    \"airline-seat-flat-angled\": \"\uf119\",\n    \"airline-seat-flat\": \"\uf11a\",\n    \"airline-seat-individual-suite\": \"\uf11b\",\n    \"airline-seat-legroom-extra\": \"\uf11c\",\n    \"airline-seat-legroom-normal\": \"\uf11d\",\n    \"airline-seat-legroom-reduced\": \"\uf11e\",\n    \"airline-seat-recline-extra\": \"\uf11f\",\n    \"airline-seat-recline-normal\": \"\uf120\",\n    \"airplanemode-active\": \"\uf121\",\n    \"airplanemode-inactive\": \"\uf122\",\n    \"airplay\": \"\uf123\",\n    \"airport-shuttle\": \"\uf124\",\n    \"alarm-add\": \"\uf125\",\n    \"alarm-off\": \"\uf126\",\n    \"alarm-on\": \"\uf127\",\n    \"alarm\": \"\uf128\",\n    \"album\": \"\uf129\",\n    \"align-center\": \"\uf12a\",\n    \"align-justify\": \"\uf12b\",\n    \"align-left\": \"\uf12c\",\n    \"align-right\": \"\uf12d\",\n    \"all-inclusive\": \"\uf12e\",\n    \"all-out\": \"\uf12f\",\n    \"analytics-circle\": \"\uf130\",\n    \"analytics\": \"\uf131\",\n    \"android\": \"\uf132\",\n    \"angle-double-down\": \"\uf133\",\n    \"angle-double-left\": \"\uf134\",\n    \"angle-double-right\": \"\uf135\",\n    \"angle-double-up\": \"\uf136\",\n    \"announcement\": \"\uf137\",\n    \"apps\": \"\uf138\",\n    \"archive\": \"\uf139\",\n    \"arrow-back\": \"\uf13a\",\n    \"arrow-down-circle\": \"\uf13b\",\n    \"arrow-down\": \"\uf13c\",\n    \"arrow-downward\": \"\uf13d\",\n    \"arrow-drop-down-circle\": \"\uf13e\",\n    \"arrow-drop-down\": \"\uf13f\",\n    \"arrow-drop-up\": \"\uf140\",\n    \"arrow-forward\": \"\uf141\",\n    \"arrow-left-circle\": \"\uf142\",\n    \"arrow-left\": \"\uf143\",\n    \"arrow-right-circle\": \"\uf144\",\n    \"arrow-right\": \"\uf145\",\n    \"arrow-up-circle\": \"\uf146\",\n    \"arrow-up\": \"\uf147\",\n    \"arrow-upward\": \"\uf148\",\n    \"art-track\": \"\uf149\",\n    \"aspect-ratio\": \"\uf14a\",\n    \"assessment\": \"\uf14b\",\n    \"assignment-ind\": \"\uf14c\",\n    \"assignment-late\": \"\uf14d\",\n    \"assignment-return\": \"\uf14e\",\n    \"assignment-returned\": \"\uf14f\",\n    \"assignment-turned-in\": \"\uf150\",\n    \"assignment\": \"\uf151\",\n    \"assistant-photo\": \"\uf152\",\n    \"assistant\": \"\uf153\",\n    \"at\": \"\uf154\",\n    \"attach-file\": \"\uf155\",\n    \"attach-money\": \"\uf156\",\n    \"attachment\": \"\uf157\",\n    \"audiotrack\": \"\uf158\",\n    \"autorenew\": \"\uf159\",\n    \"av-timer\": \"\uf15a\",\n    \"award\": \"\uf15b\",\n    \"back\": \"\uf15c\",\n    \"backspace\": \"\uf15d\",\n    \"backup\": \"\uf15e\",\n    \"backward\": \"\uf15f\",\n    \"badge\": \"\uf160\",\n    \"bar-chart\": \"\uf161\",\n    \"bar-graph\": \"\uf162\",\n    \"bars\": \"\uf163\",\n    \"battery-20\": \"\uf164\",\n    \"battery-30\": \"\uf165\",\n    \"battery-50\": \"\uf166\",\n    \"battery-60\": \"\uf167\",\n    \"battery-80\": \"\uf168\",\n    \"battery-90\": \"\uf169\",\n    \"battery-alert\": \"\uf16a\",\n    \"battery-empty\": \"\uf16b\",\n    \"battery-full\": \"\uf16c\",\n    \"battery-half\": \"\uf16d\",\n    \"battery-std\": \"\uf16e\",\n    \"battery-unknown\": \"\uf16f\",\n    \"battery\": \"\uf170\",\n    \"beach-access\": \"\uf171\",\n    \"beenhere\": \"\uf172\",\n    \"bell-slash\": \"\uf173\",\n    \"bell\": \"\uf174\",\n    \"block\": \"\uf175\",\n    \"bluetooth-audio\": \"\uf176\",\n    \"bluetooth-connected\": \"\uf177\",\n    \"bluetooth-disabled\": \"\uf178\",\n    \"bluetooth-searching\": \"\uf179\",\n    \"bluetooth\": \"\uf17a\",\n    \"blur-circular\": \"\uf17b\",\n    \"blur-linear\": \"\uf17c\",\n    \"blur-off\": \"\uf17d\",\n    \"blur-on\": \"\uf17e\",\n    \"bold\": \"\uf17f\",\n    \"bolt\": \"\uf180\",\n    \"book-binder\": \"\uf181\",\n    \"book-open\": \"\uf182\",\n    \"book\": \"\uf183\",\n    \"bookmark-border\": \"\uf184\",\n    \"bookmark\": \"\uf185\",\n    \"border-all\": \"\uf186\",\n    \"border-bottom\": \"\uf187\",\n    \"border-clear\": \"\uf188\",\n    \"border-color\": \"\uf189\",\n    \"border-horizontal\": \"\uf18a\",\n    \"border-inner\": \"\uf18b\",\n    \"border-left\": \"\uf18c\",\n    \"border-outer\": \"\uf18d\",\n    \"border-right\": \"\uf18e\",\n    \"border-style\": \"\uf18f\",\n    \"border-top\": \"\uf190\",\n    \"border-vertical\": \"\uf191\",\n    \"branding-watermark\": \"\uf192\",\n    \"briefcase\": \"\uf193\",\n    \"brightness-auto\": \"\uf194\",\n    \"brightness-high\": \"\uf195\",\n    \"brightness-low\": \"\uf196\",\n    \"brightness-medium\": \"\uf197\",\n    \"broken-image\": \"\uf198\",\n    \"brush\": \"\uf199\",\n    \"bubble-chart\": \"\uf19a\",\n    \"bug-report\": \"\uf19b\",\n    \"build\": \"\uf19c\",\n    \"building\": \"\uf19d\",\n    \"bullhorn\": \"\uf19e\",\n    \"burst-mode\": \"\uf19f\",\n    \"business-center\": \"\uf1a0\",\n    \"business\": \"\uf1a1\",\n    \"cached\": \"\uf1a2\",\n    \"cake\": \"\uf1a3\",\n    \"calculator\": \"\uf1a4\",\n    \"calendar\": \"\uf1a5\",\n    \"call-end\": \"\uf1a6\",\n    \"call-incoming\": \"\uf1a7\",\n    \"call-made\": \"\uf1a8\",\n    \"call-merge\": \"\uf1a9\",\n    \"call-missed-outgoing\": \"\uf1aa\",\n    \"call-missed\": \"\uf1ab\",\n    \"call-outgoing\": \"\uf1ac\",\n    \"call-received\": \"\uf1ad\",\n    \"call-split\": \"\uf1ae\",\n    \"call-to-action\": \"\uf1af\",\n    \"call\": \"\uf1b0\",\n    \"camera-alt\": \"\uf1b1\",\n    \"camera-enhance\": \"\uf1b2\",\n    \"camera-front\": \"\uf1b3\",\n    \"camera-rear\": \"\uf1b4\",\n    \"camera-roll\": \"\uf1b5\",\n    \"camera\": \"\uf1b6\",\n    \"cancel\": \"\uf1b7\",\n    \"card-giftcard\": \"\uf1b8\",\n    \"card-membership\": \"\uf1b9\",\n    \"card-travel\": \"\uf1ba\",\n    \"caret-down\": \"\uf1bb\",\n    \"caret-left\": \"\uf1bc\",\n    \"caret-right\": \"\uf1bd\",\n    \"caret-up\": \"\uf1be\",\n    \"cart\": \"\uf1bf\",\n    \"casino\": \"\uf1c0\",\n    \"cast-connected\": \"\uf1c1\",\n    \"cast\": \"\uf1c2\",\n    \"cc\": \"\uf1c3\",\n    \"cd\": \"\uf1c4\",\n    \"center-focus-strong\": \"\uf1c5\",\n    \"center-focus-weak\": \"\uf1c6\",\n    \"change-history\": \"\uf1c7\",\n    \"chat-bubble-outline\": \"\uf1c8\",\n    \"chat-bubble\": \"\uf1c9\",\n    \"chat\": \"\uf1ca\",\n    \"check-box-outline-blank\": \"\uf1cb\",\n    \"check-box\": \"\uf1cc\",\n    \"check-circle\": \"\uf1cd\",\n    \"check-square\": \"\uf1ce\",\n    \"check\": \"\uf1cf\",\n    \"chevron-down\": \"\uf1d0\",\n    \"chevron-left\": \"\uf1d1\",\n    \"chevron-right\": \"\uf1d2\",\n    \"chevron-up\": \"\uf1d3\",\n    \"child-care\": \"\uf1d4\",\n    \"child-friendly\": \"\uf1d5\",\n    \"chip\": \"\uf1d6\",\n    \"chrome-reader-mode\": \"\uf1d7\",\n    \"circle\": \"\uf1d8\",\n    \"class\": \"\uf1d9\",\n    \"clear-all\": \"\uf1da\",\n    \"clear-formatting\": \"\uf1db\",\n    \"clear\": \"\uf1dc\",\n    \"clickable\": \"\uf1dd\",\n    \"clock-circle\": \"\uf1de\",\n    \"clock-square\": \"\uf1df\",\n    \"clock\": \"\uf1e0\",\n    \"clone\": \"\uf1e1\",\n    \"close\": \"\uf1e2\",\n    \"closed-caption\": \"\uf1e3\",\n    \"cloud-circle\": \"\uf1e4\",\n    \"cloud-done\": \"\uf1e5\",\n    \"cloud-download\": \"\uf1e6\",\n    \"cloud-off\": \"\uf1e7\",\n    \"cloud-queue\": \"\uf1e8\",\n    \"cloud-upload\": \"\uf1e9\",\n    \"cloud\": \"\uf1ea\",\n    \"code\": \"\uf1eb\",\n    \"collections-bookmark\": \"\uf1ec\",\n    \"collections\": \"\uf1ed\",\n    \"color-lens\": \"\uf1ee\",\n    \"colorize\": \"\uf1ef\",\n    \"comment\": \"\uf1f0\",\n    \"comments\": \"\uf1f1\",\n    \"compare-arrows\": \"\uf1f2\",\n    \"compare\": \"\uf1f3\",\n    \"compass\": \"\uf1f4\",\n    \"computer\": \"\uf1f5\",\n    \"confirmation-number\": \"\uf1f6\",\n    \"contact-mail\": \"\uf1f7\",\n    \"contact-phone\": \"\uf1f8\",\n    \"contacts\": \"\uf1f9\",\n    \"content-copy\": \"\uf1fa\",\n    \"content-cut\": \"\uf1fb\",\n    \"content-paste\": \"\uf1fc\",\n    \"control-point-duplicate\": \"\uf1fd\",\n    \"control-point\": \"\uf1fe\",\n    \"copyright\": \"\uf1ff\",\n    \"cpu\": \"\uf200\",\n    \"create-new-folder\": \"\uf201\",\n    \"create\": \"\uf202\",\n    \"credit-card\": \"\uf203\",\n    \"crop-din\": \"\uf204\",\n    \"crop-free\": \"\uf205\",\n    \"crop-landscape\": \"\uf206\",\n    \"crop-original\": \"\uf207\",\n    \"crop-portrait\": \"\uf208\",\n    \"crop-rotate\": \"\uf209\",\n    \"crop-square\": \"\uf20a\",\n    \"crop\": \"\uf20b\",\n    \"crown\": \"\uf20c\",\n    \"cut\": \"\uf20d\",\n    \"dashboard\": \"\uf20e\",\n    \"data-usage\": \"\uf20f\",\n    \"database\": \"\uf210\",\n    \"date-range\": \"\uf211\",\n    \"dehaze\": \"\uf212\",\n    \"delete-forever\": \"\uf213\",\n    \"delete-sweep\": \"\uf214\",\n    \"delete\": \"\uf215\",\n    \"description\": \"\uf216\",\n    \"desktop-mac\": \"\uf217\",\n    \"desktop-windows\": \"\uf218\",\n    \"desktop\": \"\uf219\",\n    \"details\": \"\uf21a\",\n    \"developer-board\": \"\uf21b\",\n    \"developer-mode\": \"\uf21c\",\n    \"device-hub\": \"\uf21d\",\n    \"devices-other\": \"\uf21e\",\n    \"devices\": \"\uf21f\",\n    \"dialer-sip\": \"\uf220\",\n    \"dialpad\": \"\uf221\",\n    \"diamond\": \"\uf222\",\n    \"directions-bike\": \"\uf223\",\n    \"directions-boat\": \"\uf224\",\n    \"directions-bus\": \"\uf225\",\n    \"directions-car\": \"\uf226\",\n    \"directions-railway\": \"\uf227\",\n    \"directions-run\": \"\uf228\",\n    \"directions-subway\": \"\uf229\",\n    \"directions-transit\": \"\uf22a\",\n    \"directions-walk\": \"\uf22b\",\n    \"directions\": \"\uf22c\",\n    \"directory\": \"\uf22d\",\n    \"disabled\": \"\uf22e\",\n    \"disc-full\": \"\uf22f\",\n    \"dns\": \"\uf230\",\n    \"do-not-disturb-alt\": \"\uf231\",\n    \"do-not-disturb-off\": \"\uf232\",\n    \"do-not-disturb-on\": \"\uf233\",\n    \"do-not-disturb\": \"\uf234\",\n    \"dock\": \"\uf235\",\n    \"domain\": \"\uf236\",\n    \"done-all\": \"\uf237\",\n    \"done\": \"\uf238\",\n    \"donut-large\": \"\uf239\",\n    \"donut-small\": \"\uf23a\",\n    \"dot-circle\": \"\uf23b\",\n    \"download\": \"\uf23c\",\n    \"drafts\": \"\uf23d\",\n    \"drag-handle\": \"\uf23e\",\n    \"drive-eta\": \"\uf23f\",\n    \"dvr\": \"\uf240\",\n    \"edit-location\": \"\uf241\",\n    \"edit\": \"\uf242\",\n    \"eject\": \"\uf243\",\n    \"ellipsis-h\": \"\uf244\",\n    \"ellipsis-v\": \"\uf245\",\n    \"email\": \"\uf246\",\n    \"enhanced-encryption\": \"\uf247\",\n    \"entertainment\": \"\uf248\",\n    \"envelope\": \"\uf249\",\n    \"equalizer\": \"\uf24a\",\n    \"error-outline\": \"\uf24b\",\n    \"error-triangle\": \"\uf24c\",\n    \"error\": \"\uf24d\",\n    \"eur\": \"\uf24e\",\n    \"euro-symbol\": \"\uf24f\",\n    \"ev-station\": \"\uf250\",\n    \"event-available\": \"\uf251\",\n    \"event-busy\": \"\uf252\",\n    \"event-note\": \"\uf253\",\n    \"event-seat\": \"\uf254\",\n    \"event\": \"\uf255\",\n    \"exclamation-circle\": \"\uf256\",\n    \"exclamation-triangle\": \"\uf257\",\n    \"exit-to-app\": \"\uf258\",\n    \"exit\": \"\uf259\",\n    \"expand-less\": \"\uf25a\",\n    \"expand-more\": \"\uf25b\",\n    \"explicit\": \"\uf25c\",\n    \"explore\": \"\uf25d\",\n    \"exposure-neg\": \"\uf25e\",\n    \"exposure-plus\": \"\uf25f\",\n    \"exposure-zero\": \"\uf260\",\n    \"exposure\": \"\uf261\",\n    \"extension\": \"\uf262\",\n    \"external-link\": \"\uf263\",\n    \"eye\": \"\uf264\",\n    \"face\": \"\uf265\",\n    \"fast-backward\": \"\uf266\",\n    \"fast-forward\": \"\uf267\",\n    \"fast-play-forward\": \"\uf268\",\n    \"fast-play-rewind\": \"\uf269\",\n    \"favorite-border\": \"\uf26a\",\n    \"favorite\": \"\uf26b\",\n    \"featured-play-list\": \"\uf26c\",\n    \"featured-video\": \"\uf26d\",\n    \"feedback\": \"\uf26e\",\n    \"female\": \"\uf26f\",\n    \"fiber-dvr\": \"\uf270\",\n    \"fiber-manual-record\": \"\uf271\",\n    \"fiber-new\": \"\uf272\",\n    \"fiber-pin\": \"\uf273\",\n    \"fiber-smart-record\": \"\uf274\",\n    \"file-download\": \"\uf275\",\n    \"file-text\": \"\uf276\",\n    \"file-upload\": \"\uf277\",\n    \"file\": \"\uf278\",\n    \"film\": \"\uf279\",\n    \"filter-b-and-w\": \"\uf27a\",\n    \"filter-center-focus\": \"\uf27b\",\n    \"filter-drama\": \"\uf27c\",\n    \"filter-frames\": \"\uf27d\",\n    \"filter-hdr\": \"\uf27e\",\n    \"filter-list\": \"\uf27f\",\n    \"filter-none\": \"\uf280\",\n    \"filter-tilt-shift\": \"\uf281\",\n    \"filter-vintage\": \"\uf282\",\n    \"filter\": \"\uf283\",\n    \"find-in-page\": \"\uf284\",\n    \"find-replace\": \"\uf285\",\n    \"fingerprint\": \"\uf286\",\n    \"fire\": \"\uf287\",\n    \"first-page\": \"\uf288\",\n    \"fitness-center\": \"\uf289\",\n    \"flag\": \"\uf28a\",\n    \"flare\": \"\uf28b\",\n    \"flash-auto\": \"\uf28c\",\n    \"flash-off\": \"\uf28d\",\n    \"flash-on\": \"\uf28e\",\n    \"flask\": \"\uf28f\",\n    \"flight-land\": \"\uf290\",\n    \"flight-takeoff\": \"\uf291\",\n    \"flight\": \"\uf292\",\n    \"flip-to-back\": \"\uf293\",\n    \"flip-to-front\": \"\uf294\",\n    \"flip\": \"\uf295\",\n    \"folder-open\": \"\uf296\",\n    \"folder-shared\": \"\uf297\",\n    \"folder-special\": \"\uf298\",\n    \"folder\": \"\uf299\",\n    \"font-download\": \"\uf29a\",\n    \"font-size\": \"\uf29b\",\n    \"font-underline\": \"\uf29c\",\n    \"format-align-center\": \"\uf29d\",\n    \"format-align-justify\": \"\uf29e\",\n    \"format-align-left\": \"\uf29f\",\n    \"format-align-right\": \"\uf2a0\",\n    \"format-bold\": \"\uf2a1\",\n    \"format-clear\": \"\uf2a2\",\n    \"format-color-fill\": \"\uf2a3\",\n    \"format-color-reset\": \"\uf2a4\",\n    \"format-color-text\": \"\uf2a5\",\n    \"format-indent-decrease\": \"\uf2a6\",\n    \"format-indent-increase\": \"\uf2a7\",\n    \"format-italic\": \"\uf2a8\",\n    \"format-line-spacing\": \"\uf2a9\",\n    \"format-list-bulleted\": \"\uf2aa\",\n    \"format-list-numbered\": \"\uf2ab\",\n    \"format-paint\": \"\uf2ac\",\n    \"format-quote\": \"\uf2ad\",\n    \"format-shapes\": \"\uf2ae\",\n    \"format-size\": \"\uf2af\",\n    \"format-strikethrough\": \"\uf2b0\",\n    \"format-textdirection-l-to-r\": \"\uf2b1\",\n    \"format-textdirection-r-to-l\": \"\uf2b2\",\n    \"format-underlined\": \"\uf2b3\",\n    \"forum\": \"\uf2b4\",\n    \"forward-10\": \"\uf2b5\",\n    \"forward-30\": \"\uf2b6\",\n    \"forward-5\": \"\uf2b7\",\n    \"forward\": \"\uf2b8\",\n    \"free-breakfast\": \"\uf2b9\",\n    \"full-screen\": \"\uf2ba\",\n    \"fullscreen-exit\": \"\uf2bb\",\n    \"fullscreen\": \"\uf2bc\",\n    \"functions\": \"\uf2bd\",\n    \"g-translate\": \"\uf2be\",\n    \"gamepad\": \"\uf2bf\",\n    \"games\": \"\uf2c0\",\n    \"gavel\": \"\uf2c1\",\n    \"gear\": \"\uf2c2\",\n    \"gesture\": \"\uf2c3\",\n    \"get-app\": \"\uf2c4\",\n    \"gif\": \"\uf2c5\",\n    \"gift\": \"\uf2c6\",\n    \"glass\": \"\uf2c7\",\n    \"globe\": \"\uf2c8\",\n    \"golf-course\": \"\uf2c9\",\n    \"gps-fixed\": \"\uf2ca\",\n    \"gps-not-fixed\": \"\uf2cb\",\n    \"gps-off\": \"\uf2cc\",\n    \"grade\": \"\uf2cd\",\n    \"gradient\": \"\uf2ce\",\n    \"graduation-cap\": \"\uf2cf\",\n    \"grain\": \"\uf2d0\",\n    \"graphic-eq\": \"\uf2d1\",\n    \"grid-off\": \"\uf2d2\",\n    \"grid-on\": \"\uf2d3\",\n    \"group-add\": \"\uf2d4\",\n    \"group-work\": \"\uf2d5\",\n    \"group\": \"\uf2d6\",\n    \"hammer\": \"\uf2d7\",\n    \"hand-pointer\": \"\uf2d8\",\n    \"hard-drive\": \"\uf2d9\",\n    \"hd\": \"\uf2da\",\n    \"hdd\": \"\uf2db\",\n    \"hdr-off\": \"\uf2dc\",\n    \"hdr-on\": \"\uf2dd\",\n    \"hdr-strong\": \"\uf2de\",\n    \"hdr-weak\": \"\uf2df\",\n    \"headphones\": \"\uf2e0\",\n    \"headset-mic\": \"\uf2e1\",\n    \"headset\": \"\uf2e2\",\n    \"healing\": \"\uf2e3\",\n    \"hearing\": \"\uf2e4\",\n    \"heart\": \"\uf2e5\",\n    \"help-outline\": \"\uf2e6\",\n    \"help\": \"\uf2e7\",\n    \"hexagon\": \"\uf2e8\",\n    \"high-quality\": \"\uf2e9\",\n    \"highlight-off\": \"\uf2ea\",\n    \"highlight\": \"\uf2eb\",\n    \"history\": \"\uf2ec\",\n    \"home-tall\": \"\uf2ed\",\n    \"home\": \"\uf2ee\",\n    \"hot-tub\": \"\uf2ef\",\n    \"hotel\": \"\uf2f0\",\n    \"hourglass-empty\": \"\uf2f1\",\n    \"hourglass-full\": \"\uf2f2\",\n    \"http\": \"\uf2f3\",\n    \"https\": \"\uf2f4\",\n    \"image-aspect-ratio\": \"\uf2f5\",\n    \"image\": \"\uf2f6\",\n    \"import-contacts\": \"\uf2f7\",\n    \"import-export\": \"\uf2f8\",\n    \"important-devices\": \"\uf2f9\",\n    \"inbox\": \"\uf2fa\",\n    \"indent\": \"\uf2fb\",\n    \"indeterminate-check-box\": \"\uf2fc\",\n    \"industry\": \"\uf2fd\",\n    \"info-outline\": \"\uf2fe\",\n    \"info\": \"\uf2ff\",\n    \"input\": \"\uf300\",\n    \"insert-chart\": \"\uf301\",\n    \"insert-comment\": \"\uf302\",\n    \"insert-drive-file\": \"\uf303\",\n    \"insert-emoticon\": \"\uf304\",\n    \"insert-invitation\": \"\uf305\",\n    \"insert-link\": \"\uf306\",\n    \"insert-photo\": \"\uf307\",\n    \"internet\": \"\uf308\",\n    \"invert-colors-off\": \"\uf309\",\n    \"invert-colors\": \"\uf30a\",\n    \"iso\": \"\uf30b\",\n    \"italic\": \"\uf30c\",\n    \"key\": \"\uf30d\",\n    \"keyboard-arrow-down\": \"\uf30e\",\n    \"keyboard-arrow-left\": \"\uf30f\",\n    \"keyboard-arrow-right\": \"\uf310\",\n    \"keyboard-arrow-up\": \"\uf311\",\n    \"keyboard-backspace\": \"\uf312\",\n    \"keyboard-capslock\": \"\uf313\",\n    \"keyboard-hide\": \"\uf314\",\n    \"keyboard-return\": \"\uf315\",\n    \"keyboard-tab\": \"\uf316\",\n    \"keyboard-voice\": \"\uf317\",\n    \"keyboard\": \"\uf318\",\n    \"kitchen\": \"\uf319\",\n    \"label-outline\": \"\uf31a\",\n    \"label\": \"\uf31b\",\n    \"landscape\": \"\uf31c\",\n    \"language\": \"\uf31d\",\n    \"laptop-chromebook\": \"\uf31e\",\n    \"laptop-mac\": \"\uf31f\",\n    \"laptop-windows\": \"\uf320\",\n    \"laptop\": \"\uf321\",\n    \"last-page\": \"\uf322\",\n    \"last\": \"\uf323\",\n    \"launch\": \"\uf324\",\n    \"layers-clear\": \"\uf325\",\n    \"layers\": \"\uf326\",\n    \"layout\": \"\uf327\",\n    \"leak-add\": \"\uf328\",\n    \"leak-remove\": \"\uf329\",\n    \"lens\": \"\uf32a\",\n    \"library-add\": \"\uf32b\",\n    \"library-books\": \"\uf32c\",\n    \"library-music\": \"\uf32d\",\n    \"life-ring\": \"\uf32e\",\n    \"lightbulb-outline\": \"\uf32f\",\n    \"lightbulb\": \"\uf330\",\n    \"line-chart\": \"\uf331\",\n    \"line-style\": \"\uf332\",\n    \"line-weight\": \"\uf333\",\n    \"linear-scale\": \"\uf334\",\n    \"link\": \"\uf335\",\n    \"linked-camera\": \"\uf336\",\n    \"list-ol\": \"\uf337\",\n    \"list\": \"\uf338\",\n    \"live-help\": \"\uf339\",\n    \"live-tv\": \"\uf33a\",\n    \"local-activity\": \"\uf33b\",\n    \"local-airport\": \"\uf33c\",\n    \"local-atm\": \"\uf33d\",\n    \"local-bar\": \"\uf33e\",\n    \"local-cafe\": \"\uf33f\",\n    \"local-car-wash\": \"\uf340\",\n    \"local-convenience-store\": \"\uf341\",\n    \"local-dining\": \"\uf342\",\n    \"local-drink\": \"\uf343\",\n    \"local-florist\": \"\uf344\",\n    \"local-gas-station\": \"\uf345\",\n    \"local-grocery-store\": \"\uf346\",\n    \"local-hospital\": \"\uf347\",\n    \"local-hotel\": \"\uf348\",\n    \"local-laundry-service\": \"\uf349\",\n    \"local-library\": \"\uf34a\",\n    \"local-mall\": \"\uf34b\",\n    \"local-movies\": \"\uf34c\",\n    \"local-offer\": \"\uf34d\",\n    \"local-parking\": \"\uf34e\",\n    \"local-pharmacy\": \"\uf34f\",\n    \"local-phone\": \"\uf350\",\n    \"local-pizza\": \"\uf351\",\n    \"local-play\": \"\uf352\",\n    \"local-post-office\": \"\uf353\",\n    \"local-printshop\": \"\uf354\",\n    \"local-see\": \"\uf355\",\n    \"local-shipping\": \"\uf356\",\n    \"local-taxi\": \"\uf357\",\n    \"location-arrow\": \"\uf358\",\n    \"location-city\": \"\uf359\",\n    \"location-disabled\": \"\uf35a\",\n    \"location-off\": \"\uf35b\",\n    \"location-on\": \"\uf35c\",\n    \"location-pin\": \"\uf35d\",\n    \"location-searching\": \"\uf35e\",\n    \"lock-open\": \"\uf35f\",\n    \"lock-outline\": \"\uf360\",\n    \"lock\": \"\uf361\",\n    \"long-arrow-down\": \"\uf362\",\n    \"long-arrow-left\": \"\uf363\",\n    \"long-arrow-right\": \"\uf364\",\n    \"long-arrow-up\": \"\uf365\",\n    \"looks-one\": \"\uf366\",\n    \"looks-two\": \"\uf367\",\n    \"looks\": \"\uf368\",\n    \"loop\": \"\uf369\",\n    \"loupe\": \"\uf36a\",\n    \"low-priority\": \"\uf36b\",\n    \"loyalty\": \"\uf36c\",\n    \"magic\": \"\uf36d\",\n    \"magnet\": \"\uf36e\",\n    \"mail-outline\": \"\uf36f\",\n    \"mail\": \"\uf370\",\n    \"map-marker\": \"\uf371\",\n    \"map-pin\": \"\uf372\",\n    \"map\": \"\uf373\",\n    \"markunread-mailbox\": \"\uf374\",\n    \"markunread\": \"\uf375\",\n    \"memory\": \"\uf376\",\n    \"menu\": \"\uf377\",\n    \"merge-type\": \"\uf378\",\n    \"merge\": \"\uf379\",\n    \"message\": \"\uf37a\",\n    \"mic-none\": \"\uf37b\",\n    \"mic-off\": \"\uf37c\",\n    \"mic\": \"\uf37d\",\n    \"microphone\": \"\uf37e\",\n    \"minimise\": \"\uf37f\",\n    \"minus-circle\": \"\uf380\",\n    \"minus-square\": \"\uf381\",\n    \"minus\": \"\uf382\",\n    \"mms\": \"\uf383\",\n    \"mode-comment\": \"\uf384\",\n    \"mode-edit\": \"\uf385\",\n    \"monetization-on\": \"\uf386\",\n    \"money-off\": \"\uf387\",\n    \"monochrome-photos\": \"\uf388\",\n    \"mood-bad\": \"\uf389\",\n    \"mood\": \"\uf38a\",\n    \"more-horiz\": \"\uf38b\",\n    \"more-vert\": \"\uf38c\",\n    \"more\": \"\uf38d\",\n    \"motorcycle\": \"\uf38e\",\n    \"mouse\": \"\uf38f\",\n    \"move-to-inbox\": \"\uf390\",\n    \"movie-creation\": \"\uf391\",\n    \"movie-filter\": \"\uf392\",\n    \"movie\": \"\uf393\",\n    \"mug\": \"\uf394\",\n    \"multiline-chart\": \"\uf395\",\n    \"music-note\": \"\uf396\",\n    \"music-video\": \"\uf397\",\n    \"music\": \"\uf398\",\n    \"my-location\": \"\uf399\",\n    \"nature-people\": \"\uf39a\",\n    \"nature\": \"\uf39b\",\n    \"navigate-before\": \"\uf39c\",\n    \"navigate-next\": \"\uf39d\",\n    \"navigation\": \"\uf39e\",\n    \"near-me\": \"\uf39f\",\n    \"network-cell\": \"\uf3a0\",\n    \"network-check\": \"\uf3a1\",\n    \"network-locked\": \"\uf3a2\",\n    \"network-wifi\": \"\uf3a3\",\n    \"new-releases\": \"\uf3a4\",\n    \"next-week\": \"\uf3a5\",\n    \"nfc\": \"\uf3a6\",\n    \"no-encryption\": \"\uf3a7\",\n    \"no-sim\": \"\uf3a8\",\n    \"not-interested\": \"\uf3a9\",\n    \"note-add\": \"\uf3aa\",\n    \"note\": \"\uf3ab\",\n    \"notepad\": \"\uf3ac\",\n    \"notifications-active\": \"\uf3ad\",\n    \"notifications-none\": \"\uf3ae\",\n    \"notifications-off\": \"\uf3af\",\n    \"notifications-paused\": \"\uf3b0\",\n    \"notifications\": \"\uf3b1\",\n    \"octagon\": \"\uf3b2\",\n    \"offline-pin\": \"\uf3b3\",\n    \"ondemand-video\": \"\uf3b4\",\n    \"opacity\": \"\uf3b5\",\n    \"open-envelope\": \"\uf3b6\",\n    \"open-in-browser\": \"\uf3b7\",\n    \"open-in-new\": \"\uf3b8\",\n    \"open-with\": \"\uf3b9\",\n    \"outdent\": \"\uf3ba\",\n    \"pages\": \"\uf3bb\",\n    \"pageview\": \"\uf3bc\",\n    \"palette\": \"\uf3bd\",\n    \"pan-tool\": \"\uf3be\",\n    \"panorama-fish-eye\": \"\uf3bf\",\n    \"panorama-horizontal\": \"\uf3c0\",\n    \"panorama-vertical\": \"\uf3c1\",\n    \"panorama-wide-angle\": \"\uf3c2\",\n    \"panorama\": \"\uf3c3\",\n    \"paper-plane\": \"\uf3c4\",\n    \"paperclip\": \"\uf3c5\",\n    \"party-mode\": \"\uf3c6\",\n    \"paste\": \"\uf3c7\",\n    \"pause-circle-filled\": \"\uf3c8\",\n    \"pause-circle-outline\": \"\uf3c9\",\n    \"pause\": \"\uf3ca\",\n    \"payment\": \"\uf3cb\",\n    \"pen\": \"\uf3cc\",\n    \"pencil-up\": \"\uf3cd\",\n    \"pencil\": \"\uf3ce\",\n    \"people-outline\": \"\uf3cf\",\n    \"people\": \"\uf3d0\",\n    \"perm-camera-mic\": \"\uf3d1\",\n    \"perm-contact-calendar\": \"\uf3d2\",\n    \"perm-data-setting\": \"\uf3d3\",\n    \"perm-device-information\": \"\uf3d4\",\n    \"perm-identity\": \"\uf3d5\",\n    \"perm-media\": \"\uf3d6\",\n    \"perm-phone-msg\": \"\uf3d7\",\n    \"perm-scan-wifi\": \"\uf3d8\",\n    \"person-add\": \"\uf3d9\",\n    \"person-outline\": \"\uf3da\",\n    \"person-pin-circle\": \"\uf3db\",\n    \"person-pin\": \"\uf3dc\",\n    \"person\": \"\uf3dd\",\n    \"personal-video\": \"\uf3de\",\n    \"pets\": \"\uf3df\",\n    \"phone-android\": \"\uf3e0\",\n    \"phone-bluetooth-speaker\": \"\uf3e1\",\n    \"phone-book\": \"\uf3e2\",\n    \"phone-forwarded\": \"\uf3e3\",\n    \"phone-in-talk\": \"\uf3e4\",\n    \"phone-iphone\": \"\uf3e5\",\n    \"phone-locked\": \"\uf3e6\",\n    \"phone-missed\": \"\uf3e7\",\n    \"phone-paused\": \"\uf3e8\",\n    \"phone\": \"\uf3e9\",\n    \"phonelink-erase\": \"\uf3ea\",\n    \"phonelink-lock\": \"\uf3eb\",\n    \"phonelink-off\": \"\uf3ec\",\n    \"phonelink-ring\": \"\uf3ed\",\n    \"phonelink-setup\": \"\uf3ee\",\n    \"phonelink\": \"\uf3ef\",\n    \"photo-album\": \"\uf3f0\",\n    \"photo-camera\": \"\uf3f1\",\n    \"photo-filter\": \"\uf3f2\",\n    \"photo-library\": \"\uf3f3\",\n    \"photo-size-select-actual\": \"\uf3f4\",\n    \"photo-size-select-large\": \"\uf3f5\",\n    \"photo-size-select-small\": \"\uf3f6\",\n    \"photo\": \"\uf3f7\",\n    \"picture-as-pdf\": \"\uf3f8\",\n    \"picture-in-picture-alt\": \"\uf3f9\",\n    \"picture-in-picture\": \"\uf3fa\",\n    \"picture\": \"\uf3fb\",\n    \"pie-chart-outlined\": \"\uf3fc\",\n    \"pie-chart\": \"\uf3fd\",\n    \"pin-drop\": \"\uf3fe\",\n    \"place\": \"\uf3ff\",\n    \"play-arrow\": \"\uf400\",\n    \"play-circle-filled\": \"\uf401\",\n    \"play-circle-outline\": \"\uf402\",\n    \"play-circle\": \"\uf403\",\n    \"play-for-work\": \"\uf404\",\n    \"play\": \"\uf405\",\n    \"playlist-add-check\": \"\uf406\",\n    \"playlist-add\": \"\uf407\",\n    \"playlist-play\": \"\uf408\",\n    \"plus-circle\": \"\uf409\",\n    \"plus-one\": \"\uf40a\",\n    \"plus-square\": \"\uf40b\",\n    \"plus\": \"\uf40c\",\n    \"poll\": \"\uf40d\",\n    \"polymer\": \"\uf40e\",\n    \"pool\": \"\uf40f\",\n    \"portable-wifi-off\": \"\uf410\",\n    \"portrait\": \"\uf411\",\n    \"power-input\": \"\uf412\",\n    \"power-off\": \"\uf413\",\n    \"power-settings-new\": \"\uf414\",\n    \"power\": \"\uf415\",\n    \"pregnant-woman\": \"\uf416\",\n    \"present-to-all\": \"\uf417\",\n    \"print-output\": \"\uf418\",\n    \"print\": \"\uf419\",\n    \"printer\": \"\uf41a\",\n    \"priority-high-12px\": \"\uf41b\",\n    \"priority-high\": \"\uf41c\",\n    \"public\": \"\uf41d\",\n    \"publish\": \"\uf41e\",\n    \"query-builder\": \"\uf41f\",\n    \"question-answer\": \"\uf420\",\n    \"question\": \"\uf421\",\n    \"queue-music\": \"\uf422\",\n    \"queue-play-next\": \"\uf423\",\n    \"queue\": \"\uf424\",\n    \"quote-left\": \"\uf425\",\n    \"quote-right\": \"\uf426\",\n    \"radio-button-checked\": \"\uf427\",\n    \"radio-button-unchecked\": \"\uf428\",\n    \"radio\": \"\uf429\",\n    \"random\": \"\uf42a\",\n    \"rate-review\": \"\uf42b\",\n    \"receipt\": \"\uf42c\",\n    \"recent-actors\": \"\uf42d\",\n    \"record-voice-over\": \"\uf42e\",\n    \"record\": \"\uf42f\",\n    \"redeem\": \"\uf430\",\n    \"redo\": \"\uf431\",\n    \"refresh\": \"\uf432\",\n    \"remove-circle-outline\": \"\uf433\",\n    \"remove-circle\": \"\uf434\",\n    \"remove-from-queue\": \"\uf435\",\n    \"remove-red-eye\": \"\uf436\",\n    \"remove-shopping-cart\": \"\uf437\",\n    \"remove\": \"\uf438\",\n    \"reorder\": \"\uf439\",\n    \"repeat-one\": \"\uf43a\",\n    \"repeat\": \"\uf43b\",\n    \"replay-10\": \"\uf43c\",\n    \"replay-30\": \"\uf43d\",\n    \"replay-5\": \"\uf43e\",\n    \"replay\": \"\uf43f\",\n    \"reply-all\": \"\uf440\",\n    \"reply\": \"\uf441\",\n    \"report-problem\": \"\uf442\",\n    \"report\": \"\uf443\",\n    \"restaurant-menu\": \"\uf444\",\n    \"restaurant\": \"\uf445\",\n    \"restore-page\": \"\uf446\",\n    \"restore\": \"\uf447\",\n    \"revert\": \"\uf448\",\n    \"rewind\": \"\uf449\",\n    \"ring-volume\": \"\uf44a\",\n    \"rocket\": \"\uf44b\",\n    \"room-service\": \"\uf44c\",\n    \"room\": \"\uf44d\",\n    \"rotate-90-degrees-ccw\": \"\uf44e\",\n    \"rotate-left\": \"\uf44f\",\n    \"rotate-right\": \"\uf450\",\n    \"rounded-corner\": \"\uf451\",\n    \"router\": \"\uf452\",\n    \"rowing\": \"\uf453\",\n    \"rss-feed\": \"\uf454\",\n    \"rule\": \"\uf455\",\n    \"rv-hookup\": \"\uf456\",\n    \"satellite\": \"\uf457\",\n    \"save\": \"\uf458\",\n    \"scale\": \"\uf459\",\n    \"scanner\": \"\uf45a\",\n    \"schedule\": \"\uf45b\",\n    \"school\": \"\uf45c\",\n    \"scissors\": \"\uf45d\",\n    \"screen-lock-landscape\": \"\uf45e\",\n    \"screen-lock-portrait\": \"\uf45f\",\n    \"screen-lock-rotation\": \"\uf460\",\n    \"screen-rotation\": \"\uf461\",\n    \"screen-share\": \"\uf462\",\n    \"sd-card\": \"\uf463\",\n    \"sd-storage\": \"\uf464\",\n    \"search-minus\": \"\uf465\",\n    \"search-plus\": \"\uf466\",\n    \"search\": \"\uf467\",\n    \"security\": \"\uf468\",\n    \"select-all\": \"\uf469\",\n    \"selector\": \"\uf46a\",\n    \"send\": \"\uf46b\",\n    \"sentiment-dissatisfied\": \"\uf46c\",\n    \"sentiment-neutral\": \"\uf46d\",\n    \"sentiment-satisfied\": \"\uf46e\",\n    \"sentiment-very-dissatisfied\": \"\uf46f\",\n    \"sentiment-very-satisfied\": \"\uf470\",\n    \"settings-applications\": \"\uf471\",\n    \"settings-backup-restore\": \"\uf472\",\n    \"settings-bluetooth\": \"\uf473\",\n    \"settings-brightness\": \"\uf474\",\n    \"settings-cell\": \"\uf475\",\n    \"settings-ethernet\": \"\uf476\",\n    \"settings-input-antenna\": \"\uf477\",\n    \"settings-input-component\": \"\uf478\",\n    \"settings-input-composite\": \"\uf479\",\n    \"settings-input-hdmi\": \"\uf47a\",\n    \"settings-input-svideo\": \"\uf47b\",\n    \"settings-overscan\": \"\uf47c\",\n    \"settings-phone\": \"\uf47d\",\n    \"settings-power\": \"\uf47e\",\n    \"settings-remote\": \"\uf47f\",\n    \"settings-system-daydream\": \"\uf480\",\n    \"settings-voice\": \"\uf481\",\n    \"settings\": \"\uf482\",\n    \"share-alt\": \"\uf483\",\n    \"share\": \"\uf484\",\n    \"shield\": \"\uf485\",\n    \"shop-two\": \"\uf486\",\n    \"shop\": \"\uf487\",\n    \"shopping-basket\": \"\uf488\",\n    \"shopping-cart\": \"\uf489\",\n    \"short-text\": \"\uf48a\",\n    \"show-chart\": \"\uf48b\",\n    \"shuffle\": \"\uf48c\",\n    \"sign-in\": \"\uf48d\",\n    \"sign-out\": \"\uf48e\",\n    \"signal-cellular-0-bar\": \"\uf48f\",\n    \"signal-cellular-1-bar\": \"\uf490\",\n    \"signal-cellular-2-bar\": \"\uf491\",\n    \"signal-cellular-3-bar\": \"\uf492\",\n    \"signal-cellular-4-bar\": \"\uf493\",\n    \"signal-cellular-no-sim\": \"\uf494\",\n    \"signal-cellular-null\": \"\uf495\",\n    \"signal-cellular-off\": \"\uf496\",\n    \"signal-wifi-0-bar\": \"\uf497\",\n    \"signal-wifi-1-bar-lock\": \"\uf498\",\n    \"signal-wifi-1-bar\": \"\uf499\",\n    \"signal-wifi-2-bar-lock\": \"\uf49a\",\n    \"signal-wifi-2-bar\": \"\uf49b\",\n    \"signal-wifi-3-bar-lock\": \"\uf49c\",\n    \"signal-wifi-3-bar\": \"\uf49d\",\n    \"signal-wifi-4-bar-lock\": \"\uf49e\",\n    \"signal-wifi-4-bar\": \"\uf49f\",\n    \"signal-wifi-off\": \"\uf4a0\",\n    \"signal\": \"\uf4a1\",\n    \"sim-card-alert\": \"\uf4a2\",\n    \"sim-card\": \"\uf4a3\",\n    \"sitemap\": \"\uf4a4\",\n    \"skip-next\": \"\uf4a5\",\n    \"skip-previous\": \"\uf4a6\",\n    \"slideshow\": \"\uf4a7\",\n    \"slow-motion-video\": \"\uf4a8\",\n    \"smartphone\": \"\uf4a9\",\n    \"smiley-happy\": \"\uf4aa\",\n    \"smiley-sad\": \"\uf4ab\",\n    \"smiley\": \"\uf4ac\",\n    \"smoke-free\": \"\uf4ad\",\n    \"smoking-rooms\": \"\uf4ae\",\n    \"sms-failed\": \"\uf4af\",\n    \"sms\": \"\uf4b0\",\n    \"snooze\": \"\uf4b1\",\n    \"snowflake\": \"\uf4b2\",\n    \"sort-by-alpha\": \"\uf4b3\",\n    \"sort\": \"\uf4b4\",\n    \"spa\": \"\uf4b5\",\n    \"space-bar\": \"\uf4b6\",\n    \"spanner\": \"\uf4b7\",\n    \"speaker-group\": \"\uf4b8\",\n    \"speaker-notes-off\": \"\uf4b9\",\n    \"speaker-notes\": \"\uf4ba\",\n    \"speaker-phone\": \"\uf4bb\",\n    \"speaker\": \"\uf4bc\",\n    \"spellcheck\": \"\uf4bd\",\n    \"spinner\": \"\uf4be\",\n    \"split\": \"\uf4bf\",\n    \"square\": \"\uf4c0\",\n    \"star-border\": \"\uf4c1\",\n    \"star-half\": \"\uf4c2\",\n    \"star\": \"\uf4c3\",\n    \"stars\": \"\uf4c4\",\n    \"stay-current-landscape\": \"\uf4c5\",\n    \"stay-current-portrait\": \"\uf4c6\",\n    \"stay-primary-landscape\": \"\uf4c7\",\n    \"stay-primary-portrait\": \"\uf4c8\",\n    \"steering-wheel\": \"\uf4c9\",\n    \"step-backward\": \"\uf4ca\",\n    \"step-forward\": \"\uf4cb\",\n    \"stop-screen-share\": \"\uf4cc\",\n    \"stop\": \"\uf4cd\",\n    \"storage\": \"\uf4ce\",\n    \"store-mall-directory\": \"\uf4cf\",\n    \"store\": \"\uf4d0\",\n    \"straighten\": \"\uf4d1\",\n    \"streetview\": \"\uf4d2\",\n    \"strikethrough-s\": \"\uf4d3\",\n    \"style\": \"\uf4d4\",\n    \"subdirectory-arrow-left\": \"\uf4d5\",\n    \"subdirectory-arrow-right\": \"\uf4d6\",\n    \"subject\": \"\uf4d7\",\n    \"subscript\": \"\uf4d8\",\n    \"subscriptions\": \"\uf4d9\",\n    \"subtitles\": \"\uf4da\",\n    \"subway\": \"\uf4db\",\n    \"suitcase\": \"\uf4dc\",\n    \"sun-o\": \"\uf4dd\",\n    \"sun\": \"\uf4de\",\n    \"superscript\": \"\uf4df\",\n    \"supervisor-account\": \"\uf4e0\",\n    \"surround-sound\": \"\uf4e1\",\n    \"swap-calls\": \"\uf4e2\",\n    \"swap-horiz\": \"\uf4e3\",\n    \"swap-vert\": \"\uf4e4\",\n    \"swap-vertical-circle\": \"\uf4e5\",\n    \"switch-camera\": \"\uf4e6\",\n    \"switch-video\": \"\uf4e7\",\n    \"sync-disabled\": \"\uf4e8\",\n    \"sync-problem\": \"\uf4e9\",\n    \"sync\": \"\uf4ea\",\n    \"system-update-alt\": \"\uf4eb\",\n    \"system-update\": \"\uf4ec\",\n    \"tab-unselected\": \"\uf4ed\",\n    \"tab\": \"\uf4ee\",\n    \"tablet-android\": \"\uf4ef\",\n    \"tablet-mac\": \"\uf4f0\",\n    \"tablet\": \"\uf4f1\",\n    \"tachometer\": \"\uf4f2\",\n    \"tag-faces\": \"\uf4f3\",\n    \"tag\": \"\uf4f4\",\n    \"tap-and-play\": \"\uf4f5\",\n    \"tap\": \"\uf4f6\",\n    \"telephone\": \"\uf4f7\",\n    \"television\": \"\uf4f8\",\n    \"terrain\": \"\uf4f9\",\n    \"text-fields\": \"\uf4fa\",\n    \"text-format\": \"\uf4fb\",\n    \"text-transform\": \"\uf4fc\",\n    \"textsms\": \"\uf4fd\",\n    \"texture\": \"\uf4fe\",\n    \"th-large\": \"\uf4ff\",\n    \"th\": \"\uf500\",\n    \"theaters\": \"\uf501\",\n    \"thumb-down\": \"\uf502\",\n    \"thumb-tack\": \"\uf503\",\n    \"thumb-up\": \"\uf504\",\n    \"thumbs-down\": \"\uf505\",\n    \"thumbs-up-down\": \"\uf506\",\n    \"thumbs-up\": \"\uf507\",\n    \"time-to-leave\": \"\uf508\",\n    \"timelapse\": \"\uf509\",\n    \"timeline\": \"\uf50a\",\n    \"timer-10\": \"\uf50b\",\n    \"timer-3\": \"\uf50c\",\n    \"timer-off\": \"\uf50d\",\n    \"timer\": \"\uf50e\",\n    \"tint\": \"\uf50f\",\n    \"title\": \"\uf510\",\n    \"toc\": \"\uf511\",\n    \"today\": \"\uf512\",\n    \"toll\": \"\uf513\",\n    \"tonality\": \"\uf514\",\n    \"touch-app\": \"\uf515\",\n    \"touch-id\": \"\uf516\",\n    \"toys\": \"\uf517\",\n    \"track-changes\": \"\uf518\",\n    \"traffic\": \"\uf519\",\n    \"train\": \"\uf51a\",\n    \"tram\": \"\uf51b\",\n    \"transfer-within-a-station\": \"\uf51c\",\n    \"transfer\": \"\uf51d\",\n    \"transform\": \"\uf51e\",\n    \"translate\": \"\uf51f\",\n    \"trash-covered\": \"\uf520\",\n    \"trash\": \"\uf521\",\n    \"trending-down\": \"\uf522\",\n    \"trending-flat\": \"\uf523\",\n    \"trending-up\": \"\uf524\",\n    \"tune\": \"\uf525\",\n    \"turned-in-not\": \"\uf526\",\n    \"turned-in\": \"\uf527\",\n    \"tv\": \"\uf528\",\n    \"twitch\": \"\uf529\",\n    \"umbrella\": \"\uf52a\",\n    \"unarchive\": \"\uf52b\",\n    \"underline\": \"\uf52c\",\n    \"undo\": \"\uf52d\",\n    \"unfold-less\": \"\uf52e\",\n    \"unfold-more\": \"\uf52f\",\n    \"unlock\": \"\uf530\",\n    \"unread-message\": \"\uf531\",\n    \"update\": \"\uf532\",\n    \"upload\": \"\uf533\",\n    \"usb\": \"\uf534\",\n    \"usd\": \"\uf535\",\n    \"user\": \"\uf536\",\n    \"verified-user\": \"\uf537\",\n    \"vertical-align-bottom\": \"\uf538\",\n    \"vertical-align-center\": \"\uf539\",\n    \"vertical-align-top\": \"\uf53a\",\n    \"vibration\": \"\uf53b\",\n    \"video-call\": \"\uf53c\",\n    \"video-camera\": \"\uf53d\",\n    \"video-label\": \"\uf53e\",\n    \"video-library\": \"\uf53f\",\n    \"video\": \"\uf540\",\n    \"videocam-off\": \"\uf541\",\n    \"videocam\": \"\uf542\",\n    \"videogame-asset\": \"\uf543\",\n    \"view-agenda\": \"\uf544\",\n    \"view-array\": \"\uf545\",\n    \"view-carousel\": \"\uf546\",\n    \"view-column\": \"\uf547\",\n    \"view-comfy\": \"\uf548\",\n    \"view-compact\": \"\uf549\",\n    \"view-day\": \"\uf54a\",\n    \"view-headline\": \"\uf54b\",\n    \"view-list\": \"\uf54c\",\n    \"view-module\": \"\uf54d\",\n    \"view-quilt\": \"\uf54e\",\n    \"view-stream\": \"\uf54f\",\n    \"view-week\": \"\uf550\",\n    \"vignette\": \"\uf551\",\n    \"visibility-off\": \"\uf552\",\n    \"visibility\": \"\uf553\",\n    \"voice-chat\": \"\uf554\",\n    \"voicemail\": \"\uf555\",\n    \"volume-down\": \"\uf556\",\n    \"volume-mute\": \"\uf557\",\n    \"volume-off\": \"\uf558\",\n    \"volume-up\": \"\uf559\",\n    \"volume-zero\": \"\uf55a\",\n    \"vpn-key\": \"\uf55b\",\n    \"vpn-lock\": \"\uf55c\",\n    \"wallet\": \"\uf55d\",\n    \"wallpaper\": \"\uf55e\",\n    \"wand\": \"\uf55f\",\n    \"warning\": \"\uf560\",\n    \"watch-later\": \"\uf561\",\n    \"watch\": \"\uf562\",\n    \"wb-auto\": \"\uf563\",\n    \"wb-cloudy\": \"\uf564\",\n    \"wb-incandescent\": \"\uf565\",\n    \"wb-iridescent\": \"\uf566\",\n    \"wb-sunny\": \"\uf567\",\n    \"wc\": \"\uf568\",\n    \"weather-rain\": \"\uf569\",\n    \"weather-snowfall\": \"\uf56a\",\n    \"weather-sun\": \"\uf56b\",\n    \"weather-thunder\": \"\uf56c\",\n    \"web-asset\": \"\uf56d\",\n    \"web\": \"\uf56e\",\n    \"weekend\": \"\uf56f\",\n    \"whatshot\": \"\uf570\",\n    \"widgets\": \"\uf571\",\n    \"wifi-lock\": \"\uf572\",\n    \"wifi-tethering\": \"\uf573\",\n    \"wifi\": \"\uf574\",\n    \"window\": \"\uf575\",\n    \"windows\": \"\uf576\",\n    \"work\": \"\uf577\",\n    \"wrap-text\": \"\uf578\",\n    \"wrench\": \"\uf579\",\n    \"youtube-searched-for\": \"\uf57a\",\n    \"zoom-in\": \"\uf57b\",\n    \"zoom-out-map\": \"\uf57c\",\n    \"zoom-out\": \"\uf57d\"\n};\n\nexport default createIconSet(glyphMap, 'wavicon', font);\n", "wavemaker-rn-runtime/src/components/basic/icon/streamline-regular-icon/streamline-regular-icon.component.tsx": "\n/*******************************************************\n * Don't make any changes.\n * This is a generated file.\n * See wavicon.generator.js\n ********************************************************/\n\nimport font from './streamline-regular-icon.ttf';\nimport createIconSet from '@expo/vector-icons/build/createIconSet';\n\nexport const glyphMap: any = {\n    \"accounting-bill\": \"\uf101\",\n    \"add\": \"\uf102\",\n    \"airplane-mode\": \"\uf103\",\n    \"alarm-bell-off\": \"\uf104\",\n    \"alarm-bell\": \"\uf105\",\n    \"alert-triangle\": \"\uf106\",\n    \"analytics-bars\": \"\uf107\",\n    \"analytics-pie\": \"\uf108\",\n    \"android\": \"\uf109\",\n    \"announcement\": \"\uf10a\",\n    \"apple\": \"\uf10b\",\n    \"at\": \"\uf10c\",\n    \"attachment\": \"\uf10d\",\n    \"award\": \"\uf10e\",\n    \"bank\": \"\uf10f\",\n    \"bin\": \"\uf110\",\n    \"bluetooth\": \"\uf111\",\n    \"bookmarks\": \"\uf112\",\n    \"button-fast-forward\": \"\uf113\",\n    \"button-next\": \"\uf114\",\n    \"button-pause\": \"\uf115\",\n    \"button-play\": \"\uf116\",\n    \"button-previous\": \"\uf117\",\n    \"button-rewind\": \"\uf118\",\n    \"button-stop\": \"\uf119\",\n    \"calculator\": \"\uf11a\",\n    \"calendar\": \"\uf11b\",\n    \"camera\": \"\uf11c\",\n    \"check\": \"\uf11d\",\n    \"close\": \"\uf11e\",\n    \"cloud-add\": \"\uf11f\",\n    \"cloud-data-transfer\": \"\uf120\",\n    \"cloud-download\": \"\uf121\",\n    \"cloud-off\": \"\uf122\",\n    \"cloud-remove\": \"\uf123\",\n    \"cloud-upload\": \"\uf124\",\n    \"cloud\": \"\uf125\",\n    \"computer-bug\": \"\uf126\",\n    \"computer-chip\": \"\uf127\",\n    \"css\": \"\uf128\",\n    \"currency-dollar\": \"\uf129\",\n    \"currency-euro\": \"\uf12a\",\n    \"currency-pound\": \"\uf12b\",\n    \"currency-rupee\": \"\uf12c\",\n    \"currency-yuan\": \"\uf12d\",\n    \"customer-support\": \"\uf12e\",\n    \"dashboard\": \"\uf12f\",\n    \"data-transfer\": \"\uf130\",\n    \"database-add\": \"\uf131\",\n    \"database-delete\": \"\uf132\",\n    \"database-remove\": \"\uf133\",\n    \"database\": \"\uf134\",\n    \"discount\": \"\uf135\",\n    \"download-1\": \"\uf136\",\n    \"download-2\": \"\uf137\",\n    \"duplicate\": \"\uf138\",\n    \"email-read\": \"\uf139\",\n    \"email-reply-all\": \"\uf13a\",\n    \"email-reply\": \"\uf13b\",\n    \"email-send-1\": \"\uf13c\",\n    \"email-send-2\": \"\uf13d\",\n    \"email-unread\": \"\uf13e\",\n    \"expand-1\": \"\uf13f\",\n    \"expand-2\": \"\uf140\",\n    \"face-id\": \"\uf141\",\n    \"facebook\": \"\uf142\",\n    \"file-add\": \"\uf143\",\n    \"file-attachment\": \"\uf144\",\n    \"file-copy\": \"\uf145\",\n    \"file-delete\": \"\uf146\",\n    \"file-empty\": \"\uf147\",\n    \"file-remove\": \"\uf148\",\n    \"file-zip\": \"\uf149\",\n    \"filter\": \"\uf14a\",\n    \"finger-dial\": \"\uf14b\",\n    \"flash-off\": \"\uf14c\",\n    \"flash-on\": \"\uf14d\",\n    \"floppy-disk\": \"\uf14e\",\n    \"folder-add\": \"\uf14f\",\n    \"folder-delete\": \"\uf150\",\n    \"folder-duplicate\": \"\uf151\",\n    \"folder-empty\": \"\uf152\",\n    \"folder-remove\": \"\uf153\",\n    \"folder-zip\": \"\uf154\",\n    \"font-size\": \"\uf155\",\n    \"google\": \"\uf156\",\n    \"graph-ascend\": \"\uf157\",\n    \"graph-descend\": \"\uf158\",\n    \"hamburger-menu\": \"\uf159\",\n    \"hand-cursor\": \"\uf15a\",\n    \"hashtag\": \"\uf15b\",\n    \"headphones\": \"\uf15c\",\n    \"hierarchy-1\": \"\uf15d\",\n    \"hierarchy-2\": \"\uf15e\",\n    \"hierarchy-3\": \"\uf15f\",\n    \"hierarchy-4\": \"\uf160\",\n    \"hierarchy-5\": \"\uf161\",\n    \"hierarchy-6\": \"\uf162\",\n    \"home\": \"\uf163\",\n    \"html\": \"\uf164\",\n    \"hyperlink-broken\": \"\uf165\",\n    \"hyperlink\": \"\uf166\",\n    \"keyboard-arrow-down\": \"\uf167\",\n    \"keyboard-arrow-left\": \"\uf168\",\n    \"keyboard-arrow-return\": \"\uf169\",\n    \"keyboard-arrow-right\": \"\uf16a\",\n    \"keyboard-arrow-up\": \"\uf16b\",\n    \"keyboard\": \"\uf16c\",\n    \"landscape\": \"\uf16d\",\n    \"laptop\": \"\uf16e\",\n    \"layout-1\": \"\uf16f\",\n    \"layout-2\": \"\uf170\",\n    \"layout-3\": \"\uf171\",\n    \"layout-4\": \"\uf172\",\n    \"layout-5\": \"\uf173\",\n    \"layout-6\": \"\uf174\",\n    \"layout-7\": \"\uf175\",\n    \"layout-left\": \"\uf176\",\n    \"layout-three-columns\": \"\uf177\",\n    \"layout-top\": \"\uf178\",\n    \"layout-two-columns\": \"\uf179\",\n    \"like\": \"\uf17a\",\n    \"linkedin\": \"\uf17b\",\n    \"list-bullets\": \"\uf17c\",\n    \"list-numbers\": \"\uf17d\",\n    \"loading-half\": \"\uf17e\",\n    \"loading\": \"\uf17f\",\n    \"lock\": \"\uf180\",\n    \"login\": \"\uf181\",\n    \"logout\": \"\uf182\",\n    \"medical-bag\": \"\uf183\",\n    \"medical-ribbon\": \"\uf184\",\n    \"microsoft\": \"\uf185\",\n    \"module-1\": \"\uf186\",\n    \"module-2\": \"\uf187\",\n    \"monitor\": \"\uf188\",\n    \"more-horizontal\": \"\uf189\",\n    \"more-vertical\": \"\uf18a\",\n    \"mouse-cursor\": \"\uf18b\",\n    \"mouse\": \"\uf18c\",\n    \"music-note-1\": \"\uf18d\",\n    \"music-note-2\": \"\uf18e\",\n    \"network\": \"\uf18f\",\n    \"paragraph-center-align\": \"\uf190\",\n    \"paragraph-left-align\": \"\uf191\",\n    \"paragraph-right-align\": \"\uf192\",\n    \"paypal\": \"\uf193\",\n    \"performance-decrease\": \"\uf194\",\n    \"performance-increase\": \"\uf195\",\n    \"pin\": \"\uf196\",\n    \"power\": \"\uf197\",\n    \"printer\": \"\uf198\",\n    \"programming-code-script\": \"\uf199\",\n    \"qr-code\": \"\uf19a\",\n    \"receipt-slip\": \"\uf19b\",\n    \"redo\": \"\uf19c\",\n    \"refresh\": \"\uf19d\",\n    \"remove\": \"\uf19e\",\n    \"rss-feed\": \"\uf19f\",\n    \"scissors\": \"\uf1a0\",\n    \"screen\": \"\uf1a1\",\n    \"scroll-horizontal\": \"\uf1a2\",\n    \"scroll-vertical\": \"\uf1a3\",\n    \"search\": \"\uf1a4\",\n    \"server\": \"\uf1a5\",\n    \"settings-horizontal\": \"\uf1a6\",\n    \"settings-vertical\": \"\uf1a7\",\n    \"settings\": \"\uf1a8\",\n    \"share\": \"\uf1a9\",\n    \"shop\": \"\uf1aa\",\n    \"shopping-basket\": \"\uf1ab\",\n    \"shopping-cart\": \"\uf1ac\",\n    \"shrink\": \"\uf1ad\",\n    \"signal-full\": \"\uf1ae\",\n    \"signal-loading\": \"\uf1af\",\n    \"startup\": \"\uf1b0\",\n    \"subscript\": \"\uf1b1\",\n    \"subtract\": \"\uf1b2\",\n    \"superscript\": \"\uf1b3\",\n    \"tags\": \"\uf1b4\",\n    \"text-bold\": \"\uf1b5\",\n    \"text-italic\": \"\uf1b6\",\n    \"text-strikethrough\": \"\uf1b7\",\n    \"text-style\": \"\uf1b8\",\n    \"text-underline\": \"\uf1b9\",\n    \"time\": \"\uf1ba\",\n    \"twitter\": \"\uf1bb\",\n    \"undo\": \"\uf1bc\",\n    \"upload-1\": \"\uf1bd\",\n    \"upload-2\": \"\uf1be\",\n    \"usb\": \"\uf1bf\",\n    \"view-off\": \"\uf1c0\",\n    \"view-on\": \"\uf1c1\",\n    \"volume-decrease\": \"\uf1c2\",\n    \"volume-full\": \"\uf1c3\",\n    \"volume-increase\": \"\uf1c4\",\n    \"volume-low\": \"\uf1c5\",\n    \"volume-off\": \"\uf1c6\",\n    \"widget-add\": \"\uf1c7\",\n    \"widget-remove\": \"\uf1c8\",\n    \"wifi\": \"\uf1c9\",\n    \"wireless-mouse\": \"\uf1ca\",\n    \"youtube\": \"\uf1cb\",\n    \"zoom-in\": \"\uf1cc\",\n    \"zoom-out\": \"\uf1cd\"\n};\n\nexport default createIconSet(glyphMap, 'streamline-regular-icon', font);\n", "wavemaker-rn-runtime/src/components/basic/icon/streamline-light-icon/streamline-light-icon.component.tsx": "\n/*******************************************************\n * Don't make any changes.\n * This is a generated file.\n * See wavicon.generator.js\n ********************************************************/\n\nimport font from './streamline-light-icon.ttf';\nimport createIconSet from '@expo/vector-icons/build/createIconSet';\n\nexport const glyphMap: any = {\n    \"accounting-bill\": \"\uf101\",\n    \"add\": \"\uf102\",\n    \"airplane-mode\": \"\uf103\",\n    \"alarm-bell-off\": \"\uf104\",\n    \"alarm-bell\": \"\uf105\",\n    \"alert-triangle\": \"\uf106\",\n    \"analytics-bars\": \"\uf107\",\n    \"analytics-pie\": \"\uf108\",\n    \"android\": \"\uf109\",\n    \"announcement\": \"\uf10a\",\n    \"apple\": \"\uf10b\",\n    \"at\": \"\uf10c\",\n    \"attachment\": \"\uf10d\",\n    \"award\": \"\uf10e\",\n    \"bank\": \"\uf10f\",\n    \"bin-1\": \"\uf110\",\n    \"bin-2\": \"\uf111\",\n    \"bluetooth\": \"\uf112\",\n    \"bookmarks\": \"\uf113\",\n    \"button-fast-forward\": \"\uf114\",\n    \"button-next\": \"\uf115\",\n    \"button-pause\": \"\uf116\",\n    \"button-play\": \"\uf117\",\n    \"button-previous\": \"\uf118\",\n    \"button-rewind\": \"\uf119\",\n    \"button-stop\": \"\uf11a\",\n    \"calculator\": \"\uf11b\",\n    \"calendar\": \"\uf11c\",\n    \"camera\": \"\uf11d\",\n    \"check\": \"\uf11e\",\n    \"close\": \"\uf11f\",\n    \"cloud-add\": \"\uf120\",\n    \"cloud-data-transfer\": \"\uf121\",\n    \"cloud-download\": \"\uf122\",\n    \"cloud-off\": \"\uf123\",\n    \"cloud-remove\": \"\uf124\",\n    \"cloud-upload\": \"\uf125\",\n    \"cloud\": \"\uf126\",\n    \"computer-bug\": \"\uf127\",\n    \"computer-chip\": \"\uf128\",\n    \"credit-card\": \"\uf129\",\n    \"css\": \"\uf12a\",\n    \"currency-dollar\": \"\uf12b\",\n    \"currency-euro\": \"\uf12c\",\n    \"currency-pound\": \"\uf12d\",\n    \"currency-rupee\": \"\uf12e\",\n    \"currency-yuan\": \"\uf12f\",\n    \"customer-support\": \"\uf130\",\n    \"dashboard\": \"\uf131\",\n    \"data-transfer\": \"\uf132\",\n    \"database-add\": \"\uf133\",\n    \"database-delete\": \"\uf134\",\n    \"database-remove\": \"\uf135\",\n    \"database\": \"\uf136\",\n    \"disabilty-wheelchair\": \"\uf137\",\n    \"discount\": \"\uf138\",\n    \"download-1\": \"\uf139\",\n    \"download-2\": \"\uf13a\",\n    \"duplicate\": \"\uf13b\",\n    \"email-read\": \"\uf13c\",\n    \"email-reply-all\": \"\uf13d\",\n    \"email-reply\": \"\uf13e\",\n    \"email-send-1\": \"\uf13f\",\n    \"email-send-2\": \"\uf140\",\n    \"email-unread\": \"\uf141\",\n    \"expand-1\": \"\uf142\",\n    \"expand-2\": \"\uf143\",\n    \"face-id\": \"\uf144\",\n    \"facebook\": \"\uf145\",\n    \"file-add\": \"\uf146\",\n    \"file-attachment\": \"\uf147\",\n    \"file-copy\": \"\uf148\",\n    \"file-delete\": \"\uf149\",\n    \"file-empty\": \"\uf14a\",\n    \"file-remove\": \"\uf14b\",\n    \"file-zip\": \"\uf14c\",\n    \"filter\": \"\uf14d\",\n    \"finger-dial\": \"\uf14e\",\n    \"flash-off\": \"\uf14f\",\n    \"flash-on\": \"\uf150\",\n    \"floppy-disk\": \"\uf151\",\n    \"folder-add\": \"\uf152\",\n    \"folder-delete\": \"\uf153\",\n    \"folder-duplicate\": \"\uf154\",\n    \"folder-empty\": \"\uf155\",\n    \"folder-remove\": \"\uf156\",\n    \"folder-zip\": \"\uf157\",\n    \"font-size\": \"\uf158\",\n    \"google\": \"\uf159\",\n    \"graph-ascend\": \"\uf15a\",\n    \"graph-descend\": \"\uf15b\",\n    \"hamburger-menu\": \"\uf15c\",\n    \"hand-cursor\": \"\uf15d\",\n    \"hashtag\": \"\uf15e\",\n    \"headphones\": \"\uf15f\",\n    \"hierarchy-1\": \"\uf160\",\n    \"hierarchy-2\": \"\uf161\",\n    \"hierarchy-3\": \"\uf162\",\n    \"hierarchy-4\": \"\uf163\",\n    \"hierarchy-5\": \"\uf164\",\n    \"hierarchy-6\": \"\uf165\",\n    \"home-1\": \"\uf166\",\n    \"home-2\": \"\uf167\",\n    \"html\": \"\uf168\",\n    \"hyperlink-broken\": \"\uf169\",\n    \"hyperlink\": \"\uf16a\",\n    \"keyboard-arrow-down\": \"\uf16b\",\n    \"keyboard-arrow-left\": \"\uf16c\",\n    \"keyboard-arrow-return\": \"\uf16d\",\n    \"keyboard-arrow-right\": \"\uf16e\",\n    \"keyboard-arrow-up\": \"\uf16f\",\n    \"keyboard\": \"\uf170\",\n    \"landscape\": \"\uf171\",\n    \"laptop\": \"\uf172\",\n    \"layout-1\": \"\uf173\",\n    \"layout-2\": \"\uf174\",\n    \"layout-3\": \"\uf175\",\n    \"layout-4\": \"\uf176\",\n    \"layout-5\": \"\uf177\",\n    \"layout-6\": \"\uf178\",\n    \"layout-7\": \"\uf179\",\n    \"layout-left\": \"\uf17a\",\n    \"layout-right\": \"\uf17b\",\n    \"layout-three-columns\": \"\uf17c\",\n    \"layout-top\": \"\uf17d\",\n    \"layout-two-columns\": \"\uf17e\",\n    \"like\": \"\uf17f\",\n    \"likedin\": \"\uf180\",\n    \"list-bullets\": \"\uf181\",\n    \"list-numbers\": \"\uf182\",\n    \"loading-half\": \"\uf183\",\n    \"loading\": \"\uf184\",\n    \"lock\": \"\uf185\",\n    \"login\": \"\uf186\",\n    \"logout\": \"\uf187\",\n    \"medical-bag\": \"\uf188\",\n    \"medical-ribbon\": \"\uf189\",\n    \"microsoft\": \"\uf18a\",\n    \"module-1\": \"\uf18b\",\n    \"module-2\": \"\uf18c\",\n    \"monitor\": \"\uf18d\",\n    \"more-menu-horizontal\": \"\uf18e\",\n    \"more-menu-vertical\": \"\uf18f\",\n    \"mouse-cursor\": \"\uf190\",\n    \"mouse\": \"\uf191\",\n    \"music-note-1\": \"\uf192\",\n    \"music-note-2\": \"\uf193\",\n    \"network\": \"\uf194\",\n    \"otp\": \"\uf195\",\n    \"paragraph-centre-align\": \"\uf196\",\n    \"paragraph-left-align\": \"\uf197\",\n    \"paragraph-right-align\": \"\uf198\",\n    \"paypal\": \"\uf199\",\n    \"performace-decrease\": \"\uf19a\",\n    \"performance-increase\": \"\uf19b\",\n    \"phone-ringing\": \"\uf19c\",\n    \"phone\": \"\uf19d\",\n    \"pin\": \"\uf19e\",\n    \"power\": \"\uf19f\",\n    \"printer\": \"\uf1a0\",\n    \"programming-code-script\": \"\uf1a1\",\n    \"qr-code\": \"\uf1a2\",\n    \"receipt-slip\": \"\uf1a3\",\n    \"redo\": \"\uf1a4\",\n    \"refresh\": \"\uf1a5\",\n    \"remove\": \"\uf1a6\",\n    \"rss-feed\": \"\uf1a7\",\n    \"scissors\": \"\uf1a8\",\n    \"screen\": \"\uf1a9\",\n    \"scroll-horizontal\": \"\uf1aa\",\n    \"scroll-vertical\": \"\uf1ab\",\n    \"search\": \"\uf1ac\",\n    \"server\": \"\uf1ad\",\n    \"settigs-horizontal\": \"\uf1ae\",\n    \"settigs-vertical\": \"\uf1af\",\n    \"settings\": \"\uf1b0\",\n    \"share\": \"\uf1b1\",\n    \"shop\": \"\uf1b2\",\n    \"shopping-basket\": \"\uf1b3\",\n    \"shopping-cart\": \"\uf1b4\",\n    \"shrink\": \"\uf1b5\",\n    \"signal-full\": \"\uf1b6\",\n    \"signal-loading\": \"\uf1b7\",\n    \"smiley-neutral\": \"\uf1b8\",\n    \"smiley-sad\": \"\uf1b9\",\n    \"smiley-smile\": \"\uf1ba\",\n    \"startup\": \"\uf1bb\",\n    \"subscript\": \"\uf1bc\",\n    \"subtract\": \"\uf1bd\",\n    \"superscript\": \"\uf1be\",\n    \"tags\": \"\uf1bf\",\n    \"text-bold\": \"\uf1c0\",\n    \"text-box-1\": \"\uf1c1\",\n    \"text-box-2\": \"\uf1c2\",\n    \"text-box-typing\": \"\uf1c3\",\n    \"text-italic\": \"\uf1c4\",\n    \"text-strikethrough\": \"\uf1c5\",\n    \"text-style\": \"\uf1c6\",\n    \"text-underline\": \"\uf1c7\",\n    \"thumbs-down\": \"\uf1c8\",\n    \"thumbs-up\": \"\uf1c9\",\n    \"time\": \"\uf1ca\",\n    \"twitter\": \"\uf1cb\",\n    \"undo\": \"\uf1cc\",\n    \"unlock\": \"\uf1cd\",\n    \"upload-1\": \"\uf1ce\",\n    \"upload-2\": \"\uf1cf\",\n    \"usb\": \"\uf1d0\",\n    \"user-add\": \"\uf1d1\",\n    \"user-delete\": \"\uf1d2\",\n    \"user-multiple\": \"\uf1d3\",\n    \"user-remove\": \"\uf1d4\",\n    \"user\": \"\uf1d5\",\n    \"video-off\": \"\uf1d6\",\n    \"video\": \"\uf1d7\",\n    \"view-off\": \"\uf1d8\",\n    \"view-on\": \"\uf1d9\",\n    \"volume-decrease\": \"\uf1da\",\n    \"volume-full\": \"\uf1db\",\n    \"volume-increase\": \"\uf1dc\",\n    \"volume-low\": \"\uf1dd\",\n    \"volume-medium\": \"\uf1de\",\n    \"volume-off\": \"\uf1df\",\n    \"wallet\": \"\uf1e0\",\n    \"widget-add\": \"\uf1e1\",\n    \"widget-remove\": \"\uf1e2\",\n    \"wifi\": \"\uf1e3\",\n    \"wireless-mouse\": \"\uf1e4\",\n    \"write-1\": \"\uf1e5\",\n    \"write-2\": \"\uf1e6\",\n    \"youtube\": \"\uf1e7\",\n    \"zoom-in\": \"\uf1e8\",\n    \"zoom-out\": \"\uf1e9\"\n};\n\nexport default createIconSet(glyphMap, 'streamline-light-icon', font);\n", "wavemaker-rn-runtime/src/components/basic/modal/modal.component.tsx": "import React from 'react';\nimport { View, Modal as ReactModal } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmModalProps from './modal.props';\nimport { DEFAULT_CLASS, WmModalStyles } from './modal.styles';\n\nexport class WmModalState extends BaseComponentState<WmModalProps> {\n\n}\n\nexport default class WmModal extends BaseComponent<WmModalProps, WmModalState, WmModalStyles> {\n\n  constructor(props: WmModalProps) {\n    super(props, DEFAULT_CLASS, new WmModalProps());\n  }\n\n  renderWidget(props: WmModalProps) {\n    return React.createElement(View, {\n      style: this.styles.root,\n      onLayout: (event) => this.handleLayout(event)\n    }, React.createElement(ReactModal, {\n      animationType: props.animationType as any,\n      transparent: true,\n      //@ts-ignore\n      style: this.styles.content,\n      onLayout: (event) => this.handleLayout(event)\n    }, props.children));\n  }\n}\n", "wavemaker-rn-runtime/src/components/basic/modal/modal.styles.ts": "import BASE_THEME, { AllStyle }  from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\n\nexport type WmModalStyles = BaseStyles & {\n    content: AllStyle,\n};\n\nexport const DEFAULT_CLASS = 'app-modal';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmModalStyles = defineStyles({\n        root: {\n            backgroundColor: 'rgba(0, 0, 0, 0)'\n        },\n        text: {},\n        content: {\n            borderColor: 'rgba(0, 0, 0, 0)',\n            borderWidth: 0\n        }\n    });\n\n    addStyle('centered-modal', '', {\n        root: {\n            flex: 1,\n            justifyContent: \"center\",\n            alignItems: \"center\",\n            alignSelf: 'center',\n        },\n        text: {},\n        content: {\n            alignSelf: 'center'\n        }\n    } as WmModalStyles);\n\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/basic/modal/modal.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmModalProps extends BaseProps {\n    children = null as any;\n    animationType? = 'slide';\n}", "wavemaker-rn-runtime/src/components/basic/custom/custom.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmSkeletonStyles } from '../skeleton/skeleton.styles';\n\n\nexport type WmCustomStyles = BaseStyles & {\n    skeleton: WmSkeletonStyles;\n}\n\nexport const DEFAULT_CLASS = 'app-custom';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles = defineStyles<WmCustomStyles>({\n        root: {},\n        text: {},\n        skeleton: {\n            root: {\n              width: 96,\n              height: 48,\n              borderRadius: 4\n            }\n          } as WmSkeletonStyles\n    });\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/basic/custom/custom.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmCustomProps extends BaseProps {\n    renderview:Function = () => {return null};\n    children? = null as any;\n    skeletonheight?: string = null as any;\n    skeletonwidth?: string = null as any;\n}", "wavemaker-rn-runtime/src/components/basic/custom/custom.component.tsx": "import React from 'react';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmCustomProps from './custom.props';\nimport { DEFAULT_CLASS, WmCustomStyles } from './custom.styles';\nimport { DimensionValue, Text, View } from 'react-native';\nimport { createSkeleton } from '../skeleton/skeleton.component';\n\n\nexport class WmCustomState extends BaseComponentState<WmCustomProps> { }\n\nexport default class WmCustom extends BaseComponent<WmCustomProps, WmCustomState, WmCustomStyles> {\n\n  constructor(props: WmCustomProps) {\n    super(props, DEFAULT_CLASS, new WmCustomProps(), new WmCustomState());\n  }\n\n  public renderSkeleton(prop: WmCustomProps) {\n    return createSkeleton(this.theme, this.styles.skeleton, {\n      ...this.styles.root,\n      width: (this.props.skeletonwidth || this.styles.root.width) as DimensionValue,\n      height: (this.props.skeletonheight || this.styles.root.height) as DimensionValue\n    });\n  }\n\n  renderWidget(props: WmCustomProps) {\n    return (\n      <View \n        style={this.styles.root}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        {this._background}\n        {props.renderview(props)}\n      </View>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\n\nimport WmNavItem from '@wavemaker/app-rn-runtime/components/navigation/navitem/navitem.component';\nimport { BaseNavComponent, NavigationDataItem, BaseNavState } from '@wavemaker/app-rn-runtime/components/navigation/basenav/basenav.component';\nimport { BaseNavProps } from '@wavemaker/app-rn-runtime/components/navigation/basenav/basenav.props';\n\nimport WmNavbarProps from './navbar.props';\nimport { DEFAULT_CLASS, WmNavbarStyles } from './navbar.styles';\n\nclass WmNavbarState<T extends BaseNavProps> extends BaseNavState<T> {}\n\nexport default class WmNavbar extends BaseNavComponent<WmNavbarProps, WmNavbarState<WmNavbarProps>, WmNavbarStyles> {\n  constructor(props: WmNavbarProps) {\n    super(props, DEFAULT_CLASS, new WmNavbarProps(), new WmNavbarState());\n  }\n\n  computeItemStyles(props: WmNavbarProps) {\n    let activeItemStyles = this.theme.getStyle('app-navitem-active');\n    let itemStyles = this.theme.getStyle('app-navitem');\n    const indentStyle =  props.indent ? {\n      navAnchorItem: {\n        root: {\n          paddingLeft: props.indent\n        }\n      }\n    } :  null;\n    if (props.ischildnav) {\n      itemStyles = this.theme.mergeStyle({}, itemStyles, this.theme.getStyle('app-navitem-child'));\n    }\n    activeItemStyles = this.theme.mergeStyle({}, activeItemStyles, indentStyle);\n    itemStyles = this.theme.mergeStyle({}, itemStyles, indentStyle);\n    return {activeItemStyles, itemStyles};\n  }\n\n  renderNavItem(item: NavigationDataItem, index: number, props: WmNavbarProps) {\n    const indent = this.styles.childNav.paddingLeft as number || 0;\n    const {activeItemStyles, itemStyles} = this.computeItemStyles(props);\n    return (\n      <View style={this.styles.navitem} key={item.key} >\n        <WmNavItem item={item}\n          id={this.getTestId('child'+ index)}\n          onSelect={props.onSelect}\n          styles={item.isactive ? activeItemStyles: itemStyles}\n          getDisplayExpression={this.props.getDisplayExpression} \n          view={item.childnavigation ? 'dropdown' : 'anchor'}>\n          {item.childnavigation && (\n            <WmNavbar\n              id={this.getTestId('child'+ index +'_menu')}\n              dataset={item.childnavigation}\n              type={props.type}\n              styles={this.styles}\n              layout={props.layout}\n              itemlabel={props.itemlabel}\n              itembadge={props.itembadge}\n              itemicon={props.itemicon}\n              itemchildren={props.itemchildren}\n              itemlink={props.itemlink}\n              isactive={props.isactive}\n              indent={props.indent || indent + indent}\n              getDisplayExpression={this.props.getDisplayExpression} \n              ischildnav={true}\n              onSelect={props.onSelect}>\n            </WmNavbar>)}\n        </WmNavItem>\n      </View>\n    );\n  }\n\n  renderWidget(props: WmNavbarProps) {\n    const navItems = this.state.dataItems;\n    let childElements = props.children;\n    const styleName = props.layout + 'Nav';\n\n    return (\n      <View style={[this.theme.getStyle(styleName), this.styles.nav]} onLayout={(event) => this.handleLayout(event)}>\n          { navItems && navItems.length ? navItems.map((item, index) => {\n              return this.renderNavItem(item, index, props);\n            }) : childElements\n          }\n      </View>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.styles.ts": "import BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { ViewStyle } from 'react-native';\n\nexport type WmNavbarStyles = BaseStyles & {\n  nav: AllStyle,\n  navitem: AllStyle,\n  childNav: ViewStyle\n};\n\nexport const DEFAULT_CLASS = 'app-navbar';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmNavbarStyles = defineStyles({\n      root: {},\n      text: {},\n      nav: {\n        flexDirection: 'row'\n      },\n      navitem: {},\n      childNav: {}\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n  addStyle('stackedNav', '', {\n    root: {},\n    nav: {\n      flexDirection: 'column'\n    },\n    text: {\n      textDecorationLine: 'none'\n    },\n    navitem: {},\n    childNav:  {\n      paddingLeft: 12\n    }\n  } as WmNavbarStyles);\n  addStyle('childNav', '', {\n    navitem: {}\n  } as WmNavbarStyles);\n  addStyle('justifiedNav', '', {\n    root: {},\n    nav: {\n      justifyContent: 'space-around',\n      flexDirection: 'row',\n      alignItems: 'center',\n    },\n    navitem: {}\n  } as WmNavbarStyles);\n});\n", "wavemaker-rn-runtime/src/components/navigation/navbar/navbar.props.ts": "import { BaseNavProps } from '@wavemaker/app-rn-runtime/components/navigation/basenav/basenav.props';\nimport { SyntheticEvent } from \"@wavemaker/app-rn-runtime/core/tappable.component\";\nimport {\n  NavigationDataItem\n} from \"@wavemaker/app-rn-runtime/components/navigation/basenav/basenav.component\";\n\nexport default class WmNavbarProps extends BaseNavProps {\n  type: string = 'pills';\n  layout: string = '';\n  children?: any = [] as any;\n  indent = 0;\n  onSelect? = ($event: SyntheticEvent, target: any, $item: NavigationDataItem) => {};  ischildnav? = false;\n}\n", "wavemaker-rn-runtime/src/components/navigation/basenav/basenav.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport class BaseNavProps extends BaseProps {\n  dataset?: any = null as any;\n  itemlabel?: string | ((item: any) => string) = 'label' as any;\n  itemlink?: string | ((item: any) => string) = 'link' as any;\n  itemicon?: string | ((item: any) => string) = 'icon' as any;\n  itembadge?: string | ((item: any) => string) = null as any;\n  isactive?: string | ((item: any) => string) = null as any;\n  itemchildren?: string = null as any;\n  getDisplayExpression? = (label: string) => null as any;\n}\n", "wavemaker-rn-runtime/src/components/navigation/basenav/basenav.component.ts": "import { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { BaseNavProps } from './basenav.props';\nimport { DEFAULT_CLASS, BaseNavStyles } from './basenav.styles';\nimport { isArray } from 'lodash-es';\n\nexport interface NavigationDataItem {\n  key: string;\n  label: string;\n  icon?: string;\n  link?: string;\n  badge?: string;\n  isactive?: string;\n  data: any;\n  childnavigation?: any;\n}\n\nexport class BaseNavState <T extends BaseNavProps> extends BaseComponentState<T> {\n  dataItems = [] as NavigationDataItem[];\n}\n\nexport abstract class BaseNavComponent< T extends BaseNavProps, S extends BaseNavState<T>, L extends BaseNavStyles> extends BaseComponent<T, S, L> {\n\n  constructor(props: T, public defaultClass: string = DEFAULT_CLASS, defaultProps?: T, defaultState?: S) {\n    super(props, defaultClass, defaultProps, defaultState);\n  }\n\n  getValue(item: any, val?: string | ((item: any) => string)) {\n    if (typeof val === 'string') {\n      return item[val];\n    } else if (typeof val === 'function') {\n      return val(item);\n    }\n    return null;\n  }\n\n  setDataItems(dataset: any = this.state.props.dataset) {\n    const name = this.props.name;\n    let dataItems = [] as NavigationDataItem[];\n    if (typeof dataset === 'string') {\n      dataItems = dataset.split(',').map((s, i) => {\n        return {\n          key: `${name}_item${i}`,\n          label: s,\n          data: s\n        } as NavigationDataItem;\n      });\n    } else if (dataset) {\n      if (!isArray(dataset)) {\n        dataset = [dataset];\n      }\n      dataItems = (dataset as any[]).map((d, i) => {\n        return {\n          key: `${name}_item${i}`,\n          label: this.getValue(d, this.state.props.itemlabel),\n          icon: this.getValue(d, this.state.props.itemicon),\n          link: this.getValue(d, this.state.props.itemlink),\n          badge: this.getValue(d, this.state.props.itembadge),\n          isactive: this.getValue(d, this.state.props.isactive),\n          data: d,\n          childnavigation: this.state.props.itemchildren ? d[this.state.props.itemchildren] : null\n        } as NavigationDataItem;\n      });\n    }\n    this.updateState({dataItems: dataItems} as S);\n  }\n\n  onPropertyChange(name: string, $new: any, $old: any) {\n    switch (name) {\n      case 'dataset':\n        this.setDataItems($new);\n        break;\n      case 'itemlabel':\n      case 'itemicon':\n      case 'itemlink':\n      case 'itemchildren':\n        this.setDataItems();\n        break;\n    }\n  }\n}\n", "wavemaker-rn-runtime/src/components/navigation/basenav/basenav.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type BaseNavStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-basenav';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: BaseNavStyles = defineStyles({\n        root: {},\n        text: {}\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/navigation/popover/popover.styles.ts": "import BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmAnchorStyles } from '@wavemaker/app-rn-runtime/components/basic/anchor/anchor.styles';\nimport { WmContainerStyles } from '@wavemaker/app-rn-runtime/components/container/container.styles';\nimport { Dimensions } from 'react-native';\n\nexport type WmPopoverStyles = BaseStyles & {\n    link: WmAnchorStyles,\n    popover: AllStyle,\n    popoverContent : WmContainerStyles,\n    modal: AllStyle,\n    modalContent: AllStyle,\n    title: AllStyle\n};\n\nexport const DEFAULT_CLASS = 'app-popover';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmPopoverStyles = defineStyles({\n        root: {\n            padding: 8,\n            alignSelf: 'flex-start'\n        },\n        text: {},\n        title: {\n            backgroundColor: themeVariables.popoverTitleBackgroundColor,\n            padding: 12,\n            color: themeVariables.popoverTitleColor,\n            fontSize: 16,\n            fontFamily: themeVariables.baseFont\n        },\n        link: {\n            root:{\n            },\n            text:{\n                paddingRight: 8\n            }\n        } as WmAnchorStyles,\n        popover: {\n            backgroundColor: themeVariables.popoverBackgroundColor,\n            maxWidth: 640,\n            borderTopLeftRadius: 28,\n            borderTopRightRadius: 28        \n        },\n        popoverContent : {\n            root: {\n                flex: 1\n            }\n        } as WmContainerStyles,\n        modal: {},\n        modalContent: {\n            borderTopLeftRadius: 28,\n            borderTopRightRadius: 28\n        }\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n    addStyle('app-popover-action-sheet', '', {\n        modal: {\n            backgroundColor: 'rgba(0, 0, 0, 0.3)',\n        },\n        popover: {\n            position: \"absolute\",\n            bottom: 0,\n            left: 0,\n            right: 0,\n            width: '100%',\n            minHeight: 240,\n            elevation: 4,\n            maxHeight: Dimensions.get('window').height - 120\n        },\n        modalContent: {\n            position: 'absolute',\n            bottom: 0,\n            width: '100%',\n            ...BASE_THEME.getStyle('elevate1').root,\n            shadowOffset: {\n                width: 0,\n                height: 0\n            },\n            shadowOpacity: 0.6,\n            shadowRadius: 10,\n            justifyContent: 'flex-end'\n        }\n    } as any as WmPopoverStyles);\n    addStyle('popover-dropdown', '', {\n        modal: {\n            backgroundColor: 'transparent',\n        },\n        popover: {\n            backgroundColor: themeVariables.transparent\n        },\n        modalContent: {\n            borderRadius: 6,\n            position: 'absolute',\n            ...BASE_THEME.getStyle('elevate4').root,\n            shadowRadius: 8\n        }\n    } as WmPopoverStyles);\n});", "wavemaker-rn-runtime/src/components/navigation/popover/popover.component.tsx": "import React from 'react';\nimport { isString } from 'lodash-es';\nimport { LayoutChangeEvent, TouchableOpacity, Text, View, Dimensions, Animated, PanResponder } from 'react-native';\nimport { BaseComponent, BaseComponentState, BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport { SyntheticEvent } from '@wavemaker/app-rn-runtime/core/tappable.component';\nimport { ModalConsumer, ModalOptions, ModalService } from '@wavemaker/app-rn-runtime/core/modal.service';\nimport WmAnchor from '@wavemaker/app-rn-runtime/components/basic/anchor/anchor.component';\n\nimport WmPopoverProps from './popover.props';\nimport { DEFAULT_CLASS, WmPopoverStyles } from './popover.styles';\nimport WmContainer from '../../container/container.component';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility'; \nimport { ScrollView, GestureHandlerRootView } from 'react-native-gesture-handler';\n\nexport class WmPopoverState extends BaseComponentState<WmPopoverProps> {\n  isOpened: boolean = false;\n  modalOptions = {} as ModalOptions;\n  position = {} as PopoverPosition;\n  isPartialLoaded = false;\n}\n\nexport interface PopoverPosition {\n  top?: number;\n  bottom?: number;\n  left?: number;\n  right?: number;\n}\n\nexport default class WmPopover extends BaseComponent<WmPopoverProps, WmPopoverState, WmPopoverStyles> {\n\n  view: View = null as any;\n  dragY = new Animated.Value(0);\n\n  constructor(props: WmPopoverProps) {\n    super(props, DEFAULT_CLASS, new WmPopoverProps(), new WmPopoverState());\n\n    if (this.state.props.autoopen) {\n      this.showPopover(); \n    }\n  }\n\n  public panResponder = PanResponder.create({\n    onStartShouldSetPanResponder: () => true,\n    onMoveShouldSetPanResponder: () => true,\n    onPanResponderMove: (_, gestureState) => {\n      if (gestureState.dy > 0 && gestureState.dy < Number(this.styles.popover.minHeight)) {\n        this.dragY.setValue(Number(this.styles.popover.minHeight) - gestureState.dy);\n      }\n    },\n    onPanResponderRelease: (_, gestureState) => {\n      if (gestureState.dy < -50) {\n        Animated.timing(this.dragY, {\n          toValue: Number(this.styles.popover.maxHeight),\n          duration: 500,\n          useNativeDriver: false,\n        }).start();\n      } else {\n        Animated.timing(this.dragY, {\n          toValue: Number(this.styles.popover.minHeight),\n          duration: 500,\n          useNativeDriver: false,\n        }).start();\n      }\n    },\n  });\n  \n  getDefaultStyles() {\n    const isActionSheet = this.state.props.type === 'action-sheet';\n    return this.theme.getStyle(`${this.defaultClass} ${isActionSheet ? 'app-popover-action-sheet' : ''}`);\n  }\n\n  private computePosition = (e: LayoutChangeEvent) => {\n    const position = {} as PopoverPosition;\n    if (this.state.props.type === 'dropdown') {\n      const windowDimensions = Dimensions.get('window');\n      this.view.measure((x, y, width, height, px, py) => {\n        let popoverwidth = this.state.props.popoverwidth as any;\n        if (popoverwidth && isString(popoverwidth)) {\n          popoverwidth = parseInt(popoverwidth);\n        }\n        this.isRTL ? position.right = px : position.left = px\n        \n        if (px + popoverwidth > windowDimensions.width) {\n          this.isRTL\n            ? (position.right = px + width - popoverwidth)\n            : (position.left = px + width - popoverwidth);\n        }\n        position.top = py + height;\n        this.updateState({position: position} as WmPopoverState);\n      });\n    }\n\n    this.handleLayout(e)\n  };\n\n  public renderPopoverContent (props : WmPopoverProps , styles : WmPopoverStyles, dimensions: any) {\n    return (\n      <ScrollView style={props.type === \"action-sheet\" ? {dimensions} : this.theme.mergeStyle(styles.popover, dimensions)} \n      onScroll={(event) => {this.notify('scroll', [event])}}\n      scrollEventThrottle={48}\n      accessible={props.type !== \"dropdown\"} accessibilityViewIsModal>\n      {props.title ? (<Text style={styles.title}>{props.title}</Text>): null}\n      <TouchableOpacity \n      {...this.getTestPropsForAction('outercontent')}\n      activeOpacity={1} onPress={() => {\n        props.autoclose === 'always' && this.hide()\n      }} style={styles.popoverContent.root}>\n        <WmContainer\n            styles={styles.popoverContent}\n            onLoad={() => this.invokeEventCallback('onLoad', [this])}\n            {...props.renderPartial ? {\n              renderPartial: (p: any, onLoad: Function) => {\n                return props.renderPartial && props.renderPartial(props, onLoad);\n              }\n            } : {}}>\n            {props.renderPartial ? null : props.children}\n        </WmContainer>\n      </TouchableOpacity>\n    </ScrollView>\n    )}\n\n  public showPopover = (e?: SyntheticEvent) => {\n    this.updateState({ isOpened: true } as WmPopoverState);\n    this.invokeEventCallback('onShow', [e, this]);\n    e?.stopPropagation();\n  };\n\n  public onPropertyChange(name: string, $new: any, $old: any): void {\n    super.onPropertyChange(name, $new, $old);\n    switch(name) {\n      case \"autoopen\":\n        if($new){\n          this.showPopover && this.showPopover()\n        }\n        else{\n          this.hide && this.hide()\n      }\n    }\n  }\n\n\n  public hide = () => {};\n\n  prepareModalOptions(content: React.ReactNode, styles: WmPopoverStyles, modalService: ModalService) {\n    const o = this.state.modalOptions;\n    o.modalStyle = styles.modal;\n    o.contentStyle = {...styles.modalContent, ...this.state.position};\n    o.content = content;\n    o.isModal = this.state.props.autoclose !== 'disabled';\n    o.centered = true;\n    o.animation = this.state.props.contentanimation || 'slideInUp';\n    o.onClose = () => {\n      this.hide = () => {};\n      this.setState({ isOpened: false, isPartialLoaded: false, modalOptions: {} as ModalOptions });\n      this.invokeEventCallback('onHide', [null, this]);\n    };\n    this.hide = () => modalService.hideModal(this.state.modalOptions);\n    return o;\n  }\n\n  renderWidget(props: WmPopoverProps) {\n    let dimensions = {} as any;\n    const styles = this.theme.mergeStyle(this.theme.getStyle('popover-' + props.type), this.styles);\n    if (props.type === 'dropdown') {\n      if (props.popoverwidth) {\n        dimensions.width = props.popoverwidth;\n        styles.modalContent.width = props.popoverwidth;\n      }\n      if (props.popoverheight) {\n        dimensions.height = props.popoverheight;\n      }\n    }\n    return (\n      <View style={styles.root} onLayout={this.computePosition} ref={ref => {this.view = ref as View}} {...getAccessibilityProps(AccessibilityWidgetType.POVOVER, props)}>\n        {this._background}\n        <WmAnchor\n          id={this.getTestId('trigger')}\n          animation={props.animation}\n          caption={props.caption}\n          badgevalue={props.badgevalue}\n          iconclass={props.iconclass}\n          iconposition={props.iconposition}\n          iconheight={props.iconheight}\n          iconwidth={props.iconwidth}\n          iconmargin={props.iconmargin}\n          iconurl={props.iconurl}\n          styles={styles.link}\n          onTap={this.showPopover}/>\n        {this.state.isOpened ? (\n          <ModalConsumer>\n            {(modalService: ModalService) => {\n              modalService.showModal(this.prepareModalOptions(props.type === 'action-sheet' ?  (\n                <Animated.View style= {[styles.popover,{ height: this.dragY }]} {...this.panResponder.panHandlers}>\n                  <GestureHandlerRootView>\n                 {this.renderPopoverContent(props, styles, dimensions)}\n                 </GestureHandlerRootView>\n                  </Animated.View>\n              ): (this.renderPopoverContent(props, styles, dimensions)), styles, modalService));\n              return null;\n            }}\n          </ModalConsumer>) : null}\n      </View>);\n  }\n}\n", "wavemaker-rn-runtime/src/components/navigation/popover/popover.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\nimport React from 'react';\nimport { AccessibilityRole } from 'react-native';\n\nexport default class WmPopoverProps extends BaseProps {\n  animation?: string = null as any;\n  badgevalue? = null as any;\n  caption? = 'Link';\n  contentanimation?: string = null as any;\n  iconclass? = null as any;\n  iconposition? = 'left' as any;\n  popoverwidth?: string | number | null = 240;\n  popoverheight?: string | number | null = 360;\n  autoclose?: 'outsideClick' | 'disabled' | 'always' = 'outsideClick';\n  autoopen?: boolean = false;\n  children? = [] as any;\n  renderPartial?: Function = null as any;\n  title?: string = null as any;\n  type?: 'action-sheet' | 'dropdown' = 'action-sheet';\n  iconurl?: string = null as any;\n  iconheight?: number = null as any;\n  iconwidth?: number = null as any;\n  iconmargin?: number = null as any;\n  accessibilitylabel?: string = undefined;\n  hint?: string = undefined;\n  accessibilityrole?: AccessibilityRole;\n}\n", "wavemaker-rn-runtime/src/components/navigation/menu/menu.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\n\nimport WmAnchor from '@wavemaker/app-rn-runtime/components/basic/anchor/anchor.component';\nimport { LifecycleListener } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport { BaseNavComponent, BaseNavState, NavigationDataItem } from '../basenav/basenav.component';\nimport WmPopover from '../popover/popover.component';\nimport WmMenuProps from './menu.props';\nimport { DEFAULT_CLASS, WmMenuStyles } from './menu.styles';\n\nexport class WmMenuState <T extends WmMenuProps> extends BaseNavState<T> {}\n\nconst animationMap: any = {\n  slide: 'slideInDown',\n  fade: 'fadeIn',\n  scale: 'zoomIn'\n};\n\nexport default class WmMenu extends BaseNavComponent<WmMenuProps, WmMenuState<WmMenuProps>, WmMenuStyles> {\n\n  private popOverRef: WmPopover = null as any;\n\n  private listener: LifecycleListener = {\n    onComponentInit: (c) => {\n      if (c instanceof WmPopover) {\n        this.popOverRef = c;\n      }\n    }\n  };\n\n  constructor(props: WmMenuProps) {\n    super(props, DEFAULT_CLASS, new WmMenuProps(), new WmMenuState());\n  }\n\n  renderMenuItem(item: NavigationDataItem, index: number) {\n    const getDisplayLabel = this.props.getDisplayExpression || ((label: string) => label);\n    return (\n      <WmAnchor\n        id={this.getTestId('menuitem' + index)}\n        iconclass={item.icon as string}\n        caption={getDisplayLabel(item.label)}\n        hyperlink={item.link}\n        styles={this.styles.menuItem}\n        onTap={() => {\n          this.invokeEventCallback('onSelect', [null, this, item]);\n          this.popOverRef.hide();\n      }}></WmAnchor>\n    );\n  }\n\n  renderWidget(props: WmMenuProps) {\n    const menuItems = this.state.dataItems;\n    return (\n      <WmPopover \n        id={this.getTestId('menu')}\n        styles={this.styles}\n        contentanimation={animationMap[props.animateitems || 'scale']}\n        caption={props.caption}\n        iconclass={props.iconclass}\n        listener={this.listener}\n        popoverheight={this.styles.menu.height as string | number | undefined || null}\n        popoverwidth={this.styles.menu.width as string | number | undefined || null}\n        iconposition=\"right\"\n        type='dropdown'>\n          <View style={{...this.styles.menu}}>\n            {menuItems.map((item, index) => (\n              <View key={item.key}>\n                {this.renderMenuItem(item, index)}\n              </View>\n            ))}\n          </View>\n      </WmPopover>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/navigation/menu/menu.styles.ts": "import BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { WmAnchorStyles } from '../../basic/anchor/anchor.styles';\nimport { WmPopoverStyles, DEFAULT_CLASS as POPOVER_CLASS } from '../popover/popover.styles';\nimport { deepCopy } from '@wavemaker/app-rn-runtime/core/utils';\nimport { defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { Platform } from 'react-native';\n\nexport type WmMenuStyles = WmPopoverStyles & {\n    menu: AllStyle,\n    menuItem: WmAnchorStyles\n};\n\nexport const DEFAULT_CLASS = 'app-menu';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmMenuStyles = {\n        root : {\n            alignSelf: 'flex-start'\n        },\n        text: {},\n        link: {\n            icon: {\n                root: {\n                    color: themeVariables.menuIconColor\n                }\n            },\n            text: {\n                textDecorationLine: 'none',\n                paddingRight: 12,\n                fontWeight: 'bold',\n                color: themeVariables.menuTextColor\n            }\n        } as WmAnchorStyles,\n        popover: {\n            backgroundColor: themeVariables.transparent,\n            borderTopLeftRadius: 0,\n            borderTopRightRadius: 0  \n        },\n        popoverContent: {\n            //@ts-ignore\n            flex: undefined\n        },\n        menu: {\n            width: 160,\n            backgroundColor: themeVariables.menuBackgroundColor,\n            borderRadius: 4\n        },\n        menuItem: {\n            root : {\n                height: 48,\n                borderBottomWidth: 0,\n                borderStyle: 'solid',\n                flexDirection : 'row',\n                alignItems: 'flex-start',\n                flexGrow:1, \n                paddingTop: 8,\n                justifyContent: 'flex-start',\n                borderBottomColor: themeVariables.menuItemBorderColor\n            },\n            icon :{\n                root : {\n                  fontSize: 24,\n                  paddingLeft: 22\n                },\n                icon : {\n                    color: themeVariables.menuItemIconColor\n                }\n            },\n            text: {\n                fontSize: 16,\n                paddingTop: 4,\n                textDecorationLine: 'none',\n                color: themeVariables.menuItemTextColor\n            }\n        } as any as WmAnchorStyles\n    };\n\n    addStyle(DEFAULT_CLASS, POPOVER_CLASS, defaultStyles);\n    addStyle(DEFAULT_CLASS + '-rtl', '', Platform.OS==\"web\"?{}:{});\n});\n", "wavemaker-rn-runtime/src/components/navigation/menu/menu.props.ts": "import { BaseNavProps } from '@wavemaker/app-rn-runtime/components/navigation/basenav/basenav.props';\n\nexport default class WmMenuProps extends BaseNavProps {\n  animateitems?: string = 'slide';\n  caption?: string = '' as any;\n  dataset: any = 'Menu Item 1, Menu Item 2, Menu Item 3';\n  iconclass? = 'fa fa-caret-down';\n}\n", "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmAppNavbarProps extends BaseProps {\n    children?: any;\n    title: string = '';\n    backbutton = true;\n    backbuttonlabel = '';\n    showDrawerButton = false;\n    leftnavpaneliconclass = 'wm-sl-l sl-hamburger-menu';\n    backbuttoniconclass = 'wi wi-back';\n    imgsrc = null as any;\n    searchbutton = false;\n    searchbuttoniconclass = 'wm-sl-l sl-search';\n    badgevalue?: string;\n    hideonscroll?: boolean = false;\n}\n", "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.component.tsx": "import React from 'react';\nimport { Text, View, BackHandler, Animated } from 'react-native';\nimport { Badge } from 'react-native-paper';\n\nimport { isAndroid, isWebPreviewMode } from '@wavemaker/app-rn-runtime/core/utils';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport WmPicture from '@wavemaker/app-rn-runtime/components/basic/picture/picture.component';\n\nimport WmAppNavbarProps from './appnavbar.props';\nimport { DEFAULT_CLASS, WmAppNavbarStyles } from './appnavbar.styles';\nimport { StickyView } from '@wavemaker/app-rn-runtime/core/sticky-container.component';\nimport { EdgeInsets, SafeAreaInsetsContext } from 'react-native-safe-area-context';\nimport injector from '@wavemaker/app-rn-runtime/core/injector';\nimport AppConfig from '@wavemaker/app-rn-runtime/core/AppConfig';\nimport { FixedView } from '@wavemaker/app-rn-runtime/core/fixed-view.component';\n\nexport class WmAppNavbarState extends BaseComponentState<WmAppNavbarProps> {}\n\nexport default class WmAppNavbar extends BaseComponent<WmAppNavbarProps, WmAppNavbarState, WmAppNavbarStyles> {\n\n  private onDrawerBtnPress: Function;\n  private onBackBtnPress: Function;\n  private onSearchBtnPress: Function;\n  private appConfig = injector.get<AppConfig>('APP_CONFIG');\n  private insets: EdgeInsets | null = null;\n  private destroyScrollListner: Function = null as any;\n  private scrollY: Animated.Value = new Animated.Value(0);\n  private translateY: Animated.AnimatedInterpolation<number> = new Animated.Value(0);\n\n  constructor(props: WmAppNavbarProps) {\n    super(props, DEFAULT_CLASS, new WmAppNavbarProps());\n    this.onDrawerBtnPress = (() => this.invokeEventCallback('onDrawerbuttonpress', [null, this])).bind(this);\n    this.onBackBtnPress = (() => this.invokeEventCallback('onBackbtnclick', [null, this])).bind(this);\n    this.onSearchBtnPress = (() => this.invokeEventCallback('onSearchbuttonpress', [null, this])).bind(this);\n    if (isAndroid() && !isWebPreviewMode()) {\n      const subscription = BackHandler.addEventListener('hardwareBackPress', () => {\n        this.onBackBtnPress();\n        return true;\n      });\n      this.cleanup.push(() => subscription.remove());\n    }\n  }\n  \n   onPropertyChange(name: string, $new: any, $old: any): void {\n      super.onPropertyChange(name, $new, $old);\n      switch(name){\n        case 'hideonscroll':\n          this.destroyScrollListner && this.destroyScrollListner();\n          if($new) {\n            this.subscribeToPageScroll();\n          }\n          break;\n      }\n  }\n\n  subscribeToPageScroll(){\n    this.destroyScrollListner = this.subscribe('scroll', (e: any)=>{\n      const { contentOffset } = e.nativeEvent ;\n      this.scrollY.setValue(contentOffset.y);\n    })\n  }\n\n  updateTranslateY(insets: any):void {\n    const navbarHeight = this.getLayout()?.height ;\n    const topInsets = insets?.top || 0\n    if(navbarHeight){\n      const navbarRange = navbarHeight + topInsets;\n      this.translateY = Animated.diffClamp(this.scrollY, 0, navbarRange).interpolate({\n        inputRange: [0, navbarRange],\n        outputRange: [0, -1 * navbarRange],\n        extrapolate: 'clamp',\n      });\n      this.forceUpdate();\n    }\n  }\n\n  renderContent(props: WmAppNavbarProps) {\n    //@ts-ignore\n    const badge = props.badgevalue != undefined ? (<Badge style={this.styles.badge} {...this.getTestProps('badge')}>{props.badgevalue}</Badge>): null;\n    return (\n      <SafeAreaInsetsContext.Consumer>\n        {(insets = { top: 0, bottom: 0, left: 0, right: 0 }) => {\n          const paddingTopVal = this.styles.root.paddingTop || this.styles.root.padding;\n          const statusBarCustomisation = this.appConfig?.preferences?.statusbarStyles;\n          const isFullScreenMode = !!statusBarCustomisation?.translucent;\n\n          const stylesWithFs = isFullScreenMode ?  {height: this.styles.root.height as number + (insets?.top || 0) as number, \n          paddingTop: (paddingTopVal || 0) as number + (insets?.top || 0) as number} : {}\n          return (\n          <View style={[this.styles.root, stylesWithFs]} ref={ref => {this.baseView = ref as View}} onLayout={(event) => {\n            this.handleLayout(event);\n            this.updateTranslateY(insets);\n          }}>\n            {this._background}\n            <View style={this.styles.leftSection}>\n            {props.showDrawerButton && (<WmIcon\n              id={this.getTestId('leftnavbtn')}\n              hint={'menu'}\n              styles={this.theme.mergeStyle({}, this.styles.action, this.styles.leftnavIcon)}\n              iconclass={props.leftnavpaneliconclass}\n              onTap={this.onDrawerBtnPress}\n              />)}\n            {props.backbutton && (<WmIcon\n              id={this.getTestId('backbtn')}\n              hint={'back'}\n              styles={this.theme.mergeStyle({}, this.styles.action, this.styles.backIcon)}\n              iconclass={props.backbuttoniconclass}\n              caption={props.backbuttonlabel}\n              onTap={this.onBackBtnPress}/>)}\n            </View>\n            <View style={this.styles.middleSection}>\n              {props.imgsrc && (\n              <WmPicture\n                id={this.getTestId('picture')}\n                styles={this.styles.image}\n                picturesource={props.imgsrc} />)}\n              <Text style={this.styles.content} {...this.getTestPropsForLabel('title')} accessibilityRole='header'>{props.title}</Text>\n              {badge}\n            </View>\n            <View style={this.styles.rightSection}>\n              {props.searchbutton && (<WmIcon\n                id={this.getTestId('searchbtn')}\n                styles={this.theme.mergeStyle({}, this.styles.action, this.styles.leftnavIcon)}\n                iconclass={props.searchbuttoniconclass}\n                onTap={this.onSearchBtnPress}\n                />)}\n              {props.children}\n            </View>\n          </View>\n          )}}\n      </SafeAreaInsetsContext.Consumer>\n    )\n  }\n\n  renderWidget(props: WmAppNavbarProps){\n    this.isFixed = true;\n    const animateStyle = props.hideonscroll ? {transform: [{translateY: this.translateY}]} : {};\n\n    return <>\n        <FixedView \n          style={{...{top: 0, width:'100%'}, ...animateStyle}} \n          theme={this.theme}\n          animated={props.hideonscroll || false}>\n          {this.renderContent(props)}\n        </FixedView>\n        <View style={{ opacity: 0}}>\n          {this.renderContent(props)}\n        </View>\n    </>\n  }\n}\n", "wavemaker-rn-runtime/src/components/navigation/appnavbar/appnavbar.styles.ts": "import Color from 'color';\nimport BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { TextStyle, ViewStyle } from 'react-native';\nimport { WmIconStyles } from '@wavemaker/app-rn-runtime/components/basic/icon/icon.styles';\nimport { WmMenuStyles } from '@wavemaker/app-rn-runtime/components/navigation/menu/menu.styles';\nimport { WmAnchorStyles } from '@wavemaker/app-rn-runtime/components/basic/anchor/anchor.styles';\nimport { WmPopoverStyles } from '@wavemaker/app-rn-runtime/components/navigation/popover/popover.styles';\nimport { WmPictureStyles } from '@wavemaker/app-rn-runtime/components/basic/picture/picture.styles';\n\nexport type WmAppNavbarStyles = BaseStyles & {\n  action: WmIconStyles,\n  image: WmPictureStyles,\n  leftnavIcon: WmIconStyles,\n  backIcon: WmIconStyles,\n  leftSection: ViewStyle,\n  middleSection: ViewStyle,\n  rightSection: ViewStyle,\n  content: TextStyle,\n  badge: TextStyle\n};\n\nexport const DEFAULT_CLASS = 'app-appnavbar';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmAppNavbarStyles = defineStyles({\n    root: {\n      flexDirection: 'row',\n      backgroundColor: themeVariables.navitemActiveBackgroundColor,\n      height: 80,\n      padding: 12,\n      paddingHorizontal: 12,\n      alignItems: 'center'\n    },\n    text: {},\n    action: {} as WmIconStyles,\n    leftSection: {\n      flex: 1,\n      flexDirection: 'row'\n    },\n    leftnavIcon: {\n      root: {\n          alignItems: 'flex-start'\n      },\n      icon: {\n          fontSize: themeVariables.navbarIconSize,\n          color: themeVariables.navbarTextColor\n      }\n    } as WmIconStyles,\n    backIcon: {\n      root: {\n        rippleColor: themeVariables.transparent\n      },\n      text: {\n        fontSize: themeVariables.navbarFontSize,\n        color: themeVariables.navbarTextColor\n      },\n      icon: {\n          fontSize: themeVariables.navbarIconSize,\n          color: themeVariables.navbarTextColor\n      }\n    } as WmIconStyles,\n    image: {\n      root: {\n        width: themeVariables.navbarImageSize,\n        height: themeVariables.navbarImageSize,\n      },\n      picture: {\n        resizeMode: 'contain'\n      }\n    } as WmPictureStyles,\n    content: {\n      textTransform: 'capitalize',\n      color: themeVariables.navbarTextColor,\n      fontSize: themeVariables.navbarFontSize,\n      fontFamily: themeVariables.baseFont,\n      fontWeight: '500',\n      textAlign: 'center'\n    },\n    badge: {\n      backgroundColor: themeVariables.titleBadgeBackgroundColor,\n      color: themeVariables.titleBadgeTextColor,\n      alignSelf: 'flex-start',\n      marginLeft: 4\n    },\n    middleSection: {\n      alignItems: 'center',\n      flexDirection: 'row'\n    },\n    rightSection: {\n      flex: 1,\n      flexDirection: 'row',\n      justifyContent: 'flex-end'\n    },\n  } as WmAppNavbarStyles);\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n  addStyle('navbarAnchorItem', '', {\n    root: {\n      paddingRight: 8,\n      flexDirection: 'row',\n      justifyContent: 'center',\n      alignItems: 'center',\n      overflow: 'visible'\n    },\n    text: {\n      color: themeVariables.navbarTextColor,\n      fontSize: themeVariables.navbarFontSize,\n      textDecorationStyle: undefined\n    },\n    badge: {\n        backgroundColor: Color(themeVariables.navbarTextColor).fade(0.8).rgb().toString(),\n        color: themeVariables.navbarTextColor,\n    },\n    icon: {\n      text: {\n        color: themeVariables.navbarTextColor,\n        fontSize: themeVariables.navbarIconSize\n      },\n      icon : {\n        color: themeVariables.navbarTextColor\n      }\n    }\n  } as WmAnchorStyles);\n  addStyle('navbarButton', '', {\n    root: {\n      backgroundColor: themeVariables.transparent,\n      paddingRight: 8,\n      flexDirection: 'row',\n      justifyContent: 'center',\n      alignItems: 'center',\n      alignSelf: 'center'\n    },\n    text: {\n      color: themeVariables.navbarTextColor,\n      fontSize: themeVariables.navbarFontSize\n    },\n    icon: {\n      root: {\n        color: themeVariables.navbarTextColor\n      },\n      text: {\n        color: themeVariables.navbarTextColor,\n        fontSize: themeVariables.navbarIconSize\n      }\n    }\n  } as WmAnchorStyles);\n  addStyle('navbarMenu', '', {\n    root: {\n      paddingRight: 8,\n      height: '100%',\n      flexDirection: 'row',\n      justifyContent: 'center',\n      alignItems: 'center'\n    },\n    link: {\n      icon: {\n        root: {\n          fontSize: themeVariables.navbarIconSize,\n          color: themeVariables.navbarTextColor\n        }\n      },\n      text: {\n        color: themeVariables.navbarTextColor,\n        fontSize: themeVariables.navbarFontSize\n      }\n    }\n  } as any as WmMenuStyles);\n  addStyle('navbarPopover', '', {\n    root: {\n      height: '100%',\n      flexDirection: 'row',\n      justifyContent: 'center',\n      alignItems: 'center'\n    },\n    link: {\n      icon: {\n        root: {\n          fontSize: themeVariables.navbarIconSize,\n          color: themeVariables.navbarTextColor\n        }\n      },\n      text: {\n        color: themeVariables.navbarTextColor,\n        fontSize: themeVariables.navbarFontSize\n      }\n    }\n  } as any as WmPopoverStyles);\n});", "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.props.ts": "import {BaseComponent, BaseProps} from '@wavemaker/app-rn-runtime/core/base.component';\nimport {NavigationDataItem} from \"@wavemaker/app-rn-runtime/components/navigation/basenav/basenav.component\";\nimport {SyntheticEvent} from \"@wavemaker/app-rn-runtime/core/tappable.component\";\nimport { AccessibilityRole } from 'react-native';\n\nexport default class WmNavItemProps extends BaseProps {\n  children?: any;\n  caption?: string;\n  item: any = [];\n  view: 'default' | 'dropdown' | 'anchor' = 'default';\n  onSelect? = ($event: SyntheticEvent, target: any, $item: NavigationDataItem) => {};\n  getDisplayExpression? = (label: string) => null as any;\n  accessibilitylabel?: string = undefined;\n  hint?: string = undefined;\n  accessibilityrole?: AccessibilityRole = \"link\";\n}\n", "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.component.tsx": "import React from 'react';\nimport { View, TouchableOpacity } from 'react-native';\n\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport WmAnchor from '@wavemaker/app-rn-runtime/components/basic/anchor/anchor.component';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\n\nimport WmNavItemProps from './navitem.props';\nimport { DEFAULT_CLASS, WmNavItemStyles } from './navitem.styles';\nimport { NavigationDataItem } from \"@wavemaker/app-rn-runtime/components/navigation/basenav/basenav.component\";\nimport { SyntheticEvent } from \"@wavemaker/app-rn-runtime/core/tappable.component\";\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility'; \n\nexport class WmNavItemState extends BaseComponentState<WmNavItemProps> {\n  collapsed = true;\n}\n\nexport default class WmNavItem extends BaseComponent<WmNavItemProps, WmNavItemState, WmNavItemStyles> {\n\n  constructor(props: WmNavItemProps) {\n    super(props, DEFAULT_CLASS, new WmNavItemProps(), new WmNavItemState());\n  }\n\n  onSelectItem(cb: any, $item: NavigationDataItem, $event: SyntheticEvent) {\n    cb && cb($event, this, $item?.data);\n  }\n\n  renderWidget(props: WmNavItemProps) {\n    const getDisplayLabel = this.props.getDisplayExpression || ((label: string) => label);\n    let child = props.children;\n    if (props.view === 'anchor') {\n      child = (\n        <WmAnchor\n          id={this.getTestId('navlink')}\n          {...getAccessibilityProps(AccessibilityWidgetType.NAV, props)}\n          styles={this.styles.navAnchorItem}\n          caption={getDisplayLabel(props.item.label)}\n          hyperlink={props.item.link}\n          badgevalue={props.item.badge}\n          iconclass={props.item.icon}\n          onTap={this.onSelectItem.bind(this, props.onSelect, props.item)}\n        ></WmAnchor>\n      );\n    }\n    if (props.view === 'dropdown') {\n      child = (\n        <>\n        <TouchableOpacity \n          {...this.getTestPropsForAction('navitem')}\n          onPress={() => {\n            this.updateState({collapsed: !this.state.collapsed} as WmNavItemState);\n          }}>\n          <View style={this.styles.dropdownNav}>\n            <WmAnchor id={this.getTestId('navlink')} styles={this.styles.navAnchorItem} caption={getDisplayLabel(props.item.label)} iconclass={props.item.icon} onTap={this.onSelectItem.bind(this, props.onSelect, props.item)} {...getAccessibilityProps(AccessibilityWidgetType.NAV, props)}></WmAnchor>\n            <WmIcon id={this.getTestId('icon')} styles={this.styles.caretIcon} iconclass={this.state.collapsed ? 'fa fa-sort-down' : 'fa fa-sort-up'}></WmIcon>\n          </View>\n        </TouchableOpacity>\n        {!this.state.collapsed && props.children}\n        </>\n      );\n    }\n    return (\n      <View style={this.styles.root} onLayout={(event) => this.handleLayout(event)}>{this._background}{child}</View>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/navigation/navitem/navitem.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmAnchorStyles } from '@wavemaker/app-rn-runtime/components/basic/anchor/anchor.styles';\nimport { WmIconStyles } from '@wavemaker/app-rn-runtime/components/basic/icon/icon.styles';\nimport { ViewStyle } from 'react-native';\n\nexport type WmNavItemStyles = BaseStyles & {\n  navAnchorItem: WmAnchorStyles,\n  dropdownNav: ViewStyle,\n  caretIcon: WmIconStyles\n};\n\nexport const DEFAULT_CLASS = 'app-navitem';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmNavItemStyles = defineStyles({\n      root: {\n        backgroundColor: themeVariables.navbarBackgroundColor,\n      },\n      text: {},\n      dropdownNav: {\n        flex: 1,\n        flexDirection: 'row',\n        justifyContent: 'space-between',\n        alignItems: 'center'\n      },\n      navAnchorItem: {\n        root: {\n          padding: 12\n        },\n        text: {\n          color: themeVariables.navbarTextColor,\n          fontFamily: themeVariables.baseFont,\n          lineHeight: 20,\n          fontSize: 14,\n          fontWeight: '500',\n        },\n        icon: {\n          text: {\n            color: themeVariables.navbarTextColor,\n            fontSize: 24\n          }\n        }\n      } as WmAnchorStyles,\n      caretIcon: {\n        root : {\n          paddingRight: 12\n        },\n        text: {\n          color: themeVariables.navbarCaretColor\n        }\n      } as WmIconStyles\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n  addStyle(DEFAULT_CLASS + '-active', DEFAULT_CLASS, {\n    root : {\n      backgroundColor: themeVariables.navitemActiveBackgroundColor\n    },\n    navAnchorItem: {\n      text: {\n        color: themeVariables.navitemActiveTextColor,\n        fontFamily: themeVariables.baseFont,\n        lineHeight: 20,\n        fontSize: 14,\n        fontWeight: '700',\n      },\n      icon: {\n        text: {\n          color: themeVariables.navitemActiveIconColor\n        }\n      }\n    }\n  } as WmNavItemStyles);\n\n  addStyle(DEFAULT_CLASS + '-child', DEFAULT_CLASS, {\n    root : {\n      backgroundColor: themeVariables.navitemChildBackgroundColor\n    },\n    navAnchorItem: {\n      text: {\n        color: themeVariables.navitemChildTextColor,\n      },\n      icon: {\n        text: {\n          color: themeVariables.navitemChildIconColor\n        }\n      }\n    }\n  } as WmNavItemStyles);\n  addStyle('navAnchorItem', '',  defaultStyles.navAnchorItem);\n});", "wavemaker-rn-runtime/src/components/container/container.props.ts": "import { PartialHostProps } from './partial-host.component';\n\nexport default class WmContainerProps extends PartialHostProps {\n  animation?: string = null as any;\n  animationdelay?: number = null as any;\n  onLoad?: Function;\n  scrollable?: Boolean = false as any;\n  issticky?: Boolean = false as boolean;\n}\n", "wavemaker-rn-runtime/src/components/container/container.component.tsx": "import React from 'react';\nimport { ColorValue, LayoutChangeEvent, View, ViewStyle } from 'react-native';\n\nimport WmContainerProps from './container.props';\nimport { DEFAULT_CLASS, WmContainerStyles } from './container.styles';\nimport { Tappable } from '@wavemaker/app-rn-runtime/core/tappable.component';\nimport { Animatedview } from '@wavemaker/app-rn-runtime/components/basic/animatedview.component';\nimport { PartialHost, PartialHostState } from './partial-host.component';\nimport { createSkeleton } from '../basic/skeleton/skeleton.component';\nimport { WmSkeletonStyles } from '../basic/skeleton/skeleton.styles';\nimport { ScrollView } from 'react-native-gesture-handler';\nimport { StickyView } from '@wavemaker/app-rn-runtime/core/sticky-container.component';\n\nexport class WmContainerState extends PartialHostState<WmContainerProps> {\n  isPartialLoaded = false;\n}\n\nexport default class WmContainer extends PartialHost<WmContainerProps, WmContainerState, WmContainerStyles> {\n  constructor(props: WmContainerProps) {\n    super(props, DEFAULT_CLASS, new WmContainerProps(), new WmContainerState());\n  }\n\n  getBackground(): React.JSX.Element | null {\n    return this._showSkeleton ? null : this._background\n  } \n  \n  public renderSkeleton(props: WmContainerProps): React.ReactNode {\n      if(!props.showskeletonchildren) {\n        const dimensions = {\n          width: this.styles.root.width ? '100%' : undefined,\n          height: this.styles.root.height ? '100%' : undefined\n        };    \n        const skeletonStyles: WmSkeletonStyles = this.props?.styles?.skeleton || { root: {}, text: {}  } as WmSkeletonStyles\n        return createSkeleton(this.theme, skeletonStyles, {\n          ...this.styles.root\n        }, (<View style={[this.styles.root, { opacity: 0 }]}>\n                  <Tappable {...this.getTestPropsForAction()} target={this} styles={dimensions} disableTouchEffect={this.state.props.disabletoucheffect}>\n            <View style={[dimensions as ViewStyle,  this.styles.content]}>{this.renderContent(props)}</View>\n        </Tappable>\n\n        </View>))\n      }\n      return null;\n    }\n\n\n  renderWidget(props: WmContainerProps) {\n    const dimensions = {\n      width: this.styles.root.width ? '100%' : undefined,\n      height: this.styles.root.height ? '100%' : undefined\n    };\n\n    const styles = this._showSkeleton ? {\n      ...this.styles.root,\n      ...this.styles.skeleton.root\n    } : this.styles.root\n    if(props.issticky) this.isSticky = true;\n    return (\n      <Animatedview \n        entryanimation={props.animation} \n        delay={props.animationdelay} \n        style={styles}\n        onLayout={(event: LayoutChangeEvent, ref: React.RefObject<View>) => this.handleLayout(event, ref)}\n      >\n        {this.getBackground()}\n        <Tappable {...this.getTestPropsForAction()} target={this} styles={dimensions} disableTouchEffect={this.state.props.disabletoucheffect}>\n          { props.issticky ? \n            <StickyView\n              component={this}\n              style={this.styles.sticky}\n              theme={this.theme}>\n               <View style={styles}>\n                  {this.renderContent(props)}\n              </View>\n            </StickyView>\n            : !props.scrollable ? \n            <View style={[dimensions as ViewStyle,  this.styles.content]}>\n              {this.renderContent(props)}\n            </View>\n            :<ScrollView style={[dimensions as ViewStyle,  this.styles.content]}\n                onScroll={(event) => {this.notify('scroll', [event])}}\n                scrollEventThrottle={48}>\n              {this.renderContent(props)}\n            </ScrollView>\n          }\n        </Tappable>\n      </Animatedview>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/container/partial-host.component.tsx": "import { BaseComponent, BaseComponentState, BaseProps, BaseStyles } from \"@wavemaker/app-rn-runtime/core/base.component\";\nimport { WmSkeletonStyles } from \"../basic/skeleton/skeleton.styles\";\n\n\nexport type PartialHostStyles = BaseStyles & {\n    skeleton: WmSkeletonStyles\n}\nexport abstract class PartialHostState<T extends BaseProps> extends BaseComponentState<T> {\n    isPartialLoaded = false;\n}\n\nexport abstract class PartialHostProps extends BaseProps {\n    renderPartial?: Function;\n    children?: any;\n  }\n  \n  \nexport abstract class PartialHost<T extends PartialHostProps, S extends  PartialHostState<T>, L extends PartialHostStyles>\n    extends BaseComponent<T, S, L> {\n\n    constructor(markupProps: T, defaultClass: string, defaultProps?: T, defaultState?: S) {\n        super(markupProps, defaultClass, defaultProps, defaultState);\n    }\n\n    onPartialLoad() {\n        this.invokeEventCallback('onLoad', [this]);\n    }\n\n    renderContent(props: PartialHostProps) {\n        if (props.renderPartial) {\n            if (!this.state.isPartialLoaded && !this.isVisible()) {\n                return null;\n            }\n            if (!this.state.isPartialLoaded) {\n                setTimeout(() => {\n                    this.updateState({\n                        isPartialLoaded: true\n                    } as any);\n                });\n            }\n            return props.renderPartial(props, this.onPartialLoad.bind(this));\n        }\n        return props.children;\n    }\n\n}", "wavemaker-rn-runtime/src/components/container/container.styles.ts": "import BASE_THEME, { AllStyle }  from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmSkeletonStyles } from '../basic/skeleton/skeleton.styles';\n\nexport type WmContainerStyles = BaseStyles & {\n    content: AllStyle,\n    skeleton: WmSkeletonStyles,\n    sticky: AllStyle\n};\n\nexport const DEFAULT_CLASS = 'app-container';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmContainerStyles = defineStyles({\n        root: {},\n        text: {},\n        content: {\n            flexDirection: 'column'\n        },\n        skeleton: {\n            root: {\n                borderColor: 'transparent',\n                shadowColor: 'transparent',\n                backgroundColor: 'transparent',\n            },\n        } as any as WmSkeletonStyles, \n        sticky: {\n            paddingHorizontal: 8\n        }\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n    addStyle('media-body', '', {\n        root: {\n            flex: 1,\n            paddingLeft: 8,\n            paddingRight: 8,\n            justifyContent: 'center'\n        }\n    } as WmContainerStyles);\n    addStyle('media-right', '', {\n        root: {\n            justifyContent: 'center'\n        }\n    } as WmContainerStyles);\n    addStyle('app-elevated-container', '', {\n        root: {\n            shadowColor: 'rgba(0, 0, 0, 0.2)',\n            shadowOffset: {\n                width: 2,\n                height: 2\n            },\n            shadowRadius: 2,\n            borderRadius: 8\n        }\n    } as WmContainerStyles);\n    addStyle('app-outlined-container', '', {\n        root: {\n            borderWidth: 1,\n            borderColor: themeVariables.containerOutlineColor,\n            borderStyle: 'solid'\n        }\n    } as WmContainerStyles);\n});", "wavemaker-rn-runtime/src/components/container/tabs/tabs.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmTabsProps extends BaseProps {\n  children?: any;\n  defaultpaneindex?: number = 0;\n  enablegestures? = true;\n  enablescroll?: boolean = false;\n}\n", "wavemaker-rn-runtime/src/components/container/tabs/tabs.component.tsx": "import React from 'react';\nimport { LayoutChangeEvent, LayoutRectangle, View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport * as SwipeAnimation from '@wavemaker/app-rn-runtime/gestures/swipe.animation';\nimport { isWebPreviewMode } from '@wavemaker/app-rn-runtime/core/utils';\n\nimport WmTabsProps from './tabs.props';\nimport { DEFAULT_CLASS, WmTabsStyles } from './tabs.styles';\nimport WmTabpane from './tabpane/tabpane.component';\nimport WmTabheader from './tabheader/tabheader.component';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\nimport { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\n\nexport class WmTabsState extends BaseComponentState<WmTabsProps> {\n  tabsShown: boolean[] = [];\n  selectedTabIndex: number = 0;\n}\n\nexport default class WmTabs extends BaseComponent<WmTabsProps, WmTabsState, WmTabsStyles> {\n  public tabPanes = [] as WmTabpane[];\n  private newIndex = 0;\n  private tabLayout: LayoutRectangle = null as any;\n  private tabPaneHeights: number[] = [];\n  private animationView: SwipeAnimation.View | null = null as any;\n  private animationHandlers = {\n    bounds: (e) => {\n      const activeTabIndex = this.state.selectedTabIndex,\n            w = this.tabLayout?.width || 0,\n            noOfTabs = this.tabPanes.length;\n      return {\n        lower: -1 * (activeTabIndex - (activeTabIndex === 0 ? 0 : 1)) * w,\n        center: -1 * activeTabIndex * w,\n        upper:  -1 * (activeTabIndex + (activeTabIndex === noOfTabs - 1 ? 0 : 1)) * w\n      };\n    },\n    onLower: (e) => {\n      this.onChange(this.state.selectedTabIndex - 1);\n    },\n    onUpper: (e) => {\n      this.onChange(this.state.selectedTabIndex + 1);\n    }\n  } as SwipeAnimation.Handlers;\n\n  constructor(props: WmTabsProps) {\n    super(props, DEFAULT_CLASS, new WmTabsProps(), new WmTabsState());\n  }\n\n  setTabLayout(event: LayoutChangeEvent) {\n    this.tabLayout = event.nativeEvent.layout;\n    this.forceUpdate(() => {\n      this.goToTab();\n    });\n  }\n\n  setTabPaneHeights(index: number, nativeEvent: LayoutChangeEvent) {\n    this.tabPaneHeights[index] = nativeEvent.nativeEvent.layout?.height;\n    if (index === this.state.selectedTabIndex) {\n      this.forceUpdate();\n    }\n  }\n\n  setTabShown(tabIndex: number, callback: () => any) {\n    if (!this.state.tabsShown[tabIndex]) {\n      const tabsShown = [...this.state.tabsShown];\n      tabsShown[tabIndex] = true;\n      setTimeout(() => {\n        this.updateState({\n          tabsShown: tabsShown\n        } as WmTabsState, callback);\n      }, 300);\n    } else {\n      callback && callback();\n    }\n  }\n\n  addTabPane(tabPane: WmTabpane) {\n    tabPane.paneId = `tabPane${this.newIndex++}`;\n    const i = this.tabPanes.findIndex(t => t.paneId === tabPane.paneId);\n    if (i >= 0) {\n      this.tabPanes[i] = tabPane;\n    } else {\n      this.tabPanes.push(tabPane)\n    }\n  }\n\n  removeTabPane(tabPane: WmTabpane) {\n    const i = this.tabPanes.findIndex(t => t.paneId === tabPane.paneId);\n    if (i >= 0) {\n      this.tabPanes.splice(i, 1); \n      this.newIndex--;\n    }\n  }\n\n  selectTabPane(tabPane: WmTabpane) {\n    this.goToTab(this.tabPanes.indexOf(tabPane));\n  }\n\n  get selectedTabPane() {\n    return this.tabPanes[this.state.selectedTabIndex];\n  }\n\n  goToTab(index = this.state.selectedTabIndex) {\n    if (index < 0 || index >= this.tabPanes.length) {\n      return;\n    }\n    const position = -1 * index * (this.tabLayout?.width || 0);\n    if(this.animationView) {\n      this.animationView.setPosition(position)\n      .then(() => this.onChange(index));\n    } else {\n      this.onChange(index);\n    }\n  }\n\n  prev() {\n    this.animationView?.goToLower();\n  }\n\n  next() {\n    this.animationView?.goToLower();\n  }\n\n  onChange(newIndex: number) {\n    if (newIndex < 0 || newIndex >= this.tabPanes.length) {\n      return;\n    }\n    const oldIndex = this.state.selectedTabIndex;\n    const deselectedTab = this.tabPanes[this.state.selectedTabIndex];\n    this.newIndex = newIndex;\n    deselectedTab?._onDeselect();\n    this.updateState({\n      selectedTabIndex: newIndex\n    } as WmTabsState, () => {\n      this.setTabShown(newIndex, () => {\n        const selectedTab = this.tabPanes[newIndex];\n        selectedTab?._onSelect();\n        this.invokeEventCallback('onChange', [{}, this.proxy, newIndex, oldIndex]);\n      });\n    });\n  }\n\n  public renderSkeletonContent(props: WmTabsProps) {\n    const tabPanes =  React.Children.toArray(this.props.children)\n    .filter((item: any, index: number) => item.props.show != false);\n    const headerData = tabPanes.map((p: any, i: number) =>\n      ({title: p.props.title, icon: '', key:  `tab-${p.props.title}-${i}`}));\n    return(\n      <View style={[this.styles.root, { borderBottomWidth: 0}]}>\n      <View onLayout={this.setTabLayout.bind(this)} style={{width: '100%'}}></View>\n      <WmTabheader\n        styles={this.styles.tabHeader}\n        data={headerData}\n        showskeleton={this.props.showskeleton}\n        selectedTabIndex={this.state.selectedTabIndex}\n      ></WmTabheader>\n      <View\n        //{...this.panResponder.panHandlers}\n        style={{\n          width: '100%',\n          //height: this.tabPaneHeights[this.state.selectedTabIndex],\n          overflow: 'hidden'\n        }} >\n        <View style={{\n          flexDirection: 'row',\n          flexWrap: 'nowrap'\n        }}>\n          {tabPanes.map((p: any, i) => {\n            return (\n            <View\n              key={`tab-${p.props.title}-${i}`}\n              style={{width: '100%', alignSelf: 'flex-start'}}\n              onLayout={this.setTabPaneHeights.bind(this, i)}>\n              {/* {this.state.tabsShown[i] ? p : null} */}\n              {React.cloneElement(p, { \"invokeVariables\": false })}\n              {/* {p} */}\n            </View>);\n          })}\n        </View>\n      </View>\n    </View>\n    )\n  }\n\n  public renderSkeleton(props: WmTabsProps){\n    if(!props.showskeletonchildren) {\n      const skeletonStyles: WmSkeletonStyles = this.props?.styles?.skeleton || { root: {}, text: {}  } as WmSkeletonStyles\n      return createSkeleton(this.theme, skeletonStyles, {\n        ...this.styles.root\n      }, (<View style={[this.styles.root, { opacity: 0 }]}>\n        {this.renderSkeletonContent(props)}\n      </View>)) \n    }\n    return this.renderSkeletonContent(props);\n  }\n\n  public onPropertyChange(name: string, $new: any, $old: any): void {\n    super.onPropertyChange(name, $new, $old);\n    switch(name) {\n      case \"defaultpaneindex\":\n        const selectedIndex = $new || 0;\n        const tabsShown: boolean[] = [];\n        tabsShown[selectedIndex] = true;\n        this.updateState({\n          selectedTabIndex: selectedIndex,\n          tabsShown: tabsShown\n        } as WmTabsState);\n    }\n  }\n\n  getBackground(): React.JSX.Element | null {\n    return this._showSkeleton ? null : this._background\n  } \n\n\n  renderWidget(props: WmTabsProps) {\n    const tabPanes =  React.Children.toArray(props.children)\n      .filter((item: any, index: number) => item.props.show != false);\n    const headerData = tabPanes.map((p: any, i: number) =>\n      ({title: p.props.title,  icon: p.props.paneicon || '', key:  `tab-${p.props.title}-${i}`}));\n    const styles = this._showSkeleton ? {\n      ...this.styles.root,\n      ...this.styles.skeleton.root\n    } : this.styles.root\n    return (\n      <View \n        style={styles}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        {this.getBackground()}\n        <View onLayout={this.setTabLayout.bind(this)} style={{width: '100%'}}></View>\n        <WmTabheader\n          id={this.getTestId('headers')}\n          styles={this.styles.tabHeader}\n          data={headerData}\n          selectedTabIndex={this.state.selectedTabIndex}\n          onIndexChange={this.goToTab.bind(this)}\n          shouldScroll={props.enablescroll}\n          disabletoucheffect = {this.state.props.disabletoucheffect}\n        ></WmTabheader>\n        <View\n          style={[{\n            width: '100%',\n            flex: 1\n          }, this.styles.root.height ?\n          (isWebPreviewMode() ? {'overflowX': 'hidden','overflowY': 'auto'} as any : {overflow: 'scroll'})\n          : {\n            overflow: 'hidden',\n            maxHeight: this.tabPaneHeights[this.state.selectedTabIndex],\n          }, this.styles.tabContent]} >\n          <SwipeAnimation.View\n            enableGestures={props.enablegestures}\n            style={{\n              flexDirection: 'row',\n              flexWrap: 'nowrap',\n              alignItems: 'flex-start'\n            }}\n            direction='horizontal'\n            ref={(r) => {this.animationView = r}}\n            handlers = {this.animationHandlers}\n          >\n            {tabPanes.map((p: any, i) => {\n              return (\n              <View\n                key={`tab-${p.props.title}-${i}`}\n                style={{\n                  width: '100%',\n                  height: this.styles.root.height  ? undefined : 1000000,\n                  alignSelf: 'flex-start'}}>\n                <View\n                  style={{width: '100%', alignSelf: 'flex-start'}}\n                  onLayout={this.setTabPaneHeights.bind(this, i)}>\n                  {/* {this.state.tabsShown[i] ? p : null} */}\n                  {p}\n                </View>\n              </View>);\n            })}\n          </SwipeAnimation.View>\n        </View>\n      </View>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/container/tabs/tabs.styles.ts": "import { ViewStyle } from 'react-native';\nimport BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmTabheaderStyles } from './tabheader/tabheader.styles';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmTabsStyles = BaseStyles & {\n  tabHeader: WmTabheaderStyles,\n  tabContent: ViewStyle,\n  skeleton: WmSkeletonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-tabs';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmTabsStyles = defineStyles({\n      root: {\n        minHeight: 240,\n        elevation: 0,\n        borderBottomWidth: 1,\n        borderStyle: 'solid',\n        borderColor: themeVariables.tabBorderColor\n      },\n      text: {},\n      tabContent: {},\n      tabHeader: {} as WmTabheaderStyles,\n      skeleton: { \n        root: {\n        }\n      } as WmSkeletonStyles\n  });\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n  addStyle('tabs-with-arrow-indicator', '', {\n    tabHeader: {\n      root: {\n        backgroundColor: themeVariables.transparent\n      },\n      header: {\n        marginBottom: 16\n      },\n      activeIndicator: {\n        justifyContent: 'center',\n        alignItems: 'center',\n        marginTop: 2,\n        height: 0\n      },\n      arrowIndicator: {\n        display: 'flex',\n        backgroundColor: themeVariables.tabArrowIndicatorBgColor,\n        width: 24,\n        height: 24,\n        justifyContent: 'center',\n        alignItems: 'center',\n        transform: [{\n          rotateZ: '45deg'\n        }]\n      },\n      arrowIndicatorDot: {\n        display: 'flex',\n        backgroundColor: themeVariables.tabArrowIndicatorDotColor,\n        width: 4,\n        height: 4, \n        borderRadius: 8,\n        transform: [{\n          translateX: -2\n        }, {\n          translateY: -2\n        }]\n      }\n    } as any as WmTabheaderStyles\n  });\n});", "wavemaker-rn-runtime/src/components/container/tabs/tabpane/tabpane.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type WmTabpaneStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-tabpane';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmTabpaneStyles = defineStyles({\n        root: {\n            backgroundColor: themeVariables.tabContentBgColor\n        },\n        text: {}\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/container/tabs/tabpane/tabpane.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmTabpaneProps extends BaseProps {\n  children?: any;\n  paneicon?: string = null as any;\n  title: string = 'Tab Title';\n  renderPartial?: Function;\n  isPartialLoaded? = false;\n  invokeVariables = true;\n}\n", "wavemaker-rn-runtime/src/components/container/tabs/tabpane/tabpane.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { ScrollView } from 'react-native-gesture-handler'\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmTabpaneProps from './tabpane.props';\nimport { DEFAULT_CLASS, WmTabpaneStyles } from './tabpane.styles';\nimport WmTabs from '../tabs.component';\n\nexport class WmTabpaneState extends BaseComponentState<WmTabpaneProps> {\n  isPartialLoaded = false;\n  isActive = false;\n}\n\nexport default class WmTabpane extends BaseComponent<WmTabpaneProps, WmTabpaneState, WmTabpaneStyles> {\n  public paneId: string = \"\";\n  constructor(props: WmTabpaneProps) {\n    super(props, DEFAULT_CLASS, new WmTabpaneProps(), new WmTabpaneState());\n    this.subscribe('scroll', (event: any) => {\n      return this.state.isActive;\n    });\n  }\n\n  onPartialLoad() {\n    this.invokeEventCallback('onLoad', [null, this]);\n  }\n\n  renderContent(props: WmTabpaneProps) {\n    if (props.renderPartial) {\n      if (!this.state.isPartialLoaded) {\n        setTimeout(() => {\n          this.updateState({\n            isPartialLoaded: true\n          } as WmTabpaneState);\n        });\n      }\n      return props.renderPartial(props, this.onPartialLoad.bind(this));\n    }\n    return props.children;\n  }\n\n  showView(): boolean {\n    return this.isVisible() && this.state.isActive;\n  }\n\n  componentDidMount() {\n    const tabs = (this.parent) as WmTabs;\n    // When skeleton is enabled in the tabs component, the parent would be WMSkeleton which doesnot have addTabPane function\n    if(tabs.addTabPane) {\n      tabs.addTabPane(this.proxy as WmTabpane);\n    }\n    super.componentDidMount();\n  }\n\n  componentWillUnmount() {\n    const tabs = (this.parent) as WmTabs;\n    if(tabs.removeTabPane) {\n      tabs.removeTabPane(this)\n    }\n  }\n\n  _onSelect() {\n    this.updateState({\n      isActive: true\n    } as WmTabpaneState);\n    this.invokeEventCallback('onSelect', [null, this.proxy]);\n  }\n  _onDeselect() {\n    this.updateState({\n      isActive: false\n    } as WmTabpaneState);\n    this.invokeEventCallback('onDeselect', [null, this.proxy]);\n  }\n\n  select() {\n    (this.parent as WmTabs).selectTabPane(this);\n  }\n\n  renderWidget(props: WmTabpaneProps) {\n    return (\n    <ScrollView \n      style={this.styles.root} \n      onScroll={(event) => {this.notify('scroll', [event])}}\n      onLayout={(event) => this.handleLayout(event)}\n    >\n        {this._background}\n        {this.renderContent(props)}\n      </ScrollView>);\n  }\n}\n", "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.component.tsx": "import React, { createRef } from 'react';\nimport { Animated, Easing, LayoutChangeEvent, LayoutRectangle, Text, View, ScrollView } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmTabheaderProps from './tabheader.props';\nimport { DEFAULT_CLASS, WmTabheaderStyles } from './tabheader.styles';\nimport { Tappable } from '@wavemaker/app-rn-runtime/core/tappable.component';\nimport WmSkeleton, { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\nimport { BackgroundComponent } from '@wavemaker/app-rn-runtime/styles/background.component';\nimport WmIcon from \"@wavemaker/app-rn-runtime/components/basic/icon/icon.component\";\n\nexport class WmTabheaderState extends BaseComponentState<WmTabheaderProps> {\n}\n\nexport default class WmTabheader extends BaseComponent<WmTabheaderProps, WmTabheaderState, WmTabheaderStyles> {\n\n  private headerPanelLayout: LayoutRectangle = null as any;\n  private headersLayout: LayoutRectangle[] = [];\n  private headerScrollPosition = new Animated.Value(0);\n  private headerScrollPositionValue = 0;\n  private indicatorPosition = new Animated.Value(0);\n  private reverseIndicatorWidth = new Animated.Value(0);\n  private indicatorWidth = new Animated.Value(0);\n  private listRef: any = createRef();\n\n  constructor(props: WmTabheaderProps) {\n    super(props, DEFAULT_CLASS, new WmTabheaderProps(), new WmTabheaderState());\n    this.headerScrollPosition.addListener(({value}) => this.headerScrollPositionValue = value);\n  }\n\n  setHeaderPanelPositon(nativeEvent: LayoutChangeEvent) {\n    this.headerPanelLayout = nativeEvent.nativeEvent.layout;\n    this.forceUpdate();\n  }\n\n  setHeaderPositon(index: number, nativeEvent: LayoutChangeEvent) {\n    this.headersLayout[index] = nativeEvent.nativeEvent.layout;\n    if (index === this.props.selectedTabIndex) {\n      this.forceUpdate();\n    }\n  }\n\n  onTabSelection(index: number) {\n    if (this.state.props.selectedTabIndex != index) {\n      this.state.props.onIndexChange && this.state.props.onIndexChange(index);\n    }\n  }\n\n  scrollPosition(selectedTabIndex: number, totalWidth: number, toIndicatorPosition: number) {\n    const initialPosition = this.isRTL ? totalWidth : 0;\n    const baseWidth = this.isRTL ? totalWidth - toIndicatorPosition : toIndicatorPosition;\n    const elementWidth  = this.isRTL ? -1 * (this.headersLayout[selectedTabIndex]?.width/2) : this.headersLayout[selectedTabIndex]?.width/2\n    const positionX = selectedTabIndex === 0 ? initialPosition : \n      ((baseWidth + (elementWidth)) - (this.headerPanelLayout?.width || 0) / 2);\n\n    return positionX\n  }\n\n  setPosition() {\n    const selectedTabIndex = this.state.props.selectedTabIndex ? this.state.props.selectedTabIndex : 0\n    let toIndicatorPosition = 0;\n    let toIndicatorWidth = this.headersLayout[selectedTabIndex]?.width || 0;\n    let toHeaderScrollPosition = this.headerScrollPositionValue;\n    let totalWidth = 0;\n    if (this.state.props.data.length !== this.headersLayout.length) {\n      return;\n    }\n    this.headersLayout.forEach((p, i) => {\n      if (i < selectedTabIndex) {\n        toIndicatorPosition += p.width;\n      }\n      totalWidth += p.width;\n    });\n    toHeaderScrollPosition = -1 * (toIndicatorPosition - (this.headerPanelLayout?.width || 0) / 2 + toIndicatorWidth/ 2) ;\n    const minScrollPosition = -1 * (totalWidth - (this.headerPanelLayout?.width || 0));\n    const maxScrollPosition = 0;\n    toHeaderScrollPosition = Math.max(minScrollPosition, toHeaderScrollPosition);\n    toHeaderScrollPosition = Math.min(maxScrollPosition, toHeaderScrollPosition);\n    let positionIndicator = (toIndicatorPosition - (100 - toIndicatorWidth) / 2);\n    let position = this.isRTL?-positionIndicator:positionIndicator;\n\n    const positionX = this.scrollPosition(selectedTabIndex, totalWidth, toIndicatorPosition)\n\n    this.listRef.current?.scrollTo({\n      x: positionX,\n      y: 0,\n      Animated: true\n    });\n\n    Animated.parallel([\n      Animated.timing(this.headerScrollPosition, {\n        useNativeDriver: true,\n        toValue:  toHeaderScrollPosition,\n        duration: 200,\n        easing: Easing.linear\n      }),\n      Animated.timing(this.indicatorWidth, {\n        useNativeDriver: true,\n        toValue:  toIndicatorWidth / 100,\n        duration: 200,\n        easing: Easing.linear\n      }),\n      Animated.timing(this.reverseIndicatorWidth, {\n        useNativeDriver: true,\n        toValue:  toIndicatorWidth ? 100 / toIndicatorWidth : 0,\n        duration: 200,\n        easing: Easing.linear\n      }),\n      Animated.timing(this.indicatorPosition, {\n        useNativeDriver: true,\n        toValue:  position,\n        duration: 200,\n        easing: Easing.linear\n      })\n    ]).start();\n  }\n\n  public renderSkeleton(props: WmTabheaderProps){\n    return(\n      <Animated.View style={{\n        transform: [{\n          translateX: this.headerScrollPosition\n        }]\n      }}\n      onLayout={this.setHeaderPanelPositon.bind(this)}>\n        <View style={this.styles.root}>\n          {this.props.data.map((header ,i) => {\n            const isSelected = i === this.props.selectedTabIndex;\n            return (\n              <Tappable onTap={this.onTabSelection.bind(this, i)} key={header.key} styles={{flex: 1}} disableTouchEffect={this.state.props.disabletoucheffect}>\n                <View onLayout={this.setHeaderPositon.bind(this, i)} style={[\n                  this.styles.header,\n                  isSelected ? this.styles.activeHeader : null]}>\n                  {\n                    createSkeleton(this.theme, { root: { borderRadius: 4 }} as WmSkeletonStyles, {\n                      ...this.styles.root,\n                      width: this.styles.root?.width || \"80%\",\n                      height: this.styles.root?.height || this.styles.activeHeaderText?.fontSize || 16\n                    })\n                  }\n                </View>\n              </Tappable>\n            );\n          })}\n        </View>\n        <Animated.View style={[this.styles.activeIndicator, {\n          transform: [{\n            translateX: this.indicatorPosition\n          }, {\n            scaleX: this.indicatorWidth\n          }]\n        }]}></Animated.View>\n      </Animated.View>\n\n    )\n  }\n\n  renderWidget(props: WmTabheaderProps) {\n    this.setPosition();\n    const arrowIndicator = this.styles.arrowIndicator as any;\n    return (\n      <View \n        style={{overflow: 'hidden', zIndex: 16}}\n        {...this.getTestProps('tabheader')}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n      <ScrollView\n        ref={this.listRef}\n        horizontal={true}\n        onLayout={this.setHeaderPanelPositon.bind(this)}\n        showsHorizontalScrollIndicator={false}\n        scrollEnabled={props.shouldScroll}\n      >\n      <View>\n        <View style={this.styles.root}>\n          {this._background}\n          {props.data.map((header ,i) => {\n            const isSelected = i === props.selectedTabIndex ;\n            return (\n              <Tappable onTap={this.onTabSelection.bind(this, i)}\n                {...this.getTestPropsForAction(i +'')}\n                key={header.key}\n                disableTouchEffect={this.state.props.disabletoucheffect}\n                styles={this.styles.header.flexGrow ? {flexGrow: this.styles.header.flexGrow} : null}>\n                <View onLayout={this.setHeaderPositon.bind(this, i)}>\n                  <View style={[\n                    this.styles.header,\n                    {flexGrow: undefined},\n                    isSelected ? this.styles.activeHeader : null]}>\n                    <WmIcon\n                      id={this.getTestId(i + 'icon')}\n                      styles={this.theme.mergeStyle({}, this.styles.headerIcon, isSelected ? this.styles.activeHeaderIcon : null)}\n                      iconclass={header.icon}></WmIcon>\n                    <Text numberOfLines={1} style={[\n                      this.styles.headerText,\n                      isSelected ? this.styles.activeHeaderText : null]}\n                      {...this.getTestPropsForLabel(i + '_title')}\n                    >{header.title}</Text>\n                  </View>\n                </View>\n              </Tappable>\n            );\n          })}\n        </View>\n        <Animated.View style={[this.styles.activeIndicator, {\n          transform: [{\n            translateX: this.indicatorPosition\n          }, {\n            scaleX: this.indicatorWidth\n          }]\n        }]}>\n          <Animated.View style={[{\n              transform: [{\n                scaleX: this.reverseIndicatorWidth\n              }]\n            },\n            this.styles.arrowIndicator\n          ]}>\n            {\n            arrowIndicator.backgroundImage ? (\n              <BackgroundComponent\n              image={arrowIndicator.backgroundImage}\n              position={arrowIndicator.backgroundPosition}\n              size={arrowIndicator.backgroundSize}\n              repeat={arrowIndicator.backgroundRepeat}\n              resizeMode={arrowIndicator.backgroundResizeMode}\n              style={{borderRadius: this.styles.root.borderRadius}}\n              ></BackgroundComponent>\n            ) : null }\n            <View style={this.styles.arrowIndicatorDot}></View>\n          </Animated.View>\n        </Animated.View>\n        </View>\n      </ScrollView>\n      </View>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmTabheaderProps extends BaseProps {\n  data: {icon: string, key: string, title: string}[] = [] as any;\n  selectedTabIndex? = 0;\n  onIndexChange?: (index: number) => any = null as any;\n  shouldScroll?: boolean;\n  disabletoucheffect?: boolean = false;\n}", "wavemaker-rn-runtime/src/components/container/tabs/tabheader/tabheader.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { TextStyle, ViewStyle } from 'react-native';\nimport { WmIconStyles } from '@wavemaker/app-rn-runtime/components/basic/icon/icon.styles';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmTabheaderStyles = BaseStyles & {\n    activeIndicator: ViewStyle,\n    header: ViewStyle,\n    headerIcon: WmIconStyles,\n    headerText: TextStyle,\n    arrowIndicator: ViewStyle,\n    arrowIndicatorDot: ViewStyle,\n    activeHeader: ViewStyle,\n    activeHeaderIcon: WmIconStyles,\n    activeHeaderText: TextStyle,\n    skeleton: WmSkeletonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-tabheader';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles = {\n        root: {\n            flexDirection: 'row',\n            minWidth: '100%',\n            overflow: 'visible',\n            backgroundColor: themeVariables.tabHeaderBgColor,\n        },\n        text: {},\n        header: {\n            backgroundColor: themeVariables.tabHeaderBgColor,\n            paddingTop: 16,\n            paddingBottom: 16,\n            paddingVertical: 12,\n            minWidth: 80,\n            minHeight:48,\n            flexDirection: 'row',\n            justifyContent: 'center',\n            flexGrow: 1\n        },\n        headerIcon: {\n            text: {\n                color: themeVariables.tabHeaderIconColor\n            },\n            icon: {\n                fontSize : 12\n             }\n        } as WmIconStyles,\n        headerText: {\n            color: themeVariables.tabHeaderTextColor,\n            overflow: 'visible',\n            fontFamily: themeVariables.baseFont,\n            fontWeight: '500',\n            fontSize: 14,\n        },\n        activeHeader: {\n            backgroundColor: themeVariables.tabActiveHeaderBgColor\n        },\n        activeIndicator: {\n            backgroundColor: themeVariables.tabActiveIndicatorBgColor,\n            width: 100,\n            height: 2,\n            marginTop: -2\n        },\n        activeHeaderIcon: {\n            text: {\n                color: themeVariables.tabActiveHeaderIconColor\n            }\n        } as WmIconStyles,\n        activeHeaderText: {\n            color: themeVariables.tabActiveHeaderTextColor\n        },\n        arrowIndicator: {\n            display: 'none',\n            backgroundImage: '',\n            backgroundSize: '100% 100%',\n            backgroundPosition: 'center',\n            backgroundRepeat: 'no-repeat'\n        },\n        arrowIndicatorDot: {\n            display: 'none'\n        },\n        skeleton: {} as WmSkeletonStyles\n    } as WmTabheaderStyles;\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});\n", "wavemaker-rn-runtime/src/components/container/layoutgrid/layoutgrid.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmLabelStyles } from '@wavemaker/app-rn-runtime/components/basic/label/label.styles';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmLayoutGridStyles = BaseStyles & {\n  skeleton: WmSkeletonStyles\n}\n\nexport const DEFAULT_CLASS = 'app-layoutgrid';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmLayoutGridStyles = defineStyles({\n      root: {\n        flexDirection: 'column',\n        width: '100%'\n      },\n      text: {},\n      skeleton: {\n        root: {\n        }\n      } as any as WmSkeletonStyles\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n\n  addStyle('table', '', {\n    root: {\n      backgroundColor: themeVariables.layoutGridBgColor,\n      borderWidth: 1,\n      borderLeftWidth: 1,\n      borderTopWidth: 1,\n      borderStyle: 'solid',\n      borderColor: themeVariables.layoutGridBorderColor,\n      borderRadius: 2\n    }\n  });\n\n  addStyle('table-header-label', '', {\n      text: {\n        color: themeVariables.layoutGridHeaderTextColor,\n        fontWeight: 'bold'\n      }\n  } as WmLabelStyles);\n});\n", "wavemaker-rn-runtime/src/components/container/layoutgrid/layoutgrid.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmLayoutgridProps extends BaseProps {\n  children: any;\n}\n", "wavemaker-rn-runtime/src/components/container/layoutgrid/layoutgrid.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmLayoutgridProps from './layoutgrid.props';\nimport { DEFAULT_CLASS, WmLayoutGridStyles } from './layoutgrid.styles';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\nimport { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\n\nexport class WmLayoutgridState extends BaseComponentState<WmLayoutgridProps> {\n\n}\n\nexport default class WmLayoutgrid extends BaseComponent<WmLayoutgridProps, WmLayoutgridState, WmLayoutGridStyles> {\n\n  constructor(props: WmLayoutgridProps) {\n    super(props, DEFAULT_CLASS, new WmLayoutgridProps());\n  }\n\n  getBackground(): React.JSX.Element | null {\n    return this._showSkeleton ? null : this._background\n  } \n\n  public renderSkeleton(props: WmLayoutgridProps): React.ReactNode {\n    if(!props.showskeletonchildren) {\n      const skeletonStyles: WmSkeletonStyles = this.props?.styles?.skeleton || { root: {}, text: {}  } as WmSkeletonStyles\n      return createSkeleton(this.theme, skeletonStyles, {\n        ...this.styles.root\n      }, (<View style={[this.styles.root, { opacity: 0 }]}>\n        {props.children}\n      </View>))\n    }\n    return null;\n  }\n\n\n  renderWidget(props: WmLayoutgridProps) {\n    const styles = this._showSkeleton ? {\n      ...this.styles.root,\n      ...this.styles.skeleton.root\n    } : this.styles.root\n    return (\n      <View \n        onLayout={(event) => this.handleLayout(event)}\n        style={styles} \n        testID={this.getTestId()}\n      >\n        {this.getBackground()}\n        {props.children}\n      </View>\n    ); \n  }\n}\n", "wavemaker-rn-runtime/src/components/container/layoutgrid/gridcolumn/gridcolumn.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type WmGridColumnStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-gridcolumn';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmGridColumnStyles = defineStyles({\n        root: {},\n        text: {}\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n\n    addStyle('table-cell', '', {});\n});\n", "wavemaker-rn-runtime/src/components/container/layoutgrid/gridcolumn/gridcolumn.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmGridcolumnProps from './gridcolumn.props';\nimport { DEFAULT_CLASS, WmGridColumnStyles } from './gridcolumn.styles';\n\nexport class WmGridcolumnState extends BaseComponentState<WmGridcolumnProps> {\n\n}\n\nexport default class WmGridcolumn extends BaseComponent<WmGridcolumnProps, WmGridcolumnState, WmGridColumnStyles> {\n\n  constructor(props: WmGridcolumnProps) {\n    super(props, DEFAULT_CLASS, new WmGridcolumnProps());\n  }\n\n  renderWidget(props: WmGridcolumnProps) {\n    if (this.styles.root.height) {\n      this.styles.root.overflow = undefined;\n    }\n    const styles = this.theme.getStyle(`col-xs-${props.xscolumnwidth}  col-sm-${props.columnwidth}`);\n    return (\n      <View \n        style={[{width: \"100%\"}, styles.root, this.styles.root]}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        {this._background}\n        {props.children}\n      </View>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/container/layoutgrid/gridcolumn/gridcolumn.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmGridcolumnProps extends BaseProps {\n  children: any;\n  columnwidth: number = null as any;\n  xscolumnwidth: number = null as any;\n}\n", "wavemaker-rn-runtime/src/components/container/layoutgrid/gridrow/gridrow.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmGridrowProps extends BaseProps {\n  children: any;\n}", "wavemaker-rn-runtime/src/components/container/layoutgrid/gridrow/gridrow.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmGridrowProps from './gridrow.props';\nimport { DEFAULT_CLASS, WmGridRowStyles } from './gridrow.styles';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport class WmGridrowState extends BaseComponentState<WmGridrowProps> {\n\n}\n\nexport default class WmGridrow extends BaseComponent<WmGridrowProps, WmGridrowState, WmGridRowStyles> {\n\n  constructor(props: WmGridrowProps) {\n    super(props, DEFAULT_CLASS, new WmGridrowProps());\n  }\n\n  renderWidget(props: WmGridrowProps) {\n    const styles = this._showSkeleton ?  {\n      ...this.styles.root,\n      ...this.styles.skeleton.root\n    } : this.styles.root\n\n    return (\n      <View \n        style={styles}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        {this._background}\n        {props.children}\n      </View>\n    ); \n  }\n}\n", "wavemaker-rn-runtime/src/components/container/layoutgrid/gridrow/gridrow.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmGridRowStyles = BaseStyles & {\n  skeleton: WmSkeletonStyles;\n};\n\nexport const DEFAULT_CLASS = 'app-gridrow';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmGridRowStyles = defineStyles({\n      root: {\n          flexDirection: 'row',\n          width: '100%',\n          flexWrap: 'wrap'\n      },\n      text: {},\n      skeleton: {\n        root: {\n          borderColor: 'transparent'\n        } \n      } as any as WmSkeletonStyles\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n  addStyle('table-row', '', {\n      root: {\n          borderBottomWidth: 1,\n          borderStyle: 'solid',\n          borderColor: themeVariables.gridColumnBorderColor\n      }\n  });\n  addStyle('table-header-row', '', {\n      root: {\n          backgroundColor: themeVariables.layoutGridHeaderBgColor\n      }\n  });\n  addStyle('table-striped-row0', '', {\n    root: {\n      backgroundColor: themeVariables.layoutGridStripColor1\n    }\n  });\n  addStyle('table-striped-row1', '', {\n    root: {\n      backgroundColor: themeVariables.layoutGridStripColor2\n    }\n  });\n});", "wavemaker-rn-runtime/src/components/container/panel/panel.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmPanelProps extends BaseProps {\n  animation: string = null as any;\n  children: any;\n  collapsible: boolean = null as any;\n  iconclass: string = null as any;\n  title: string = 'Title';\n  renderPartial?: Function;\n  subheading: string = null as any;\n  badgevalue: string = null as any;\n  badgetype: string = 'default';\n  expanded: boolean = true;\n  iconurl?: string = null as any;\n  iconheight?: number = null as any;\n  iconwidth?: number = null as any;\n  iconmargin?: number = null as any;\n}\n\n", "wavemaker-rn-runtime/src/components/container/panel/panel.styles.ts": "import BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmIconStyles } from '@wavemaker/app-rn-runtime/components/basic/icon/icon.styles';\nimport { Platform } from 'react-native';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmPanelStyles = BaseStyles & {\n  icon: WmIconStyles,\n  badge: AllStyle,\n  header: AllStyle,\n  subheading: AllStyle,\n  skeleton: WmSkeletonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-panel';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmPanelStyles = defineStyles({\n      root: {\n        backgroundColor: themeVariables.panelBgColor,\n        borderStyle: 'solid',\n        borderWidth: 0,\n        padding: 12,\n        borderRadius: 6\n      },\n      text: {\n        color: themeVariables.panelHeaderTextColor,\n        fontSize: 16,\n        fontWeight: 'bold'\n      },\n      header: {\n        flexDirection: 'row',\n        backgroundColor: themeVariables.panelHeaderBgColor,\n        paddingHorizontal: 8,\n        paddingVertical: 4,\n        borderStyle: 'solid',\n        borderWidth: 0,\n        borderColor: themeVariables.panelHeaderBgColor,\n        borderTopLeftRadius: 6,\n        borderTopRightRadius: 6\n      },\n      heading: {\n        paddingHorizontal: 16\n      },\n      subheading: {\n        paddingHorizontal: 16\n      },\n      icon: {\n        root: {\n          alignSelf: 'auto',\n          fontSize: 32,\n        },\n      } as WmIconStyles,\n      toggleIcon: {\n        root: {\n          fontSize: 16,\n        },\n      } as WmIconStyles,\n      badge: {\n        color: themeVariables.badgeTextColor,\n        marginRight: 8,\n        alignSelf: 'center'\n      },\n      default: {\n        backgroundColor: themeVariables.labelDefaultColor\n      },\n      success: {\n        backgroundColor: themeVariables.labelSuccessColor\n      },\n      danger: {\n        backgroundColor: themeVariables.labelDangerColor\n      },\n      warning: {\n        backgroundColor: themeVariables.labelWarningColor\n      },\n      info: {\n        backgroundColor: themeVariables.labelInfoColor\n      },\n      primary: {\n        backgroundColor: themeVariables.labelPrimaryColor\n      },\n      skeleton: {\n        root: {\n        }\n      } as WmSkeletonStyles, \n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n  addStyle(DEFAULT_CLASS + '-rtl', '', Platform.OS==\"web\"?{\n    text:{\n      textAlign:'right',\n    } ,\n    subheading:{\n      textAlign:'right',\n    }\n  }:{});\n  const getPanelBgStyles = (color: string) => {\n    return {\n      header: {\n        backgroundColor: color\n      },\n      text: {\n        color: themeVariables.panelTextColor\n      },\n      subheading: {\n        color: themeVariables.panelTextColor\n      },\n      icon: {\n        text: {\n          color: themeVariables.panelTextColor\n        }\n      } as WmIconStyles\n    } as WmPanelStyles;\n  };\n\n  addStyle('panel-danger', '', getPanelBgStyles(themeVariables.panelDangerColor));\n  addStyle('panel-default', '', getPanelBgStyles(themeVariables.panelDefaultColor));\n  addStyle('panel-info', '', getPanelBgStyles(themeVariables.panelInfoColor));\n  addStyle('panel-primary', '', getPanelBgStyles(themeVariables.panelPrimaryColor));\n  addStyle('panel-success', '', getPanelBgStyles(themeVariables.panelSuccessColor));\n  addStyle('panel-warning', '', getPanelBgStyles(themeVariables.panelWarningColor));\n});", "wavemaker-rn-runtime/src/components/container/panel/collapsible-pane.component.tsx": "import React, { useCallback, useMemo, useState } from 'react';\nimport { LayoutChangeEvent, View } from 'react-native';\nimport { isWebPreviewMode } from '@wavemaker/app-rn-runtime/core/utils';\n\nconst Animated: any = isWebPreviewMode() ? {} : require('react-native-reanimated');\n\nexport const CollapsiblePane = (props: {\n    close: boolean,\n    children: any\n  }) => {\n    const [height, setHeight] = useState(0);\n    const offset = Animated.useSharedValue(0);\n    offset.value = props.close ? 0 : 1;\n    const onLayoutChange = (e: LayoutChangeEvent) => {\n      setHeight((e.nativeEvent?.layout?.height || height || 100000000) + 1000);\n    };\n    const animatedStyles = Animated.useAnimatedStyle(() => {\n      return {\n        maxHeight: Animated.withTiming(offset.value * height)\n      };\n    });\n    return (\n        <Animated.default.View style={[{overflow: 'hidden'}, animatedStyles]}>\n          <View onLayout={onLayoutChange}>\n            {props.children}\n          </View>\n        </Animated.default.View>\n      );\n  };", "wavemaker-rn-runtime/src/components/container/panel/panel.component.tsx": "import React from 'react';\nimport { Text, View, TouchableOpacity } from 'react-native';\nimport { isUndefined } from 'lodash';\nimport { Badge } from 'react-native-paper';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\n\nimport WmPanelProps from './panel.props';\nimport { DEFAULT_CLASS, WmPanelStyles } from './panel.styles';\nimport { isWebPreviewMode } from '@wavemaker/app-rn-runtime/core/utils';\nimport { CollapsiblePane } from './collapsible-pane.component';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\nimport { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\nimport WmLabel from '@wavemaker/app-rn-runtime/components/basic/label/label.component';\n\nexport class WmPanelState extends BaseComponentState<WmPanelProps> {\n  isPartialLoaded = false;\n}\n\nexport default class WmPanel extends BaseComponent<WmPanelProps, WmPanelState, WmPanelStyles> {\n  constructor(props: WmPanelProps) {\n    super(props, DEFAULT_CLASS, new WmPanelProps());\n  }\n\n  onPartialLoad() {\n    this.invokeEventCallback('onLoad', [this]);\n  }\n\n  renderContent(props: WmPanelProps) {\n    if (props.renderPartial) {\n      if (!this.state.isPartialLoaded) {\n        setTimeout(() => {\n          this.updateState({\n            isPartialLoaded: true\n          } as WmPanelState);\n        });\n      }\n      return props.renderPartial(props, this.onPartialLoad.bind(this));\n    }\n  }\n\n  onPanelPress() {\n    if (!this.state.props.collapsible) {\n      return;\n    }\n    const eventName = this.state.props.expanded ? 'onCollapse' : 'onExpand';\n    this.updateState({\n      props: {\n        expanded: !this.state.props.expanded\n      }\n    } as WmPanelState);\n\n    this.invokeEventCallback(eventName, [null, this.proxy]);\n  }\n\n  expandCollapseIcon(isExpanded: boolean) {\n    const widgetProps = this.state.props;\n    //@ts-ignore\n    const badge = widgetProps.badgevalue != undefined ? (<Badge style={[this.styles.badge, this.styles[widgetProps.badgetype || 'default']]} {...this.getTestProps('badge')}>{widgetProps.badgevalue}</Badge>): null;\n    const iconclass = isExpanded ? 'wi wi-chevron-up' : 'wi wi-chevron-down';\n    const expandCollapseIcon = widgetProps.collapsible ? (<WmIcon id={this.getTestId('collapseicon')} name={'expand_collapse_icon'} styles={this.styles.toggleIcon} iconclass={iconclass}></WmIcon>) : null;\n    return (<View style={{flexDirection: 'row', alignItems: 'center'}}>{badge}{expandCollapseIcon}</View>);\n  }\n\n  renderHeader() {\n    const props = this.state.props;\n    return (\n      <TouchableOpacity\n        {...this.getTestPropsForAction(`header`)}\n        style={[this.styles.header]}\n        onPress={this.onPanelPress.bind(this)}\n        accessibilityRole='header'>\n      {props.iconclass || props.iconurl ? \n        <WmIcon styles={this.styles.icon}\n        id={this.getTestId('icon')} \n        name={props.name + '_icon'}\n        iconclass={props.iconclass}\n        iconheight={props.iconheight}\n        iconwidth={props.iconwidth}\n        iconmargin={props.iconmargin}\n        iconurl={props.iconurl}\n        /> : null}\n        <View style={{flexDirection: 'column', flex: 1, justifyContent: 'center'}}>\n          {\n            this._showSkeleton ? \n            <WmLabel \n            showskeleton={true}\n            styles={{root: [\n              this.styles.text,\n              this.styles.heading]}} caption={isUndefined(props.title) ? 'Title' : props.title}/> : \n            <Text style={[\n              this.styles.text,\n              this.styles.heading]}\n              {...this.getTestPropsForAction(`header_title`)}>\n                {isUndefined(props.title) ? 'Title' : props.title}\n            </Text>\n          }\n          {props.subheading ? \n            (this._showSkeleton ? \n            <WmLabel  \n              showskeleton={true} \n              styles={{root: this.styles.subheading}} \n              caption={props.subheading} /> :\n             <Text \n               style={this.styles.subheading}\n              {...this.getTestPropsForAction(`subheader`)}>\n                {props.subheading}\n              </Text> ) : null }\n        </View>\n        {this.expandCollapseIcon(props.expanded)}\n      </TouchableOpacity>\n    );\n  }\n\n  renderPane(content: React.ReactNode) {\n    const expanded = this.state.props.expanded;\n    return isWebPreviewMode() || this.styles.header.display == \"none\" ? \n      (<View style={expanded ? {} : {maxHeight: 0, overflow: 'hidden'}}>\n        {content}\n      </View>) :\n      (<CollapsiblePane close={!expanded}>\n        {content}\n      </CollapsiblePane>);\n  }\n\n  protected getBackground(): React.JSX.Element | null {\n    return this._showSkeleton ? null : this._background\n  } \n  \n  public renderSkeleton(props: WmPanelProps): React.ReactNode {\n      if(!props.showskeletonchildren) {\n        const skeletonStyles: WmSkeletonStyles = this.props?.styles?.skeleton || { root: {}, text: {}  } as WmSkeletonStyles\n        return createSkeleton(this.theme, skeletonStyles, {\n          ...this.styles.root\n        }, (<View style={[this.styles.root, { opacity: 0 }]}>\n                {this.renderHeader()}\n                {this.renderPane((\n                  <>\n                  {this.renderContent(props)}\n                  <View>{props.children}</View>\n                  </>\n                ))}\n        </View>))\n      }\n      return null;\n    }\n\n  renderWidget(props: WmPanelProps) {\n    const styles = this._showSkeleton ? {\n      ...this.styles.root,\n      ...this.styles.skeleton.root\n    } : this.styles.root\n    return (\n    <View \n      style={styles} \n      testID={this.getTestId()} \n      onLayout={(event) => this.handleLayout(event)}\n    >\n      {this.getBackground()}\n      {this.renderHeader()}\n      {this.renderPane((\n        <>\n        {this.renderContent(props)}\n        <View>{props.children}</View>\n        </>\n      ))}\n    </View>);\n  }\n}\n", "wavemaker-rn-runtime/src/components/container/panel/panel-content/panel-content.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmPanelContentProps from './panel-content.props';\nimport { DEFAULT_CLASS, WmPanelContentStyles } from './panel-content.styles';\n\nexport class WmPanelContentState extends BaseComponentState<WmPanelContentProps> {}\n\nexport default class WmPanelContent extends BaseComponent<WmPanelContentProps, WmPanelContentState, WmPanelContentStyles> {\n\n  constructor(props: WmPanelContentProps) {\n    super(props, DEFAULT_CLASS, new WmPanelContentProps());\n  }\n\n  renderWidget(props: WmPanelContentProps) {\n    return (<View style={this.styles.root}>{this._background}{props.children}</View>); \n  }\n}\n", "wavemaker-rn-runtime/src/components/container/panel/panel-content/panel-content.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type WmPanelContentStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-panel-content';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmPanelContentStyles = defineStyles({\n        root: {\n            borderStyle: 'solid',\n            borderWidth: 1,\n            borderTopWidth: 0,\n            borderColor: themeVariables.panelHeaderBgColor\n        },\n        text: {}\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/container/panel/panel-content/panel-content.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmPanelContentProps extends BaseProps {\n    children?: any[];\n}", "wavemaker-rn-runtime/src/components/container/panel/panel-footer/panel-footer.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type WmPanelFooterStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-panel-footer';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmPanelFooterStyles = defineStyles({\n        root: {\n            borderStyle: 'solid',\n            borderWidth: 1,\n            borderColor: themeVariables.panelFooterColor,\n            minHeight: 64,\n            marginTop: 8,\n            padding: 8,\n            borderRadius: 6\n        },\n        text: {}\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/container/panel/panel-footer/panel-footer.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmPanelFooterProps from './panel-footer.props';\nimport { DEFAULT_CLASS, WmPanelFooterStyles } from './panel-footer.styles';\n\nexport class WmPanelFooterState extends BaseComponentState<WmPanelFooterProps> {}\n\nexport default class WmPanelFooter extends BaseComponent<WmPanelFooterProps, WmPanelFooterState, WmPanelFooterStyles> {\n\n  constructor(props: WmPanelFooterProps) {\n    super(props, DEFAULT_CLASS, new WmPanelFooterProps());\n  }\n\n  renderWidget(props: WmPanelFooterProps) {\n    return (<View style={this.styles.root}>{this._background}{props.children}</View>);\n  }\n}\n", "wavemaker-rn-runtime/src/components/container/panel/panel-footer/panel-footer.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmPanelFooterProps extends BaseProps {\n  children: any;\n}\n", "wavemaker-rn-runtime/src/components/container/accordion/accordion.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmAccordionProps extends BaseProps {\n  animation: string = 'fadeInDown';\n  children: any;\n  defaultpaneindex: number = 0;\n  closeothers = true;\n}\n\n", "wavemaker-rn-runtime/src/components/container/accordion/accordion.component.tsx": "import React from 'react';\nimport { Text, TouchableOpacity, View } from 'react-native';\nimport { Badge } from 'react-native-paper';\nimport { isArray } from 'lodash';\n\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport WmAccordionProps from './accordion.props';\nimport {  DEFAULT_CLASS, WmAccordionStyles } from './accordion.styles';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport WmAccordionpane from './accordionpane/accordionpane.component';\nimport { isDefined } from '@wavemaker/app-rn-runtime/core/utils';\n\nimport { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\nimport WmLabel from '@wavemaker/app-rn-runtime/components/basic/label/label.component';\n\nexport class WmAccordionState extends BaseComponentState<WmAccordionProps> {\n  lastExpandedIndex = -1;\n  isExpanded = [] as boolean[];\n}\n\n\nexport default class WmAccordion extends BaseComponent<WmAccordionProps, WmAccordionState, WmAccordionStyles> {\n  public accordionPanes = [] as WmAccordionpane[];\n  private newIndex = 0;\n\n  constructor(props: WmAccordionProps) {\n    super(props, DEFAULT_CLASS, new WmAccordionProps(), new WmAccordionState());\n  }\n\n  addAccordionPane(accordionPane: WmAccordionpane) {\n    const i = this.accordionPanes.findIndex(t => {\n      return t.paneId === accordionPane.paneId});\n    if (i >= 0) {\n      this.accordionPanes[i] = accordionPane;\n    } else {\n      accordionPane.paneId = `accordionPane${this.newIndex++}`;\n      this.accordionPanes.push(accordionPane);\n    }\n    this.toggle(this.state.props.defaultpaneindex + 1);\n  }\n\n  removeAccordionPane(accordionPane: WmAccordionpane){\n    const index = this.accordionPanes.findIndex(t => t.paneId === accordionPane.paneId);\n    if (index >= 0) {\n      this.accordionPanes.splice(index, 1); \n      this.newIndex--;\n    }\n  }\n\n  expand(accordionName: string) {\n    const i = this.accordionPanes.findIndex(t => t.props.name === accordionName);\n    this.toggle(i + 1, true);\n  }\n\n  collapse(accordionName: string) {\n    const i = this.accordionPanes.findIndex(t => t.props.name === accordionName);\n    this.toggle(i + 1, false);\n  }\n\n  expandCollapseIcon(item: any, index: number, showBadge = true, showIcon = true, useChevron = true, isExpanded = false) {\n    const widgetProps = item.props;\n    //@ts-ignore\n    const badge = showBadge && widgetProps.badgevalue != undefined ? (\n      <Badge style={[\n        this.styles.badge,\n        isExpanded ? this.styles.activeBadge: null,\n        this.styles[widgetProps.badgetype || 'default']]}\n        {...this.getTestProps('badge'+index)}>\n        {widgetProps.badgevalue}\n      </Badge>): null;\n    let iconclass = null;\n    if (useChevron) {\n      iconclass = isExpanded ? 'wi wi-chevron-down' : 'wi wi-chevron-up';\n    } else {\n      iconclass = isExpanded ? 'wi wi-minus' : 'wi wi-plus';\n    }\n    return (<View style={{flexDirection: 'row'}}>\n            {badge}\n            {showIcon ? (\n              <WmIcon\n              id={this.getTestId('icon' + index)}\n              styles={this.theme.mergeStyle({}, this.styles.icon, isExpanded ? this.styles.activeIcon : null)}\n              name={'expand_collapse_icon'}\n              iconclass={iconclass}></WmIcon>): null}\n          </View>);\n  }\n\n  renderAccordionpane(item: any, index: any, accordionpanes: any[] = []) {\n    const showIconOnLeft = this.styles.leftToggleIcon.root.width !== undefined;\n    const isExpanded = this.state.isExpanded[index];\n    const titleIconStyles = this.theme.mergeStyle(this.styles.icon, this.styles.titleIcon)\n    return item.props.show != false ? (\n      <View \n        style={this.styles.pane} \n        key={item.props.title}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        <TouchableOpacity key={'accordionpane_' + (index + 1)}\n              {...this.getTestPropsForAction(`header${index}`)}\n              style={[this.styles.header,\n                index === 0 ? this.styles.firstHeader: null,\n                index === accordionpanes.length - 1 && !isExpanded ? this.styles.lastHeader: null,\n                isExpanded ? this.styles.activeHeader : {}]}\n                onPress={this.toggle.bind(this, index + 1, !isExpanded)}>\n          {this.expandCollapseIcon(item, index, false, showIconOnLeft, true, isExpanded)}\n          {item.props.iconclass ? <WmIcon id={this.getTestId('icon')} styles={titleIconStyles} name={item.props.name + '_icon'} iconclass={item.props.iconclass}></WmIcon>: null}\n          <View style={{flexDirection: 'column', flex: 1, justifyContent: 'center'}}>\n            {this._showSkeleton ? \n             <WmLabel \n               showskeleton={true}\n               styles={{\n                root: [\n                  this.styles.text,\n                  this.styles.heading\n                ]\n              }} \n              caption={isDefined(item.props.title) ? item.props.title : 'Title'}/> :  \n             <Text \n                style={[\n                  this.styles.text,\n                  this.styles.heading,\n                  isExpanded ? this.styles.activeHeaderTitle : {}]}\n                  {...this.getTestPropsForAction(`header${index}_title`)}\n                  accessibilityRole='header'>\n                    {isDefined(item.props.title) ? item.props.title : 'Title'}\n            </Text>} \n            {item.props.description ? \n              (this._showSkeleton ? \n              <WmLabel \n                styles={{root: this.styles.subheading}} \n                showskeleton={true} \n                caption={item.props.description} /> : \n              <Text style={this.styles.subheading}\n                {...this.getTestPropsForAction(`header${index}_description`)}>\n                  {item.props.description}\n               </Text>) : null }\n          </View>\n          {this.expandCollapseIcon(item, index, true, !showIconOnLeft, true, isExpanded)}\n        </TouchableOpacity>\n        {item}\n      </View>\n    ): null;\n  }\n\n  toggle(index: number, expand = true) {\n    let expandedId = expand ? index : -1;\n    let collapseId = expand ? -1 : index;\n    const expandedPane = expandedId ? this.accordionPanes[expandedId - 1]: null;\n    if (expand && this.state.isExpanded[expandedId - 1] && !expandedPane?.state.collapsed\n        || !expand && this.state.isExpanded[collapseId - 1] === false && expandedPane?.state.collapsed) {\n        return;\n    }\n    if (collapseId < 0 && this.state.props.closeothers) {\n      collapseId = this.state.lastExpandedIndex;\n    }\n    const collapsedPane = this.accordionPanes[collapseId -1];\n    collapsedPane?.hide();\n    Promise.resolve().then(() => {\n      expandedPane?.show();\n      this.setState((state) => {\n        if (collapseId > 0 && collapsedPane) {\n          state.isExpanded[collapseId - 1] = false;\n        }\n        if (expandedId > 0 && expandedPane) {\n          state.isExpanded[expandedId - 1] = true;\n        }\n        return {\n          lastExpandedIndex: expandedId,\n          isExpanded: [...state.isExpanded]\n        };\n      }, () => {\n        this.invokeEventCallback('onChange', [{},\n          this.proxy,\n          expandedId - 1,\n          collapseId ? collapseId - 1 : null,\n          expandedPane && expandedPane.props.name,\n          collapsedPane && collapsedPane.props.name]);\n        });\n    }, () => {});\n  }\n\n  public componentDidMount(): void {\n      super.componentDidMount();\n      this.toggle(this.state.props.defaultpaneindex + 1);\n  }\n\n  protected getBackground(): React.JSX.Element | null {\n    return this._showSkeleton ? null : this._background\n  } \n  \n  public renderSkeleton(props: WmAccordionProps): React.ReactNode {\n    const accordionpanes = props.children;\n      if(!props.showskeletonchildren) {\n        const skeletonStyles: WmSkeletonStyles = this.props?.styles?.skeleton || { root: {}, text: {}  } as WmSkeletonStyles\n        return createSkeleton(this.theme, skeletonStyles, {\n          ...this.styles.root\n        }, (<View style={[this.styles.root, { opacity: 0 }]}>\n           {accordionpanes\n              ? isArray(accordionpanes) && accordionpanes.length\n                ? accordionpanes.map((item: any, index: any) => this.renderAccordionpane(item, index, accordionpanes))\n                : this.renderAccordionpane(accordionpanes, 0)\n              : null}\n        </View>))\n      }\n      return null;\n    }\n\n\n  renderWidget(props: WmAccordionProps) {\n    const accordionpanes = props.children;\n    const expandedId = this.state.lastExpandedIndex || 0;\n    const styles = this._showSkeleton ? {\n      ...this.styles.root,\n      ...this.styles.skeleton?.root\n    } : this.styles.root\n    return (\n        <View style={styles}>\n          {this.getBackground()}\n            {accordionpanes\n              ? isArray(accordionpanes) && accordionpanes.length\n                ? accordionpanes.map((item: any, index: any) => this.renderAccordionpane(item, index, accordionpanes))\n                : this.renderAccordionpane(accordionpanes, 0)\n              : null}\n        </View>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/container/accordion/accordion.styles.ts": "import BASE_THEME, {AllStyle} from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmIconStyles } from '@wavemaker/app-rn-runtime/components/basic/icon/icon.styles';\nimport { TextStyle, ViewStyle, Platform } from 'react-native';\nimport Color from 'color';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmAccordionStyles = BaseStyles & {\n  icon: WmIconStyles,\n  rightToggleIcon: WmIconStyles,\n  leftToggleIcon: WmIconStyles,\n  activeIcon: WmIconStyles,\n  pane: AllStyle,\n  badge: AllStyle,\n  activeBadge: AllStyle,\n  firstHeader: ViewStyle,\n  lastHeader: ViewStyle,\n  header: AllStyle,\n  activeHeader: AllStyle,\n  activeHeaderTitle: TextStyle,\n  subheading: AllStyle,\n  titleIcon: WmIconStyles,\n  skeleton: WmSkeletonStyles\n};\n \nexport const DEFAULT_CLASS = 'app-accordion';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmAccordionStyles = defineStyles({\n      root: {\n        width: '100%',\n        borderWidth: 0,\n        borderStyle: 'solid',\n        borderColor: themeVariables.accordionBorderColor,\n        borderRadius: 6,\n        backgroundColor: themeVariables.transparent\n      },\n      text: {\n        color: themeVariables.accordionTitleColor,\n        fontSize: 18\n      },\n      firstHeader: {\n        borderTopLeftRadius: 6,\n        borderTopRightRadius: 6\n      },\n      pane : {},\n      header: {\n        borderBottomWidth: 1,\n        borderStyle: 'solid',\n        borderColor: themeVariables.accordionBorderColor,\n        backgroundColor: themeVariables.accordionHeaderBgColor,\n        padding: 8,\n        flexDirection: 'row',\n        justifyContent: 'center'\n      },\n      lastHeader: {\n        borderBottomWidth: 0,\n        borderBottomLeftRadius: 6,\n        borderBottomRightRadius: 6\n      },\n      activeHeader: {\n        borderColor: themeVariables.accordionActiveHeaderBgColor,\n        backgroundColor: themeVariables.accordionActiveHeaderBgColor\n      },\n      activeHeaderTitle: {\n        color: themeVariables.accordionActiveHeaderTextColor\n      },\n      subheading: {\n\n      },\n      icon: {\n        root: {\n          alignSelf: 'auto',\n          width: 24,\n          height: 24,\n          borderRadius: 24,\n          justifyContent: 'center'\n        },\n        icon: {\n          color: themeVariables.accordionIconColor,\n          alignSelf: 'center',\n          justifyContent: 'center',\n          fontSize: 16,\n          fontWeight: 'bold'\n        }\n      } as WmIconStyles,\n      leftToggleIcon: {\n        root: {}\n      } as WmIconStyles,\n      rightToggleIcon: {\n        root: {}\n      } as WmIconStyles,\n      activeIcon : {\n        root: {\n          borderColor: themeVariables.accordionActiveHeaderTextColor,\n        },\n        icon: {\n          color: themeVariables.accordionActiveHeaderTextColor\n        }\n      } as WmIconStyles,\n      activeBadge: {\n        borderColor: themeVariables.accordionActiveHeaderTextColor,\n        color: themeVariables.accordionActiveHeaderTextColor\n      },\n      badge: {\n          color: themeVariables.accordionIconColor,\n          fontSize: 14,\n          marginRight: 4,\n          width: 24,\n          height: 24,\n          borderRadius: 12,\n          alignContent: 'center',\n          borderStyle: 'solid',\n          borderWidth: 2,\n          borderColor: themeVariables.accordionIconColor,\n          backgroundColor: themeVariables.transparent\n      },\n      titleIcon: {} as WmIconStyles,\n      default: {},\n      success: {\n        backgroundColor: themeVariables.labelSuccessColor\n      },\n      danger: {\n        backgroundColor: themeVariables.labelDangerColor\n      },\n      warning: {\n        backgroundColor: themeVariables.labelWarningColor\n      },\n      info: {\n        backgroundColor: themeVariables.labelInfoColor\n      },\n      primary: {\n        backgroundColor: themeVariables.labelPrimaryColor\n      },\n      skeleton: {\n        root: {\n        },\n        text: {}\n      } as WmSkeletonStyles\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n  addStyle(DEFAULT_CLASS + '-rtl', '', Platform.OS==\"web\"?{\n    text:{\n        textAlign:'right',\n    }  \n  }:{\n    text:{\n      textAlign:'left',\n    }  \n  });\n  addStyle('app-accordion1', '', {\n    pane: {\n      marginBottom: 0\n    },\n    leftToggleIcon: {\n      root: {\n        width: 1\n      }\n    },\n    icon: {\n      root: {\n        backgroundColor: 'rgba(255, 255, 255, 0.1)'\n      }\n    }\n  } as WmAccordionStyles);\n});\n", "wavemaker-rn-runtime/src/components/container/accordion/accordionpane/accordionpane.component.tsx": "import React, { useCallback, useMemo, useState } from 'react';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmAccordionpaneProps from './accordionpane.props';\nimport { DEFAULT_CLASS, WmAccordionpaneStyles } from './accordionpane.styles';\nimport WmAccordion from '../accordion.component';\nimport { View } from 'react-native';\nimport { isWebPreviewMode } from '@wavemaker/app-rn-runtime/core/utils';\nimport { CollapsiblePane } from '../../panel/collapsible-pane.component';\n\nexport class WmAccordionpaneState extends BaseComponentState<WmAccordionpaneProps> {\n  isPartialLoaded = false;\n  collapsed = true;\n}\n\nexport default class WmAccordionpane extends BaseComponent<WmAccordionpaneProps, WmAccordionpaneState, WmAccordionpaneStyles> {\n  public paneId: string = \"\";\n  constructor(props: WmAccordionpaneProps) {\n    super(props, DEFAULT_CLASS, new WmAccordionpaneProps(), new WmAccordionpaneState());\n  }\n\n  isCollapsed() {\n    return this.state.collapsed;\n  }\n  \n  show() {\n    this.updateState({\n      collapsed: false\n    } as WmAccordionpaneState);\n    this.invokeEventCallback('onExpand', [null, this.proxy]);\n  }\n\n  hide() {\n    this.updateState({\n      collapsed: true\n    } as WmAccordionpaneState);\n    this.invokeEventCallback('onCollapse', [null, this.proxy]);\n  }\n\n  expand() {\n    (this.parent as WmAccordion).expand(this.props.name || '');\n  }\n\n  collapse() {\n    (this.parent as WmAccordion).expand(this.props.name || '');\n  }\n\n  componentDidMount() {\n    const accordion = (this.parent) as WmAccordion;\n    // When skeleton is enabled in the accordion component, the parent would be WMSkeleton which doesnot have addAccordionPane function\n    if(accordion.addAccordionPane) {\n      accordion.addAccordionPane(this);\n    }\n    super.componentDidMount();\n  }\n\n  componentWillUnmount() {\n    const accordion = (this.parent) as WmAccordion;\n    if(accordion.removeAccordionPane) {\n      accordion.removeAccordionPane(this);\n    }\n  }\n\n  onPartialLoad() {\n    this.invokeEventCallback('onLoad', [this]);\n  }\n\n  renderContent(props: WmAccordionpaneProps) {\n    if (props.renderPartial) {\n      if (!this.state.isPartialLoaded) {\n        setTimeout(() => {\n          this.updateState({\n            isPartialLoaded: true\n          } as WmAccordionpaneState);\n        });\n      }\n      return props.renderPartial(props, this.onPartialLoad.bind(this));\n    }\n    return props.children;\n  }\n  renderWidget(props: WmAccordionpaneProps) {\n    return isWebPreviewMode() ? \n    (<View style={this.state.collapsed ? {maxHeight: 0, overflow: 'hidden'} : {}}>\n      {this._background}\n      {this.renderContent(props)}\n    </View>) :\n    (<CollapsiblePane close={this.state.collapsed}>\n      {this._background}\n      {this.renderContent(props)}\n    </CollapsiblePane>);\n  }\n}\n", "wavemaker-rn-runtime/src/components/container/accordion/accordionpane/accordionpane.styles.ts": "import Color from 'color';\nimport BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type WmAccordionpaneStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-accordionpane';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmAccordionpaneStyles = defineStyles({\n        root: {\n            minHeight: 120,\n            borderStyle: 'solid',\n            borderColor: themeVariables.accordionBorderColor,\n            backgroundColor: themeVariables.accordionPaneBgColor,\n            padding: 4\n        },\n        text: {}\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/container/accordion/accordionpane/accordionpane.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmAccordionpaneProps extends BaseProps {\n  children: any;\n  iconclass: string = null as any;\n  title: string = 'Title';\n  renderPartial?: Function;\n  subheading: string = null as any;\n  badgevalue: string = null as any;\n  badgetype: string = null as any;\n}\n", "wavemaker-rn-runtime/src/components/container/wizard/wizard.styles.ts": "import BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmButtonStyles } from '@wavemaker/app-rn-runtime/components/basic/button/button.styles';\nimport { WmIconStyles } from '@wavemaker/app-rn-runtime/components/basic/icon/icon.styles';\nimport { WmAnchorStyles } from '@wavemaker/app-rn-runtime/components/basic/anchor/anchor.styles';\nimport { WmProgressCircleStyles } from '@wavemaker/app-rn-runtime/components/basic/progress-circle/progress-circle.styles';\nimport { WmPopoverStyles } from '@wavemaker/app-rn-runtime/components/navigation/popover/popover.styles';\nimport { WmLabelStyles } from '@wavemaker/app-rn-runtime/components/basic/label/label.styles';\nimport { TextStyle } from 'react-native';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmWizardStyles = BaseStyles & {\n  wizardHeader: AllStyle,\n  wizardBody: AllStyle,\n  wizardFooter: AllStyle,\n  wizardActions: WmButtonStyles,\n  stepTitle: AllStyle,\n  stepSubTitle: AllStyle,\n  buttonWrapper: AllStyle,\n  step: AllStyle,\n  nextButton: WmButtonStyles,\n  doneButton: WmButtonStyles,\n  prevButton: WmButtonStyles,\n  cancelButton: WmButtonStyles,\n  stepIcon: WmIconStyles,\n  skipLink: WmAnchorStyles,\n  activeStep: AllStyle,\n  doneStep: AllStyle,\n  headerWrapper: AllStyle,\n  stepWrapper: AllStyle,\n  stepConnector: AllStyle,\n  numberTextStepConnector: AllStyle,\n  activeStepCounter: TextStyle,\n  stepCounter: AllStyle,\n  progressCircle: WmProgressCircleStyles,\n  popover: WmPopoverStyles,\n  stepMenu: AllStyle,\n  activeStepMenu: AllStyle,\n  stepMenuLabel: WmLabelStyles,\n  stepMenuActiveLabel: WmLabelStyles\n  stepMenuIcon: WmIconStyles,\n  stepMenuActiveIcon: WmIconStyles,\n  skeleton: WmSkeletonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-wizard';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmWizardStyles = defineStyles({\n      root: {\n        flexDirection: 'column',\n        backgroundColor: themeVariables.wizardBackgroundColor,\n        display: 'flex',\n        minHeight: 240\n      },\n      text: {},\n      activeStep:{\n          backgroundColor: themeVariables.wizardStepActiveColor,\n          borderColor: themeVariables.wizardStepActiveColor,\n          color: themeVariables.wizardActiveStepColor\n      },\n      doneStep: {\n        backgroundColor: themeVariables.wizardStepDoneColor,\n        color: themeVariables.wizardDoneStepColor,\n        borderColor: themeVariables.wizardStepDoneColor\n      },\n      wizardHeader: {\n        padding: 8,\n        flexDirection: 'row',\n        alignItems: 'flex-start',\n        justifyContent: 'center'\n      },\n      stepWrapper: {\n        alignItems: 'center',\n        justifyContent: 'center',\n        zIndex: 20\n      },\n      headerWrapper: {\n        flex: 1\n      },\n      wizardBody: {\n        alignSelf: 'flex-start',\n        paddingTop: 10,\n        width: '100%',\n        borderWidth: 0,\n        borderTopWidth: 1,\n        borderBottomWidth: 1,\n        borderColor: themeVariables.wizardBorderColor\n      },\n      wizardFooter: {\n        flexDirection: 'row',\n        justifyContent: 'flex-start',\n        padding: 12,\n        width: '100%',\n      },\n      buttonWrapper: {\n        flexDirection: 'row',\n      },\n      stepTitle: {\n          textTransform: 'capitalize',\n          fontSize: 12,\n          color: themeVariables.wizardStepTitleColor\n      },\n      stepSubTitle:{\n        color: themeVariables.wizardStepTitleColor\n      },\n      step: {\n        alignItems: 'center',\n        justifyContent: 'center',\n        width: 37,\n        backgroundColor: themeVariables.wizardBackgroundColor,\n        height: 37,\n        borderWidth: 1,\n        borderRadius: 18.5,\n        color: themeVariables.wizardStepColor,\n        borderColor: themeVariables.wizardStepColor\n      },\n      wizardActions: {\n        root: {\n          marginRight: 8\n        },\n        text : {\n          textTransform: 'capitalize',\n          fontSize: 14\n        }\n      } as WmButtonStyles,\n      nextButton: {\n        root: {\n          marginRight: 0,\n          paddingRight: 8,\n          backgroundColor: themeVariables.wizardNextBtnColor,\n          borderColor: themeVariables.wizardActiveStepColor\n        },\n        text:{\n          color: themeVariables.wizardActiveStepColor\n        }\n      } as WmButtonStyles,\n      prevButton: {\n        root: {\n          paddingLeft: 16\n        },\n        icon: {\n          icon:{\n          paddingRight: 0,\n          paddingLeft: 0\n          }\n        } as WmIconStyles\n      } as WmButtonStyles,\n      cancelButton: {\n        root:{\n          minHeight: 46\n        }\n      } as WmButtonStyles,\n      doneButton: {\n        root: {\n          marginRight: 0,\n          backgroundColor: themeVariables.wizardDoneBtnColor,\n          borderColor: themeVariables.wizardActiveStepColor\n        },\n        text:{\n          color: themeVariables.wizardActiveStepColor\n        },\n        icon: {\n          text: {\n            fontSize: 12,\n            color: themeVariables.wizardActiveStepColor\n          }\n        }\n      } as WmButtonStyles,\n      stepIcon: {\n          root: {\n            alignSelf: 'center',\n            justifyContent: 'center',\n            paddingLeft: 8\n          },\n          text: {\n            color: themeVariables.wizardStepIconColor,\n            fontSize: 15\n          },\n          icon: {\n            color: themeVariables.wizardStepIconColor\n          }\n      } as WmIconStyles,\n      skipLink: {\n        root: {\n        padding: 8,\n        alignSelf: 'flex-end'\n        },\n      } as WmAnchorStyles,\n      stepConnector: {\n        backgroundColor: themeVariables.wizardStepConnectorColor,\n        position: 'absolute',\n        top: 17.5,\n        zIndex: 10,\n        height: 2\n      },\n      numberTextStepConnector: {\n       display: 'none'\n      },\n      activeStepCounter: {\n        color: themeVariables.wizardActiveStepColor\n      },\n      skeleton: {  \n        root: {\n        }\n      } as WmSkeletonStyles,\n      stepCounter: {\n        fontSize: 15,\n        color: themeVariables.wizardStepColor\n      },\n      progressCircle:{} as WmProgressCircleStyles,\n      popover:{} as WmPopoverStyles,\n      stepMenu:{},\n      activeStepMenu:{},\n      stepMenuLabel: {} as WmLabelStyles,\n      stepMenuActiveLabel: {} as WmLabelStyles,\n      stepMenuIcon: {} as WmIconStyles,\n      stepMenuActiveIcon: {} as WmIconStyles\n  } as WmWizardStyles);\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n  addStyle('number-text-inline', '', {\n    stepConnector: {\n      display: 'none'\n    },\n    numberTextStepConnector: {\n      backgroundColor: themeVariables.wizardStepConnectorColor,\n      height: 2,\n      display: 'flex'\n    },\n    stepWrapper: {\n      flexDirection: 'row'\n    },\n    wizardHeader: {\n      justifyContent: 'flex-start'\n    },\n    headerWrapper: {\n      flex: -1\n    },\n    stepTitle: {\n      padding: 5\n    },\n  } as WmWizardStyles);\n  addStyle('progress-circle-header', '', {\n    stepWrapper: {\n      paddingBottom: 4,\n      flexDirection: 'row',\n      alignItems: 'center'\n    },\n    wizardHeader: {\n      justifyContent: 'flex-start',\n      alignItems: 'center',\n      backgroundColor: themeVariables.wizardBackgroundColor,\n      height: 120,\n      borderRadius: 30\n    },\n    stepSubTitle:{\n      fontSize: 12,\n      paddingHorizontal: 5\n    },\n    headerWrapper: {\n      flex: 1\n    },\n    stepTitle: {\n      fontSize: 16,\n      paddingHorizontal: 5\n    },\n    progressCircle:{\n      root: { \n        height: 60, \n        width: 60 \n      }, \n      text: {},\n      progressValue:{\n        height: 8\n      }\n    },\n    popover:{\n      popover:{\n        width: 160,\n        paddingTop: 8,\n        paddingBottom: 8,\n        backgroundColor: themeVariables.menuBackgroundColor,\n        minHeight:160,\n        borderBottomLeftRadius: 28,\n        borderBottomRightRadius: 28  \n      },\n      popoverContent: {\n        root:{\n          //@ts-ignore\n          flex: undefined\n        }\n      },\n      modalContent:{\n        borderBottomLeftRadius: 28,\n        borderBottomRightRadius: 28\n      }\n    } as WmPopoverStyles,\n    stepMenu:{\n      flexDirection: 'row', \n      padding: 14, \n      alignItems: 'center', \n      justifyContent:'flex-start'\n    },\n    activeStepMenu:{},\n    stepMenuLabel:{\n      text:{\n        color:themeVariables.menuItemTextColor\n      }\n    },\n    stepMenuActiveLabel:{\n      text:{\n        color: themeVariables.primaryColor\n      }\n    },\n    stepMenuIcon: {\n      root:{\n        paddingRight: 4\n      },\n      text:{\n        color:themeVariables.menuItemTextColor\n      }\n    },\n    stepMenuActiveIcon:{\n      root:{\n        paddingRight: 4\n      },\n      text:{\n        color: themeVariables.primaryColor\n      }\n    }\n  } as WmWizardStyles);\n  addStyle(DEFAULT_CLASS + '-rtl', '', {\n    wizardActions: {\n      icon: {\n        root:{\n          transform: [{rotateY:'180deg'}]\n        }\n      },\n    },\n    nextButton:{\n      root: {\n        marginRight: 8,\n      }\n    },\n    doneButton:{\n      root: {\n        marginRight: 8,\n      },\n      icon:{\n        root:{\n          transform: [{rotateY:'0deg'}]\n        }\n      }\n    }\n  });\n});\n", "wavemaker-rn-runtime/src/components/container/wizard/wizard.component.tsx": "import React from 'react';\nimport { Text, View, TouchableOpacity, Platform, TouchableWithoutFeedback, DimensionValue } from 'react-native';\nimport { isArray, merge } from 'lodash';\nimport {  BaseComponent, BaseComponentState, LifecycleListener } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmWizardProps from './wizard.props';\nimport { DEFAULT_CLASS, WmWizardStyles } from './wizard.styles';\nimport WmButton from '@wavemaker/app-rn-runtime/components/basic/button/button.component';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport WmAnchor from '@wavemaker/app-rn-runtime/components/basic/anchor/anchor.component';\nimport WmWizardstep from './wizardstep/wizardstep.component';\nimport WmProgressCircle from '@wavemaker/app-rn-runtime/components/basic/progress-circle/progress-circle.component';\nimport WmPopover from '@wavemaker/app-rn-runtime/components/navigation/popover/popover.component';\nimport WmLabel from '@wavemaker/app-rn-runtime/components/basic/label/label.component';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\nimport { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\n\nexport class WmWizardState extends BaseComponentState<WmWizardProps> {\n  currentStep: number = 0;\n  isDone: boolean = false;\n}\n\nexport default class WmWizard extends BaseComponent<WmWizardProps, WmWizardState, WmWizardStyles> {\n  private numberOfSteps: number = null as any;\n  private steps = [] as WmWizardstep[];\n  private popOverRef: WmPopover = null as any;\n\n  private listener: LifecycleListener = {\n    onComponentInit: (c) => {\n      if (c instanceof WmPopover) {\n        this.popOverRef = c;\n      }\n    }\n  };\n\n  constructor(props: WmWizardProps) {\n    super(props, DEFAULT_CLASS, new WmWizardProps());\n  }\n\n  updateDefaultStep() {\n    const steps = this.steps;\n    const props = this.props;\n    let defaultStepIndex = 0;\n    if (isArray(steps) && props.defaultstep) {\n      steps && steps.map((item: any, index: any) => {\n        if (props.defaultstep === item.props.name) {\n          defaultStepIndex = index;\n        }\n      })\n    }\n    this.updateCurrentStep(defaultStepIndex);\n  }\n\n  addWizardStep(step: WmWizardstep) {\n    this.steps[step.props.index] = step;\n    this.forceUpdate();\n  }\n\n  componentDidMount() {\n    super.componentDidMount();\n    if (this.props.defaultstep && this.props.defaultstep != 'none') {\n      this.updateDefaultStep();\n    }\n  }\n\n  componentDidUpdate(prevProps: Readonly<WmWizardProps>, prevState: Readonly<WmWizardState>, snapshot?: any): void {\n    super.componentDidUpdate && super.componentDidUpdate(prevProps, prevState, snapshot);\n    // * when a variable is bind to default step\n    if (this.props.defaultstep && prevProps.defaultstep !== this.props.defaultstep) {\n      this.updateDefaultStep();\n    }\n  }\n\n  showActiveStep() {\n    this.steps[this.state.currentStep]?.setActive();\n  }\n\n  updateCurrentStep(index: number, isDone = false) {\n    const lastStep = this.state.currentStep;\n    let nextStep = index\n    this.steps[this.state.currentStep]?.setInActive();\n\n    // check for next available step if next or prev steps show prop is false\n    if(this.steps[nextStep]?.state && !this.steps[nextStep].state.props.show){\n      if(lastStep < nextStep){\n        for(let i = nextStep + 1; i < this.steps.length; i++){\n          if(this.steps[i].state.props.show) {\n            nextStep = i;\n            break;\n          }\n        }\n      }else if(lastStep > nextStep) {\n        for(let i = nextStep - 1; i >= 0; i--){\n          if(this.steps[i].state.props.show) {\n            nextStep = i;\n            break;\n          }\n        }\n      }\n    }\n\n    this.updateState({\n      currentStep: nextStep,\n      isDone: isDone\n    } as WmWizardState, () => {\n      this.showActiveStep();\n      if (lastStep !== nextStep) {\n        this.invokeEventCallback('onChange', [null, this.proxy, nextStep + 1, lastStep + 1]);\n      }\n    });\n  }\n\n  getStepStyle(index: number) {\n    const style = [this.styles.step];\n    if (this.state.isDone || index < this.state.currentStep) {\n      style.push(this.styles.doneStep);\n    } else if (this.state.currentStep === index) {\n      style.push(this.styles.activeStep);\n    }\n    return style;\n  }\n\n  renderMenuPopover(){\n    const menuDataset = this.props.getmenudataexpression || ((item: any, index: number) => '') ;\n    const Labels = this.steps.map((step: WmWizardstep) => step.state.props.title);\n    return (\n      <WmPopover\n        id={this.getTestId('menu')}\n        styles={this.styles.popover}\n        contentanimation={'slideInDown'}\n        caption={''}\n        popoverheight={this.styles.popover.popover.height as string | number | undefined || null}\n        popoverwidth={this.styles.popover.popover.width as string | number | undefined || null}\n        listener={this.listener}\n        iconclass={this.props.popovericonclass || 'fa fa-caret-down'}\n        iconposition=\"right\"\n        type='dropdown'>\n          <View style={this.styles.popover.popover}>\n            {Labels.map((item: any, index: number) => {\n              const currentMenuItem = index==this.state.currentStep;\n              const caption = menuDataset({\"count\":this.steps.length}, index);\n              return (\n              <TouchableWithoutFeedback key={'wizard_menu_item_'+index} onPress={()=>{this.popOverRef.hide();}}>\n                <View style={[this.styles.stepMenu, currentMenuItem?this.styles.activeStepMenu:{}]}>\n                  <WmIcon id={this.getTestId('icon')} caption={caption} iconclass={currentMenuItem? \"wi wi-radio-button-checked\" : 'wi wi-radio-button-unchecked'} styles={currentMenuItem?this.styles.stepMenuActiveIcon:this.styles.stepMenuIcon}/>\n                  <WmLabel caption={item} styles={currentMenuItem?this.styles.stepMenuActiveLabel:this.styles.stepMenuLabel}/>\n                </View>\n              </TouchableWithoutFeedback>\n            )})}\n          </View>\n      </WmPopover>\n    );\n  }\n\n  renderProgressCircleHeader(item: any, index: number) {\n    const progressTitle = this.props.progresstitle || (index + 1 + '/' + this.steps.length);\n    return (\n      <View style={[this.styles.headerWrapper]} key={index + 1}>\n        <View style={this.styles.stepWrapper}>\n          <View style={{ flex: 1, alignItems: 'flex-start', justifyContent: 'center', flexDirection:'row' }}>\n            <WmProgressCircle id={this.getTestId('progress')} minvalue={0} maxvalue={this.steps.length} datavalue={index + 1} captionplacement={'inside'} type={this.props.progresstype} title={progressTitle} subtitle={''} styles={this.styles.progressCircle}/>\n          </View>\n        <View style={{ flex: 2, justifyContent: 'center', flexDirection: 'column' }}>\n            <Text style={this.styles.stepTitle} {...this.getTestPropsForLabel('step' + (index + 1) + '_title')}>\n              {item.props.title || 'Step Title'}</Text>\n            <Text style={this.styles.stepSubTitle} {...this.getTestPropsForLabel('step' + (index + 1)+ '_subtitle')}>\n              {item.props.subtitle || 'Step Sub Title'}</Text>\n          </View>\n          <View style={{ flexDirection: 'row', alignItems: 'flex-end', justifyContent: 'flex-end', flex: 1 }}>\n            {this.renderMenuPopover()}\n          </View>\n        </View>\n      </View>\n    );\n  }\n\n  stepConnectorWidth(isFirstOrLastConnector: boolean, stepIndex: number): DimensionValue {\n    if(stepIndex === this.lastStepIndex() || stepIndex === this.firstStepIndex()){\n      return '50%';\n    }\n    return isFirstOrLastConnector ? '50%' : '100%';\n  }\n\n  renderWizardHeader(item: any, index: number) {\n    const isLastStep = index === this.lastStepIndex();\n    const isFirstStep = index === this.firstStepIndex();\n    const isActiveStep = index === this.state.currentStep;\n    const isNumberTextLayout = this.state.props.classname === 'number-text-inline';\n    const wizardStepCountVisibility = (index >= this.state.currentStep && !this.state.isDone) || !this.state.currentStep\n    return item.state.props.show !== false ? (\n      <View \n        style={[\n          this.styles.headerWrapper, isNumberTextLayout ?\n          {paddingRight: isActiveStep ? 0 : 5, paddingLeft: index === this.state.currentStep + 1 ? 0 : 5}: {}\n        ]} \n        key={index+1}\n      >\n        <TouchableOpacity \n          style={this.styles.stepWrapper}\n          onPress={this.updateCurrentStep.bind(this, index, false)} disabled={index >= this.state.currentStep || !this.state.props.headernavigation}\n          accessibilityRole='header'\n        >\n            {!this._showSkeleton ? \n              <View style={this.getStepStyle(index)} {...this.getTestPropsForAction('step'+index)}>\n                { wizardStepCountVisibility &&\n                  <Text \n                    style={\n                      isActiveStep ? [this.styles.activeStep, this.styles.activeStepCounter] : this.styles.stepCounter} \n                      {...this.getTestPropsForLabel('step' + (index + 1) + '_indicator')\n                    }\n                  >\n                    {index+1}\n                  </Text>\n                }\n                {(index < this.state.currentStep || this.state.isDone) &&\n                  <WmIcon \n                    id={this.getTestId('status')} \n                    styles={isActiveStep ? merge({}, this.styles.stepIcon, {icon: {color: this.styles.activeStep.color}}) : this.styles.stepIcon}\n                    iconclass={item.state.props.iconclass || 'wm-sl-l sl-check'}\n                  ></WmIcon>\n                }\n              </View> : \n              <WmLabel showskeleton={true} styles={{root: {...this.getStepStyle(index)[0]}}}/>\n            }\n            {(isActiveStep) &&\n              <Text style={this.styles.stepTitle} {...this.getTestPropsForLabel('step' + (index + 1) + '_title')}>\n                {item.state.props.title || 'Step Title'}\n              </Text> \n            }\n            {this.numberOfSteps > 1 && isActiveStep &&\n              <View style={[this.styles.numberTextStepConnector, {width: isLastStep ? 0 : 50}]}></View>}\n        </TouchableOpacity>\n        {this.getTotalVisibleSteps() > 1 &&\n          item.state.props.show &&\n          <View \n            style={[\n              this.styles.stepConnector, \n              {\n                width: this.stepConnectorWidth(isFirstStep || isLastStep, index),\n                left: Platform.OS === \"web\" ?\n                  (!this.isRTL && isFirstStep) || (this.isRTL && isLastStep) ? \n                  '50%': '0%': isFirstStep ? '50%': '0%'\n              }\n            ]}\n          ></View>\n        }\n      </View>\n    ) : null;\n  }\n\n  prev() {\n    const index = this.state.currentStep;\n    if (index <= 0) {\n      return;\n    }\n    const currentStep = this.steps[index];\n    if(currentStep.invokePrevCB(index) == false){\n      return;\n    }\n    this.updateCurrentStep(index - 1);\n  }\n\n  next(eventName?: string) {\n    const index = this.state.currentStep;\n    if (index >= this.steps.length - 1) {\n      return;\n    }\n    const currentStep = this.steps[index];\n    if (eventName === 'skip') {\n      currentStep.invokeSkipCB(index);\n    } else if (currentStep.invokeNextCB(index) == false) {\n      return;\n    }\n    this.updateCurrentStep(index + 1);\n  }\n\n  done($event: any) {\n    if (this.state.currentStep !== this.lastStepIndex()) {\n      return;\n    }\n    this.updateState({\n      isDone: true\n    } as WmWizardState);\n    this.invokeEventCallback('onDone', [$event, this.proxy]);\n  }\n\n  cancel() {\n    this.invokeEventCallback('onCancel', [null, this.proxy]);\n  }\n\n  skip() {\n    this.next('skip');\n  }\n\n  getBackground(): React.JSX.Element | null {\n    return this._showSkeleton ? null : this._background\n  } \n\n  lastStepIndex(): number {\n    let lastStep = 0;\n    for(let i = 0; i < this.steps.length; i++) {\n      if(this.steps[i].state.props.show) {\n        lastStep = i;\n      }\n    }\n    return lastStep;\n  }\n\n  firstStepIndex(): number {\n    let firstStep = -1;\n    for(let i = 0; i < this.steps.length; i++) {\n      if(this.steps[i].state.props.show) {\n        if (firstStep === -1) {\n          firstStep = i;\n        }\n      }\n    }\n    return firstStep;\n  }\n\n  getTotalVisibleSteps(): number {\n    let lastStep = 0;\n    for(let i = 0; i < this.steps.length; i++) {\n      if(this.steps[i].state.props.show) {\n        lastStep++;\n      }\n    }\n    return lastStep;\n  }\n  \n  public renderSkeleton(props: WmWizardProps): React.ReactNode {\n      if(!props.showskeletonchildren) {\n        const skeletonStyles: WmSkeletonStyles = this.props?.styles?.skeleton || { root: {}, text: {}  } as WmSkeletonStyles\n        return createSkeleton(this.theme, skeletonStyles, {\n          ...this.styles.root\n        }, (<View style={[this.styles.root, { opacity: 0 }]}>\n          {props.children}\n        </View>))\n      }\n      return null;\n    }\n\n\n  renderWidget(props: WmWizardProps) {\n    this.numberOfSteps = this.steps.length;\n    const activeStep = this.steps[this.state.currentStep];\n    const isSkippable = activeStep && activeStep.state.props.enableskip;\n    const isProgressCircleHeader = this.state.props.classname?.includes('progress-circle-header');\n    const styles = this._showSkeleton ? {\n      ...this.styles.root,\n      ...this.styles.skeleton.root\n    } : this.styles.root\n    return (\n      <View \n        style={styles}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        {this.getBackground()}\n        <View style={this.styles.wizardHeader}>\n          {activeStep && isProgressCircleHeader ? (this.renderProgressCircleHeader(activeStep, this.state.currentStep)) : (this.steps ? this.steps.map((step, i) => this.renderWizardHeader(step, i)) : null)}\n        </View>\n        <View style={this.styles.wizardBody}>\n          {props.children}\n        </View>\n        <View style={[this.styles.wizardFooter,\n          {flexDirection: props.actionsalignment === 'right' ? 'row-reverse': 'row'}]}>\n          {(this.state.currentStep) === this.lastStepIndex() && activeStep.state.props.showdone &&\n            <WmButton iconclass={'wm-sl-l sl-check'} styles={merge({}, this.styles.wizardActions, this.theme.getStyle('btn-default'), this.styles.doneButton)}\n              id = {this.getTestId('donebtn')} caption={props.donebtnlabel} onTap={this.done.bind(this)} disabled={activeStep.state.props.disabledone}></WmButton>\n          }\n          {(this.state.currentStep) < this.lastStepIndex() && activeStep.state.props.shownext &&\n            <WmButton iconclass={'wi wi-chevron-right'} styles={merge({}, this.styles.wizardActions, this.theme.getStyle('btn-default'), this.styles.nextButton)}\n                id = {this.getTestId('nextbtn')}\n                      iconposition={'right'} caption={props.nextbtnlabel} onTap={this.next.bind(this)} disabled={activeStep.state.props.disablenext}></WmButton>\n          }\n          {this.state.currentStep > 0 && activeStep.state.props.showprev &&\n            <WmButton iconclass={'wi wi-chevron-left'} styles={merge({}, this.theme.getStyle('btn-default'), this.styles.wizardActions, this.styles.prevButton)} caption={props.previousbtnlabel}\n                id = {this.getTestId('prevbtn')}\n                onTap={this.prev.bind(this)} disabled={activeStep.state.props.disableprev}></WmButton>\n          }\n          {props.cancelable ?\n              <WmButton id = {this.getTestId('cancelbtn')}  caption={props.cancelbtnlabel} styles={merge({}, this.theme.getStyle('btn-default'), this.styles.wizardActions, this.styles.cancelButton)} onTap={this.cancel.bind(this)}></WmButton>\n              : null\n          }\n          {isSkippable &&\n              <WmAnchor iconclass={'wi wi-chevron-right'} iconposition={'right'} caption={'Skip'}\n                id = {this.getTestId('skip')}\n                styles={merge({}, this.styles.wizardActions, this.styles.skipLink)} onTap={this.skip.bind(this)}></WmAnchor>\n          }\n        </View>\n      </View>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/container/wizard/wizard.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmWizardProps extends BaseProps {\n  actionsalignment: string = 'right';\n  children: any;\n  cancelable: boolean = true;\n  cancelbtnlabel: string = 'Cancel';\n  donebtnlabel: string = 'Done';\n  nextbtnlabel: string = 'Next';\n  previousbtnlabel: string = 'Previous';\n  defaultstep: string = 'none';\n  progresstitle: string = '';\n  progresstype: 'default' | 'success' | 'info' | 'warning' | 'error' = 'default';\n  getmenudataexpression: any = undefined;\n  popovericonclass: string = 'fa fa-caret-down';\n  headernavigation: boolean = true\n}\n\n", "wavemaker-rn-runtime/src/components/container/wizard/wizardstep/wizardstep.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type WmWizardstepStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-wizardstep';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmWizardstepStyles = defineStyles({\n        root: {\n            flex: 1,\n        },\n        text: {}\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});\n", "wavemaker-rn-runtime/src/components/container/wizard/wizardstep/wizardstep.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmWizardstepProps extends BaseProps {\n  disableprev: boolean = false;\n  disablenext: boolean = false;\n  disabledone: boolean = false;\n  showprev: boolean = true;\n  shownext: boolean = true;\n  showdone: boolean = true;\n  children: any;\n  enableskip: boolean = false;\n  iconclass: string = 'wm-sl-l sl-check';\n  title: string = 'Step Title';\n  subtitle: string = 'Sub Title';\n  index: number = 0;\n}\n", "wavemaker-rn-runtime/src/components/container/wizard/wizardstep/wizardstep.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmWizardstepProps from './wizardstep.props';\nimport { DEFAULT_CLASS, WmWizardstepStyles } from './wizardstep.styles';\nimport WmWizard from '../wizard.component';\nimport { isBoolean } from 'lodash-es';\n\nexport class WmWizardstepState extends BaseComponentState<WmWizardstepProps> {\n  active = false;\n  showContent: boolean = false;\n}\n\nexport default class WmWizardstep extends BaseComponent<WmWizardstepProps, WmWizardstepState, WmWizardstepStyles> {\n\n  constructor(props: WmWizardstepProps) {\n    super(props, DEFAULT_CLASS, new WmWizardstepProps(), new WmWizardstepState());\n  }\n\n  componentDidMount() {\n    const wizard = (this.parent) as WmWizard;\n    // When skeleton is enabled in the wizard component, the parent would be WMSkeleton which doesnot have addWizardStep function\n    if(wizard.addWizardStep) {\n      wizard.addWizardStep(this);\n    }\n    super.componentDidMount();\n  }\n\n  onPropertyChange(name: string, $new: any, $old: any) {\n    super.onPropertyChange(name, $new, $old);\n    switch(name) {\n      case 'title':\n        const wizard = (this.parent) as WmWizard;\n        wizard?.refresh();\n        break;\n      case 'disableprev':\n      case 'disablenext':\n      case 'disabledone':\n      case 'enableskip':\n        setTimeout(() => {\n          this.parent.forceUpdate();\n        }, 10);\n        break;\n      case 'show':\n        if($new !== $old){\n          setTimeout(() => {\n            this.parent.forceUpdate();\n          }, 10);\n        }\n        break;\n    }\n  }\n\n  setActive() {\n    this.updateState({\n      active: true\n    } as WmWizardstepState, () => {\n      if(this.state.showContent) {\n        this.invokeEventCallback('onLoad', [this]);\n      }\n    });\n  }\n\n  setInActive() {\n    this.updateState({\n      active: false\n    } as WmWizardstepState);\n  }\n\n  isVisible() {\n    return super.isVisible() && this.state.active;\n  }\n\n  invokeNextCB(index: number) : boolean {\n    return this.invokeEventCallback('onNext', [this.proxy, this, index]);\n  }\n\n  invokePrevCB(index: number) : boolean {\n    return this.invokeEventCallback('onPrev', [this.proxy, this, index]);\n  }\n\n  invokeSkipCB(index: number) {\n    this.invokeEventCallback('onSkip', [this.proxy, this, index]);\n  }\n  renderWidget(props: WmWizardstepProps) {\n    if(!this.state.showContent && this.isVisible()){\n      this.updateState({showContent: true} as WmWizardstepState, ()=>{\n        this.invokeEventCallback('onLoad', [this]);\n      });\n    }\n    return this.state.showContent && (\n      <View \n        style={this.styles.root}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        {this._background}\n        {props.children}\n      </View>);\n  }\n}\n", "wavemaker-rn-runtime/src/components/container/tile/tile.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmTileProps extends BaseProps {\n  animation: string = null as any;\n  animationdelay?: number = null as any;\n  children: any;\n}\n\n", "wavemaker-rn-runtime/src/components/container/tile/tile.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmTileStyles = BaseStyles & {\n  skeleton: WmSkeletonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-tile';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmTileStyles = defineStyles({\n      root: {\n        borderRadius: 6,\n        borderWidth: 1,\n        borderStyle: 'solid',\n        borderColor: themeVariables.transparent,\n        padding: 12\n      },\n      text: {},\n      skeleton: {\n        root:{\n          width: '100%',\n        },\n      } as any as WmSkeletonStyles\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n\n  addStyle('tile-template-text', '', {\n    text: {\n      color: themeVariables.tilePrimaryTextColor\n    }\n  } as any);\n\n  addStyle('well', '', {\n    root: {\n      padding: 20,\n      marginBottom: 20,\n      borderWidth: 1,\n      backgroundColor: themeVariables.tileWellbgColor,\n      borderColor: themeVariables.tileWellBorderColor,\n      borderStyle: 'solid',\n      borderRadius: 2\n    }\n  });\n});\n", "wavemaker-rn-runtime/src/components/container/tile/tile.component.tsx": "import React from 'react';\nimport { LayoutChangeEvent, View } from 'react-native'\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmTileProps from './tile.props';\nimport { DEFAULT_CLASS, WmTileStyles } from './tile.styles';\nimport { Tappable } from '@wavemaker/app-rn-runtime/core/tappable.component';\nimport { Animatedview } from '@wavemaker/app-rn-runtime/components/basic/animatedview.component';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\nimport { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\n\nexport class WmTileState extends BaseComponentState<WmTileProps> {}\n\nexport default class WmTile extends BaseComponent<WmTileProps, WmTileState, WmTileStyles> {\n\n  constructor(props: WmTileProps) {\n    super(props, DEFAULT_CLASS, new WmTileProps());\n  }\n    \n  public renderSkeleton(props: WmTileProps): React.ReactNode {\n    if(!props.showskeletonchildren) {\n      const skeletonStyles: WmSkeletonStyles = this.props?.styles?.skeleton || { root: {}, text: {}  } as WmSkeletonStyles\n      return createSkeleton(this.theme, skeletonStyles, {\n        ...this.styles.root\n      }, (<View style={[this.styles.root, { opacity: 0 }]}>\n        {props.children}\n      </View>))\n    }\n    return null;\n  }\n\n  getBackground(): React.JSX.Element | null {\n    return this._showSkeleton ? null : this._background\n  } \n  \n  renderWidget(props: WmTileProps) {\n    const styles = this._showSkeleton ? {\n      ...this.styles.root,\n      ...this.styles.skeleton.root\n     } : this.styles.root;\n     \n    return (\n    <Tappable \n      {...this.getTestPropsForAction()} \n      target={this} \n      disableTouchEffect={this.state.props.disabletoucheffect}\n      onLayout={(event: LayoutChangeEvent) => this.handleLayout(event)}\n    >\n      <Animatedview entryanimation={props.animation} delay={props.animationdelay} style={styles}>{this.getBackground()}{props.children}</Animatedview>\n    </Tappable>);\n  }\n}\n\n", "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayout.component.tsx": "import React from 'react';\nimport { View, ViewStyle } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmLinearlayoutProps from './linearlayout.props';\nimport { DEFAULT_CLASS, WmLinearlayoutStyles } from './linearlayout.styles';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\nimport { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\n\nconst ALIGNMENT_MAP = {\n  'top':  'flex-start',\n  'left': 'flex-start',\n  'center': 'center',\n  'right': 'flex-end',\n  'bottom': 'flex-end'\n} as any;\n\nexport class WmLinearlayoutState extends BaseComponentState<WmLinearlayoutProps> {}\n\nexport default class WmLinearlayout extends BaseComponent<WmLinearlayoutProps, WmLinearlayoutState, WmLinearlayoutStyles> {\n\n  constructor(props: WmLinearlayoutProps) {\n    super(props, DEFAULT_CLASS, new WmLinearlayoutProps());\n  }\n\n  getStyles(props: WmLinearlayoutProps) {\n    const s = {} as ViewStyle;\n    const direction = props.direction;\n    s.display = 'flex';\n    s.width = \"100%\";\n    s.flexDirection = direction;\n    const isHorizontal = direction.startsWith('row');\n    if (isHorizontal) {\n      s.justifyContent = ALIGNMENT_MAP[props.horizontalalign];\n      s.alignItems = ALIGNMENT_MAP[props.verticalalign];\n    } else {\n      s.justifyContent = ALIGNMENT_MAP[props.verticalalign];\n      s.alignItems = ALIGNMENT_MAP[props.horizontalalign];\n    }\n    return s;\n  }\n\n  protected getBackground(): React.JSX.Element | null {\n    return this._showSkeleton ? null : this._background\n  } \n  \n  public renderSkeleton(props: WmLinearlayoutProps): React.ReactNode {\n      if(!props.showskeletonchildren) {\n        const skeletonStyles: WmSkeletonStyles = this.props?.styles?.skeleton || { root: {}, text: {}  } as WmSkeletonStyles\n        return createSkeleton(this.theme, skeletonStyles, {\n          ...this.styles.root\n        }, (<View style={[this.styles.root, { opacity: 0 }]}>\n          {props.children}\n        </View>))\n      }\n      return null;\n    }\n\n\n  renderWidget(props: WmLinearlayoutProps) {\n\n    const rootStyles = {...this.getStyles(props), ...this.styles.root}\n    const styles = this._showSkeleton ? {\n      ...rootStyles,\n      ...this.styles.skeleton.root\n    } : rootStyles\n\n    return (\n      <View \n        style={styles}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        {this.getBackground()}{props.children}\n      </View>\n    ); \n  }\n}\n", "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayout.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmLinearlayoutStyles = BaseStyles & {\n    skeleton: WmSkeletonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-linearlayout';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmLinearlayoutStyles = defineStyles({\n        root: {},\n        text: {},\n        skeleton: {\n            root: {\n            }\n        } as WmSkeletonStyles\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayout.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmLinearlayoutProps extends BaseProps {\n    children? = [] as any[];\n    direction: 'row'|'row-reverse' | 'column' | 'column-reverse' = 'row';\n    horizontalalign: 'left' | 'center' | 'right' = 'left';\n    verticalalign: 'top' | 'center' | 'bottom' = 'top';\n    spacing = 0;\n}\n", "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayoutitem/linearlayoutitem.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmLinearlayoutitemProps extends BaseProps {\n    children?: any[] = [];\n    flexgrow: number = null as any;\n    flexshrink: number = null as any;\n}", "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayoutitem/linearlayoutitem.component.tsx": "import React from 'react';\nimport { View, Platform } from 'react-native';\nimport { isNil } from 'lodash-es';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmLinearlayout from '../linearlayout.component';\nimport WmLinearlayoutitemProps from './linearlayoutitem.props';\nimport { DEFAULT_CLASS, WmLinearlayoutitemStyles } from './linearlayoutitem.styles';\n\nexport class WmLinearlayoutitemState extends BaseComponentState<WmLinearlayoutitemProps> {}\n\nexport default class WmLinearlayoutitem extends BaseComponent<WmLinearlayoutitemProps, WmLinearlayoutitemState, WmLinearlayoutitemStyles> {\n\n  constructor(props: WmLinearlayoutitemProps) {\n    super(props, DEFAULT_CLASS, new WmLinearlayoutitemProps());\n  }\n\n  renderWidget(props: WmLinearlayoutitemProps) {\n    const direction = (this.parent as WmLinearlayout).state.props.direction;\n    return (\n    <View \n      style={{\n        ...this.styles.root,\n        flexGrow: props.flexgrow,\n        flexShrink: isNil(props.flexshrink) ? props.flexgrow : props.flexshrink,\n        flexBasis:  Platform.OS == \"web\" ? 'auto' : (props.flexgrow && (direction === 'row' || direction === 'row-reverse') ? 0 : 'auto')\n      }}\n      onLayout={(event) => this.handleLayout(event)}\n    >{this._background}{props.children}</View>); \n  }\n}", "wavemaker-rn-runtime/src/components/container/linearlayout/linearlayoutitem/linearlayoutitem.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type WmLinearlayoutitemStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-linearlayoutitem';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmLinearlayoutitemStyles = defineStyles({\n        root: {},\n        text: {}\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/prefab/prefab-container.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmSkeletonStyles } from '../basic/skeleton/skeleton.styles';\n\nexport type WmPrefabContainerStyles =  BaseStyles & {\n    skeleton: WmSkeletonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-prefab';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmPrefabContainerStyles = defineStyles({\n        root: {},\n        text: {},\n        skeleton: {\n            root: {\n                height: 200\n            }\n        } as WmSkeletonStyles\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/prefab/prefab-container.props.ts": "import {  BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { SkeletonAnimationProps } from '@wavemaker/app-rn-runtime/runtime/base-fragment.component';\n\n\n\nexport default interface WmPrefabContainerProps extends SkeletonAnimationProps {\n    children: any[];\n}", "wavemaker-rn-runtime/src/components/prefab/prefab-container.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmPrefabContainerProps from './prefab-container.props';\nimport { DEFAULT_CLASS, WmPrefabContainerStyles } from './prefab-container.styles';\nimport WmLottie from '../basic/lottie/lottie.component';\nimport { WmSkeletonStyles } from '../basic/skeleton/skeleton.styles';\n\nexport class WmPrefabContainerState extends BaseComponentState<WmPrefabContainerProps> {\n\n}\n\n\nexport default class WmPrefabContainer extends BaseComponent<WmPrefabContainerProps, WmPrefabContainerState, WmPrefabContainerStyles> {\n\n  constructor(props: WmPrefabContainerProps) {\n    super(props, DEFAULT_CLASS, );\n  }\n\n  public renderSkeleton(props: WmPrefabContainerProps): React.ReactNode {\n    const lottieContentStyles = this.styles?.skeleton as any as WmSkeletonStyles\n    if(this.props.skeletonanimationresource) {\n      return <View style={[{width: '100%'}, this.styles?.root]}>\n        <WmLottie styles={{ content: lottieContentStyles.root}} source={this.props.skeletonanimationresource} loop={true} autoplay={true} speed={this.props.skeletonanimationspeed}/>\n        </View>\n    }\n    return null;\n  }\n\n  renderWidget(props: WmPrefabContainerProps) {\n    const styles = this._showSkeleton ? {\n      ...this.styles.root,\n      ...this.styles.skeleton.root\n    } : this.styles.root\n    return (\n      <View style={styles}>\n        {this._background}\n        {props.children}\n      </View>\n    ); \n  }\n}\n", "wavemaker-rn-runtime/src/components/dialogs/dialogactions/dialogactions.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmDialogactionsProps from './dialogactions.props';\nimport { DEFAULT_CLASS, WmDialogactionsStyles } from './dialogactions.styles';\n\nexport class WmDialogactionsState extends BaseComponentState<WmDialogactionsProps> {}\n\nexport default class WmDialogactions extends BaseComponent<WmDialogactionsProps, WmDialogactionsState, WmDialogactionsStyles> {\n  __TYPE='WmDialogactions';\n\n  constructor(props: WmDialogactionsProps) {\n    super(props, DEFAULT_CLASS, new WmDialogactionsProps());\n  }\n\n  renderWidget(props: WmDialogactionsProps) {\n    return (\n    <View \n      style={this.styles.root}\n      onLayout={(event) => this.handleLayout(event)}\n    >{this._background}{props.children}</View>); \n  }\n}\n", "wavemaker-rn-runtime/src/components/dialogs/dialogactions/dialogactions.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmDialogactionsProps extends BaseProps {\n  children? = null as any;\n}", "wavemaker-rn-runtime/src/components/dialogs/dialogactions/dialogactions.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type WmDialogactionsStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-dialogactions';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmDialogactionsStyles = defineStyles({\n        root: {\n            flexDirection: 'row',\n            justifyContent: 'flex-end',\n            alignItems: 'center',\n            borderStyle: 'solid',\n            borderColor: themeVariables.dialogBorderColor\n        },\n        text: {}\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmDialogProps extends BaseProps {\n  animation: string = null as any;\n  animationdelay?: number = null as any;\n  show? = false;\n  children = null as any;\n  closable?= true;\n  dialogtype?='design-dialog';\n  iconclass? = '';\n  modal? = true;\n  showheader? = true;\n  title? = '';\n  onOpened?: Function = null as any;\n  iconurl?: string = null as any;\n  iconheight?: number = null as any;\n  iconwidth?: number = null as any;\n  iconmargin?: number = null as any;\n}\n", "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.styles.ts": "import { ViewStyle } from 'react-native';\nimport BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmIconStyles } from '@wavemaker/app-rn-runtime/components/basic/icon/icon.styles';\nimport { WmButtonStyles } from '@wavemaker/app-rn-runtime/components/basic/button/button.styles';\n\nexport type WmDialogStyles = BaseStyles & {\n    modal: ViewStyle,\n    modalContent: ViewStyle,\n    icon: WmIconStyles,\n    closeBtn: WmButtonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-dialog';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmDialogStyles = defineStyles<WmDialogStyles>({\n        root: {\n            minWidth: 320,\n            paddingTop: 24,\n            paddingBottom: 24,\n            paddingLeft: 24,\n            paddingRight: 24,\n            elevation: 6,\n            width: '90%',\n            maxHeight: themeVariables.maxModalHeight,\n            backgroundColor: themeVariables.dialogBackgroundColor,\n            borderRadius: 28,\n        },\n        text: {},\n        modal: {},\n        modalContent: {\n            width: undefined\n        },\n        icon: {\n            root: {\n                alignSelf: 'center',\n            },\n            text: {\n                fontFamily: themeVariables.baseFont,\n                fontSize: 24,\n                fontWeight: '400',\n                color : themeVariables.dialogLabelColor,\n            },\n            icon: {\n                fontSize: 24,\n                color: themeVariables.dialogIconColor\n            }\n        } as WmIconStyles,\n        header: {\n            flexDirection: 'row',\n            borderStyle: 'solid',\n            borderColor: themeVariables.dialogBorderColor\n        },\n        headerLabel: {\n            flex: 1,\n            flexDirection: 'row',\n            justifyContent: 'flex-start',\n            alignItems: 'center',\n            paddingBottom: 16,\n        },\n        closeBtn: {\n            root: {\n                alignSelf: 'flex-end',\n                backgroundColor: 'transparent',\n                borderRadius: 8,\n                paddingRight: 8,\n                paddingTop: 8,\n                paddingBottom: 8,\n                paddingLeft: 8,\n                minHeight: 0,\n                marginBottom: 22,\n                rippleColor: themeVariables.transparent\n            },\n            icon : {\n                root: {\n                    alignItems: 'center',\n                },\n                icon: {\n                    paddingRight: 0\n                },\n                text: {\n                    color: themeVariables.dialogCloseIconColor,\n                    fontSize: 14\n                }\n            }\n        } as WmButtonStyles\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/dialogs/dialog/dialog.component.tsx": "import React from 'react';\nimport {\n  Animated,\n  GestureResponderEvent,\n  PanResponder,\n  PanResponderGestureState,\n  View,\n  Dimensions\n} from 'react-native';\nimport { ModalConsumer, ModalOptions, ModalService } from '@wavemaker/app-rn-runtime/core/modal.service';\nimport { AssetProvider } from '@wavemaker/app-rn-runtime/core/asset.provider';\nimport { HideMode } from '@wavemaker/app-rn-runtime/core/if.component';\nimport { ThemeProvider } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport WmButton from '@wavemaker/app-rn-runtime/components/basic/button/button.component';\n\nimport WmDialogProps from './dialog.props';\nimport { DEFAULT_CLASS, WmDialogStyles } from './dialog.styles';\n\nexport class WmDialogState extends BaseComponentState<WmDialogProps> {\n  modalOptions = {} as ModalOptions;\n  translateY: Animated.Value = new Animated.Value(0);\n}\n\nexport default class WmDialog extends BaseComponent<WmDialogProps, WmDialogState, WmDialogStyles> {\n  private _close: Function = () => {};\n  private swipeThreshold: number = 100;\n  private maxTranslateY: number; // Allow dragging to the bottom of the screen\n  private panResponder: any;\n\n  constructor(props: WmDialogProps) {\n    super(props, DEFAULT_CLASS, new WmDialogProps(), new WmDialogState());\n    this.hideMode = HideMode.DONOT_ADD_TO_DOM;\n\n    // Dynamically calculate maxTranslateY as the entire screen height\n    const screenHeight = Dimensions.get('window').height;\n    this.maxTranslateY = screenHeight;  // Allow drag till bottom of the screen\n\n    this.state.modalOptions.onClose = () => {\n      return new Promise<void>((res) => {\n        this.updateState({\n          props: { show: false }\n        } as WmDialogState, () => {\n          this.invokeEventCallback('onClose', [null, this]);\n          res();\n        });\n      });\n    };\n\n    this.state.modalOptions.onOpen = () => {\n      this.invokeEventCallback('onOpened', [null, this]);\n    };\n\n    // PanResponder to handle swipe gestures\n    this.panResponder = PanResponder.create({\n      onStartShouldSetPanResponder: () => true,\n      onMoveShouldSetPanResponder: (evt, gestureState) => {\n        return Math.abs(gestureState.dy) > Math.abs(gestureState.dx) && gestureState.dy > 0;\n      },\n      onPanResponderMove: (evt: GestureResponderEvent, gestureState: PanResponderGestureState) => {\n        if (gestureState.dy > 0) {\n          const dy = Math.min(gestureState.dy, this.maxTranslateY);\n          this.state.translateY.setValue(dy);\n        }\n      },\n      onPanResponderRelease: (evt: GestureResponderEvent, gestureState: PanResponderGestureState) => {\n        const shouldClose =\n          gestureState.dy > this.swipeThreshold || gestureState.vy > 1.2;\n\n        if (shouldClose) {\n          this.close();\n        } else {\n          Animated.spring(this.state.translateY, {\n            toValue: 0,\n            useNativeDriver: true\n          }).start();\n        }\n      }\n    });\n  }\n\n  open() {\n    if (!this.state.props.show) {\n      this.state.translateY.setValue(0); // Reset position\n      this.updateState({\n        props: { show: true }\n      } as WmDialogState);\n    }\n  }\n\n  close() {\n    Animated.timing(this.state.translateY, {\n      toValue: this.maxTranslateY, // Close till bottom of screen\n      duration: 300,\n      useNativeDriver: true\n    }).start(() => {\n      this._close(); // Hide after animation\n    });\n  }\n\n  prepareModalOptions(content: React.ReactNode, modalService: ModalService) {\n    const o = this.state.modalOptions;\n    o.name = this.state.props.name;\n    o.modalStyle = this.styles.modal;\n    o.content = content;\n    o.contentStyle = this.styles.content;\n    o.isModal = !!this.state.props.modal;\n    o.centered = true;\n    o.animation = this.state.props.animation;\n    o.animationdelay = this.state.props.animationdelay || 0;\n    this._close = () => modalService.hideModal(this.state.modalOptions);\n    return o;\n  }\n\n    renderWidget(props: WmDialogProps) {\n    return (<ModalConsumer>\n      {(modalService: ModalService) => {\n        modalService.showModal(this.prepareModalOptions((\n          <AssetProvider value={this.loadAsset}>\n            <ThemeProvider value={this.theme}>\n              <Animated.View\n                {...this.panResponder.panHandlers}\n                style={[\n                  this.styles.root,\n                  {transform: [{ translateY: this.state.translateY }]}\n                ]}\n                testID=\"wm-dialog\"\n                onLayout={(event) => this.handleLayout(event)}\n              >\n                {this._background}\n                {props.showheader ? (<View style={this.styles.header} testID=\"wm-dialog-header\">\n                  <View style={this.styles.headerLabel}>\n                    {props.iconclass || props.iconurl || props.title ?\n                      <WmIcon id={this.getTestId('icon')}\n                        caption={props.title}\n                        accessibilityrole='header'\n                        iconclass={props.iconclass}\n                        styles={this.styles.icon}\n                        iconurl={props.iconurl}\n                        iconheight={props.iconheight}\n                        iconmargin={props.iconmargin}\n                        iconwidth={props.iconwidth}\n                      /> : null}\n                  </View>\n                  {props.closable && <WmButton id={this.getTestId('closebtn')} show={props.closable} iconclass=\"wm-sl-l sl-close\" onTap={() => this.close()} styles={this.styles.closeBtn}></WmButton>}\n                </View>) : null}\n                {props.children}\n              </Animated.View>\n            </ThemeProvider>\n          </AssetProvider>\n        ), modalService));\n        return null;\n      }}\n    </ModalConsumer>);\n  }\n}\n\n  \n ", "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmConfirmdialogProps extends BaseProps {\n    animation: string = null as any;\n    animationdelay: number = null as any;\n    title? = 'Confirm';\n    iconclass? = 'wm-sl-l sl-check';\n    oktext? = 'Ok';\n    canceltext? = 'CANCEL';\n    message? = 'I am confirm box!';\n    modal? = false;\n    closable? = true;\n    onOpened?: Function = null as any;\n    iconurl?: string = null as any;\n    iconheight?: number = null as any;\n    iconwidth?: number = null as any;\n    iconmargin?: number = null as any;\n}\n", "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmButtonStyles } from '@wavemaker/app-rn-runtime/components/basic/button/button.styles';\nimport { WmDialogStyles } from '../dialog/dialog.styles';\nimport { WmDialogcontentStyles } from '../dialogcontent/dialogcontent.styles';\nimport { WmDialogactionsStyles } from '../dialogactions/dialogactions.styles';\nimport { WmLabelStyles } from '../../basic/label/label.styles';\nimport { Platform } from 'react-native';\n\nexport type WmConfirmdialogStyles = BaseStyles & {\n    dialog: WmDialogStyles,\n    dialogContent: WmDialogcontentStyles,\n    dialogActions: WmDialogactionsStyles,\n    okButton: WmButtonStyles,\n    cancelButton: WmButtonStyles,\n    message: WmLabelStyles\n};\n\nexport const DEFAULT_CLASS = 'app-confirmdialog';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmConfirmdialogStyles = defineStyles({\n        root: {},\n        text: {},\n        dialog: {\n            icon: {\n                icon: {\n                    fontSize: 16\n                }\n            }\n        } as WmDialogStyles,\n        dialogContent: {\n            root: {}\n        } as WmDialogcontentStyles,\n        dialogActions: {\n            root: {\n                padding: 0,\n                flexDirection: 'row',\n            }\n        } as WmDialogactionsStyles,\n        okButton: {\n            root : {},\n            text: {\n                textTransform: 'capitalize',\n                fontSize: 16\n            }\n        } as WmButtonStyles,\n        cancelButton: {\n            root : {\n            },\n            text: {\n                textTransform: 'capitalize',\n                fontSize: 16\n            }\n        }  as WmButtonStyles,\n        message: {\n            text: {\n                fontFamily: themeVariables.baseFont,\n                fontSize: 14,\n                fontWeight: '400',\n                color: themeVariables.dialogSupportingTextColor\n            }\n        } as WmLabelStyles\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n    addStyle(DEFAULT_CLASS + '-rtl', '', Platform.OS==\"web\"?{\n        cancelButton: {\n            root: {\n                marginLeft: 8,\n                marginRight: 0\n            }\n        }\n    }:{});\n});", "wavemaker-rn-runtime/src/components/dialogs/confirmdialog/confirmdialog.component.tsx": "import React from 'react';\nimport { BaseComponent, BaseComponentState, LifecycleListener } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmButton from '@wavemaker/app-rn-runtime/components/basic/button/button.component';\nimport WmLabel from '@wavemaker/app-rn-runtime/components/basic/label/label.component';\n\nimport WmDialog from '../dialog/dialog.component';\nimport WmDialogcontent from '../dialogcontent/dialogcontent.component';\nimport WmDialogactions from '../dialogactions/dialogactions.component';\n\nimport WmConfirmdialogProps from './confirmdialog.props';\nimport { DEFAULT_CLASS, WmConfirmdialogStyles } from './confirmdialog.styles';\nimport { merge } from 'lodash-es';\n\nexport class WmConfirmdialogState extends BaseComponentState<WmConfirmdialogProps> {}\n\nexport default class WmConfirmdialog extends BaseComponent<WmConfirmdialogProps, WmConfirmdialogState, WmConfirmdialogStyles> {\n\n  private dialogRef: WmDialog = null as any;\n\n  private listener: LifecycleListener = {\n    onComponentInit: (c) => {\n      if (c instanceof WmDialog) {\n        this.dialogRef = c;\n      }\n    }\n  };\n\n  constructor(props: WmConfirmdialogProps) {\n    super(props, DEFAULT_CLASS, new WmConfirmdialogProps());\n  }\n\n  open() {\n    this.dialogRef.open();\n  }\n\n  close() {\n    this.dialogRef.close();\n  }\n\n  getMessageStyle(type: string) {\n\n  }\n\n  renderWidget(props: WmConfirmdialogProps) {\n    return (\n      <WmDialog\n        id={this.getTestId('dialog')}\n        iconclass={props.iconclass}\n        iconurl={props.iconurl}\n        iconheight={props.iconheight}\n        iconmargin={props.iconmargin}\n        iconwidth={props.iconwidth}\n        animation={props.animation}\n        animationdelay={props.animationdelay}\n        closable={props.closable}\n        modal={props.modal}\n        styles={this.styles.dialog}\n        title={props.title}\n        listener={this.listener} onOpened={() => {\n        this.invokeEventCallback('onOpened', [null, this]);\n      }}>\n        <WmDialogcontent styles={this.styles.dialogContent}>\n          <WmLabel\n            id={this.getTestId('msg')}\n            caption={props.message || ''}\n            styles={this.styles.message}></WmLabel>\n        </WmDialogcontent>\n        <WmDialogactions styles={this.styles.dialogActions}>\n          <WmButton\n            id={this.getTestId('cancelbtn')}\n            caption={props.canceltext}\n            styles={this.theme.mergeStyle({}, this.theme.getStyle('btn-onlyLabel'), this.styles.cancelButton)}\n            onTap={() => {\n              this.dialogRef.close();\n              this.invokeEventCallback('onCancel', [null, this]);\n            }}></WmButton>\n          <WmButton\n            id={this.getTestId('okbtn')}\n            caption={props.oktext}\n            styles={this.theme.mergeStyle({}, this.theme.getStyle('btn-only-label'), this.styles.okButton)}\n            onTap={() => {\n              this.dialogRef.close();\n              this.invokeEventCallback('onOk', [null, this]);\n            }}></WmButton>\n        </WmDialogactions>\n      </WmDialog>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/dialogs/dialogcontent/dialogcontent.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type WmDialogcontentStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-dialogcontent';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmDialogcontentStyles = defineStyles({\n        root: {\n            padding: 16,\n            minHeight: 80,\n            maxHeight: 0.9 * themeVariables.maxModalHeight\n        },\n        text: {}\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/dialogs/dialogcontent/dialogcontent.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmDialogcontentProps extends BaseProps {\n  children? = null as any;\n}", "wavemaker-rn-runtime/src/components/dialogs/dialogcontent/dialogcontent.component.tsx": "import React from 'react';\nimport { TouchableOpacity } from 'react-native';\nimport { ScrollView } from 'react-native-gesture-handler';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmDialogcontentProps from './dialogcontent.props';\nimport { DEFAULT_CLASS, WmDialogcontentStyles } from './dialogcontent.styles';\n\nexport class WmDialogcontentState extends BaseComponentState<WmDialogcontentProps> {}\n\nexport default class WmDialogcontent extends BaseComponent<WmDialogcontentProps, WmDialogcontentState, WmDialogcontentStyles> {\n\n  constructor(props: WmDialogcontentProps) {\n    super(props, DEFAULT_CLASS, new WmDialogcontentProps());\n  }\n\n  renderWidget(props: WmDialogcontentProps) {\n    return (<ScrollView\n     \n      alwaysBounceVertical={false}\n      alwaysBounceHorizontal={false}\n      onLayout={(event) => this.handleLayout(event)}\n      contentContainerStyle={[this.styles.root, {maxHeight: undefined}]}\n      onScroll={(event) => {this.notify('scroll', [event])}}\n      scrollEventThrottle={48}\n      showsVerticalScrollIndicator={false}\n      style={{maxHeight: this.styles.root.maxHeight}}>\n        {this._background}\n\n        {/* *IMPORTANT: Pan responder in WmDialog interfering with scroll of ScrollView [https://github.com/facebook/react-native/issues/11206] */}\n        <TouchableOpacity \n          activeOpacity={1}\n        >\n          <>\n            {props.children}\n          </>\n        </TouchableOpacity>\n    </ScrollView>);\n  }\n}\n", "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmButtonStyles } from '@wavemaker/app-rn-runtime/components/basic/button/button.styles';\nimport { WmDialogStyles } from '../dialog/dialog.styles';\nimport { WmDialogcontentStyles } from '../dialogcontent/dialogcontent.styles';\nimport { WmDialogactionsStyles } from '../dialogactions/dialogactions.styles';\nimport { WmLabelStyles } from '../../basic/label/label.styles';\n\nexport type WmAlertdialogStyles = BaseStyles & {\n    dialog: WmDialogStyles,\n    dialogContent: WmDialogcontentStyles,\n    dialogActions: WmDialogactionsStyles,\n    okButton: WmButtonStyles,\n    message: WmLabelStyles\n};\n\nexport const DEFAULT_CLASS = 'app-alertdialog';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmAlertdialogStyles = defineStyles({\n        root: {},\n        text: {},\n        dialog: {} as WmDialogStyles,\n        dialogContent: {\n            root: {}\n        } as WmDialogactionsStyles,\n        dialogActions: {} as WmDialogcontentStyles,\n        okButton: {\n            root: {\n               border: 'none',\n               marginLeft: 4\n            },\n            text : {\n                textTransform: 'capitalize',\n                fontSize: 16\n            }\n        } as any as WmButtonStyles,\n        message: {\n            text: {\n                fontFamily: themeVariables.baseFont,\n                fontSize: 14,\n                fontWeight: '400',\n                color: themeVariables.dialogSupportingTextColor\n            }\n        } as WmLabelStyles\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmAlertdialogProps extends BaseProps {\n  animation: string = null as any;\n  animationdelay: number = null as any;\n  title? = 'Alert';\n  iconclass? = 'wi wi-warning';\n  alerttype? = 'error'\n  oktext? = 'Ok';\n  message? = 'I am an alert box!';\n  modal? = false;\n  closable? = true;\n  onOpened?: Function = null as any;\n  iconurl?: string = null as any;\n  iconheight?: number = null as any;\n  iconwidth?: number = null as any;\n  iconmargin?: number = null as any;\n}\n", "wavemaker-rn-runtime/src/components/dialogs/alertdialog/alertdialog.component.tsx": "import React from 'react';\nimport { BaseComponent, BaseComponentState, LifecycleListener } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmButton from '@wavemaker/app-rn-runtime/components/basic/button/button.component';\nimport WmLabel from '@wavemaker/app-rn-runtime/components/basic/label/label.component';\n\nimport WmDialog from '../dialog/dialog.component';\nimport WmDialogcontent from '../dialogcontent/dialogcontent.component';\nimport WmDialogactions from '../dialogactions/dialogactions.component';\n\nimport WmAlertdialogProps from './alertdialog.props';\nimport { DEFAULT_CLASS, WmAlertdialogStyles } from './alertdialog.styles';\n\nexport class WmAlertdialogState extends BaseComponentState<WmAlertdialogProps> {}\n\nconst MESSAGE_STYLES = new Map<string, string>([\n  ['error', 'text-danger'],\n  ['information', 'text-info'],\n  ['warning', 'text-warning'],\n  ['success', 'text-success']\n]);\n\nexport default class WmAlertdialog extends BaseComponent<WmAlertdialogProps, WmAlertdialogState, WmAlertdialogStyles> {\n\n  private dialogRef: WmDialog = null as any;\n\n  private listener: LifecycleListener = {\n    onComponentInit: (c) => {\n      if (c instanceof WmDialog) {\n        this.dialogRef = c;\n      }\n    }\n  };\n\n  constructor(props: WmAlertdialogProps) {\n    super(props, DEFAULT_CLASS, new WmAlertdialogProps());\n  }\n\n  open() {\n    this.dialogRef.open();\n  }\n\n  close() {\n    this.dialogRef.close();\n  }\n\n  getMessageStyle(type: string) {\n\n  }\n\n  renderWidget(props: WmAlertdialogProps) {\n    const messageStyle = this.theme.getStyle(MESSAGE_STYLES.get(props.alerttype || 'error') as string);\n    return (\n      <WmDialog\n        id={this.getTestId('dialog')}\n        iconclass={props.iconclass}\n        iconurl={props.iconurl}\n        iconheight={props.iconheight}\n        iconmargin={props.iconmargin}\n        iconwidth={props.iconwidth}\n        animation={props.animation}\n        animationdelay={props.animationdelay}\n        closable={props.closable}\n        modal={props.modal}\n        styles={this.styles.dialog}\n        title={props.title}\n        listener={this.listener} onOpened={() => {\n        this.invokeEventCallback('onOpened', [null, this]);\n      }}>\n        <WmDialogcontent styles={this.styles.dialogContent}>\n          <WmLabel\n            id={this.getTestId('msg')}\n            caption={props.message || ''}\n            styles={this.styles.message}></WmLabel>\n        </WmDialogcontent>\n        <WmDialogactions styles={this.styles.dialogActions}>\n          <WmButton\n            id={this.getTestId('okbtn')}\n            caption={props.oktext}\n            styles={this.theme.mergeStyle({},this.styles.okButton,this.theme.getStyle('btn-only-label'))}\n            onTap={() => {\n              this.dialogRef.close();\n              this.invokeEventCallback('onOk', [null, this]);\n            }}></WmButton>\n        </WmDialogactions>\n      </WmDialog>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/device/camera/camera.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { AccessibilityRole } from 'react-native';\n\nexport default class WmCameraProps extends BaseProps {\n  allowedit: boolean = false;\n  capturetype: string = 'IMAGE';\n  iconclass: string = 'wm-sl-l sl-camera';\n  iconsize: number = 16;\n  imagequality: number = 80;\n  imageencodingtype: string = 'JPEG';\n  imagetargetwidth: number = null as any;\n  imagetargetheight: number = null as any;\n  datavalue: any;\n  localFilePath: string = '';\n  accessibilitylabel?: string = undefined;\n  hint?: string = undefined;\n  accessibilityrole?: AccessibilityRole = \"imagebutton\";\n  caption?: string = undefined;\n}\n", "wavemaker-rn-runtime/src/components/device/camera/camera.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmCameraProps from './camera.props';\nimport { DEFAULT_CLASS, WmCameraStyles } from './camera.styles';\nimport WmButton from '@wavemaker/app-rn-runtime/components/basic/button/button.component';\nimport { CaptureImageOutput } from '@wavemaker/app-rn-runtime/variables/device/camera/capture-image.operation';\nimport { CameraConsumer, CameraInput, CameraService } from \"@wavemaker/app-rn-runtime/core/device/camera-service\";\nimport { CaptureVideoOutput } from '@wavemaker/app-rn-runtime/variables/device/camera/capture-video.operation';\nimport { AccessibilityWidgetType, getAccessibilityProps } from '@wavemaker/app-rn-runtime/core/accessibility'; \n\n\nexport class WmCameraState extends BaseComponentState<WmCameraProps> {}\n\nexport default class WmCamera extends BaseComponent<WmCameraProps, WmCameraState, WmCameraStyles> {\n  private camera: CameraService = null as any;\n  public localFile: string = '';\n  constructor(props: WmCameraProps) {\n    super(props, DEFAULT_CLASS, new WmCameraProps());\n  }\n\n  onCameraTap() {\n    const props = this.state.props;\n    if (props.capturetype === 'IMAGE') {\n      const params: CameraInput = {\n        allowImageEdit: props.allowedit,\n        imageQuality: props.imagequality,\n        imageEncodingType: props.imageencodingtype,\n        imageTargetWidth: props.imagetargetwidth,\n        imageTargetHeight: props.imagetargetheight\n      };\n\n      this.camera.captureImage(params).then((res: CaptureImageOutput) => {\n        this.updateModel(null, res.imagePath, res.content);\n      });\n    } else {\n      this.camera.captureVideo().then((res: CaptureVideoOutput) => {\n        this.updateModel(null, res.videoPath, res.content);\n      });\n    }\n\n  }\n\n  private updateModel($event: any, value: any, content: string) {\n    value = (value.startsWith('file://') ? '' : 'file://') + value;\n    this.localFile = content;\n    this.updateState({\n      props: {\n        datavalue: value,\n        localFilePath: value\n      }\n    } as WmCameraState, this.invokeEventCallback.bind(this, 'onSuccess', [null, this.proxy, value, this.localFile]));\n  }\n\n  renderWidget(props: WmCameraProps) {\n    return (\n          <CameraConsumer>\n              {(cameraService: CameraService) => {\n              {this._background}\n              this.camera = cameraService;\n              return <View style={this.styles.root} onLayout={(event) => this.handleLayout(event)}>\n                <WmButton id={this.getTestId('button')} caption={props.caption} iconclass={props.iconclass} iconsize={props.iconsize} iconposition={props.caption ? '' : 'left'} styles={this.styles.button} onTap={this.onCameraTap.bind(this)} accessibilitylabel={props.accessibilitylabel} hint={props.hint} accessibilityrole={props.accessibilityrole}></WmButton>\n              </View>\n            }}\n          </CameraConsumer>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/device/camera/camera.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmButtonStyles } from '@wavemaker/app-rn-runtime/components/basic/button/button.styles';\n\nexport type WmCameraStyles = BaseStyles & {\n  button: WmButtonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-camera';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmCameraStyles = defineStyles({\n      root: {},\n      text: {},\n      button: {\n        root: {\n          minHeight: 30,\n          minWidth: 40,\n          paddingRight: 0,\n          paddingLeft: 7,\n          paddingBottom: 4,\n          paddingTop: 4,\n          borderWidth: 1,\n          borderColor: themeVariables.defaultColor2,\n          borderStyle: 'solid',\n          backgroundColor: themeVariables.primaryColor,\n          borderRadius: 20,\n          rippleColor : themeVariables.rippleColor\n        },\n        text: {\n          color: themeVariables.cameraTextColor,\n        },\n        icon: {\n          text: {\n            color: themeVariables.defaultColorF,\n            paddingRight: 0\n          },\n          icon: {\n            fontSize: 24\n          }\n        }\n      } as WmButtonStyles\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmButtonStyles } from '@wavemaker/app-rn-runtime/components/basic/button/button.styles';\n\nexport type WmBarcodescannerStyles = BaseStyles & {\n  button: WmButtonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-barcodescanner';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmBarcodescannerStyles = defineStyles({\n      root: {},\n      text: {},\n      button: {\n        root: {\n          minHeight: 30,\n          minWidth: 40,\n          paddingRight: 0,\n          paddingTop: 10,\n          paddingLeft: 8,\n          paddingBottom: 8,\n          borderWidth: 1,\n          borderColor: themeVariables.defaultColor2,\n          borderStyle: 'solid',\n          backgroundColor: themeVariables.primaryColor,\n          borderRadius: 20,\n        },\n        text: {\n          color: themeVariables.barcodeScannerTextColor,\n          paddingRight: 0\n        },\n        icon: {\n          text: {\n            color: themeVariables.defaultColorF\n          },\n          icon: {\n            fontSize: 21\n          }\n        }\n      } as WmButtonStyles\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n});\n", "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { ScanInput, ScanOutput } from '@wavemaker/app-rn-runtime/variables/device/scan/scan.operation';\nimport { ScanConsumer, ScanService } from '@wavemaker/app-rn-runtime/core/device/scan-service';\n\nimport WmBarcodescannerProps from './barcodescanner.props';\nimport { DEFAULT_CLASS, WmBarcodescannerStyles } from './barcodescanner.styles';\nimport WmButton from '@wavemaker/app-rn-runtime/components/basic/button/button.component';\n\nexport class WmBarcodescannerState extends BaseComponentState<WmBarcodescannerProps> {}\n\nexport default class WmBarcodescanner extends BaseComponent<WmBarcodescannerProps, WmBarcodescannerState, WmBarcodescannerStyles> {\n  private scanner: ScanService = null as any;\n  constructor(props: WmBarcodescannerProps) {\n    super(props, DEFAULT_CLASS, new WmBarcodescannerProps());\n  }\n\n  onScanTap() {\n    const params: ScanInput = {\n      barcodeFormat: this.state.props.barcodeformat\n    };\n    this.scanner.scanBarcode(params).then((res: ScanOutput) => {\n      this.updateState({\n        props: {\n          datavalue: res.text\n        }\n      } as WmBarcodescannerState, () => {\n        this.invokeEventCallback('onSuccess', [null, this.proxy]);\n      });\n    })\n  }\n\n  renderWidget(props: WmBarcodescannerProps) {\n    return (\n      <ScanConsumer>\n        {(scanService: ScanService) => {\n          this.scanner = scanService;\n          return <View style={this.styles.root} onLayout={(event) => this.handleLayout(event)}>\n            {this._background}\n            <WmButton id={this.getTestId('button')} iconclass={props.iconclass} styles={this.styles.button} onTap={this.onScanTap.bind(this)} caption={props.caption} iconsize={props.iconsize} accessibilitylabel={props.accessibilitylabel} hint={props.hint} accessibilityrole={props.accessibilityrole}></WmButton>\n          </View>\n        }}\n      </ScanConsumer>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/device/barcodescanner/barcodescanner.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { AccessibilityRole } from 'react-native';\n\nexport default class WmBarcodescannerProps extends BaseProps {\n  barcodeformat: string = 'ALL';\n  caption: string = null as any;\n  datavalue: any;\n  iconclass: string = 'fa fa-barcode';\n  iconsize: number = 16;\n  accessibilitylabel?: string = undefined;\n  hint?: string = undefined;\n  accessibilityrole?: AccessibilityRole = \"imagebutton\";\n}\n", "wavemaker-rn-runtime/src/components/data/form/form.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { isDefined, widgetsWithUndefinedValue } from '@wavemaker/app-rn-runtime/core/utils';\nimport { debounce, find, forEach, isNil, get, set, cloneDeep, isEmpty } from 'lodash';\n\nimport WmLabel from '@wavemaker/app-rn-runtime/components/basic/label/label.component';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport WmFormField, { WmFormFieldState } from '@wavemaker/app-rn-runtime/components/data/form/form-field/form-field.component';\nimport WmMessage from '@wavemaker/app-rn-runtime/components/basic/message/message.component';\nimport { ToastConsumer, ToastService } from '@wavemaker/app-rn-runtime/core/toast.service';\n\nimport WmFormProps from './form.props';\nimport { DEFAULT_CLASS, WmFormStyles } from './form.styles';\nimport { isDataSetWidget } from '@wavemaker/app-rn-runtime/core/utils';\nimport WmFormAction, {\n  WmFormActionState\n} from '@wavemaker/app-rn-runtime/components/data/form/form-action/form-action.component';\n\nexport class WmFormState extends BaseComponentState<WmFormProps> {\n  isValid = false;\n  type: 'success' | 'warning' | 'error' | 'info' | 'loading' | undefined = 'success';\n  message: string = '';\n  showInlineMsg: boolean = false;\n  isUpdateMode: boolean = true;\n  dynamicForm: any;\n}\nexport default class WmForm extends BaseComponent<WmFormProps, WmFormState, WmFormStyles> {\n  public formFields: Array<WmFormField> = []; // contains array of direct widget elements [WmText, WmNumber, WmCurrent]\n  public parentFormRef: any;\n  public formfields: {[key: string]: WmFormField} = {};\n  public formdataoutput: any;\n  private toaster: any;\n  public formActions: Array<WmFormAction> = [];\n  primaryKey = [];\n  buttonArray: Array<WmFormAction> = [];\n  formWidgets: { [key: string]: BaseComponent<any, any, any> } = {}; // object containing key as name of formField and value as WmFormField proxy.\n  constructor(props: WmFormProps) {\n    super(props, DEFAULT_CLASS, new WmFormProps(), new WmFormState());\n  }\n\n  private _debouncedSubmitForm = debounce(this.handleSubmit, 250);\n\n  componentDidMount() {\n    super.componentDidMount();\n    this.getParentFormRef(this.props.parentForm);\n  }\n\n  getParentFormRef(pformName: string) {\n    let current = this.parent;\n    while (current) {\n      if (pformName && (get(current, 'props.name') === pformName)) {\n        this.parentFormRef = current;\n        break;\n      }\n      current = current.parent;\n    }\n  }\n\n  setReadonlyFields() {\n    this.formFields?.forEach((field: any) => {\n      field.setReadOnlyState(this.state.isUpdateMode);\n    });\n  }\n\n  setReadonlyState(updateMode: any) {\n    this.updateState({\n      isUpdateMode: updateMode,\n    } as WmFormState);\n    setTimeout(() => {\n      this.showActions();\n      this.setReadonlyFields();\n    }, 100);\n  }\n\n  edit() {\n    this.setReadonlyState(true);\n  }\n\n  new() {\n    this.setReadonlyState(true);\n  }\n\n  cancel() {\n    this.setReadonlyState(false);\n  }\n\n  delete() { }\n\n  registerFormFields(\n    formFields: Array<WmFormField>,\n    formWidgets: { [key: string]: BaseComponent<any, any, any> }\n  ) {\n    forEach(formFields, (w: WmFormField) => {\n      if (!w.form) {\n        w.form = this;\n        w.formwidget = (w.props.formKey && formWidgets[w.props.formKey])\n          || (w.props.name && formWidgets[w.props.name]);\n      }\n    });\n\n    this.formFields = formFields;\n    this.formWidgets = formWidgets;\n\n    formFields?.forEach((f: WmFormField) => {\n      if (f.props.name) {\n        set(this.formfields, f.props.name, f);\n      }\n    })\n\n    this.setReadonlyFields();\n\n    this.applyFormData();\n    this.applyDefaultValue();\n\n    // setting default form dataoutput.\n    if (!this.formdataoutput) {\n      this.formdataoutput = {};\n      formFields?.forEach((w: WmFormField) => {\n        const name = get(w.props, 'formKey') || w.props.name;\n        if (name) {\n          set(this.formdataoutput, name, w.props.datavalue);\n        }\n      });\n      this.updateState({\n        props: {\n          dataoutput: this.formdataoutput\n        }\n      } as WmFormState);\n    }\n  }\n\n  showActions () {\n    this.buttonArray?.forEach((action: any) => {\n      action.updateState({\n        props: {\n          show: action.updateMode === this.state.isUpdateMode\n        }} as WmFormActionState);\n    });\n  }\n\n  registerFormActions(formActions: Array<WmFormAction>) {\n    this.buttonArray = formActions;\n    this.showActions();\n  }\n\n  private _updateFieldOnDataSourceChange(field: WmFormField, formFields: Array<WmFormField>) {\n    if (!field.state.props.isDataSetBound && isDataSetWidget(field.props.widget)) {\n      if (field.state.props.isRelated) {\n        field.updateState({\n          props: {\n            isDataSetBound: true\n          }} as WmFormFieldState);\n        this.props.relatedData && this.props.relatedData(field);\n      }\n    }\n  }\n\n  applyFormData() {\n    let formData = this.state.props.formdata || this.parentFormRef?.state.props.formdata;\n    if (!formData || (this.parentFormRef && this.state.props.formdata)) {\n      return;\n    }\n    forEach(this.formFields, (formField: WmFormField) => {\n      let fw = formField.props?.name && this.formWidgets[formField.props.name];\n      if (!fw) {\n        fw = find(this.formWidgets, (fw: BaseComponent<any, any, any>) => {\n          return get(fw, 'formfieldname') === formField.props.name\n        });\n      }\n      let key = get(formField, 'formKey') || get(fw, 'props.name');\n      fw && fw.setState({ isDefault: true });\n      if(Array.isArray(formData)){\n        formData = formData[0];\n      }\n      formField.updateState({\n        props: {\n          datavalue: get(formData, key)\n        }\n      } as WmFormFieldState);\n    });\n  }\n\n  updateFormFieldDefaultValue(formField: WmFormField) {\n    if (formField) {\n      const dv = formField.state.props.defaultvalue;\n      if (isDefined(dv) && dv !== null && this.formFields) {\n        let field = formField.props?.name && this.formWidgets[formField.props.name];\n        if (!field) {\n          field = find(this.formWidgets, (fw: BaseComponent<any, any, any>) => {\n            return get(fw, 'formfieldname') === formField.props.name\n          });\n        }\n        if (field) {\n          field.setState({ isDefault: true });\n          field.updateState({\n            props: {\n              datavalue: dv\n            }\n          }, this.invokeEventCallback.bind(formField, 'onFieldChange', [undefined, formField, dv]));\n        }\n      }\n    }\n  }\n\n  get dataoutput() {\n    return this.formdataoutput;\n  }\n\n  applyDefaultValue(formField?: WmFormField) {\n    if (formField) {\n      this.updateFormFieldDefaultValue(formField);\n      return;\n    }\n    forEach(this.formFields, (w: WmFormField) => {\n      this.updateFormFieldDefaultValue(w);\n    });\n  }\n\n  formreset() {\n    this.formdataoutput = {};\n    forEach(this.formFields, (ff: WmFormField) => {\n      const defaultValue = isNil(ff.state.props.defaultvalue) ?  '' : ff.state.props.defaultvalue;\n      ff.updateState({\n        props : {\n          datavalue: defaultValue\n        }\n      } as WmFormFieldState, () => {\n          const id = ff.props.formKey || ff.props.name;\n          if (id) {\n            let widget: BaseComponent<any, any, any> | undefined | any = this.formWidgets[id];\n            if (!widget) {\n              widget = find(this.formWidgets, (fw: BaseComponent<any, any, any>) => {\n                return get(fw, 'formfieldname') === ff.props.name\n              });\n            }\n            widget.updateState({\n              isValid: true,\n              props : {\n                datavalue: defaultValue\n              }\n            }, () => ff.updateState({\n              isValid: true\n            } as WmFormFieldState));\n            widget?.reset();\n          }\n        }\n      );\n    });\n  }\n\n  submit() {\n    this._debouncedSubmitForm();\n  }\n\n  // Function to generate and compile the form fields from the metadata\n  generateFormFields() {\n    let userFields;\n    let fields = this.state.props.metadata ? this.state.props.metadata.data || this.state.props.metadata : [];\n\n    if (isEmpty(fields)) {\n      return;\n    }\n\n    if (this.props.onBeforerender) {\n      userFields = this.invokeEventCallback('onBeforerender', [fields,  this.proxy]);\n      if (userFields) {\n        fields = userFields;\n      }\n    }\n\n    this.updateState({\n      dynamicForm:  this.props.generateComponent(fields, this.props.name)\n    } as WmFormState);\n\n  }\n\n  onPropertyChange(name: string, $new: any, $old: any) {\n    switch (name) {\n      case 'formdata':\n        if ($new) {\n          this.applyFormData();\n        }\n        break;\n      case 'defaultmode':\n        this.updateState({\n          isUpdateMode: $new && $new === 'Edit' ? true : false,\n        } as WmFormState);\n        break;\n      case 'dataset':\n        this.formFields?.forEach((w: WmFormField) => {\n          this._updateFieldOnDataSourceChange(w, this.formFields);\n        });\n        break;\n      case 'metadata':\n        this.generateFormFields();\n        break;\n    }\n  }\n  setPrimaryKey(fieldName: string) {\n    /*Store the primary key of data*/\n    this.primaryKey = this.primaryKey || [];\n    // @ts-ignore\n    if (this.primaryKey.indexOf(fieldName) === -1) {\n      // @ts-ignore\n      this.primaryKey.push(fieldName);\n    }\n  }\n  // Disable the form submit if form is in invalid state. Highlight all the invalid fields if validation type is default\n  validateFieldsOnSubmit() {\n    let isValid = true;\n    forEach(this.formFields, (field) => {\n      const val = field?.state.props.datavalue;\n\n      const onValidate = get(field, 'props.onValidate');\n      onValidate && onValidate(field);\n      if (!val && field?.state.props.required && ((field?.props.primaryKey && field?.props.generator === 'assigned') || !field?.props.primaryKey)) {\n        isValid = false;\n        const msg = get(field.defaultValidatorMessages, 'required') || field.state.props.validationmessage;\n        field.updateState({ isValid: isValid, props: {\n            validationmessage: msg\n          }} as WmFormFieldState);\n        field.formwidget.validate && field.formwidget.validate(val);\n      }\n      // check for isvalid state of formwidget\n      if (field.formwidget.state.isValid === false) {\n        isValid = false;\n      }\n    });\n    return isValid;\n  }\n\n  // @ts-ignore\n  handleSubmit(event?: any) {\n    event?.preventDefault();\n    const formData = cloneDeep(this.state.props.dataoutput || this.formdataoutput);\n\n    if (!this.validateFieldsOnSubmit()) {\n      return false;\n    }\n    if (this.props.onBeforesubmit) {\n      this.invokeEventCallback('onBeforesubmit', [ null, this.proxy, formData ]);\n    }\n    if (this.props.formSubmit) {\n      this.props.formSubmit(formData, ((data: any) => {\n        this.invokeEventCallback('onSubmit', [ null, this.proxy, formData ]);\n        this.onResultCb(get(data, 'params'), 'success');\n      }), ((error: any) => {\n        this.invokeEventCallback('onSubmit', [ null, this.proxy, formData ]);\n        this.onResultCb(error, '');\n      }));\n    } else {\n      this.invokeEventCallback('onSubmit', [ null, this.proxy, formData ]);\n    }\n  }\n\n  onResultCb(response: any, status: string, event?: any) {\n    this.invokeEventCallback('onResult', [ null, this.proxy, response ]);\n    if (status) {\n      this.invokeEventCallback('onSuccess', [ null, this.proxy, response ]);\n      !this.props.onSuccess && this.state.props.postmessage && this.toggleMessage('success', this.state.props.postmessage);\n    } else {\n      this.invokeEventCallback('onError', [ null, this.proxy, response ]);\n      !this.props.onError && this.toggleMessage('error', this.state.props.errormessage || get(response, 'message'));\n    }\n  }\n\n  updateDataOutput(key: string, val: any) {\n    const current = this.formdataoutput || {};\n    if (key) {\n      set(current, key, val);\n    } else {\n      Object.assign(current, val)\n    }\n    this.formdataoutput = current;\n    this.updateState({ props: { dataoutput: current }} as WmFormState);\n    this.parentFormRef && this.parentFormRef.updateDataOutput && this.parentFormRef.updateDataOutput(undefined, this.formdataoutput);\n    this.updateState({\n      props: {\n        dataoutput: this.formdataoutput\n      }\n    } as WmFormState);\n  }\n\n  toggleMessage(\n    type: 'success' | 'warning' | 'error' | 'info' | 'loading' | undefined,\n    message: string\n  ) {\n    if (this.state.props.messagelayout === 'Inline') {\n        this.setState({\n          type: type,\n          message: message,\n          showInlineMsg: true\n        } as WmFormState)\n      return;\n    }\n    this.toaster.showToast({\n      name: this, placement: \"\", styles: {bottom: 0},\n      text: message,\n      type: type,\n      hideOnClick: true,\n      duration: 5000\n    });\n  }\n\n  onMsgClose() {\n    this.setState({\n      showInlineMsg: false\n    } as WmFormState)\n  }\n\n  renderWidget(props: WmFormProps) {\n    return (\n      <ToastConsumer>\n        {(toastService: ToastService) => {\n          this.toaster = toastService;\n          return <View style={this.styles.root} onLayout={(event) => this.handleLayout(event)}>\n            {this._background}\n            {props.iconclass || props.title || props.subheading ? (\n              <View style={this.styles.heading}>\n                <View style={{flex: 1, flexDirection: 'row'}}>\n                  <WmIcon  id={this.getTestId('icon')} styles={this.styles.listIcon} iconclass={props.iconclass}></WmIcon>\n                  <View>\n                    <WmLabel id={this.getTestId('title')} styles={this.styles.title} caption={props.title} accessibilityrole='header'></WmLabel>\n                    <WmLabel id={this.getTestId('description')} styles={this.styles.subheading} caption={props.subheading}></WmLabel>\n                  </View>\n                </View>\n              </View>\n            ) : null}\n            {this.state.showInlineMsg ? <WmMessage type={this.state.type} caption={this.state.message} hideclose={false} onClose={this.onMsgClose.bind(this)}></WmMessage> : null\n            }\n            { props.metadata && this.state.dynamicForm }\n            { props.children}\n          </View>\n        }\n        }\n      </ToastConsumer>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/data/form/form.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmFormProps extends BaseProps {\n  children: any;\n  dataoutput: any;\n  onBeforeservicecall: any;\n  onBeforesubmit: any;\n  formdata: any;\n  parentForm: string = '';\n  metadata: any;\n  title: any;\n  subheading: any;\n  iconclass: any;\n  postmessage: string = 'Data posted successfully';\n  errormessage: string = 'An error occured. Please try again!';\n  messagelayout: string = 'Inline';\n  formSubmit: Function = () => {};\n  formSuccess: Function = () => {};\n  relatedData: Function = () => {};\n  onSuccess: Function = () => {};\n  onError: Function = () => {};\n  onBeforerender: Function = () => {};\n  generateComponent: Function = (metadata:any) => {};\n  showinfoskeleton: boolean = false;\n}\n", "wavemaker-rn-runtime/src/components/data/form/form.styles.ts": "import BASE_THEME, {AllStyle} from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport {WmLabelStyles} from \"@wavemaker/app-rn-runtime/components/basic/label/label.styles\";\nimport ThemeVariables from \"@wavemaker/app-rn-runtime/styles/theme.variables\";\nimport { WmIconStyles } from '@wavemaker/app-rn-runtime/components/basic/icon/icon.styles';\n\nexport type WmFormStyles = BaseStyles & {\n  heading: AllStyle,\n  title: WmLabelStyles,\n  listIcon: WmIconStyles,\n  subheading: WmLabelStyles\n};\n\nexport const DEFAULT_CLASS = 'app-form';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmFormStyles = defineStyles({\n    root: {},\n    text: {},\n    heading : {\n      paddingTop: 12,\n      paddingBottom: 12,\n      paddingLeft: 0,\n      paddingRight: 0,\n      borderBottomWidth: 0,\n      borderStyle: 'solid',\n      borderColor: themeVariables.formBorderColor\n    },\n    title: {\n      text: {\n        fontSize: themeVariables.heading4FontSize,\n        color: themeVariables.formTitleColor,\n        fontWeight: 'bold'\n      }\n    } as WmLabelStyles,\n    subheading: {\n      text: {\n        fontSize: 12,\n        lineHeight: 18,\n        color: themeVariables.formSubTitleColor\n      }\n    } as WmLabelStyles,\n    listIcon: {\n      root: {\n        fontSize: 18,\n        marginRight: 8\n      }\n    } as WmIconStyles,\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n  addStyle('form-action', '', {\n    root: {\n      marginLeft: 12\n    }\n  } as BaseStyles);\n});\n", "wavemaker-rn-runtime/src/components/data/form/form-footer/form-footer.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmFormFooterProps from './form-footer.props';\nimport { DEFAULT_CLASS, WmFormFooterStyles } from './form-footer.styles';\n\nexport class WmFormFooterState extends BaseComponentState<WmFormFooterProps> {}\n\nexport default class WmFormFooter extends BaseComponent<WmFormFooterProps, WmFormFooterState, WmFormFooterStyles> {\n\n  constructor(props: WmFormFooterProps) {\n    super(props, DEFAULT_CLASS, new WmFormFooterProps());\n  }\n\n  renderWidget(props: WmFormFooterProps) {\n    return (\n      <View \n        style={this.styles.root}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        {this._background}\n        {props.children}\n      </View>\n    ); \n  }\n}\n", "wavemaker-rn-runtime/src/components/data/form/form-footer/form-footer.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type WmFormFooterStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-form-footer';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmFormFooterStyles = defineStyles({\n        root: {\n            flexDirection: 'row',\n            padding: 8,\n            justifyContent: 'flex-end',\n            borderStyle: 'solid',\n            borderTopWidth: 1,\n            borderColor: themeVariables.formBorderColor\n        },\n        text: {}\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/data/form/form-footer/form-footer.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmFormFooterProps extends BaseProps {\n    children: any = [] as any;\n}", "wavemaker-rn-runtime/src/components/data/form/form-body/form-body.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmFormBodyProps from './form-body.props';\nimport { DEFAULT_CLASS, WmFormBodyStyles } from './form-body.styles';\n\nexport class WmFormBodyState extends BaseComponentState<WmFormBodyProps> {}\n\nexport default class WmFormBody extends BaseComponent<WmFormBodyProps, WmFormBodyState, WmFormBodyStyles> {\n\n  constructor(props: WmFormBodyProps) {\n    super(props, DEFAULT_CLASS, new WmFormBodyProps());\n  }\n\n  renderWidget(props: WmFormBodyProps) {\n    return (\n      <View \n        style={this.styles.root}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        {this._background}\n        {props.children}\n      </View>\n    ); \n  }\n}\n", "wavemaker-rn-runtime/src/components/data/form/form-body/form-body.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type WmFormBodyStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-form-body';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmFormBodyStyles = defineStyles({\n        root: {\n            flex: 1\n        },\n        text: {}\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/data/form/form-body/form-body.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmFormBodyProps extends BaseProps {\n    children: any = [] as any;\n}", "wavemaker-rn-runtime/src/components/data/form/form-field/form-field.component.tsx": "import React from 'react';\nimport {Text, View} from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { widgetsWithUndefinedValue } from '@wavemaker/app-rn-runtime/core/utils';\nimport { isEqual, isNil, get, find, cloneDeep, forEach, keys } from 'lodash';\n\nimport WmFormFieldProps from './form-field.props';\nimport { DEFAULT_CLASS, WmFormFieldStyles } from './form-field.styles';\nimport {PERFORMANCE_LOGGER} from \"@wavemaker/app-rn-runtime/core/logger\";\n\nexport class WmFormFieldState extends BaseComponentState<WmFormFieldProps> {\n  isValid = true;\n}\n\nexport default class WmFormField extends BaseComponent<WmFormFieldProps, WmFormFieldState, WmFormFieldStyles> {\n  public form: any;\n  public formwidget: any;\n  public _syncValidators: any;\n  public defaultValidatorMessages: any = [];\n  private notifyForFields: any = [];\n  private _asyncValidatorFn: any;\n  constructor(props: WmFormFieldProps) {\n    super(props, DEFAULT_CLASS, new WmFormFieldProps(), new WmFormFieldState());\n    if (!this.form) {\n      this.form = props.formScope && props.formScope();\n    }\n  }\n\n  componentDidMount() {\n    super.componentDidMount();\n    this.formwidget = (this.props.formKey && this.form?.formWidgets[this.props.formKey])\n      || (this.props.name && this.form?.formWidgets[this.props.name]);\n    this.form?.registerFormFields(this.form.formFields, this.form.formWidgets);\n  }\n\n  onFieldChangeEvt(name: string, $new: any, $old: any, isDefault: boolean) {\n    this.notifyChanges();\n    if (!isEqual($old, $new)) {\n      this.updateState({ props: { datavalue: $new }} as WmFormFieldState, () => {\n        !isDefault && this.invokeEventCallback('onChange', [undefined, this, $new, $old]);\n        this.validateFormField();\n      });\n      if (this.form) {\n        this.form.updateDataOutput.call(this.form, get(this.props, 'formKey', this.props.name), $new);\n      }\n    }\n  }\n\n  // Registers observer of validation fields\n  observeOn(fields: any) {\n    forEach(fields, (field) => {\n      const formfield = find(this.form.formFields, (f) => f.proxy.name === field);\n      if (formfield) {\n        formfield.notifyForFields.push(this);\n      }\n    });\n  }\n\n  // Notifies changes to observing validation fields\n  notifyChanges() {\n    forEach(this.notifyForFields, (field) => {\n      field.formwidget.validate(field.formwidget.datavalue);\n      setTimeout(() => field.validateFormField());\n    });\n  }\n\n  getPromiseList(validators: any) {\n    const arr: any = [];\n    forEach(validators, (fn) => {\n      let promise = fn;\n      if (fn instanceof Function && fn.bind) {\n        promise = fn(this.formwidget.proxy, this.form);\n      }\n      if (promise instanceof Promise) {\n        arr.push(promise);\n      }\n    });\n    return arr;\n  }\n\n  // this method sets the asyncValidation on the form field. Assigns validationmessages from the returned response\n  setAsyncValidators(validators: any) {\n    this._asyncValidatorFn = () => {\n        return Promise.all(this.getPromiseList(validators)).then(() => {\n          return null;\n        }, err => {\n          let validationMsg: string;\n          // if err obj has validationMessage key, then set validationMessage using this value\n          // else return the value of the first key in the err object as validation message.\n          if (err.hasOwnProperty('errorMessage')) {\n            validationMsg = get(err, 'errorMessage');\n          } else {\n            const messageKeys = keys(err);\n            validationMsg = (err[messageKeys[0]]).toString();\n          }\n          this.setInvalidState(validationMsg);\n          return err;\n        })\n      };\n  }\n\n  // sets the default validation on the form field\n  setValidators(validators: any) {\n    let _cloneValidators = cloneDeep(validators);\n    this._syncValidators = [];\n    forEach(_cloneValidators, (obj, index) => {\n      // custom validation is bound to function.\n      if (obj && obj instanceof Function) {\n        // passing formwidget and form as arguments to the obj (i.e. validator function)\n        _cloneValidators[index] = obj.bind(undefined, this.formwidget.proxy, this.form);\n        this._syncValidators.push(_cloneValidators[index]);\n      } else {\n        // checks for default validator like required, maxchars etc.\n        const key = get(obj, 'type');\n        this.defaultValidatorMessages[key] = get(obj, 'errorMessage');\n        const value = get(obj, 'validator');\n        let propsObj: any = {\n          props: {}\n        };\n        propsObj.props[key] = value;\n        key === 'required' && this.updateState(propsObj as WmFormFieldState);\n        this.formwidget.updateState(propsObj as WmFormFieldState);\n      }\n    });\n  }\n\n  updateFormWidgetDataset(res: any, displayField: string) {\n    this.formwidget.updateState({\n      props: {\n        dataset: res.data,\n        datafield: 'All Fields',\n        displayfield: this.formwidget.state.props.displayfield || displayField,\n      }\n    } as WmFormFieldState);\n  }\n\n  setInvalidState(msg: string) {\n    this.updateState({\n      isValid: false,\n      props: {\n        validationmessage: msg\n      }\n    } as WmFormFieldState)\n    this.formwidget.updateState({\n      isValid: false,\n      props: {\n        validationmessage: msg\n      }\n    } as WmFormFieldState);\n  }\n\n  onPropertyChange(name: string, $new: any, $old: any) {\n    switch (name) {\n      case 'datavalue':\n        if (!isEqual($old, $new)) {\n          PERFORMANCE_LOGGER.debug(`form field ${this.props.name} changed from ${$old} to ${$new}`);\n        }\n        break;\n      case 'defaultvalue':\n        if (!isEqual($old, $new)) {\n          get(this, 'form') && this.form.applyDefaultValue(this);\n        }\n        break;\n      case 'primary-key':\n        if ($new) {\n          this.form.setPrimaryKey(this.props.name);\n        }\n        break;\n    }\n  }\n\n  setReadOnlyState(updateMode: any) {\n    this.formwidget?.updateState({\n      props: {\n        readonly: !updateMode,\n      }\n    } as WmFormFieldState);\n  }\n\n  validateFormField() {\n    if (this.formwidget?.state.isValid === false) {\n      const errorType = this.formwidget?.state?.errorType;\n      let validationMsg = get(this.defaultValidatorMessages, errorType);\n      if (validationMsg) {\n        if (validationMsg instanceof Function) {\n          // passing formwidget and form as arguments to the errorMessage function.\n          validationMsg = validationMsg(this.formwidget.proxy, this.form);\n        }\n        this.updateState({ props: {\n            validationmessage: validationMsg\n          }} as WmFormFieldState);\n      }\n      this.updateState({ isValid: false} as WmFormFieldState);\n    } else {\n      this.updateState({ isValid: true } as WmFormFieldState);\n    }\n\n    this._syncValidators?.forEach((fn: any) => {\n      const errormsg = fn();\n      let validationMsg = errormsg?.errorMessage;\n      if (validationMsg) {\n        if (validationMsg instanceof Function) {\n          // passing formwidget and form as arguments to the errorMessage function.\n          validationMsg = validationMsg(this.formwidget.proxy, this.form);\n        }\n        this.setInvalidState(validationMsg);\n      }\n    })\n\n    this._asyncValidatorFn && this._asyncValidatorFn();\n\n  }\n\n  get value(){\n    return this.state.props.datavalue;\n  }\n\n  renderWidget(props: WmFormFieldProps) {\n    var childrenWithProps = React.Children.map(props.renderFormFields(this.proxy).props.children, (child) => {\n      return React.cloneElement(child, {\n          datavalue: props.datavalue || child?.props?.datavalue,\n          value: this.value,\n          isValid: this.state.isValid,\n          maskchar: props.maskchar,\n          displayformat: props.displayformat,\n          invokeEvent: this.invokeEventCallback.bind(this),\n          triggerValidation: this.validateFormField.bind(this),\n          onFieldChange: this.onFieldChangeEvt.bind(this),\n          formRef: props.formRef,\n          isdefault: props.defaultvalue && props.defaultvalue.length > 0 ? true : false, \n          ...(!isNil(props?.placeholder) ? { placeholder: props.placeholder } : {})\n         });\n    });\n    return (\n      <View \n        style={this.styles.root}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        {this._background}\n        {childrenWithProps}\n        {this.state.isValid === false && <Text {...this.getTestPropsForLabel('error_msg')} style={this.styles.errorMsg}>{props.validationmessage}</Text>}\n      </View>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/data/form/form-field/form-field.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmFormFieldProps extends BaseProps {\n  children: any;\n  formRef: any;\n  placeholder?: string;\n  defaultvalue: any;\n  generator: string = '';\n  datavalue: any;\n  onChange: any;\n  renderFormFields: any;\n  validationmessage: any;\n  required: Boolean = false;\n  primaryKey: Boolean = false;\n  isRelated: any;\n  widget: any;\n  onFieldChange: any;\n  formKey: string = '';\n  dataset: any;\n  displayfield: any;\n  datafield: string = '';\n  isDataSetBound: boolean = false;\n  readonly: boolean = false;\n  onValidate?: Function;\n  formScope?: Function = () => {};\n  maskchar: string = null as any;\n  displayformat: string = null as any;\n}\n", "wavemaker-rn-runtime/src/components/data/form/form-field/form-field.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { TextStyle } from 'react-native';\n\nexport type WmFormFieldStyles = BaseStyles & {\n    errorMsg: TextStyle\n};\n\nexport const DEFAULT_CLASS = 'app-form-field';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmFormFieldStyles = defineStyles({\n        root: {\n            marginBottom: 24\n        },\n        text: {},\n        errorMsg: {\n            color: 'red',\n            fontSize: 13,\n            paddingTop: 6,\n            fontFamily: themeVariables.baseFont\n        }\n    });\n    addStyle('form-label', '', {\n        root : {\n            paddingBottom: 5\n        },\n        text: {\n            color: themeVariables.defaultTextColor,\n            fontSize: themeVariables.heading5FontSize\n        }\n    } as BaseStyles);\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});\n", "wavemaker-rn-runtime/src/components/data/form/form-action/form-action.component.tsx": "import React from 'react';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport WmButton from '@wavemaker/app-rn-runtime/components/basic/button/button.component';\nimport { SyntheticEvent } from '@wavemaker/app-rn-runtime/core/tappable.component';\n\nimport WmFormActionProps from './form-action.props';\nimport { DEFAULT_CLASS, WmFormActionStyles } from './form-action.styles';\nimport {debounce} from \"lodash\";\nimport WmSkeleton, { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\nimport { ThemeConsumer } from '@wavemaker/app-rn-runtime/styles/theme';\n\nexport class WmFormActionState extends BaseComponentState<WmFormActionProps> {}\n\nexport default class WmFormAction extends BaseComponent<WmFormActionProps, WmFormActionState, WmFormActionStyles> {\n\n  constructor(props: WmFormActionProps) {\n    super(props, DEFAULT_CLASS, new WmFormActionProps());\n  }\n\n  private _debouncedFormAction = debounce(this.onClick, 250);\n\n  onClick($event: SyntheticEvent, cb: Function | undefined) {\n    cb && cb($event);\n  }\n\n  renderWidget(props: WmFormActionProps) {\n    return (\n      <WmButton\n        id={this.getTestId()}\n        show={props.show}\n        disabled={props.disabled}\n        caption={props.displayName}\n        styles={this.styles}\n        name={props.name}\n        iconclass={props.iconclass}\n        iconposition={props.iconposition}\n        onTap={($event: any) => {\n          this._debouncedFormAction($event, props.formAction);\n        }}\n      />\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/data/form/form-action/form-action.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmButtonStyles } from '@wavemaker/app-rn-runtime/components/basic/button/button.styles';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmFormActionStyles = WmButtonStyles & {\n  skeleton: WmSkeletonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-form-action';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n  const defaultStyles: WmFormActionStyles = defineStyles({\n    root: {\n      marginTop: 0,\n      marginLeft: 4,\n      marginRight: 4,\n      marginBottom: 0,\n      flex: 1,\n      rippleColor: themeVariables.rippleColor\n    },\n    text: {},\n    icon : {\n      icon: {\n        fontSize: 20\n      }\n    },\n    skeleton: {\n      root: {\n        width: 96,\n        height: 48\n      }\n    } as WmSkeletonStyles\n  } as WmFormActionStyles);\n  addStyle(DEFAULT_CLASS + '-disabled', '', {\n    root : {\n      opacity: 0.5\n    }\n  });\n\n  addStyle(DEFAULT_CLASS, '', defaultStyles);\n});\n", "wavemaker-rn-runtime/src/components/data/form/form-action/form-action.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmFormActionProps extends BaseProps {\n  displayName: string = '';\n  formKey: string = '';\n  action: any = '';\n  show: boolean = true;\n  iconclass: any;\n  updateMode: boolean = true;\n  formAction: Function = null as any;\n  iconposition? = 'left';\n}\n", "wavemaker-rn-runtime/src/components/data/card/card.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport WmLabel from '@wavemaker/app-rn-runtime/components/basic/label/label.component';\nimport WmMenu from '@wavemaker/app-rn-runtime/components/navigation/menu/menu.component';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport { Tappable } from '@wavemaker/app-rn-runtime/core/tappable.component';\nimport WmPicture from '@wavemaker/app-rn-runtime/components/basic/picture/picture.component';\n\n\nimport WmCardProps from './card.props';\nimport { DEFAULT_CLASS, WmCardStyles } from './card.styles';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\nimport { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\n\nexport class WmCardState extends BaseComponentState<WmCardProps> {}\n\nexport default class WmCard extends BaseComponent<WmCardProps, WmCardState, WmCardStyles> {\n\n  constructor(props: WmCardProps) {\n    super(props, DEFAULT_CLASS, new WmCardProps());\n  }\n\n  renderHeader(props: WmCardProps) {\n    return (\n      <View style={{flexDirection: 'row'}}>\n        {(props.iconclass || props.title || props.subheading || props.actions) ?\n        (<View style={this.styles.heading}>\n        {props.iconclass || props.iconurl ? \n          <WmIcon styles={this.styles.cardIcon}\n           iconclass={props.iconclass}\n           iconurl={props.iconurl}\n           iconheight={props.iconheight}\n           iconmargin={props.iconmargin}\n           iconwidth={props.iconwidth}\n           /> : null} \n          <View style={{flex: 1}}>\n            <WmLabel styles={this.styles.title} caption={props.title}></WmLabel>\n            <WmLabel styles={this.styles.subheading} caption={props.subheading}></WmLabel>\n          </View>\n          <WmMenu\n            caption=\"\"\n            iconclass=\"wm-sl-l sl-more-menu-vertical\"\n            dataset={props.actions}\n            itemlabel={props.itemlabel}\n            itemlink={props.itemlink}\n            itemicon={props.itemicon}\n            itembadge={props.itembadge}\n            isactive={props.isactive}\n            itemchildren={props.itemchildren}></WmMenu>\n        </View>) : null}\n        {props.picturesource &&\n          (<WmPicture\n            picturesource={props.picturesource}\n            styles={this.theme.mergeStyle({root : {height: props.imageheight}}, this.styles.picture)}></WmPicture>\n        )}\n      </View>);\n  }\n\n  public renderSkeleton(props: WmCardProps): React.ReactNode {\n    if(!props.showskeletonchildren) {\n      const skeletonStyles: WmSkeletonStyles = this.props?.styles?.skeleton || { root: {}, text: {}  } as WmSkeletonStyles\n      return createSkeleton(this.theme, skeletonStyles, {\n        ...this.styles.root\n      }, (<View style={[this.styles.root, { opacity: 0 }]}>\n        {props.children}\n      </View>))\n    }\n    return null;\n  }\n\n  renderWidget(props: WmCardProps) {\n       return (\n      <View \n        style={this.styles.root}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        {this._background}\n        <Tappable {...this.getTestPropsForAction()} target={this} styles={{width: '100%', height: this.styles.root.height ? '100%' : null}} disableTouchEffect={this.state.props.disabletoucheffect}>\n            {this.renderHeader(props)}\n            {props.children}\n        </Tappable>\n      </View>);\n  }\n}\n", "wavemaker-rn-runtime/src/components/data/card/card.styles.ts": "import BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmPictureStyles } from '@wavemaker/app-rn-runtime/components/basic/picture/picture.styles';\nimport { WmIconStyles } from '@wavemaker/app-rn-runtime/components/basic/icon/icon.styles';\nimport { WmLabelStyles } from '@wavemaker/app-rn-runtime/components/basic/label/label.styles';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmCardStyles = BaseStyles & {\n    heading: AllStyle,\n    cardIcon: WmIconStyles,\n    title: WmLabelStyles,\n    subheading: WmLabelStyles,\n    picture: WmPictureStyles,\n    skeleton: WmSkeletonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-card';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmCardStyles = defineStyles({\n        root: {\n            width: '100%',\n        },\n        text: {},\n        cardIcon: {\n            root: {\n                marginTop: 4,\n                marginRight: 8\n            }\n        } as WmIconStyles,\n        heading : {\n            paddingTop: 8,\n            paddingBottom: 8,\n            paddingLeft: 8,\n            paddingRight: 8,\n            backgroundColor: themeVariables.cardHeaderBgColor,\n            flexDirection: 'row',\n            alignContent: 'center',\n            width: '100%'\n        },\n        title: {\n            text: {\n                fontSize: 16,\n                lineHeight: 24,\n                color: themeVariables.cardTitleColor\n            }\n        } as WmLabelStyles,\n        subheading: {\n            text: {\n                fontSize: 12,\n                lineHeight: 18,\n                color: themeVariables.cardSubTitleColor\n            }\n        } as WmLabelStyles,\n        picture: {\n            root : {\n                width: '100%'\n            }\n        } as any as WmPictureStyles,\n        skeleton: {\n            root: {\n            }\n        } as any as WmSkeletonStyles\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/data/card/card.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmCardProps extends BaseProps {\n  children? = null as any;\n  actions?: string = null as any;\n  itemlabel?: string = null as any;\n  itemlink?: string = null as any;\n  itemicon?: string = null as any;\n  itembadge?: string = null as any;\n  isactive?: string = null as any;\n  itemchildren?: string = null as any;\n  iconclass?: string = null as any;\n  imageheight?: number = 200;\n  picturesource?: string = null as any;\n  subheading?: string = null as any;\n  title?: string = null as any;\n  iconurl?: string = null as any;\n  iconheight?: number = null as any;\n  iconwidth?: number = null as any;\n  iconmargin?: number = null as any;\n}", "wavemaker-rn-runtime/src/components/data/card/card-footer/card-footer.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmCardFooterProps from './card-footer.props';\nimport { DEFAULT_CLASS, WmCardFooterStyles } from './card-footer.styles';\n\nexport class WmCardFooterState extends BaseComponentState<WmCardFooterProps> {}\n\nexport default class WmCardFooter extends BaseComponent<WmCardFooterProps, WmCardFooterState, WmCardFooterStyles> {\n\n  constructor(props: WmCardFooterProps) {\n    super(props, DEFAULT_CLASS, new WmCardFooterProps());\n  }\n\n  renderWidget(props: WmCardFooterProps) {\n    return (\n      <View \n        style={this.styles.root}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        {this._background}\n        {props.children}\n      </View>); \n  }\n}\n", "wavemaker-rn-runtime/src/components/data/card/card-footer/card-footer.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmCardFooterProps extends BaseProps {\n    children? = null as any;\n}", "wavemaker-rn-runtime/src/components/data/card/card-footer/card-footer.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport type WmCardFooterStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-card-footer';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmCardFooterStyles = defineStyles({\n        root: {\n            width: '100%',\n            backgroundColor: themeVariables.cardFooterBgColor,\n            padding: 8,\n            borderTopWidth: 1,\n            borderStyle: 'solid',\n            borderColor: themeVariables.cardFooterBorderColor\n        },\n        text: {}\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/data/card/card-content/card-content.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmCardContentProps extends BaseProps {\n  children? = null as any;\n  renderPartial?: Function;\n}\n", "wavemaker-rn-runtime/src/components/data/card/card-content/card-content.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmCardContentProps from './card-content.props';\nimport { DEFAULT_CLASS, WmCardContentStyles } from './card-content.styles';\n\nexport class WmCardContentState extends BaseComponentState<WmCardContentProps> {\n  isPartialLoaded = false;\n}\n\nexport default class WmCardContent extends BaseComponent<WmCardContentProps, WmCardContentState, WmCardContentStyles> {\n\n  constructor(props: WmCardContentProps) {\n    super(props, DEFAULT_CLASS, new WmCardContentProps());\n  }\n\n  onPartialLoad() {\n    this.invokeEventCallback('onLoad', [null, this]);\n  }\n\n  renderContent(props: WmCardContentProps) {\n    if (props.renderPartial) {\n      if (!this.state.isPartialLoaded) {\n        setTimeout(() => {\n          this.updateState({\n            isPartialLoaded: true\n          } as WmCardContentState);\n        });\n      }\n      return props.renderPartial(props, this.onPartialLoad.bind(this));\n    }\n    return props.children;\n  }\n\n  renderWidget(props: WmCardContentProps) {\n    const styles = this._showSkeleton ? {\n      ...this.styles.root,\n      ...this.styles.skeleton.root\n    } : this.styles.root\n\n    return (\n      <View \n        style={styles}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        {!this._showSkeleton ? this._background : null}\n        {this.renderContent(props)}\n      </View>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/data/card/card-content/card-content.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmCardContentStyles = BaseStyles & {\n    skeleton: WmSkeletonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-card-content';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmCardContentStyles = defineStyles({\n        root: {\n            backgroundColor: themeVariables.cardContentBgColor,\n            padding: 8\n        },\n        text: {},\n        skeleton: {\n            root: {\n            }\n        } as any as WmSkeletonStyles\n    });\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n});", "wavemaker-rn-runtime/src/components/data/list/list.styles.ts": "import { TextStyle, ViewStyle } from 'react-native';\nimport BASE_THEME, { AllStyle } from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmLabelStyles } from '@wavemaker/app-rn-runtime/components/basic/label/label.styles';\nimport { WmIconStyles } from '@wavemaker/app-rn-runtime/components/basic/icon/icon.styles';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmListStyles = BaseStyles & {\n    heading: AllStyle,\n    groupHeading: TextStyle,\n    listIcon: WmIconStyles,\n    loadingIcon: WmIconStyles,\n    title: WmLabelStyles,\n    subheading: WmLabelStyles,\n    emptyMessage: WmLabelStyles,\n    onDemandMessage: WmLabelStyles,\n    item: AllStyle,\n    itemContainer: ViewStyle | ViewStyle[],\n    selectedItem: AllStyle,\n    selectedIcon: WmIconStyles,\n    group: AllStyle,\n    skeleton: WmSkeletonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-list';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmListStyles = defineStyles({\n        root: {},\n        text: {},\n        listIcon: {\n            root: {\n                marginTop: 10,\n                marginRight: 8\n            }\n        } as WmIconStyles,\n        groupHeading: {\n            backgroundColor: themeVariables.groupHeadingBgColor,\n            fontSize: 16,\n            paddingLeft: 8,\n            paddingRight: 8,\n            lineHeight: 40,\n            fontFamily: themeVariables.baseFont\n        },\n        loadingIcon: {\n            root: {\n                flex: 1,\n                alignSelf: 'center',\n                justifyContent: 'center',\n                fontSize: 16\n            },\n            text: {\n                color: themeVariables.listSubTitleColor\n            }\n        } as WmIconStyles,\n        heading : {\n            padding: 8,\n            marginBottom: 6,\n            backgroundColor: themeVariables.listHeaderBgColor\n        },\n        title: {\n            text: {\n                color: themeVariables.listTitleColor,\n                fontSize: 16,\n                fontFamily: themeVariables.baseFont,\n                lineHeight: 24,\n                fontWeight: '400'   \n            }\n        } as WmLabelStyles,\n        subheading: {\n            text: {\n                fontSize: 14,\n                lineHeight: 20,\n                fontFamily: themeVariables.baseFont,\n                fontWeight: '400',\n                color: themeVariables.listSubTitleColor\n            }\n        } as WmLabelStyles,\n        emptyMessage: {\n            root: {\n                flex: 1,\n                alignSelf: 'center',\n                fontSize: 16,\n                lineHeight: 18,\n                color: themeVariables.listSubTitleColor\n            }\n        } as WmLabelStyles,\n        onDemandMessage: {\n            root: {\n                paddingVertical: 8,\n                width: '100%'\n            } as ViewStyle,\n            text: {\n                textAlign: 'center',\n                color: themeVariables.listSubTitleColor\n            }\n        } as WmLabelStyles,\n        group: {\n            marginBottom: 16,\n        },\n        item: {\n            ...BASE_THEME.getStyle('elevate1').root,\n            shadowColor: 'rgba(0, 0, 0, 0.3)',\n            paddingLeft: 4,\n            paddingRight: 4,\n            flex: 1,\n            flexDirection: 'row',\n            paddingTop: 4,\n            paddingBottom: 4,\n            minHeight: 56,\n            backgroundColor: themeVariables.itemBgColor,\n            borderColor: themeVariables.selectedItemBorderColor,\n            borderRadius: 6,\n            borderStyle: 'solid',\n        },\n        itemContainer: {\n        },\n        selectedItem : {} as AllStyle,\n        selectedIcon : {\n            root: {\n                position: 'absolute',\n                right: 0,\n                top: 0\n            },\n            text: {\n                color: themeVariables.primaryColor,\n                fontSize: 16\n            }\n        } as WmIconStyles,\n        skeleton: {\n            root: {\n                shadowColor: 'transparent',\n                paddingTop: 0,\n                paddingBottom: 0,    \n                paddingLeft: 0,\n                paddingRight: 0,    \n            }\n        } as any as WmSkeletonStyles\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n\n    addStyle('app-horizontal-list', '', {\n        groupHeading: {\n            minWidth: 120,\n            backgroundColor: themeVariables.groupHeadingBgColor,\n        },\n        item: {\n            marginRight: 6,\n            borderColor: themeVariables.selectedItemBorderColor,\n        }\n    } as WmListStyles);\n\n    addStyle('app-vertical-list', '', {\n        item: {\n            marginBottom: 6,\n            width: '100%',\n            borderBottomWidth: 0,\n            borderBottomColor: themeVariables.listDividerColor,\n        }\n    } as any as WmListStyles);\n\n    addStyle('app-horizontal-list-dense', '', {\n        item: {\n            marginRight: 0,\n            borderRadius: 0,\n            borderRightWidth: 1,\n            borderRightColor: 'rgba(0,0,0,0.05)'\n        } as ViewStyle\n    } as WmListStyles);\n\n    addStyle('app-list-dense', '', {\n        item: {\n            marginBottom: 0,\n            borderRadius: 0,\n            borderBottomWidth: 1,\n            borderBottomColor: 'rgba(0,0,0,0.05)'\n        } as ViewStyle\n    } as WmListStyles);\n});\n", "wavemaker-rn-runtime/src/components/data/list/list.component.tsx": "import React from 'react';\nimport { ActivityIndicator, SectionList, Text, View, FlatList, LayoutChangeEvent, TouchableOpacity } from 'react-native';\nimport { isArray, isEmpty, isNil, isNumber, round } from 'lodash-es';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { getGroupedData, getNumberOfEmptyObjects, isDefined } from \"@wavemaker/app-rn-runtime/core/utils\";\nimport { Tappable } from '@wavemaker/app-rn-runtime/core/tappable.component';\nimport { DefaultKeyExtractor } from '@wavemaker/app-rn-runtime/core/key.extractor';\nimport WmLabel from '@wavemaker/app-rn-runtime/components/basic/label/label.component';\nimport WmIcon from '@wavemaker/app-rn-runtime/components/basic/icon/icon.component';\nimport { Swipeable } from 'react-native-gesture-handler';\nimport WmListActionTemplate from './list-action-template/list-action-template.component';\n\nimport WmListProps from './list.props';\nimport { DEFAULT_CLASS, WmListStyles } from './list.styles';\nimport { BackgroundComponent } from '@wavemaker/app-rn-runtime/styles/background.component';\n\n\nexport class WmListState extends BaseComponentState<WmListProps> {\n  public selectedindex: any;\n  groupedData: Array<any> = [];\n  currentPage = 1;\n  maxRecordsToShow = 20;\n  loadingData = false;\n}\n\nexport default class WmList extends BaseComponent<WmListProps, WmListState, WmListStyles> {\n\n  private itemWidgets = [] as any[];\n  private selectedItemWidgets = {} as any;\n  private keyExtractor = new DefaultKeyExtractor();\n  private endThreshold = -1;\n  // private loadingData = false;\n  private hasMoreData = true;\n  public leftActionTemplate?: WmListActionTemplate;\n  public rightActionTemplate?: WmListActionTemplate;\n  private flatListRefs: any = {};\n  private selectedItems = [] as any[];\n\n  constructor(props: WmListProps) {\n    super(props, DEFAULT_CLASS, new WmListProps(), new WmListState());\n    this.updateState({\n      maxRecordsToShow: this.state.props.pagesize\n    } as WmListState);\n  }\n\n  private isSelected($item: any) {\n    const selectedItem = this.state.props.selecteditem;\n    if (isArray(selectedItem)) {\n      return selectedItem.indexOf($item) >= 0;\n    }\n    return selectedItem === $item;\n  }\n\n  private async onSelect($item: any, $index: number | string, $event?: any) {\n    const props = this.state.props;\n    let selectedItem = null as any;\n    let eventName = 'onSelect';\n    if (props.disableitem !== true\n      && (typeof props.disableitem !== 'function' || !props.disableitem($item, $index))) {\n      if (props.multiselect) {\n        selectedItem = [...(props.selecteditem || [])];\n        const index = selectedItem.indexOf($item);\n        if (index < 0) {\n          if ((!props.selectionlimit)\n            || props.selectionlimit < 0\n            || selectedItem.length < props.selectionlimit) {\n            selectedItem.push($item);\n          } else {\n            this.invokeEventCallback('onSelectionlimitexceed', [null, this]);\n          }\n        } else {\n          selectedItem.splice(index, 1);\n          eventName = 'onDeselect';\n        }\n      } else {\n        this.state.props.selecteditem && this.invokeEventCallback('onDeselect', [this.proxy, this.state.props.selecteditem]);\n        selectedItem = $item;\n      }\n      this.selectedItems = selectedItem;\n      this.selectedItemWidgets = this.itemWidgets[$index as number];\n      let groupKey: string | null = null;\n\n      if (props.direction === 'horizontal') {\n        this.state.groupedData?.forEach((group) => {\n          if (group.data.includes($item)) {\n            groupKey = group.key;\n          }\n        });\n      }\n\n      return new Promise(resolve => {\n        this.updateState({\n          props: { selecteditem: selectedItem },\n          selectedindex: $index\n        } as WmListState, () => {\n          if (props.direction === 'horizontal') {\n            this.scrollToItem(groupKey, $index as number);\n          }\n          this.invokeEventCallback(eventName, [this.proxy, $item]);\n          $event && this.invokeEventCallback('onTap', [$event, this.proxy]);\n          resolve(null);\n        });\n      });\n\n    } else {\n      return Promise.resolve(null);\n    }\n  }\n\n  private get loadDataOnDemand() {\n    const navigation = this.state.props.navigation;\n    return navigation === 'Scroll' || navigation === 'On-Demand';\n  }\n\n  renderLeftActions = () => {\n    return this.leftActionTemplate ? (\n      <>\n        {this.leftActionTemplate.getTemplate()}\n      </>\n    ) : null;\n  };\n\n  renderRightActions = () => {\n    return this.rightActionTemplate ? (\n      <>\n        {this.rightActionTemplate.getTemplate()}\n      </>\n    ) : null;\n  };\n\n  private loadData() {\n    if (this.state.loadingData || !this.hasMoreData) {\n      return;\n    }\n    if (isArray(this.state.props.dataset)\n      && this.state.props.dataset.length > this.state.maxRecordsToShow) {\n      this.updateState({\n        loadingData: true,\n        maxRecordsToShow: this.state.maxRecordsToShow + this.state.props.pagesize\n      } as WmListState);\n      setTimeout(() => {\n        // Force a re-render by making a small state update\n        this.updateState({\n          loadingData: false,\n          } as WmListState);\n      }, 100);\n    } else if (this.loadDataOnDemand) {\n      const $list = this.proxy as any;\n      $list.loadingdata = true;\n      // Set loading state via updateState\n      this.updateState({\n        loadingData: true\n      } as WmListState);\n      this.props.getNextPageData && this.props.getNextPageData(null, this.proxy, this.state.currentPage + 1).then((data) => {\n        if (isArray(data) && data.length > 0\n          && isArray(this.state.props.dataset)) {\n          $list.dataset = [...this.state.props.dataset, ...data];\n          this.updateState({\n            currentPage: this.state.currentPage + 1,\n            maxRecordsToShow: this.state.maxRecordsToShow + this.state.props.pagesize\n          } as WmListState);\n          this.hasMoreData = true;\n          if((data as any)?.last === true) {\n            this.hasMoreData = false;\n          }\n        } else {\n          this.hasMoreData = false;\n        }\n      }).catch((err) => {\n        console.error(err);\n      }).then(() => {\n        setTimeout(() => {\n          $list.loadingdata = false;\n        }, 1000);\n      });\n    }\n  }\n\n  private selectFirstItem() {\n    const props = this.state.props;\n    if (this.initialized\n      && props.dataset\n      && props.dataset.length) {\n      const index = props.groupby ? '00' : 0;\n      this.onSelect(props.dataset[0], index);\n    }\n  }\n\n  clear() {\n    this.updateState({\n      groupedData: {},\n    } as WmListState);\n  }\n\n  selectItem = (item: any) => {\n    const dataset = this.state.props.dataset;\n    if (isNumber(item)) {\n      this.onSelect(dataset[item], item);\n    }\n    else {\n      let index = dataset.indexOf(item);\n      this.onSelect(dataset[index], index);\n    }\n  }\n\n  getSelectedItems = () => {\n    if(!this.props.multiselect){\n      return [this.selectedItems]\n    }\n    return this.selectedItems;\n  }\n\n  getItem(index: number) {\n    const props = this.state.props;\n    return this.props.dataset[index]\n  }\n\n  deselect(item: any) {\n    const props = this.state.props;\n    let selectedItem = null as any;\n    let index = isNumber(item) ? item : props.dataset.indexOf(item);\n    if (props.multiselect && index >= 0) {\n      selectedItem = [...(props.selecteditem || [])];\n      let selectedItemIndex = selectedItem.indexOf(props.dataset[index])\n      if (selectedItemIndex >= 0) {\n        selectedItem.splice(selectedItemIndex, 1);\n      }\n    }\n    else {\n      if (props.selecteditem === props.dataset[index]) {\n        selectedItem = null;\n      }\n    }\n    this.updateState({\n      props: { selecteditem: selectedItem },\n\n    } as WmListState, () => {\n      this.invokeEventCallback('onDeselect', [this.proxy, item]);\n    });\n  }\n\n  getWidgets(widgetname: string, index: number) {\n    if (index >= 0 && index < this.itemWidgets.length) {\n      return this.itemWidgets[index][widgetname]\n    }\n    else {\n      return this.itemWidgets.map(item => item[widgetname]).filter(widget => widget !== undefined);\n    }\n  }\n\n  selectAll = () => {\n    const props = this.state.props;\n    const dataset = props.dataset;\n    if (!props.multiselect || !isArray(dataset) || dataset.length === 0) {\n      return;\n    }\n    const selectedItems = [...dataset];\n  \n    this.updateState({\n      props: { selecteditem: selectedItems },\n      selectedindex: -1\n    } as WmListState );\n  }  \n\n  private deselectAll() {\n    this.updateState({\n      props: { selecteditem: null },\n      selectedindex: -1\n    } as WmListState);\n  }\n\n  setGroupData(items: any) {\n    const dataItems = items;\n    const props = this.state.props;\n    if (props.groupby) {\n      const groupedData = dataItems && getGroupedData(dataItems, props.groupby, props.match, props.orderby, props.dateformat, this);\n      this.updateState({\n        groupedData: groupedData\n      } as WmListState, () => {\n        this.keyExtractor?.clear();\n      });\n    }\n  }\n\n  public onPropertyChange(name: string, $new: any, $old: any) {\n    super.onPropertyChange(name, $new, $old);\n    const props = this.state.props;\n    switch (name) {\n      case 'selectfirstitem':\n        if ($new) {\n          this.selectFirstItem();\n        }\n        break;\n      case 'dataset':\n        if (this.state.props.groupby) {\n          this.setGroupData($new);\n        } else {\n          if (!($old && $old.length)\n            && $new && $new.length\n            && this.loadDataOnDemand) {\n            this.updateState({\n              props: {\n                dataset: [...$new]\n              }\n            } as WmListState);\n          }\n          const data = isArray($new) ? $new : (!isEmpty($new) && isDefined($new) ? [$new] : []);\n          if (props.orderby) {\n            const orderbyData = data && getGroupedData(data, props.groupby, props.match, props.orderby, props.dateformat, this);\n            this.updateState({\n              groupedData: (orderbyData[0] ? [{\n                key: 'key',\n                data: orderbyData[0].data\n              }] : [])\n            } as WmListState, () => {\n              this.keyExtractor?.clear();\n            });\n          } else {\n            this.updateState({\n              groupedData: (data[0] || props.direction === 'horizontal' ? [{\n                key: 'key',\n                data: data\n              }] : [])\n            } as WmListState, () => {\n              this.keyExtractor?.clear();\n            });\n          }\n        }\n        this.itemWidgets = [];\n        if (props.selectfirstitem) {\n          this.selectFirstItem();\n        } else {\n          this.deselectAll();\n        }\n        break;\n      case 'groupby':\n      case 'match':\n        this.setGroupData(this.state.props.dataset);\n        break;\n      case 'multiselect':\n        if ($new) {\n          if (!isArray(this.state.props.selecteditem)) {\n            this.state.props.selecteditem = this.state.props.selecteditem ?\n              [this.state.props.selecteditem] : [];\n          }\n        } else if (isArray(this.state.props.selecteditem)) {\n          this.state.props.selecteditem = this.state.props.selecteditem.pop();\n        }\n        break;\n      case 'loadingdata':\n        this.updateState({\n          loadingData: $new && this.state.loadingData\n        } as WmListState);\n        break;\n      case 'selecteditem':\n        if ($new != $old && isNumber($new)) {\n          this.selectItem(this.state.props.dataset[$new])\n        }\n        break;\n    }\n  }\n\n  componentDidMount() {\n    const props = this.state.props;\n    if (this.state.props.selectfirstitem && props.dataset?.length) {\n      setTimeout(() => {\n        this.onSelect(props.dataset[0], 0);\n      });\n    }\n    this.subscribe('scroll', (event: any) => {\n      const scrollPosition = event.nativeEvent.contentOffset.y + event.nativeEvent.layoutMeasurement.height;\n      if (scrollPosition > this.endThreshold && this.state.props.direction === 'vertical') {\n        this.loadData();\n      }\n    });\n    super.componentDidMount();\n  }\n\n  componentDidUpdate(prevProps: WmListProps, prevState: WmListState, snapshot?: any) {\n    super.componentDidUpdate && super.componentDidUpdate(prevProps, prevState, snapshot);\n    if (prevProps.triggeronrenderwhenhidden === true || this.showView()) {\n      this.invokeEventCallback('onRender', [this, this.state.props.dataset]);\n    }\n  }\n\n  getDefaultStyles() {\n    const isHorizontal = this.state.props.direction === 'horizontal';\n    return this.theme.getStyle(`${this.defaultClass} ${isHorizontal ? 'app-horizontal-list' : 'app-vertical-list'}`);\n  }\n\n  getIndex(item: any) {\n    return this.state.props.dataset.indexOf(item);\n  }\n\n  private generateItemKey(item: any, index: number, props: WmListProps) {\n    if (props.itemkey && item && !this._showSkeleton) {\n      return props.itemkey(item, index);\n    }\n    return 'list_item_' + this.keyExtractor.getKey(item, true);\n  }\n\n  private renderItem(item: any, index: number, props: WmListProps) {\n    const cols = this.getNoOfColumns();\n    const isHorizontal = (props.direction === 'horizontal');\n    \n    const styles = this._showSkeleton ? {\n      ...this.styles.item,\n      ...this.styles.skeleton.root\n    } : this.styles.item as any\n\n    const containerStyle = cols ? { width: round(100/cols) + \"%\" , flex: null} : {};\n\n    return (index < this.state.maxRecordsToShow || isHorizontal) ? \n    !props.shouldswipe ? (\n     <View style={containerStyle as any}>\n       <View style={[\n        styles,\n        props.itemclass ? this.theme.getStyle(props.itemclass(item, index)) : null,\n        this.isSelected(item) ? this.styles.selectedItem : {}]}>\n        {styles.backgroundImage ? (\n          <BackgroundComponent\n          image={styles.backgroundImage}\n          position={styles.backgroundPosition || 'center'}\n          size={styles.backgroundSize || 'cover'}\n          repeat={styles.backgroundRepeat || 'no-repeat'}\n          resizeMode={styles.backgroundResizeMode || 'cover'}\n          style={{ borderRadius: this.styles.item.borderRadius }}\n        />\n        ) : null}\n        <Tappable\n          {...this.getTestPropsForAction(`item${index}`)}\n          disableTouchEffect={this.state.props.disabletoucheffect}\n          onTap={($event) => this.onSelect(item, index, $event)}\n          onLongTap={() => this.invokeEventCallback('onLongtap', [null, this.proxy])}\n          onDoubleTap={() => this.invokeEventCallback('onDoubletap', [null, this.proxy])}\n          styles={\n            [{display: 'flex', flexDirection : 'row'},\n              cols ? {\n                width: '100%'\n              } : null,\n              (cols && cols > 1) || isHorizontal ? {\n                paddingRight: (isNil(this.styles.item.marginRight)\n                  ? this.styles.item.margin : this.styles.item.marginRight) || 4\n              } : null,\n              this.styles.itemContainer\n            ]\n          }>\n          {props.renderItem(item, index, this)}\n          {this.isSelected(item) ? (\n            <WmIcon id={this.getTestId('icon' + index)} iconclass='wi wi-check-circle' styles={this.styles.selectedIcon} />\n          ) : null}\n        </Tappable>\n      </View>\n     </View>\n    ) :\n    (\n      <Swipeable\n      renderLeftActions={() => this.renderLeftActions()}\n      renderRightActions={() => this.renderRightActions()} containerStyle={containerStyle as any}>\n      <View style={[\n        styles,\n        props.itemclass ? this.theme.getStyle(props.itemclass(item, index)) : null,\n        this.isSelected(item) ? this.styles.selectedItem : {}]}>\n        {styles.backgroundImage ? (\n          <BackgroundComponent\n          image={styles.backgroundImage}\n          position={styles.backgroundPosition || 'center'}\n          size={styles.backgroundSize || 'cover'}\n          repeat={styles.backgroundRepeat || 'no-repeat'}\n          resizeMode={styles.backgroundResizeMode || 'cover'}\n          style={{ borderRadius: this.styles.item.borderRadius }}\n        />\n        ) : null}\n        <Tappable\n          {...this.getTestPropsForAction(`item${index}`)}\n          disableTouchEffect={this.state.props.disabletoucheffect}\n          onTap={($event) => this.onSelect(item, index, $event)}\n          onLongTap={() => this.invokeEventCallback('onLongtap', [null, this.proxy])}\n          onDoubleTap={() => this.invokeEventCallback('onDoubletap', [null, this.proxy])}\n          styles={\n            [{display: 'flex', flexDirection : 'row'},\n              cols ? {\n                width: '100%'\n              } : null,\n              (cols && cols > 1) || isHorizontal ? {\n                paddingRight: (isNil(this.styles.item.marginRight)\n                  ? this.styles.item.margin : this.styles.item.marginRight) || 4\n              } : null,\n              this.styles.itemContainer\n              ]\n            }>\n            {props.renderItem(item, index, this)}\n            {this.isSelected(item) ? (\n              <WmIcon id={this.getTestId('icon' + index)} iconclass={props.selecteditemicon ? props.selecteditemicon : 'wi wi-check-circle'} styles={this.styles.selectedIcon} />\n            ) : null}\n          </Tappable>\n        </View>\n      </Swipeable>\n    ) : null\n  }\n\n  private renderHeader(props: WmListProps, title: string) {\n    return props.groupby ? (\n      <Text style={this.styles.groupHeading} accessibilityRole='header'>{title}</Text>\n    ) : (props.iconclass || props.title || props.subheading) ? (\n      <View style={this.styles.heading}>\n        <View style={{ flex: 1, flexDirection: 'row' }}>\n          <WmIcon id={this.getTestId('icon')} styles={this.styles.listIcon} iconclass={props.iconclass}></WmIcon>\n          <View>\n            <WmLabel id={this.getTestId('title')} styles={this.styles.title} caption={props.title} accessibilityrole='header'></WmLabel>\n            <WmLabel id={this.getTestId('subheading')} styles={this.styles.subheading} caption={props.subheading}></WmLabel>\n          </View>\n        </View>\n      </View>) : null;\n  }\n\n  private renderEmptyMessage(isHorizontal: boolean, item: any, index: any, props: WmListProps) {\n    return (<WmLabel id={this.getTestId('emptymsg')} styles={this.styles.emptyMessage} caption={props.nodatamessage}></WmLabel>);\n  }\n\n  private renderLoadingIcon(props: WmListProps) {\n    return props.loadingicon ? (<WmIcon\n      id={this.getTestId('loadingicon')}\n      styles={this.styles.loadingIcon}\n      iconclass={props.loadingicon}\n      caption={props.loadingdatamsg}></WmIcon>)\n      : (\n        <ActivityIndicator color={this.styles.loadingIcon.text.color}></ActivityIndicator>\n      );\n  }\n\n  public getNoOfColumns() {\n    const props = this.state.props;\n    if (props.direction === 'vertical') {\n      return props.itemsperrow.xs;\n    }\n    return 0;\n  }\n\n  private onLayoutChange(e: LayoutChangeEvent) {\n    const l = e.nativeEvent.layout;\n    this.endThreshold = l.height + l.y - 100;\n    if (!this.endThreshold) {\n      this.endThreshold = -1;\n    }\n  }\n\n  private scrollToItem = (groupKey: string | null, itemIndex: number) => {\n    const refKey = groupKey || 'main';\n    if (this.flatListRefs[refKey]) {\n      this.flatListRefs[refKey].scrollToIndex({\n        index: itemIndex,\n        animated: true,\n        viewPosition: 0.5,\n      });\n    }\n  };\n\n   getCaption = (isHorizontal: boolean, vData: any[]): string => {\n    const { nodatamessage, ondemandmessage } = this.state.props\n    if(!isHorizontal) {\n      return this.hasMoreData ? ondemandmessage : nodatamessage\n    }\n    return this.hasMoreData ? ondemandmessage : nodatamessage\n  }\n\n  private renderWithFlatList(props: WmListProps, isHorizontal = false) {\n\n    return (\n      <View style={this.styles.root} onLayout={e => this.onLayoutChange(e)}>\n        {!isEmpty(this.state.groupedData) ? this.state.groupedData.map((v: any, i) => ((\n          <View style={this.styles.group} key={v.key || this.keyExtractor.getKey(v, true)}>\n            {this.renderHeader(props, v.key)}\n            <FlatList\n              ref={(ref) => { this.flatListRefs[v.key || 'main'] = ref; }}\n              testID={this.getTestId('flat_list')}\n              key={props.name + '_' + (isHorizontal ? 'H' : 'V') + props.itemsperrow.xs}\n              keyExtractor={(item, i) => this.generateItemKey(item, i, props)}\n              scrollEnabled={isHorizontal}\n              horizontal={isHorizontal}\n              data={this._showSkeleton ? [...getNumberOfEmptyObjects(this.props.numberofskeletonitems as number ?? 3)] : (isEmpty(v.data[0]) ? [] : v.data)}\n              ListEmptyComponent={(itemInfo) => this.renderEmptyMessage(isHorizontal, itemInfo.item, itemInfo.index, props)}\n              renderItem={(itemInfo) => this.renderItem(itemInfo.item, itemInfo.index, props)}\n              {...(isHorizontal ? { showsHorizontalScrollIndicator: !props.hidehorizontalscrollbar } : { numColumns: this.getNoOfColumns() })}>\n            </FlatList>\n            {this.loadDataOnDemand || (v.data.length > this.state.maxRecordsToShow  && props.navigation !== 'None') ?\n            (this.state.loadingData ? this.renderLoadingIcon(props) :\n            (<WmLabel id={this.getTestId('ondemandmessage')}\n            styles={this.styles.onDemandMessage}\n           caption={this.getCaption( isHorizontal, v.data)}\n          onTap={() => this.loadData()}></WmLabel>)): null}\n          </View>\n        ))) : this.renderEmptyMessage(isHorizontal, null, null, props)\n        }\n      </View>);\n  }\n\n  private getSectionListData(props: WmListProps) {\n    if (this._showSkeleton) {\n      return [{\n        key: '',\n        data: [...getNumberOfEmptyObjects(this.props.numberofskeletonitems as number ?? 3)]\n      }];\n    } else if (this.state.groupedData\n      && this.state.groupedData[0]\n      && this.state.groupedData[0]['data'].length) {\n      return this.state.groupedData;\n    }\n    return [];\n  }\n\n  private renderWithSectionList(props: WmListProps, isHorizontal = false) {\n    return (\n      <SectionList\n        keyExtractor={(item, i) => this.generateItemKey(item, i, props)}\n        horizontal={isHorizontal}\n        contentContainerStyle={this.styles.root}\n        sections={this.getSectionListData(props)}\n        renderSectionHeader={({ section: { key, data } }) => {\n          return this.renderHeader(props, key);\n        }}\n        renderSectionFooter={() => props.loadingdata ? this.renderLoadingIcon(props) : null}\n        ListEmptyComponent={(itemInfo) => this.renderEmptyMessage(isHorizontal, itemInfo.item, itemInfo.index, props)}\n        renderItem={(itemInfo) => this.renderItem(itemInfo.item, itemInfo.index, props)}>\n      </SectionList>\n    );\n  }\n\n  renderWidget(props: WmListProps) {\n    this.invokeEventCallback('onBeforedatarender', [this, this.state.props.dataset]);\n    const isHorizontal = (props.direction === 'horizontal');\n\n    return (\n      <View\n        style={isHorizontal ? null : { width: '100%' }}\n        onLayout={(event) => this.handleLayout(event)}\n      >\n        {this._background}\n        {(isHorizontal || !props.groupby) ?\n          this.renderWithFlatList(props, isHorizontal)\n          : this.renderWithSectionList(props, isHorizontal)}\n      </View>\n    );\n  }\n}\n", "wavemaker-rn-runtime/src/components/data/list/list.props.tsx": "import React from 'react';\nimport { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { View } from 'react-native';\n\nexport default class WmListProps extends BaseProps {\n    formRef: any;\n    iconclass: string = null as any;\n    deferload = false;\n    ondemandmessage = 'Load More';\n    title: string = null as any;\n    subheading: string = null as any;\n    dataset = [] as any;\n    maxnumberofitems = 50;\n    children? = null as any;\n    renderItem: any = () => (<View />);\n    loadingicon: string = null as any;\n    loadingdatamsg = 'Loading...';\n    multiselect = false;\n    nodatamessage = 'No data found';\n    loadingdata = false;\n    selectfirstitem = false;\n    selectionlimit = -1;\n    disableitem: Function | boolean = ($item: any, $index: any) => false;\n    itemkey?: ($item: any, $index: any) => any = null as any;\n    direction: 'horizontal' | 'vertical' = 'vertical';\n    groupby: string = null as any;\n    match: string = null as any;\n    orderby: string = null as any;\n    dateformat: string = null as any;\n    selecteditem = null as any;\n    navigation: 'Scroll' | 'On-Demand' | 'None' = 'None';\n    itemclass: ($item: any, $index: any) => string = null as any;\n    getNextPageData: ($event: any, $list: any, page: number) => Promise<any> = null as any;\n    pagesize = 20;\n    itemsperrow = {\n        xs: 1,\n        sm: 1,\n        md: 1,\n        lg: 1,\n    };\n    numberofskeletonitems?: number | string;\n    hidehorizontalscrollbar?: boolean = false;\n    shouldswipe?: boolean = false;\n    horizontalondemandenabled:boolean = false;\n    triggeronrenderwhenhidden?: boolean = true;\n    selecteditemicon: string = null as any;\n}\n", "wavemaker-rn-runtime/src/components/data/list/list-template/list-template.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmSkeletonStyles } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.styles';\n\nexport type WmListTemplateStyles = BaseStyles & {\n    skeleton: WmSkeletonStyles\n};\n\nexport const DEFAULT_CLASS = 'app-list-template';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles: WmListTemplateStyles = defineStyles<WmListTemplateStyles>({\n        root: {\n            backgroundColor: themeVariables.listHeaderBgColor,\n        },\n        text: {},\n        skeleton: {\n            root: {\n                backgroundColor: themeVariables.skeletonBgColor,\n                paddingLeft: 10,\n                paddingRight: 10,\n                paddingTop: 16,\n                paddingBottom: 16,\n                flex: 1\n            }\n        } as any as WmSkeletonStyles\n    });\n\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n    addStyle('list-card-template', '', {\n        root : {\n            borderBottomWidth: 0,\n            // marginLeft: 35,\n        }\n    } as WmListTemplateStyles);\n    addStyle('horizontal-list-template', '', {\n        root : {}\n    } as WmListTemplateStyles);\n    addStyle('vertical-list-template', '', {\n        root : {\n        }\n    } as WmListTemplateStyles);\n});", "wavemaker-rn-runtime/src/components/data/list/list-template/list-template.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { isNil } from 'lodash';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmListTemplateProps from './list-template.props';\nimport { DEFAULT_CLASS, WmListTemplateStyles } from './list-template.styles';\nimport WmList from '../list.component';\nimport { createSkeleton } from '@wavemaker/app-rn-runtime/components/basic/skeleton/skeleton.component';\n\nexport class WmListTemplateState extends BaseComponentState<WmListTemplateProps> {\n\n}\n\nexport default class WmListTemplate extends BaseComponent<WmListTemplateProps, WmListTemplateState, WmListTemplateStyles> {\n\n  constructor(props: WmListTemplateProps) {\n    super(props, DEFAULT_CLASS, new WmListTemplateProps());\n  }\n\n  renderWidget(props: WmListTemplateProps) {\n\n    if(this._showSkeleton && !props.showskeletonchildren) {  \n      return createSkeleton(this.theme, this.styles.skeleton, {\n        ...this.styles.root,\n       }, (<View style={[this.styles.root, {opacity: 0}]}>\n        {props.children}\n      </View>))\n    }\n    \n    const list = (this.parent as WmList);\n    const listProps = list.state.props;\n    const isHorizontalList = listProps.direction === 'horizontal';\n    const noOfCols = list.getNoOfColumns();\n    let style = this.theme.getStyle( isHorizontalList ? 'horizontal-list-template' : 'vertical-list-template');\n    if (isNil(style['flex']) && !isHorizontalList && noOfCols === 1) {\n        style = this.theme.mergeStyle({root: {flex: 1}}, style);\n    }\n    const styles = [this.styles.root, style?.root];\n    if(this._showSkeleton) {\n      styles.push(this.styles.skeleton.root)\n    }\n    return (\n      <View \n        style={styles}\n        onLayout={(event) => this.handleLayout(event)}\n      >{this._background}{props.children}</View>\n    ); \n  }\n}\n", "wavemaker-rn-runtime/src/components/data/list/list-template/list-template.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmListTemplateProps extends BaseProps {\n  children: any;\n  showskeletonchildren = true;\n}", "wavemaker-rn-runtime/src/components/data/list/list-action-template/list-action-template.component.tsx": "import React from 'react';\nimport { View } from 'react-native';\nimport { BaseComponent, BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\n\nimport WmListActionTemplateProps from './list-action-template.props';\nimport { DEFAULT_CLASS, WmListActionTemplateStyles } from './list-action-template.styles';\nimport WmList from '../list.component';\n\nexport class WmListActionTemplateState extends BaseComponentState<WmListActionTemplateProps> { }\n\nexport default class WmListActionTemplate extends BaseComponent<WmListActionTemplateProps, WmListActionTemplateState, WmListActionTemplateStyles> {\n\n  constructor(props: WmListActionTemplateProps) {\n    super(props, DEFAULT_CLASS, new WmListActionTemplateProps(), new WmListActionTemplateState());\n  }\n\n  getTemplate() {\n    return (\n      <View style={this.styles.root}>{this._background}\n        {this.props.children}\n      </View>);\n  }\n\n  componentDidMount(): void {\n      const list = (this.parent) as WmList;\n      if (this.state.props.position === 'left') {\n        list.leftActionTemplate = this;\n      } else if (this.state.props.position === 'right') {\n        list.rightActionTemplate = this;\n      }\n  }\n\n  renderWidget(props: WmListActionTemplateProps) {\n    return null;\n  }\n}\n", "wavemaker-rn-runtime/src/components/data/list/list-action-template/list-action-template.props.ts": "import { BaseProps } from '@wavemaker/app-rn-runtime/core/base.component';\n\nexport default class WmListActionTemplateProps extends BaseProps {\n    position: 'left' | 'right' = null as any;\n    children? = null as any;\n}", "wavemaker-rn-runtime/src/components/data/list/list-action-template/list-action-template.styles.ts": "import BASE_THEME from '@wavemaker/app-rn-runtime/styles/theme';\nimport { BaseStyles, defineStyles } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { WmButtonStyles } from '@wavemaker/app-rn-runtime/components/basic/button/button.styles';\nimport { WmAnchorStyles } from '@wavemaker/app-rn-runtime/components/basic/anchor/anchor.styles';\n\nexport type WmListActionTemplateStyles = BaseStyles & {};\n\nexport const DEFAULT_CLASS = 'app-list-action-template';\nBASE_THEME.registerStyle((themeVariables, addStyle) => {\n    const defaultStyles = defineStyles<WmListActionTemplateStyles>({\n        root: {\n            flexDirection: 'row',\n            marginBottom: 6\n        },\n        text: {}\n    });\n    addStyle(DEFAULT_CLASS, '', defaultStyles);\n    addStyle('list-action-btn', '', {\n        root: {\n          backgroundColor: themeVariables.transparent,\n          borderColor: themeVariables.transparent,\n          borderWidth: 0,\n          borderRadius: 0,\n          width: 'auto',\n          justifyContent: 'center',\n          alignItems: 'center',\n          alignSelf: 'center',\n          height: '100%'\n         },\n        text: {\n          color: themeVariables.defaultColor,\n          fontSize: 14,\n          fontWeight: '600',\n        },\n        icon: {\n          root: {},\n          text: {}\n        }\n      } as any as WmButtonStyles);\n});", "wavemaker-rn-runtime/src/components/data/liveform/liveform.component.tsx": "import { BaseComponentState } from '@wavemaker/app-rn-runtime/core/base.component';\nimport { forEach, isEmpty, some, get } from 'lodash';\n\nimport WmFormProps from '../form/form.props';\nimport WmForm from '@wavemaker/app-rn-runtime/components/data/form/form.component';\n\nexport class WmFormState extends BaseComponentState<WmFormProps> {\n  isValid = false;\n  type: 'success' | 'warning' | 'error' | 'info' | 'loading' | undefined = 'success';\n  message: string = '';\n  showInlineMsg: boolean = false;\n}\nconst Live_Operations = {\n  INSERT : 'insert',\n  UPDATE : 'update',\n  DELETE : 'delete',\n  READ : 'read'\n}\n\nexport default class WmLiveForm extends WmForm {\n\n  findOperationType() {\n    let operation;\n    let isPrimary = false;\n    // const sourceOperation = this.form.datasource && this.form.datasource.execute(DataSource.Operation.GET_OPERATION_TYPE);\n    // if (sourceOperation && sourceOperation !== 'read') {\n    //   return sourceOperation;\n    // }\n    /*If OperationType is not set then based on the formdata object return the operation type,\n        this case occurs only if the form is outside a livegrid*/\n    /*If the formdata object has primary key value then return update else insert*/\n    if (this.primaryKey && !isEmpty(this.state.props.formdata)) {\n      /*If only one column is primary key*/\n      if (this.primaryKey.length === 1) {\n        if (this.state.props.formdata[this.primaryKey[0]]) {\n          operation = Live_Operations.UPDATE;\n        }\n        /*If only no column is primary key*/\n      } else if (this.primaryKey.length === 0) {\n          forEach(this.state.props.formdata, (value) => {\n          if (value) {\n            isPrimary = true;\n          }\n        });\n        if (isPrimary) {\n          operation = Live_Operations.UPDATE;\n        }\n        /*If multiple columns are primary key*/\n      } else {\n        // @ts-ignore\n        isPrimary = some(this.primaryKey, (primaryKey: any) => {\n          if (this.state.props.formdata[primaryKey]) {\n            return true;\n          }\n        });\n        if (isPrimary) {\n          operation = Live_Operations.UPDATE;\n        }\n      }\n    }\n    return operation || Live_Operations.INSERT;\n  }\n\n  // @ts-ignore\n  handleSubmit(event?: any) {\n    event?.preventDefault();\n    const formData = this.state.props.dataoutput || this.formdataoutput;\n    const operationType = this.findOperationType();\n\n    if (!this.validateFieldsOnSubmit()) {\n      return false;\n    }\n    if (this.props.onBeforeservicecall) {\n      this.invokeEventCallback('onBeforeservicecall', [ null, operationType, formData ]);\n    }\n    if (this.props.formSubmit) {\n      this.props.formSubmit({inputFields: formData}, operationType, ((data: any) => {\n        this.onResultCb(data, 'success', operationType);\n      }), ((error: any) => {\n        this.onResultCb(error, '', operationType);\n      }));\n    }\n  }\n\n  onResultCb(response: any, status: string, operationType: string, event?: any) {\n    this.invokeEventCallback('onResult', [ null, operationType, response ]);\n    if (status) {\n      this.invokeEventCallback('onSuccess', [ null, operationType, response ]);\n      this.props.formSuccess && this.props.formSuccess();\n      !this.props.onSuccess && this.state.props.postmessage && this.toggleMessage('success', this.state.props.postmessage);\n    } else {\n      this.invokeEventCallback('onError', [ null, operationType, response ]);\n      !this.props.onError && this.toggleMessage('error', this.state.props.errormessage || get(response, 'message') || response);\n    }\n  }\n\n}\n", "wavemaker-rn-runtime/src/variables/device-variable.ts": "import { BaseVariable, VariableConfig, VariableEvents } from '@wavemaker/app-rn-runtime/variables/base-variable';\nimport OperationProvider, { Input, Output } from './device/operation.provider';\n\nexport interface DeviceVariableConfig extends VariableConfig {\n  service: string;\n  operation: string;\n}\n\nexport class DeviceVariable extends BaseVariable<DeviceVariableConfig> {\n\n  constructor(config: DeviceVariableConfig) {\n    super(config);\n    this.dataSet = this.isList ? [] : {};\n  }\n\n  invoke(params: any, onSuccess?: Function, onError?: Function): Promise<DeviceVariable> {\n    super.invoke(params, onSuccess, onError);\n    const operation = OperationProvider.get(`${this.config.service}.${this.config.operation}`);\n    if (!operation) {\n      return Promise.resolve(this);\n    }\n    this.notify(VariableEvents.BEFORE_INVOKE, [this, this.dataSet]);\n\n    return operation.invoke(this.params as Input, onSuccess, onError, this.config.operation, this)\n      .then((data: Output) => {\n        this.dataSet = data;\n        this.config.onSuccess && this.config.onSuccess(this, this.dataSet);\n        this.notify(VariableEvents.SUCCESS, [this, this.dataSet]);\n      }, (err: Output) => {\n        this.config.onError && this.config.onError(this, null);\n        this.notify(VariableEvents.ERROR, [this, this.dataSet]);\n      }).then(() => {\n        this.notify(VariableEvents.AFTER_INVOKE, [this, this.dataSet]);\n        return this;\n    });\n  }\n}\n", "wavemaker-rn-runtime/src/variables/model-variable.ts": "import { assignIn, clone, isEqual } from 'lodash-es';\nimport { BaseVariable, VariableConfig, VariableEvents } from './base-variable';\nimport { ModelVariable as _ModelVariable } from '@wavemaker/variables/src/model/variable/model-variable';\n\nexport class ModelVariable extends _ModelVariable {\n  config: any;\n  lastParams: any;\n\n  constructor(config: VariableConfig) {\n    const variable = {\n      name: config.name,\n      dataSet: config.paramProvider(),\n      isList: config.isList,\n      twoWayBinding: config.twoWayBinding\n    }\n    super(variable);\n    this.config = config;\n    this.invoke();\n  }\n\n  invoke(params?: any, onSuccess?: Function, onError?: Function) {\n    let result;\n    this.dataSet = this.config.paramProvider();\n    this.notify(VariableEvents.BEFORE_INVOKE, [this, this.dataSet]);\n    try{\n      result = super.execute(params, ()=>{});\n      this.config.onSuccess && this.config.onSuccess(this, this.dataSet);\n      onSuccess && onSuccess(this, this.dataSet);\n      this.notify(VariableEvents.SUCCESS, [this, this.dataSet]);\n    }\n    catch(error){\n      this.config.onError && this.config.onError(this, this.dataSet);\n      onError && onError(this, this.dataSet);\n      this.notify(VariableEvents.ERROR, [this, this.dataSet]);\n    }\n\n    this.notify(VariableEvents.AFTER_INVOKE, [this, this.dataSet]);\n    return result;\n  }\n\n  invokeOnParamChange() {\n    const latest = this.config.paramProvider();\n    if (!isEqual(this.lastParams, latest)) {\n        this.invoke();\n        this.lastParams = clone(latest);\n    }\n    return Promise.resolve(this);\n  }\n}\n", "wavemaker-rn-runtime/src/variables/http.service.ts": "import axios from 'axios';\nimport { HttpClientService } from '@wavemaker/variables/src/types/http-client.service';\nimport { WS_CONSTANTS } from '@wavemaker/app-rn-runtime/variables/utils/variable.constants';\nimport { get, isEmpty } from 'lodash';\nimport AppConfig from '@wavemaker/app-rn-runtime/core/AppConfig';\nimport { isWebPreviewMode } from '@wavemaker/app-rn-runtime/core/utils';\nimport injector from '@wavemaker/app-rn-runtime/core/injector';\n\nexport class HttpService implements HttpClientService {\n\n  send(options: any, variable: any) {\n    const serviceInfo = variable.serviceInfo;\n    let headers: any = options.headers,\n      requestBody: any = options.data,\n      url: string = options.url;\n      variable.cancelTokenSource = axios.CancelToken.source();\n    if (!isWebPreviewMode() && (variable?.serviceInfo?.consumes||[])[0] === 'multipart/form-data') {\n      headers['Content-Type'] = 'multipart/form-data';\n      let formData = new FormData();\n      (variable.serviceInfo.parameters||[]).forEach((p: any) => {\n        const v = variable.params[p.name];\n        if (v) {\n          formData.append(p.name, variable.params[p.name]);\n        }\n      });\n      requestBody = formData;\n    }\n    if (!isWebPreviewMode()\n      && variable.category === 'wm.LiveVariable'\n      && !(url.startsWith('http://') || url.startsWith(\"https://\"))) {\n      options.url = options.url.replace('./', '/');\n      url = variable.config.baseUrl + options.url;\n    }\n\n    if (!isWebPreviewMode() \n      && variable.serviceType === \"JavaService\"\n      && !(url.startsWith('http://') || url.startsWith(\"https://\"))) {\n        options.url = options.url.replace('./', '');\n        url = options.url;\n    }\n\n    const methodType: string = serviceInfo?.methodType || options.method.toLowerCase();\n    const isNonDataMethod: boolean = WS_CONSTANTS.NON_DATA_AXIOS_METHODS.indexOf(methodType.toUpperCase()) > -1;\n    const axiosConfig = {\n      headers: headers,\n      cancelToken: variable.cancelTokenSource.token,\n      withCredentials: !isWebPreviewMode() || options?.withCredentials !== false,\n      __wmVariable: {\n        name: variable.name,\n        owner: variable.config._context.name\n      }\n    };\n    return new Promise((resolve, reject) => {\n      // @ts-ignore\n      axios[methodType].apply(variable, ( isNonDataMethod ? [url, axiosConfig] : [url, requestBody || {}, axiosConfig]))\n        .then((result: any) => {\n         resolve(result);\n        }, (err: any) => {\n          reject(err.response);\n        })\n    })\n  }\n\n  sendCall(requestParams: any, variable: any) {\n    return new Promise((resolve, reject) => {\n      this.send(requestParams, variable).then((response: any) => {\n          resolve(response);\n      }, (err: any) => {\n        reject(err);\n      });\n    });\n  }\n\n  getLocale() {\n    const appConfig = injector.get<AppConfig>('APP_CONFIG');\n    return appConfig.appLocale.messages;\n  }\n\n  cancel(variable: any) {\n    variable.cancelTokenSource.cancel();\n  }\n\n  uploadFile(url: any, data: any, variable: any, options?: any) {\n    const requestParams = {\n      url: url,\n      data: data\n    }\n    return new Promise((resolve, reject) => {\n      return this.send(requestParams, variable).then((event: any) => {\n        resolve(event.data);\n      }, (error: any) => {\n        reject(error);\n      });\n    });\n  }\n}\n\nconst httpService = new HttpService();\n\nexport default httpService;\n", "wavemaker-rn-runtime/src/variables/service-variable.ts": "import { VariableConfig, VariableEvents } from './base-variable';\nimport { isEqual, assignIn, isString } from 'lodash';\nimport AppConfig from '@wavemaker/app-rn-runtime/core/AppConfig';\nimport { deepCopy } from '@wavemaker/app-rn-runtime/core/utils';\nimport { ServiceVariable as _ServiceVariable } from '@wavemaker/variables/src/model/variable/service-variable';\nimport httpService from '@wavemaker/app-rn-runtime/variables/http.service';\nimport injector from '@wavemaker/app-rn-runtime/core/injector';\n\nexport interface ServiceVariableConfig extends VariableConfig {\n  baseUrl: string;\n  maxResults: number;\n  _context: any;\n  serviceType: string;\n  onCanUpdate: any;\n  onBeforeUpdate: any;\n  onResult: any;\n  onBeforeDatasetReady: any;\n  inFlightBehavior: string;\n  controller: string;\n  getServiceInfo: Function;\n}\n\nenum _ServiceVariableEvents {\n  BEFORE_INVOKE = 'beforeInvoke'\n}\nexport type ServiceVariableEvents = _ServiceVariableEvents | VariableEvents;\n\nexport class ServiceVariable extends _ServiceVariable {\n  private cancelTokenSource: any;\n  params: any = {};\n  public appConfig = injector.get<AppConfig>('APP_CONFIG');\n\n  constructor(public config: ServiceVariableConfig) {\n    let variableConfig: any = {\n      name: config.name,\n      dataSet: config.paramProvider(),\n      dataBinding: {},\n      isList: config.isList,\n      service: config.service,\n      serviceType: config.serviceType,\n      maxResults: config.maxResults,\n      _context: config._context,\n      operation: config.operation,\n      operationId: config.operationId,\n      operationType: config.operationType,\n      controller: config.controller,\n      serviceInfo: config.getServiceInfo(),\n      httpClientService: httpService,\n      inFlightBehavior: config.inFlightBehavior,\n      onSuccess: (context: any, args: any) => {\n        this.notify(VariableEvents.AFTER_INVOKE, [args.variable, args.data, args.options]);\n        this.notify(VariableEvents.SUCCESS, [args.variable, args.data, args.options]);\n        return config.onSuccess && config.onSuccess(args.variable, args.data, args.options);\n      },\n      onError: (context: any, args: any) => {\n        this.notify(VariableEvents.AFTER_INVOKE, [args.variable, args.data, args.options]);\n        this.notify(VariableEvents.ERROR, [args.variable, args.data, args.options]);\n        return config.onError && config.onError(args.variable, args.data, args.options);\n      },\n      onCanUpdate: (context: any, args: any) => {\n        return config.onCanUpdate && config.onCanUpdate(args.variable, args.data, args.options);\n      },\n      onBeforeUpdate: (context: any, args: any) => {\n        this.notify(VariableEvents.BEFORE_INVOKE, [args.variable, args.inputData, args.options]);\n        return config.onBeforeUpdate && config.onBeforeUpdate(args.variable, args.inputData, args.options);\n      },\n      onResult: (context: any, args: any) => {\n        return config.onResult && config.onResult(args.variable, args.data, args.options);\n      },\n      onBeforeDatasetReady: (context: any, args: any) => {\n        return config.onBeforeDatasetReady && config.onBeforeDatasetReady(args.variable, args.data, args.options);\n      }\n    }\n    if (config.onError) {\n      variableConfig.onError = (context: any, args: any) => {\n        return config.onError && config.onError(args.variable, args.data, args.options);\n      };\n    }\n    super(variableConfig);\n    this.subscribe(VariableEvents.AFTER_INVOKE, () => {\n        this.dataBinding = {};\n    });\n    this.init();\n  }\n\n  invokeOnParamChange() {\n    const last = this.params;\n    const latest = this.config.paramProvider();\n    if (!isEqual(last, latest)) {\n      this.invoke(latest);\n    }\n    return Promise.resolve(this);\n  }\n\n  public async doNext() {\n    let page = 0 as any;\n    if (isString(this.pagination.page)) {\n      page = (parseInt(this.pagination.page) + 1) + '';\n    } else {\n      page = this.pagination.page + 1;\n    }\n    return new Promise((resolve, reject) => {\n      this.invoke({\n        page: page\n      },\n      (dataset: any) => resolve(dataset),\n      reject);\n    });\n  }\n\n  onDataUpdated() {\n    this.appConfig.refresh(false);\n  }\n\n  invoke(options? : any, onSuccess?: Function, onError?: Function) {\n    this.params = this.config.paramProvider();\n    this.params = deepCopy({} as any, this.params, this.dataBinding);\n    if (options) {\n      this.params = deepCopy({} as any, this.params, options.inputFields ? options.inputFields : options);\n    }\n    options = options || {};\n    options.inputFields = this.params;\n      // service definitions data depends on whether user logged in or not\n    // Try to get the latest definition\n    this.serviceInfo = this.config.getServiceInfo();\n    if (!this.serviceInfo) {\n      console.error(`Service Info is missing for (${this.name}) variable.`)\n    }\n    return super.invoke(options, onSuccess, onError);\n  }\n\n  // cancel($file?: any) {\n  //   // CHecks if there is any pending requests in the queue\n  //   if ($queue.requestsQueue.has(this)) {\n  //     // If the request is a File upload request then modify the elements associated with file upload\n  //     // else unsubscribe from the observable on the variable.\n  //     if (false) {\n  //       // $file._uploadProgress.unsubscribe();\n  //       // $file.status = 'abort';\n  //       // this.totalFilesCount--;\n  //       // initiateCallback(VARIABLE_CONSTANTS.EVENT.ABORT, variable, $file);\n  //       // if (!this.isFileUploadInProgress(variable.dataBinding) && this.totalFilesCount === 0) {\n  //       //   $queue.process(variable);\n  //       //   // notify inflight variable\n  //       //   this.notifyInflight(variable, false);\n  //       // }\n  //     } else {\n  //       if (true) {\n  //         this.cancelTokenSource.cancel();\n  //         $queue.process(this);\n  //         // notify inflight variable\n  //         //this.notifyInflight(variable, false);\n  //       }\n  //     }\n  //   }\n  // }\n\n  // setInput(key: any, val?: any, options?: any) {\n  //   this.params = merge({}, this.config.paramProvider(), _setInput(this.params, key, val, options));\n  //    return this.params;\n  // }\n}\n", "wavemaker-rn-runtime/src/variables/base-variable.ts": "import DatasetUtil from './utils/dataset-util';\nimport EventNotifier from '@wavemaker/app-rn-runtime/core/event-notifier';\nimport { ROOT_LOGGER } from '@wavemaker/app-rn-runtime/core/logger';\nimport { isNumber, isObject, isBoolean, get, isEqual } from 'lodash';\nexport interface VariableConfig {\n    name: string;\n    paramProvider: Function;\n    onBefore: Function;\n    onComplete: Function;\n    onSuccess: Function;\n    onError: Function;\n    isList: boolean;\n    twoWayBinding: boolean;\n    service: any;\n    operation: string;\n    operationId: string;\n    operationType: string;\n    serviceType: string;\n}\n\nexport enum VariableEvents {\n  BEFORE_INVOKE = 'beforeInvoke',\n  SUCCESS = 'success',\n  ERROR = 'error',\n  AFTER_INVOKE = 'afterInvoke'\n};\n\nexport const VARIABLE_LOGGER = ROOT_LOGGER.extend('variable');\n\nexport abstract class BaseVariable<T extends VariableConfig> extends EventNotifier {\n    name: string = '';\n    params: any = {};\n    dataSet: any = {};\n    isList: boolean;\n    twoWayBinding: boolean;\n    isExecuting = false;\n\n    constructor(public config: T) {\n      super();\n      this.name = config.name;\n      this.isList = config.isList;\n      this.twoWayBinding = config.twoWayBinding;\n      this.dataSet = this.isList ? []: this.dataSet;\n      this.subscribe(VariableEvents.BEFORE_INVOKE, () => {\n        this.isExecuting = true;\n        VARIABLE_LOGGER.info(`Before Invoking variable ${this.name}`);\n      });\n      this.subscribe(VariableEvents.AFTER_INVOKE, () => {\n        this.isExecuting = false;\n        VARIABLE_LOGGER.info(`After Invoking variable ${this.name}`);\n      });\n    }\n\n    public invoke(params?: {}, onSuccess?: Function, onError?: Function): Promise<BaseVariable<T>> {\n        if (!params) {\n            this.params = this.config.paramProvider();\n        } else {\n            this.params = params;\n        }\n        return Promise.resolve(this);\n    }\n\n    public doNext(): Promise<BaseVariable<T>> {\n      return Promise.reject(this);\n    }\n\n    public invokeOnParamChange(): Promise<BaseVariable<T>> {\n        const last = this.params;\n        const latest = this.config.paramProvider();\n        if (!isEqual(last, latest)) {\n            return this.invoke(latest);\n        }\n        return Promise.resolve(this);\n    }\n\n    public getData() {\n        return this.dataSet;\n    }\n\n    public setData(dataSet: any) {\n      if (DatasetUtil.isValidDataset(dataSet, this.isList)) {\n        this.dataSet = dataSet;\n      }\n      return this.dataSet;\n    }\n\n    getValue(key: string, index: number) {\n      return DatasetUtil.getValue(this.dataSet, key, index, this.isList);\n    }\n\n    setValue(key: string, value: any) {\n      return DatasetUtil.setValue(this.dataSet, key, value, this.isList);\n    }\n\n    getItem(index: number) {\n      return DatasetUtil.getItem(this.dataSet, index, this.isList);\n    }\n\n    setItem(index: any, value: any, options?: any) {\n      options = DatasetUtil.getChildDetails(this.dataSet, options, this.isList);\n      return DatasetUtil.setItem(this.dataSet, index, value, options);\n    }\n\n    addItem(value: any, options?: any) {\n      let index;\n      if (isNumber(options)) {\n        index = options;\n      }\n      if (isObject(options)) {\n        // @ts-ignore\n        index = options.index;\n      }\n\n      options = DatasetUtil.getChildDetails(this.dataSet, options, this.isList);\n      return DatasetUtil.addItem(this.dataSet, value, index, options);\n    }\n\n    removeItem(index: any, options?: any) {\n      let exactMatch, parentIndex;\n      if (options) {\n        if (isBoolean(options)) {\n          exactMatch = options;\n        }\n        if (isObject(options)) {\n          // @ts-ignore\n          exactMatch = options.exactMatch;\n          if (this.isList) {\n            // @ts-ignore\n            parentIndex = options.parentIndex || 0;\n          }\n        }\n      }\n      return DatasetUtil.removeItem(this.dataSet, index, { exactMatch, path: get(options, 'path'), parentIndex });\n    }\n\n    clearData() {\n      this.dataSet = DatasetUtil.getValidDataset(this.isList);\n      return this.dataSet;\n    }\n\n    getCount() {\n      return DatasetUtil.getCount(this.dataSet, this.isList);\n    }\n\n    pause() {}\n\n    resume() {}\n\n    destroy() {}\n\n}\n", "wavemaker-rn-runtime/src/variables/live-variable.ts": "import { VariableConfig, VariableEvents } from './base-variable';\nimport { isEqual, isUndefined, isFunction, forEach, isEmpty } from 'lodash';\nimport AppConfig from '@wavemaker/app-rn-runtime/core/AppConfig';\nimport { LiveVariable as _LiveVariable } from '@wavemaker/variables/src/model/variable/live-variable';\nimport httpService from '@wavemaker/app-rn-runtime/variables/http.service';\nimport injector from '@wavemaker/app-rn-runtime/core/injector';\nimport { deepCopy } from '@wavemaker/app-rn-runtime/core/utils';\nimport Formatters from '@wavemaker/app-rn-runtime/core/formatters';\n\nexport interface LiveVariableConfig extends VariableConfig {\n  baseUrl: string;\n  maxResults: number;\n  _context: any;\n  onCanUpdate: any;\n  onBeforeUpdate: any;\n  onResult: any;\n  onBeforeDatasetReady: any;\n  inFlightBehavior: string;\n  type: string;\n  autoUpdate: boolean;\n  orderBy: string;\n  category: string;\n  liveSource: string;\n  propertiesMap: any;\n  properties: any;\n  tableName: string;\n  tableType: string;\n  relatedTables: any;\n  filterExpressions: any;\n  filterProvider: any;\n}\n\nenum _LiveVariableEvents {\n  BEFORE_INVOKE = 'beforeInvoke'\n}\nexport type LiveVariableEvents = _LiveVariableEvents | VariableEvents;\n\nexport class LiveVariable extends _LiveVariable {\n  params: any = {};\n  filters: any = {};\n  public appConfig = injector.get<AppConfig>('APP_CONFIG');\n\n  constructor(public config: LiveVariableConfig) {\n    const variableConfig: any = {\n      name: config.name,\n      dataSet: config.paramProvider(),\n      inputFields: config.paramProvider(),\n      filterExpressions: config.filterExpressions,\n      filterFields: config.paramProvider(),\n      isList: config.isList,\n      maxResults: config.maxResults,\n      _context: config._context,\n      operation: config.operation,\n      type: config.type,\n      autoUpdate: config.autoUpdate,\n      liveSource: config.liveSource,\n      orderBy: config.orderBy,\n      category: config.category,\n      properties: config.properties,\n      propertiesMap: config.propertiesMap,\n      tableName: config.tableName,\n      tableType: config.tableType,\n      relatedTables: config.relatedTables,\n      httpClientService: httpService,\n      inFlightBehavior: config.inFlightBehavior,\n      onSuccess: (context: any, args: any) => {\n        return config.onSuccess && config.onSuccess(args.variable, args.data, args.options);\n      },\n      onCanUpdate: (context: any, args: any) => {\n        return config.onCanUpdate && config.onCanUpdate(args.variable, args.data, args.options);\n      },\n      onBeforeUpdate: (context: any, args: any) => {\n        return config.onBeforeUpdate && config.onBeforeUpdate(args.variable, args.dataFilter || args.inputData, args.options);\n      },\n      onResult: (context: any, args: any) => {\n        return config.onResult && config.onResult(args.variable, args.data, args.options);\n      },\n      onBeforeDatasetReady: (context: any, args: any) => {\n        return config.onBeforeDatasetReady && config.onBeforeDatasetReady(args.variable, args.data, args.options);\n      }\n    }\n    if (config.onError) {\n      variableConfig.onError = (context: any, args: any) => {\n        return config.onError && config.onError(args.variable, args.data, args.options);\n      };\n    }\n    super(variableConfig);\n    this.dateFormatter = Formatters.get('toDate');\n    this.init();\n  }\n\n  setFilterExpValue(filter: any) {\n    this.filterExpressions?.rules.forEach((r: any) => {\n      r.value = filter[r.target];\n    });\n  }\n\n  invokeOnParamChange() {\n    const last = this.params;\n    const latest = this.config.paramProvider();\n    if (this.config.operation === 'read') {\n      const lastFilter = this.filters;\n      const latestFilter = this.config.filterProvider && this.config.filterProvider();\n      if (!isEqual(lastFilter, latestFilter)) {\n        this.setFilterExpValue(latestFilter);\n        if (this.autoUpdate && !isEmpty(latestFilter) && isFunction(this.update)) {\n          this.filters = latestFilter;\n          this.invoke();\n        }\n      }\n    }\n    if (!isEqual(last, latest)) {\n      if (this.config.operation === 'read') {\n        forEach(latest, (val: any, key: any) => {\n          this.filterFields[key] = {\n            'value': val\n          };\n        });\n      } else {\n        this.inputFields = latest;\n      }\n      /* if auto-update set for the variable with read operation only, get its data */\n      // @ts-ignore\n      if (this.autoUpdate && !isUndefined(latest) && isFunction(this[this.config.operation + 'Record'])) {\n        this.invoke();\n      }\n    }\n    return Promise.resolve(this);\n  }\n\n  listRecords(options? : any, onSuccess?: Function, onError?: Function) {\n    this.notify(VariableEvents.BEFORE_INVOKE, [this]);\n    this.filters = this.config.filterProvider && this.config.filterProvider();\n    if (options) {\n      this.filters = deepCopy({} as any, this.filters, options.filterFields ? options.filterFields : options);\n    }\n    options = options || {};\n    options.filterFields = this.filters;\n    this.setFilterExpValue(this.filters);\n    return super.listRecords(options, onSuccess, onError);\n  }\n\n\n  updateRecord(options?: any, success?: any, error?: any) {\n    this.notify(VariableEvents.BEFORE_INVOKE, [this]);\n    return super.updateRecord(options, success, error);\n  }\n\n  insertRecord(options?: any, success?: any, error?: any) {\n    this.notify(VariableEvents.BEFORE_INVOKE, [this]);\n    return super.insertRecord(options, success, error);\n  }\n\n  deleteRecord(options?: any, success?: any, error?: any) {\n    this.notify(VariableEvents.BEFORE_INVOKE, [this]);\n    return super.deleteRecord(options, success, error);\n  }\n\n}\n", "wavemaker-rn-runtime/src/variables/utils/dataset-util.ts": "import { isUndefined, isBoolean, isEqual, isObject, isArray, get, set, findIndex } from \"lodash\";\nexport default class DatasetUtil {\n\n  static isValidDataset(dataSet: any, isList?: boolean) {\n    if (!dataSet || (isList && !isArray(dataSet))) {\n      return false;\n    }\n    return dataSet;\n  }\n\n  static getValue(dataSet: any, key: any, index: any, isList?: boolean) {\n    index = index || 0;\n    return isList ? dataSet[index][key] : dataSet[key];\n  }\n\n  static setValue(dataSet: any, key: any, value: any, isList?: boolean) {\n    if (key && !isList) {\n      dataSet[key] = value;\n    }\n    return dataSet;\n  }\n\n  private static getTargetNode(dataSet: any, options: any) {\n    dataSet = options.parentIndex !== undefined ?  dataSet[options.parentIndex] : dataSet;\n    return get(dataSet, options.path);\n  }\n\n  static getItem(dataSet: any, index: any, isList?: boolean) {\n    return isList ? dataSet[index] : dataSet;\n  }\n\n  static setItem(dataSet: any, i: any, value: any, options?: any) {\n    let index;\n    if (isUndefined(i) || !options.isList) {\n      return dataSet;\n    }\n\n    if (isObject(i)) {\n      index = findIndex(dataSet, i);\n    } else {\n      index = i;\n    }\n\n    if (options.path) {\n      const innerArray = DatasetUtil.getTargetNode(dataSet, options);\n      const innerElemindex = findIndex(innerArray, i);\n      if (innerElemindex > -1) {\n        innerArray[innerElemindex] = value;\n      }\n    } else {\n      if (index > -1) {\n        dataSet[index] = value;\n      }\n    }\n\n    return dataSet;\n  }\n\n  /**\n   * This method is to get target node options like path, parentIndex and isList\n   * Example: if we have parent dataset as object and we are performing operations on inner list then we have to set isList as true.\n   * So finding the target node type and updating the isList option.\n   */\n  static getChildDetails (dataSet: any, options: any, isList: boolean) {\n    let parentIndex, path;\n    if (options && options.path) {\n      path = options.path;\n      let targetNode;\n      if (isList) {\n        parentIndex = options.parentIndex || 0;\n        targetNode =  get(dataSet[parentIndex], options.path);\n      } else {\n        targetNode = get(dataSet, options.path);\n      }\n      isList = targetNode ? isArray(targetNode) ? true : false : true;\n    }\n    return {path, isList, parentIndex};\n  }\n\n  static addItem(dataSet: any, value: any, index: any, options?: any) {\n    if (isUndefined(value) || !options.isList) {\n      return dataSet;\n    }\n\n    if (options.path) {\n      const innerArray = DatasetUtil.getTargetNode(dataSet, options);\n      if (innerArray) {\n        // check for index sanity\n        index = index !== undefined ? index : innerArray.length;\n        innerArray.splice(index, 0, value);\n      } else {\n        options.parentIndex !== undefined ? set(dataSet[options.parentIndex], options.path, [value]) : set(dataSet, options.path, [value]);\n      }\n\n    } else {\n      index = index !== undefined ? index : dataSet.length;\n      dataSet.splice(index, 0, value);\n    }\n\n    return dataSet;\n  }\n\n  /**\n   *\n   * @param dataSet\n   * @param i, can be index value of the object/element in array\n   *      or\n   * the whole object which needs to be removed\n   * @param exactMatch\n   * @returns {any}\n   */\n  static removeItem(dataSet: any, i: any, options: any) {\n    let index, exactMatch;\n    i = i !== undefined ? i : dataSet.length - 1;\n\n    if (isBoolean(options)) {\n      exactMatch = options;\n    }\n    if (isObject(options)) {\n      // @ts-ignore\n      exactMatch = options.exactMatch;\n    }\n\n    if (isObject(i)) {\n      if (options.path) {\n        const innerArray = DatasetUtil.getTargetNode(dataSet, options);\n        const innerElemindex = findIndex(innerArray, i);\n        if (innerElemindex > -1 && (!exactMatch || (exactMatch && isEqual(innerArray[innerElemindex], i)))) {\n          innerArray.splice(innerElemindex, 1);\n        }\n      } else {\n        index = findIndex(dataSet, i);\n        // When exactMatch property is set to true delete only when every property values are same*/\n        if (index > -1 && (!exactMatch || (exactMatch && isEqual(dataSet[index], i)))) {\n          dataSet.splice(index, 1);\n        }\n      }\n    } else {\n      dataSet.splice(i, 1);\n    }\n    return dataSet;\n  }\n\n  static getValidDataset(isList?: boolean) {\n    return isList ? [] : {};\n  }\n\n  static getCount(dataSet: any, isList?: boolean) {\n    return isList ? dataSet.length : Object.keys(dataSet).length;\n  }\n}\n", "wavemaker-rn-runtime/src/variables/utils/inflight-queue.ts": "class InflightQueue {\n  requestsQueue = new Map();\n\n  /**\n   * pushes the process against a variable in its queue\n   * @param variable\n   * @param {{resolve: (value?: any) => void; reject: (reason?: any) => void}} param2\n   * the resolve callback will be called on\n   */\n  private addToQueue(variable: any, param2: {resolve: (value?: (any)) => void; reject: (reason?: any) => void}) {\n    if (this.requestsQueue.has(variable)) {\n      this.requestsQueue.get(variable).push(param2);\n    } else {\n      const processes = [];\n      processes.push({resolve: param2.resolve, reject: param2.reject, active: false});\n      this.requestsQueue.set(variable, processes);\n    }\n  }\n\n  /**\n   * Calls the reject method against the passed process\n   * @param process\n   */\n  private rejectProcess(process: any) {\n    process.reject('PROCESS_REJECTED_IN_QUEUE');\n  }\n\n  /**\n   * clears the queue against a variable\n   * @param variable\n   */\n  public clear(variable: any) {\n    this.requestsQueue.delete(variable);\n  }\n\n  /**\n   * executes the n/w calls for a specified variable pushed in its respective queue (pushed while it was inFlight)\n   * @param variable\n   */\n  process(variable: any) {\n    const processes: [any] = this.requestsQueue.get(variable);\n    let nextProcess;\n\n    // process request queue for the variable only if it is not empty\n    if (!processes || !processes.length) {\n      this.clear(variable);\n      return;\n    }\n\n    // If only one item in queue\n    if (processes.length === 1) {\n      nextProcess = processes[0];\n      if (nextProcess.active) {\n        this.clear(variable);\n      } else {\n        nextProcess.active = true;\n        nextProcess.resolve();\n      }\n      return;\n    }\n\n    switch (variable.config.inFlightBehavior) {\n      case 'executeLast':\n        for (let i = 0; i < processes.length - 2; i++) {\n          this.rejectProcess(processes[i]);\n        }\n        processes.splice(0, processes.length - 1);\n        this.process(variable);\n        break;\n      case 'executeAll':\n        nextProcess = processes.splice(0, 1)[0];\n        if (nextProcess.active) {\n          nextProcess = processes.splice(0, 1)[0];\n        }\n        nextProcess.active = true;\n        nextProcess.resolve();\n        break;\n      default:\n        for (let i = 0; i < processes.length - 1; i++) {\n          this.rejectProcess(processes[i]);\n        }\n        this.clear(variable);\n        break;\n    }\n  }\n\n  /**\n   * initializes the queue against a variable and makes the first process call\n   * If already initialized and a process in queue is in progress, the queue is not processed.\n   * To process the next item in the queue, the process method has to be called from the caller.\n   * @param variable\n   * @returns {Promise<any>}\n   */\n  submit(variable: any) {\n    return new Promise((resolve, reject) => {\n      this.addToQueue(variable, {resolve: resolve, reject: reject});\n\n      if (this.requestsQueue.get(variable).length === 1) {\n        this.process(variable);\n      }\n    });\n  }\n}\n\nexport const $queue = new InflightQueue();\n", "wavemaker-rn-runtime/src/variables/utils/variable.constants.ts": "export const WS_CONSTANTS = {\n  NON_BODY_HTTP_METHODS: ['GET', 'HEAD'],\n  NON_DATA_AXIOS_METHODS: ['GET', 'DELETE', 'HEAD', 'OPTIONS'],\n  CONTENT_TYPES: {\n    FORM_URL_ENCODED: 'application/x-www-form-urlencoded',\n    MULTIPART_FORMDATA: 'multipart/form-data',\n    OCTET_STREAM: 'application/octet-stream'\n  },\n  REST_SERVICE: {\n    ERR_TYPE: {\n      METADATA_MISSING: 'metadata_missing',\n      CRUD_OPERATION_MISSING: 'crud_operation_missing',\n      USER_UNAUTHORISED: 'user_unauthorised',\n    },\n    ERR_MSG: {\n      METADATA_MISSING: 'Metadata missing for \"$variable\"',\n      USER_UNAUTHORISED: 'Unauthorized User',\n      CRUD_OPERATION_MISSING: 'Operation \"$operation\" not allowed for \"$variable\"',\n    }\n  }\n};\n", "wavemaker-rn-runtime/src/variables/utils/variable.utils.ts": "import { forEach, get, isNumber, isObject, isEqual, omit, keys } from \"lodash\";\n/**\n * sets the value against passed key on the \"inputFields\" object in the variable\n * @param targetObj: the object in which the key, value is to be set\n * @param variable\n * @param key: can be:\n *  - a string e.g. \"username\"\n *  - an object, e.g. {\"username\": \"john\", \"ssn\": \"11111\"}\n * @param val\n * - if key is string, the value against it (for that data type)\n * - if key is object, not required\n * @param options\n * @returns {any}\n */\n\nexport const _setInput = (targetObj: any, key: any, val: any, options?: any) => {\n  targetObj = targetObj || {};\n  let keys,\n    lastKey,\n    paramObj: any = {};\n\n  // content type check\n  if (isObject(options)) {\n    // @ts-ignore\n    switch (options.type) {\n      case 'file':\n        //val = getBlob(val, options.contentType);\n        break;\n      case 'number':\n        val = isNumber(val) ? val : parseInt(val, 10);\n        break;\n    }\n  }\n\n  if (isObject(key)) {\n    // check if the passed parameter is an object itself\n    paramObj = key;\n  } else if (key.indexOf('.') > -1) {\n    // check for '.' in key e.g. 'employee.department'\n    keys = key.split('.');\n    lastKey = keys.pop();\n    // Finding the object based on the key\n    targetObj = findValueOf(targetObj, keys.join('.'), true);\n    key = lastKey;\n    paramObj[key] = val;\n  } else {\n    paramObj[key] = val;\n  }\n\n  forEach(paramObj, function (paramVal, paramKey) {\n    targetObj[paramKey] = paramVal;\n  });\n  return targetObj;\n}\n\n/*\n * Util method to find the value of a key in the object\n * if key not found and create is true, an object is created against that node\n * Examples:\n * var a = {\n *  b: {\n *      c : {\n *          d: 'test'\n *      }\n *  }\n * }\n * Utils.findValue(a, 'b.c.d') --> 'test'\n * Utils.findValue(a, 'b.c') --> {d: 'test'}\n * Utils.findValue(a, 'e') --> undefined\n * Utils.findValue(a, 'e', true) --> {} and a will become:\n * {\n *   b: {\n *      c : {\n *          d: 'test'\n *      }\n *  },\n *  e: {\n *  }\n * }\n */\nexport const findValueOf = (obj: any, key: any, create?: any) => {\n\n  if (!obj || !key) {\n    return;\n  }\n\n  if (!create) {\n    return get(obj, key);\n  }\n\n  const parts = key.split('.'),\n    keys: any = [];\n\n  let skipProcessing;\n\n  // @ts-ignore\n  parts.forEach((part: any) => {\n    if (!parts.length) { // if the part of a key is not valid, skip the processing.\n      skipProcessing = true;\n      return false;\n    }\n\n    const subParts = part.match(/\\w+/g);\n    let subPart;\n\n    while (subParts.length) {\n      subPart = subParts.shift();\n      keys.push({ 'key': subPart, 'value': subParts.length ? [] : {} }); // determine whether to create an array or an object\n    }\n  });\n\n  if (skipProcessing) {\n    return undefined;\n  }\n\n  keys.forEach((_key: any) => {\n    let tempObj = obj[_key.key];\n    if (!isObject(tempObj)) {\n      tempObj = getValidJSON(tempObj);\n      if (!tempObj) {\n        tempObj = _key.value;\n      }\n    }\n    obj[_key.key] = tempObj;\n    obj = tempObj;\n  });\n\n  return obj;\n};\n\nexport const getValidJSON = (content: any) => {\n  if (!content) {\n    return undefined;\n  }\n  try {\n    const parsedIntValue = parseInt(content, 10);\n    /*obtaining json from editor content string*/\n    return isObject(content) || !isNaN(parsedIntValue) ? content : JSON.parse(content);\n  } catch (e) {\n    /*terminating execution if new variable object is not valid json.*/\n    return undefined;\n  }\n}\n\nexport const parseErrors = (errors: any) => {\n  let errMsg = '';\n  if (errors && errors.error && errors.error.length) {\n      errors.error.forEach((errorDetails: any, i: number) => {\n          errMsg += parseError(errorDetails) + (i > 0 ? '\\n' : '');\n      });\n  }\n  return errMsg;\n}\n\nexport const parseError = (errorObj: any) => {\n  let errMsg;\n  errMsg = errorObj.message ? replace(errorObj.message, errorObj.parameters, true) : ((errorObj.parameters && errorObj.parameters[0]) || '');\n  return errMsg;\n}\n\n/*\n * Util method to replace patterns in string with object keys or array values\n * Examples:\n * Utils.replace('Hello, ${first} ${last} !', {first: 'wavemaker', last: 'ng'}) --> Hello, wavemaker ng\n * Utils.replace('Hello, ${0} ${1} !', ['wavemaker','ng']) --> Hello, wavemaker ng\n * Examples if parseError is true:\n * Utils.replace('Hello, {0} {1} !', ['wavemaker','ng']) --> Hello, wavemaker ng\n */\nexport const replace = (template: any, map: any, parseError?: boolean) => {\n  let regEx = /\\$\\{([^\\}]+)\\}/g;\n  if (!template) {\n      return;\n  }\n  if (parseError) {\n      regEx = /\\{([^\\}]+)\\}/g;\n  }\n\n  return template.replace(regEx, function (match: any, key: any) {\n      return get(map, key);\n  });\n};\n\n/*Function to check whether the specified object is a pageable object or not.*/\nexport const isPageable = (obj: any): boolean => {\n  const pageable = {\n    content: [],\n    first: true,\n    last: true,\n    number: 0,\n    numberOfElements: 10,\n    size: 20,\n    sort: null,\n    totalElements: 10,\n    totalPages: 1\n  };\n  // paginated object may or may not contain 'empty' property. In either case, Pageable should return as true.\n  const paginatedObj = omit(obj, 'empty');\n  return isEqual(keys(pageable), keys(paginatedObj).sort());\n};\n", "wavemaker-rn-runtime/src/variables/device/operation.provider.ts": "import { DeviceVariable } from \"../device-variable\";\n\nexport interface Operation {\n  invoke(params?: Input, onSuccess?: Function, onError?: Function, operation?: string, variable?: DeviceVariable): Promise<Output>;\n}\n\nexport interface Input {\n}\n\nexport interface Output {\n}\n\nconst registry = new Map<string, Operation>();\n\nexport class OperationProvider {\n\n  public set(name: string, operation: Operation) {\n    return registry.set(name, operation);\n  }\n\n  public get(name: string) {\n    return registry.get(name);\n  }\n}\n\nexport default new OperationProvider();", "wavemaker-rn-runtime/src/variables/device/calendar/delete-event.operation.tsx": "import { Operation, Output } from '../operation.provider';\nimport { CalendarInput, CalendarService } from \"@wavemaker/app-rn-runtime/core/device/calendar-service\";\n\nexport interface DeleteEventOutput extends Output {\n  dataValue: boolean;\n}\n\nexport class DeleteEventOperation implements Operation {\n  constructor(private calendar: CalendarService) {}\n\n  public invoke(params: CalendarInput): Promise<DeleteEventOutput> {\n    return this.calendar.deleteEvent(params);\n  }\n}\n", "wavemaker-rn-runtime/src/variables/device/calendar/create-event.operation.tsx": "import { Operation, Output } from '../operation.provider';\nimport { isDate, isString } from 'lodash';\nimport moment from 'moment';\nimport { CalendarInput, CalendarService } from \"@wavemaker/app-rn-runtime/core/device/calendar-service\";\n\nexport interface CreateEventOutput extends Output {\n  dataValue: string;\n}\n\n/**\n * method to get the date object from the input received\n */\nexport const getDateObj = (value: any): any => {\n\n  /*if the value is a date object, no need to covert it*/\n  if (isDate(value)) {\n    return value;\n  }\n\n  /*if the value is a timestamp string, convert it to a number*/\n  if (!isNaN(value)) {\n    value = parseInt(value, 10);\n  }\n\n  if (!moment(value).isValid() || value === '' || value === null || value === undefined) {\n    return undefined;\n  }\n  let dateObj = new Date(value);\n  /**\n   * if date value is string \"20-05-2019\" then new Date(value) return 20May2019 with current time in India,\n   * whereas this will return 19May2019 with time lagging for few hours.\n   * This is because it returns UTC time i.e. Coordinated Universal Time (UTC).\n   * To create date in local time use moment\n   */\n  if (isString(value)) {\n    /*\n     * If selected locale is Arabic, moment(value).format() is giving date in Arabic language\n     * (Ex: If date value is \"1990-11-23\" and moment(value).format() is \"\u0661\u0669\u0669\u0660-\u0661\u0661-\u0662\u0663T\u0660\u0660:\u0660\u0660:\u0660\u0660+\u0660\u0665:\u0663\u0660\")\n     * and new Date(moment(value).format()) is giving Invalid Date. So frst converting it to timestamp value.\n    */\n    dateObj = new Date(moment(moment(value).format()).valueOf());\n  }\n\n  if (isNaN(dateObj.getDay())) {\n    return new Date();\n  }\n  return dateObj;\n};\n\nexport class CreateEventOperation implements Operation {\n  constructor(private calendar: CalendarService) {}\n\n  public invoke(params: CalendarInput): Promise<CreateEventOutput> {\n    return this.calendar.createEvent(params);\n  }\n}\n", "wavemaker-rn-runtime/src/variables/device/calendar/get-events.operation.tsx": "import { Operation, Output } from '../operation.provider';\nimport { CalendarInput, CalendarService } from \"@wavemaker/app-rn-runtime/core/device/calendar-service\";\n\nexport interface CalendarEvent extends Output {\n  title: string;\n  message: string;\n  location: string;\n  startDate: string | Date;\n  endDate: string | Date;\n}\n\nexport class GetEventsOperation implements Operation {\n  constructor(private calendar: CalendarService) {}\n\n  public invoke(params: CalendarInput): Promise<Array<CalendarEvent>> {\n    return this.calendar.getEvents(params);\n  }\n}\n\n", "wavemaker-rn-runtime/src/variables/device/file/upload-file.operation.tsx": "import axios from 'axios';\nimport { Platform } from 'react-native';\nimport { endsWith } from 'lodash-es';\nimport * as DocumentPicker from 'expo-document-picker';\n\nimport { Operation } from '@wavemaker/app-rn-runtime/variables/device/operation.provider';\nimport { FileExtensionTypesMap } from '@wavemaker/app-rn-runtime/core/file-extension-types';\n\nexport interface UploadFileInput {\n  localFile: string;\n  remoteFolder: string;\n  serverUrl: string;\n  browse: boolean;\n}\n\nexport interface UploadFileOutput {\n  fileName: string;\n  path: string;\n  length: number;\n  success: boolean;\n  inlinePath: string;\n  errorMessage: string;\n}\n\nconst namedParameters = {\n  copyToCacheDirectory: false,\n  multiple: false,\n  type: '*/*'\n};\n\nexport class UploadFileOperation implements Operation {\n\n  public chooseFile() {\n    return DocumentPicker.getDocumentAsync(namedParameters).then((response: any) => {\n      const assets = response?.assets[0];\n      return { uri: assets.uri, name: assets.name };\n    });\n  }\n\n  public invoke(params: UploadFileInput): Promise<UploadFileOutput> {\n    params.serverUrl = endsWith(params.serverUrl, '/') ? params.serverUrl : params.serverUrl + '/';\n    let serverUrl = params.serverUrl + 'services/file/uploadFile';\n    if (params.remoteFolder) {\n      serverUrl = serverUrl + '?relativePath=' + params.remoteFolder\n    }\n    return Promise.resolve().then(() => {\n      if (!params.localFile && params.browse) {\n        return this.chooseFile();\n      } else {\n        const name: string | undefined = params.localFile.split('/').pop() || '';\n        return { uri: params.localFile, name: name };\n      }\n    }).then((data: { uri: string | undefined, name: string }) => {\n      if (!data || !data?.uri) {\n        return;\n      }\n      const fileName: string | undefined = data.name;\n      const arr: any = fileName.split('.');\n      const fileExtension: string = ('.' + arr[arr.length - 1]).toLocaleLowerCase();\n      let fileObj = {\n        uri: data.uri,\n        type: FileExtensionTypesMap[fileExtension],\n        name: fileName,\n      };\n\n      let formData = new FormData();\n      formData.append('files', fileObj as any);\n      return axios({\n        url: serverUrl,\n        method: 'POST',\n        headers: {\n          'Content-Type': 'multipart/form-data'\n        },\n        data: formData\n      }).then(\n        (response) => {\n        return response.data[0];\n      }, error => error);\n    });\n  }\n}\n", "wavemaker-rn-runtime/src/variables/device/camera/capture-image.operation.tsx": "import {CameraInput, CameraService} from \"@wavemaker/app-rn-runtime/core/device/camera-service\";\nimport { Operation, Output } from '../operation.provider';\n\nexport interface CaptureImageOutput extends Output {\n  imagePath: string;\n  content: string;\n}\n\nexport class CaptureImageOperation implements Operation {\n  constructor(private camera: CameraService) {}\n\n  public invoke(params: CameraInput): Promise<CaptureImageOutput> {\n    return this.camera.captureImage(params);\n  }\n}\n", "wavemaker-rn-runtime/src/variables/device/camera/capture-video.operation.tsx": "import { CameraService } from \"@wavemaker/app-rn-runtime/core/device/camera-service\";\nimport { Operation, Output } from '../operation.provider';\n\nexport interface CaptureVideoOutput extends Output {\n  videoPath: string;\n  content: string;\n}\n\nexport class CaptureVideoOperation implements Operation {\n  constructor(private camera: CameraService) {\n  }\n\n  public invoke(): Promise<CaptureVideoOutput> {\n    return this.camera.captureVideo();\n  }\n}\n", "wavemaker-rn-runtime/src/variables/device/contacts/get-contacts.operation.ts": "import { Output, Operation } from '../operation.provider';\nimport { ContactsInput, ContactsService } from \"@wavemaker/app-rn-runtime/core/device/contacts-service\";\n\nexport interface PhoneNumber {\n  value: string;\n}\n\nexport interface ContactsOutput extends Output{\n  id: number;\n  displayName: string;\n  phoneNumbers: Array<PhoneNumber>;\n}\n\nexport class GetContactsOperation implements Operation {\n  constructor(private contacts: ContactsService) {}\n\n  public invoke(params: ContactsInput): Promise<Array<ContactsOutput>> {\n    return this.contacts.getContacts(params);\n  }\n}\n", "wavemaker-rn-runtime/src/variables/device/scan/scan.operation.tsx": "import { ScanService } from \"@wavemaker/app-rn-runtime/core/device/scan-service\";\nimport { Operation, Input, Output } from '../operation.provider';\n\nexport interface ScanInput extends Input {\n  barcodeFormat: string;\n}\n\nexport interface ScanOutput extends Output {\n  text : string;\n  format : string;\n  cancelled : boolean;\n}\n\nexport class ScanOperation implements Operation {\n\n  constructor(private scan: ScanService) {}\n\n  public invoke(params: ScanInput): Promise<ScanOutput> {\n    return this.scan.scanBarcode(params);\n  }\n}\n", "wavemaker-rn-runtime/src/variables/device/device/current-geo-position.operation.ts": "import { Input, Operation, Output } from \"@wavemaker/app-rn-runtime/variables/device/operation.provider\";\nimport { LocationService } from \"@wavemaker/app-rn-runtime/core/device/location-service\";\n\nexport interface coordsOutput {\n  latitude: number | null;\n  longitude: number | null;\n  altitude: number | null;\n  accuracy: number | null;\n  altitudeAccuracy: number | null;\n  heading: number | null;\n  speed: number | null;\n}\n\nexport interface GeoPositionOutput extends Output {\n  coords: coordsOutput;\n  timestamp: number | null;\n}\n\nexport interface GeoPositionInput extends Input {\n  maximumAge: number;\n  timeout: number;\n  enableHighAccuracy: boolean;\n}\n\nexport class CurrentGeoPositionOperation implements Operation {\n  constructor(private location: LocationService) {\n  }\n\n  public invoke(params: GeoPositionInput): Promise<GeoPositionOutput> {\n    return this.location.getCurrentGeoPosition(params);\n  }\n}\n", "wavemaker-rn-runtime/src/variables/device/device/vibrate.operation.ts": "import { Vibration } from 'react-native';\nimport { Operation, Output } from \"@wavemaker/app-rn-runtime/variables/device/operation.provider\";\n\nexport interface VibrateInput {\n  vibrationtime: number;\n}\n\nexport class VibrateOperation implements Operation {\n\n  public invoke(params: VibrateInput): Promise<Output> {\n    Vibration.vibrate(params.vibrationtime * 1000);\n    return Promise.resolve({} as Output);\n  }\n}\n", "wavemaker-rn-runtime/src/variables/device/device/network-info.operation.ts": "import * as Network from 'expo-network';\nimport { Operation } from '@wavemaker/app-rn-runtime/variables/device/operation.provider';\nimport NetworkService from '@wavemaker/app-rn-runtime/core/network.service';\n\nimport { DeviceVariable } from '../../device-variable';\n\nexport interface NetworkInfoOutput {\n  connectionType: string;\n  isConnecting: boolean;\n  isNetworkAvailable: boolean;\n  isOnline: boolean;\n  isOffline: boolean;\n}\n\nexport class NetworkInfoOperation implements Operation {\n  isOnline = true;\n\n  public invoke(params?: any, onSuccess?: Function, onError?: Function, operation?: string, variable?: DeviceVariable): Promise<NetworkInfoOutput> {\n    const networkState = params.networkStatus;\n    return Network.getNetworkStateAsync().then((response) => {\n      return {\n        connectionType: Network.NetworkStateType[response.type as Network.NetworkStateType],      \n        isConnecting: networkState.isConnecting,\n        isNetworkAvailable: networkState.isNetworkAvailable,\n        isOnline: networkState.isConnected,\n        isOffline: !networkState.isConnected\n      } as NetworkInfoOutput;\n    }).then((dataset) => {\n      try {\n        if (this.isOnline !== networkState.isConnected) {\n          this.isOnline = networkState.isConnected;\n          const callback = (variable?.config as any)[networkState.isConnected ? 'onOnline' : 'onOffline'] as Function;\n          callback?.(variable, dataset);\n        }\n      } catch(e) {\n        console.error(e);\n      }\n      return dataset;\n    });\n  }\n}\n", "wavemaker-rn-runtime/src/variables/device/device/app-info.operation.ts": "import React from \"react\";\nimport { Operation } from \"@wavemaker/app-rn-runtime/variables/device/operation.provider\";\n\nexport interface AppInfoOutput {\n  appversion: string;\n  reactversion: string;\n}\n\nexport class AppInfoOperation implements Operation {\n  constructor(private data: {appVersion: string}) {\n  }\n\n  public invoke(): Promise<AppInfoOutput> {\n    return Promise.resolve({\n      appversion: this.data.appVersion,\n      reactversion: React.version\n    });\n  }\n}\n", "wavemaker-rn-runtime/src/variables/device/device/device-info.operation.ts": "import * as Device from 'expo-device';\nimport { Operation } from \"@wavemaker/app-rn-runtime/variables/device/operation.provider\";\n\nexport interface DeviceInfoOutput {\n  deviceModel: string | null;\n  os: string | null;\n  osVersion: string | null;\n  deviceUUID: string;\n}\n\nexport class DeviceInfoOperation implements Operation {\n  public invoke(): Promise<DeviceInfoOutput> {\n    return Promise.resolve({\n      deviceModel: Device.modelName,\n      os: Device.osName,\n      osVersion: Device.osVersion,\n      deviceUUID: ''\n    });\n  }\n}\n", "wavemaker-rn-runtime/src/gestures/swipe.animation.tsx": "import { isNil } from 'lodash-es';\nimport React from  'react';\nimport { Animated, Easing, View as RNView, ViewStyle, LayoutChangeEvent, LayoutRectangle, DimensionValue } from 'react-native';\nimport { Gesture, GestureDetector, GestureUpdateEvent } from 'react-native-gesture-handler';\nimport { isWebPreviewMode } from '@wavemaker/app-rn-runtime/core/utils';\nimport injector from '@wavemaker/app-rn-runtime/core/injector';\n\nexport class Handlers {\n    bounds?: (g: GestureUpdateEvent<any>) => Bounds = null as any;\n    onAnimation?: (g: GestureUpdateEvent<any>) => any = () => {};\n    onLower?:  (g: GestureUpdateEvent<any>) => any = () => {};\n    onUpper?:  (g: GestureUpdateEvent<any>) => any = () => {};\n    computePhase?: (value: number) => number = null as any;\n}\n\nexport interface Bounds {\n    upper?: number;\n    center?: number;\n    lower?: number;\n}\n\nexport class Props {\n    threshold?: number = 5;\n    direction?: 'horizontal' | 'vertical' = 'horizontal';\n    handlers?: Handlers = {} as any;\n    style?: ViewStyle = {} as any;\n    children: any;\n    enableGestures: any;\n    slideWidth?: DimensionValue = '100%';\n    slideMinWidth?: DimensionValue = undefined;\n}\n\nexport class State {\n    threshold = 5;\n    isHorizontal = false;\n    bounds: Bounds = {} as any;\n    maxPosition = Number.MAX_VALUE;\n}\n\nexport class View extends React.Component<Props, State> {\n\n    static defaultProps = new Props();\n\n    private gesture = Gesture.Pan();\n    private position = new Animated.Value(0);\n    public animationPhase = new Animated.Value(0);\n    private i18nService = injector.I18nService.get();\n    private childrenLayout: LayoutRectangle[] = [];\n    private viewLayout: LayoutRectangle = null as any;\n\n    constructor(props: Props) {\n        super(props);\n        this.state = {\n            isHorizontal:  props.direction === 'horizontal',\n            threshold: props.threshold || 5,\n            bounds: {} as any\n        } as State;\n        var touchStart = {\n            x: 0,\n            y: 0,\n            active: false\n        };\n        var swipeDirection :'horizontal' | 'vertical' = 'horizontal';\n        this.gesture\n            .minPointers(1)\n            .minDistance(this.state.threshold)\n            .enabled(this.props.enableGestures && !isWebPreviewMode())\n            .onTouchesDown((e, s) => {\n                touchStart = {\n                    x: e.changedTouches[0].x,\n                    y: e.changedTouches[0].y,\n                    active: false\n                  };\n            })\n            .onTouchesMove((e, s) => {\n                if (touchStart.active) {\n                    return;\n                }\n                const translationX = e.allTouches[0].x - touchStart.x;\n                const translationY = e.allTouches[0].y - touchStart.y;\n                swipeDirection = (Math.abs(translationX) > Math.abs(translationY)) ? 'horizontal' : 'vertical';\n                const d = (this.state.isHorizontal ? translationX : translationY);\n                const od = (this.state.isHorizontal ? translationY : translationX);\n                if(swipeDirection == this.props.direction && Math.abs(d) >= this.state.threshold){\n                    touchStart.active = true;\n                }\n                this.gesture\n                  .activeOffsetX([-this.state.threshold, this.state.threshold])\n                  .failOffsetY([-this.state.threshold, this.state.threshold]);\n            })\n            .onChange(e => {\n              if (!touchStart.active || swipeDirection != this.props.direction) {\n                    return;\n                }\n                const bounds = (this.props.handlers?.bounds && this.props.handlers?.bounds(e)) || {};\n                const d = (this.state.isHorizontal ? e.translationX : e.translationY);\n                let phase = this.computePhase(bounds?.center || 0);\n                if (d && d < 0 && !isNil(bounds.center) && !isNil(bounds.lower)\n                    && bounds.center !== bounds.lower) {\n                    phase += (d / (bounds.center - bounds.lower)) || 0;\n                } else if (d && d > 0 && !isNil(bounds.center) && !isNil(bounds.upper)\n                    && bounds.center !== bounds.upper) {\n                    phase += (d / (bounds.upper - bounds.center)) || 0;\n                }\n                this.animationPhase.setValue(phase);\n                this.position.setValue(\n                    (this.isRTL()?-bounds?.center! :bounds?.center || 0) + d);\n            })\n            .onEnd(e => {\n                if (!touchStart.active || swipeDirection != this.props.direction) {\n                    return;\n                }\n                touchStart =  {\n                    x: 0,\n                    y: 0,\n                    active: false\n                };\n                this.props.handlers?.onAnimation &&\n                this.props.handlers?.onAnimation(e);\n                if (e.translationX < 0) {\n                    this.isRTL()?this.goToLower(e):this.goToUpper(e);\n                } else if (e.translationX > 0) {\n                    this.isRTL()?this.goToUpper(e):this.goToLower(e);\n                }\n            })\n\n    }\n\n    computeMaxScroll() {\n        let max = Number.MAX_VALUE;\n        const childrenWidth = this.childrenLayout.reduce((s, v) => s + v.width, 0);\n        const childrenHeight = this.childrenLayout.reduce((s, v) => s + v.height, 0);\n        if (this.props.direction === 'horizontal') {\n            if (childrenWidth && this.viewLayout?.width) {\n                max = childrenWidth - this.viewLayout.width;\n            }\n        } else if (childrenHeight && this.viewLayout?.height) {\n            max = childrenHeight - this.viewLayout.height;\n        }\n        this.setState({maxPosition: -1 * max});\n    }\n\n    setChildrenLayout(event: LayoutChangeEvent, index: number) {\n      this.childrenLayout[index] = event.nativeEvent.layout;\n      this.computeMaxScroll();\n    }\n\n    setViewLayout(event: LayoutChangeEvent) {\n        this.viewLayout = event.nativeEvent.layout;\n        this.computeMaxScroll();\n    }\n\n    computePhase(value: number) {\n        return (this.props.handlers?.computePhase &&\n            this.props.handlers?.computePhase(value)) || 0;\n    }\n\n    isRTL(){\n        return this.i18nService.isRTLLocale();\n    }\n\n    goToLower(e?: any) {\n        const bounds = (this.props.handlers?.bounds && this.props.handlers?.bounds(e)) || {};\n        this.setPosition(bounds.lower)\n            .then(() => {\n                if (!isNil(bounds.lower) && bounds.center !== bounds.lower) {\n                    this.props.handlers?.onLower &&\n                    this.props.handlers?.onLower(e);\n                }\n            });\n    }\n\n    goToUpper(e?: any) {\n        const bounds = (this.props.handlers?.bounds && this.props.handlers?.bounds(e)) || {};\n        this.setPosition(bounds.upper)\n            .then(() => {\n                if (!isNil(bounds.upper) && bounds.center !== bounds.upper) {\n                    this.props.handlers?.onUpper &&\n                    this.props.handlers?.onUpper(e);\n                }\n            });\n    }\n\n    setPosition(value: number | undefined) {\n        if (isNil(value)) {\n            return Promise.reject();\n        }\n        let position = isNaN(this.state.maxPosition) ? value : Math.max(this.state.maxPosition, value);\n        return new Promise((resolve) => {\n            Animated.parallel([\n                Animated.timing(this.animationPhase, {\n                    useNativeDriver: true,\n                    toValue:  this.computePhase(value),\n                    duration: 200,\n                    easing: Easing.out(Easing.linear)\n                }),\n                Animated.timing(this.position, {\n                    useNativeDriver: true,\n                    toValue:  (this.isRTL() ? -1: 1) * position,\n                    duration: 200,\n                    easing: Easing.out(Easing.linear)\n                })\n            ]).start(resolve);\n        });\n    }\n\n    public render() {\n        const isHorizontal = this.props.direction === 'horizontal';\n        return (\n            //@ts-ignore\n            <GestureDetector gesture={this.gesture}>\n                <Animated.View style={[\n                    isHorizontal ? {\n                        flexDirection: 'row',\n                        flexWrap: 'nowrap',\n                        alignItems: 'center',\n                    } : null,\n                    this.props.style,\n                    ]} onLayout={this.setViewLayout.bind(this)}>\n                    {this.props.children.map((c: any, i: number) => {\n                        return (<Animated.View onLayout={(e) => this.setChildrenLayout(e, i)} key={c.key}\n                            style={[this.props.slideMinWidth ? {\n                                minWidth: this.props.slideMinWidth\n                            } : {\n                                width: this.props.slideWidth\n                            },\n                            {\n                                transform: this.state.isHorizontal ? [{\n                                    translateX: this.position\n                                }] : [{\n                                    translateY: this.position\n                                }]\n                            },\n                            this.props.style?.height === '100%' ? {\n                                height: '100%'\n                            } : null\n                        ]}>\n                            {c}\n                        </Animated.View>);\n                    })}\n                </Animated.View>\n            </GestureDetector>\n        );\n    }\n\n}\n", "wavemaker-rn-runtime/src/gestures/carousel-swipe.animation.tsx": "import { isNil } from 'lodash-es';\nimport React from 'react';\nimport { Animated, Easing, View as RNView, ViewStyle, LayoutChangeEvent, LayoutRectangle, DimensionValue, PanResponder } from 'react-native';\nimport { Gesture, GestureDetector, GestureUpdateEvent } from 'react-native-gesture-handler';\nimport { isWebPreviewMode } from '@wavemaker/app-rn-runtime/core/utils';\nimport injector from '@wavemaker/app-rn-runtime/core/injector';\n\nexport class Handlers {\n    bounds?: (g: GestureUpdateEvent<any>) => Bounds = null as any;\n    onAnimation?: (g: GestureUpdateEvent<any>) => any = () => { };\n    onLower?: (g: GestureUpdateEvent<any>) => any = () => { };\n    onUpper?: (g: GestureUpdateEvent<any>) => any = () => { };\n    computePhase?: (value: number) => number = null as any;\n}\n\nexport interface Bounds {\n    upper?: number;\n    center?: number;\n    lower?: number;\n}\n\nexport class Props {\n    threshold?: number = 5;\n    direction?: 'horizontal' | 'vertical' = 'horizontal';\n    handlers?: Handlers = {} as any;\n    style?: ViewStyle = {} as any;\n    children: any;\n    enableGestures: any;\n    slideWidth?: DimensionValue = '100%';\n    slideMinWidth?: DimensionValue = undefined;\n    slidesLayout?: any = [];\n    activeIndex?: number | null = null;\n}\n\nexport class State {\n    threshold = 5;\n    isHorizontal = false;\n    bounds: Bounds = {} as any;\n    maxPosition = Number.MAX_VALUE;\n}\n\nexport class View extends React.Component<Props, State> {\n\n    static defaultProps = new Props();\n    private position = new Animated.Value(0);\n    public animationPhase = new Animated.Value(0);\n    private i18nService = injector.I18nService.get();\n    private childrenLayout: LayoutRectangle[] = [];\n    private viewLayout: LayoutRectangle = null as any;\n    private panResponder: any = null;\n\n    constructor(props: Props) {\n        super(props);\n        this.state = {\n            isHorizontal: props.direction === 'horizontal',\n            threshold: props.threshold || 49,\n            bounds: {} as any\n        } as State;\n        var touchStart = {\n            x: 0,\n            y: 0,\n            active: false\n        };\n\n        this.panResponder = PanResponder.create({\n            onStartShouldSetPanResponder: (evt, gestureState) => {\n                return this.shouldEnablePanResponder(gestureState.dx, gestureState.dy);\n            },\n            onStartShouldSetPanResponderCapture: (evt, gestureState) => {\n                return this.shouldEnablePanResponder(gestureState.dx, gestureState.dy);\n            },\n            onMoveShouldSetPanResponder: (evt, gestureState) => {\n                return this.shouldEnablePanResponder(gestureState.dx, gestureState.dy);\n            },\n            onMoveShouldSetPanResponderCapture: (evt, gestureState) =>{\n                return this.shouldEnablePanResponder(gestureState.dx, gestureState.dy);\n            },\n            onPanResponderMove: (evt, gestureState) => {\n                this.onChange(gestureState)\n            },\n            onPanResponderRelease: (evt, gestureState) => {\n                if (\n                    this.props.direction === 'horizontal' && \n                    (gestureState.dx > this.state.threshold || gestureState.dx < -this.state.threshold)\n                ) {\n                    this.onEnd(gestureState);\n                }\n                if (\n                    this.props.direction === 'vertical' && \n                    (gestureState.dy > this.state.threshold || gestureState.dy < -this.state.threshold)\n                ) {\n                    this.onEnd(gestureState);\n                }\n\n                if (\n                    !(gestureState.dy > this.state.threshold || gestureState.dy < -this.state.threshold) && \n                    !(gestureState.dx > this.state.threshold || gestureState.dx < -this.state.threshold)\n                ) {\n                    if (this.props.activeIndex) {\n                        this.setPosition(this.props.slidesLayout[this.props.activeIndex])\n                    }\n                }\n            }\n        });\n\n    }\n\n\n    shouldEnablePanResponder = (dx: number, dy: number) => {\n        const gestureEnableThreshold = 30;\n\n        const shouldEnable = (this.props.direction === 'horizontal' ? Math.abs(dx) > Math.abs(dy) : Math.abs(dx) < Math.abs(dy)) &&\n            (this.props.direction === 'horizontal' ? Math.abs(dx) > gestureEnableThreshold : Math.abs(dy) > gestureEnableThreshold)\n\n        return this.props.enableGestures && shouldEnable;\n    }\n\n    onChange = (e: any) => {\n        const bounds = (this.props.handlers?.bounds && this.props.handlers?.bounds(e)) || {};\n        const d = (this.state.isHorizontal ? e.dx : e.dy);\n        let phase = this.computePhase(bounds?.center || 0);\n        if (d && d < 0 && !isNil(bounds.center) && !isNil(bounds.lower)\n            && bounds.center !== bounds.lower) {\n            phase += (d / (bounds.center - bounds.lower)) || 0;\n        } else if (d && d > 0 && !isNil(bounds.center) && !isNil(bounds.upper)\n            && bounds.center !== bounds.upper) {\n            phase += (d / (bounds.upper - bounds.center)) || 0;\n        }\n        this.animationPhase.setValue(phase);\n        this.position.setValue(\n            (this.isRTL() ? -bounds?.center! : bounds?.center || 0) + d);\n    }\n\n    onEnd = (e: any) => {\n        this.props.handlers?.onAnimation &&\n            this.props.handlers?.onAnimation(e);\n        if (e.dx < 0) {\n            this.isRTL() ? this.goToLower(e) : this.goToUpper(e);\n        } else if (e.dx > 0) {\n            this.isRTL() ? this.goToUpper(e) : this.goToLower(e);\n        }\n    }\n\n    computeMaxScroll() {\n        let max = Number.MAX_VALUE;\n        const childrenWidth = this.childrenLayout.reduce((s, v) => s + v.width, 0);\n        const childrenHeight = this.childrenLayout.reduce((s, v) => s + v.height, 0);\n        if (this.props.direction === 'horizontal') {\n            if (childrenWidth && this.viewLayout?.width) {\n                max = childrenWidth - this.viewLayout.width;\n            }\n        } else if (childrenHeight && this.viewLayout?.height) {\n            max = childrenHeight - this.viewLayout.height;\n        }\n        this.setState({ maxPosition: -1 * max });\n    }\n\n    setChildrenLayout(event: LayoutChangeEvent, index: number) {\n        this.childrenLayout[index] = event.nativeEvent.layout;\n        this.computeMaxScroll();\n    }\n\n    setViewLayout(event: LayoutChangeEvent) {\n        this.viewLayout = event.nativeEvent.layout;\n        this.computeMaxScroll();\n    }\n\n    computePhase(value: number) {\n        return (this.props.handlers?.computePhase &&\n            this.props.handlers?.computePhase(value)) || 0;\n    }\n\n    isRTL() {\n        return this.i18nService.isRTLLocale();\n    }\n\n    goToLower(e?: any) {\n        const bounds = (this.props.handlers?.bounds && this.props.handlers?.bounds(e)) || {};\n        console.log(\"\ud83d\ude80 ~ View ~ goToLower ~ bounds:\", bounds)\n        this.setPosition(bounds.lower)\n            .then(() => {\n                if (!isNil(bounds.lower) && bounds.center !== bounds.lower) {\n                    this.props.handlers?.onLower &&\n                        this.props.handlers?.onLower(e);\n                }\n            });\n    }\n\n    goToUpper(e?: any) {\n        const bounds = (this.props.handlers?.bounds && this.props.handlers?.bounds(e)) || {};\n        this.setPosition(bounds.upper)\n            .then(() => {\n                if (!isNil(bounds.upper) && bounds.center !== bounds.upper) {\n                    this.props.handlers?.onUpper &&\n                        this.props.handlers?.onUpper(e);\n                }\n            });\n    }\n\n    setPosition(value: number | undefined) {\n        if (isNil(value)) {\n            return Promise.reject();\n        }\n        let position = isNaN(this.state.maxPosition) ? value : Math.max(this.state.maxPosition, value);\n        return new Promise((resolve) => {\n            Animated.parallel([\n                Animated.timing(this.animationPhase, {\n                    useNativeDriver: true,\n                    toValue: this.computePhase(value),\n                    duration: 200,\n                    easing: Easing.out(Easing.linear)\n                }),\n                Animated.timing(this.position, {\n                    useNativeDriver: true,\n                    toValue: (this.isRTL() ? -1 : 1) * position,\n                    duration: 200,\n                    easing: Easing.out(Easing.linear)\n                })\n            ]).start(resolve);\n        });\n    }\n\n    public render() {\n        const isHorizontal = this.props.direction === 'horizontal';\n        return (\n            //@ts-ignore\n            <RNView style={[\n                isHorizontal ? {\n                    flexDirection: 'row',\n                    flexWrap: 'nowrap',\n                    alignItems: 'center',\n                } : null,\n                this.props.style]}\n                onLayout={this.setViewLayout.bind(this)}\n                {...this.panResponder.panHandlers}\n            >\n                {this.props.children.map((c: any, i: number) => {\n                    return (<Animated.View onLayout={(e) => this.setChildrenLayout(e, i)} key={c.key}\n                        style={[this.props.slideMinWidth ? {\n                            minWidth: this.props.slideMinWidth\n                        } : {\n                            width: this.props.slideWidth\n                        },\n                        this.props.style?.height === '100%' ? {\n                            height: '100%'\n                        } : null,\n                        {\n                            transform: this.state.isHorizontal ? [{\n                                translateX: this.position\n                            }] : [{\n                                translateY: this.position\n                            }]\n                        }\n                        ]}>\n                        {c}\n                    </Animated.View>);\n                })}\n            </RNView>\n        );\n    }\n\n}\n", "wavemaker-rn-runtime/src/actions/timer-action.ts": "import { ActionConfig, BaseAction } from \"./base-action\";\nexport interface TimerActionConfig extends ActionConfig {\n    repeating: Boolean;\n    delay: number;\n    onSuccess: any;\n}\nexport class TimerAction extends BaseAction<TimerActionConfig> {\n    repeating: Boolean;\n    _isFired = false;\n    _schedulerID: any = -1;\n    delay: number;\n    constructor(config: TimerActionConfig) {\n        super(config);\n        this.repeating = config.repeating;\n        this.delay = config.delay || 500;\n    }\n\n    invoke(options: any, success: any, error: any) {\n        super.invoke(options, success, error);\n        return this.fire(this.params, success, error) as any;\n    }\n\n    cancel() {\n        if (this._schedulerID > -1) {\n            if (this.repeating) {\n                clearInterval(this._schedulerID);\n            } else {\n                clearTimeout(this._schedulerID);\n            }\n            this._schedulerID = -1;\n        }\n    }\n\n    destroy() {\n        this.cancel();\n    }\n\n    pause() {\n        this.cancel();\n    }\n\n    trigger(options: any, success: any, error: any) {\n        if (this._schedulerID > -1) {\n            return;\n        }\n        const repeatTimer = this.repeating,\n            delay = this.delay,\n            exec = () => {\n                this.config.onSuccess && this.config.onSuccess();\n            };\n\n        this._schedulerID = repeatTimer ? setInterval(exec, delay) : setTimeout( () => {\n            exec();\n            this._schedulerID = -1;\n        }, delay);\n\n        return this._schedulerID;\n    }\n\n    fire(options: any, success: any, error: any) {\n        if(this.repeating) {\n            this._isFired = true;\n        }\n        return this.trigger(options, success, error);\n    }\n}", "wavemaker-rn-runtime/src/actions/login-action.ts": "import { ActionConfig, BaseAction } from \"./base-action\";\nimport { VariableEvents } from '../variables/base-variable';\nimport { SecurityService } from \"@wavemaker/app-rn-runtime/core/security.service\";\nimport { get } from 'lodash';\nexport interface LoginActionConfig extends ActionConfig {\n    securityService: () => SecurityService;\n    baseURL: String;\n    useDefaultSuccessHandler: boolean;\n}\nexport class LoginAction extends BaseAction<LoginActionConfig> {\n    constructor(config: LoginActionConfig) {\n        super(config);\n    }\n\n    invoke(options: any, successcb?: Function, errorcb?: Function) {\n      let params;\n      if (!get(options, 'formData')) {\n        params = this.config.paramProvider();\n      }\n      this.notify(VariableEvents.BEFORE_INVOKE, [this, params]);\n      return this.config.securityService().appLogin(\n        {\n          baseURL: this.config.baseURL,\n          formData: get(options, 'formData') || params,\n          useDefaultSuccessHandler: this.config.useDefaultSuccessHandler\n      })\n        .then((data: any) => {\n            this.config.onSuccess && this.config.onSuccess(this, get(data, 'userInfo'));\n            successcb && successcb(data);\n            this.notify(VariableEvents.AFTER_INVOKE, [this, data]);\n            if (this.config.useDefaultSuccessHandler) {\n              this.config.securityService().navigateToLandingPage(data);\n            }\n        })\n        .catch((error: any) => {\n            this.config.onError && this.config.onError(this, error);\n            errorcb && errorcb(error);\n            this.notify(VariableEvents.AFTER_INVOKE, [this, error]);\n        });\n    }\n}\n", "wavemaker-rn-runtime/src/actions/base-action.ts": "import { BaseVariable, VariableConfig } from \"@wavemaker/app-rn-runtime/variables/base-variable\";\nimport {merge} from \"lodash\";\n\nexport interface ActionConfig extends VariableConfig {\n\n}\n\nexport class BaseAction<T extends ActionConfig> extends BaseVariable<T> {\n\n    constructor(config: T) {\n        super(config);\n    }\n\n    setData(dataSet: any) {\n        // @ts-ignore\n        this.dataSet = merge(this.config.paramProvider(), dataSet);\n    }\n}\n", "wavemaker-rn-runtime/src/actions/index.ts": "export * from './base-action';\nexport * from './navigation-action';\nexport * from './timer-action';\nexport * from './notification-action';\nexport * from './login-action';", "wavemaker-rn-runtime/src/actions/logout-action.ts": "import { ActionConfig, BaseAction } from \"./base-action\";\nimport { SecurityService } from \"@wavemaker/app-rn-runtime/core/security.service\";\nimport { VariableEvents } from '../variables/base-variable';\nexport interface LogoutActionConfig extends ActionConfig {\n    securityService: () => SecurityService;\n    baseURL: String;\n}\nexport class LogoutAction extends BaseAction<LogoutActionConfig> {\n    constructor(config: LogoutActionConfig) {\n        super(config);\n    }\n\n    invoke(options: any, successcb?: Function, errorcb?: Function) {\n        this.notify(VariableEvents.BEFORE_INVOKE, [this]);\n        return this.config.securityService().appLogout({baseURL: this.config.baseURL})\n        .then((data: any) => {\n            this.notify(VariableEvents.AFTER_INVOKE, [this, data]);\n            this.config.onSuccess && this.config.onSuccess(this, data);\n            successcb && successcb(data);     \n        })\n        .catch((error: any) => {\n            this.config.onError && this.config.onError(this, error);\n            errorcb && errorcb(error);\n            this.notify(VariableEvents.AFTER_INVOKE, [this, error]);\n        });\n    }\n}", "wavemaker-rn-runtime/src/actions/notification-action.ts": "import { ActionConfig, BaseAction } from \"./base-action\";\nimport { ToastOptions, ToastService } from '@wavemaker/app-rn-runtime/core/toast.service';\nimport React from 'react';\nexport interface NotificationActionConfig extends ActionConfig {\n    showDialog: Function;\n    onOk: any;\n    onCancel: any;\n    onClose: any;\n    operation: string;\n    partialContent: React.ReactNode;\n    toasterService: () => ToastService;\n}\nconst DEFAULT_DURATION = 3000;\nexport class NotificationAction extends BaseAction<NotificationActionConfig> {\n    showDialog: Function;\n    constructor(config: NotificationActionConfig) {\n        super(config);\n        this.showDialog = config.showDialog;\n    }\n\n    prepareToastOptions(options: any = {}) {\n        const params = this.config.paramProvider();\n        const o = {} as ToastOptions;\n        o.text = options.message || params.text;\n        o.type = options.class?.toLowerCase() || params.class?.toLowerCase();\n        o.onClose = () => {\n            this.config.onClose && this.config.onClose(this);\n        },\n        o.onClick = () => {\n            this.config.onOk && this.config.onOk(this);\n        },\n        o.content = this.config.partialContent;\n        o.hideOnClick = !params.showclosebutton && (options.hideOnClick || true);\n        o.showclosebutton = params.showclosebutton;\n        o.closeiconclass = params.closeiconclass || 'wi wi-close';\n        const toasterPosition = options.position || params.toasterPosition || 'bottom right';\n        const placement = toasterPosition.split(' ')[0];\n        switch(placement) {\n            case 'top':\n                o.styles = {top: 0};\n                break;\n            case 'bottom':\n                o.styles = {bottom: 0};\n                break;\n            case 'center':\n                o.styles = {top: '50%'};\n                break;\n        }\n        if (this.config.partialContent) {\n            if (!o.styles) {\n                o.styles = {};\n            }\n        }\n        if (!params.duration) {\n          params.duration = (params.duration !== 0 && o.type === 'success') ? DEFAULT_DURATION : 0;\n        }\n        o.duration = parseInt(options.duration || params.duration);\n        o.name = this.name;\n        return o;\n      }\n\n    getMessage() {\n        return this.config.paramProvider().text;\n    }\n\n    invoke(options: any, success: any, error: any) {\n        super.invoke(options, success, error);\n        if (this.config.operation === 'toast') {\n            const toasterService = this.config.toasterService();\n            return toasterService.showToast(this.prepareToastOptions(options));\n        } else {\n            return this.showDialog && this.showDialog({...this.params, onOk: this.config.onOk, onCancel: this.config.onCancel, onClose: this.config.onClose});\n        }\n    }\n}\n", "wavemaker-rn-runtime/src/actions/navigation-action.ts": "import AppConfig from \"@wavemaker/app-rn-runtime/core/AppConfig\";\nimport { VariableEvents } from \"@wavemaker/app-rn-runtime/variables/base-variable\";\nimport { ActionConfig, BaseAction } from \"./base-action\";\nimport {merge} from \"lodash\";\n\nexport interface NavigationActionConfig extends ActionConfig {\n    appConfig: AppConfig;\n    operation: string;\n    _context: any;\n}\n\nexport class NavigationAction extends BaseAction<NavigationActionConfig> {\n    constructor(config: NavigationActionConfig) {\n        super(config);\n    }\n\n    public invoke(params?: {}, onSuccess?: Function, onError?: Function): Promise<NavigationAction> {\n        const config = this.config;\n        // @ts-ignore\n        params = params?.data ? merge(this.config.paramProvider(), params.data) : merge(this.config.paramProvider(), this.dataSet);\n        this.notify(VariableEvents.BEFORE_INVOKE, [this, this.dataSet]);\n        return super.invoke(params, onSuccess, onError).then(() => {\n            switch(config.operation) {\n                case 'goToPreviousPage':\n                    config.appConfig.currentPage?.goBack();\n                    break;\n                case 'gotoTab':\n                    this.config._context?.Widgets[(params as any)?.tabName].select();\n                    break;\n                case 'gotoAccordion':\n                    this.config._context?.Widgets[(params as any)?.accordionName].expand();\n                    break;\n                case 'gotoPage' : \n                    config.appConfig.currentPage?.goToPage(this.params.pageName, this.params);\n            }\n        }).then(() => {\n            config.onSuccess && config.onSuccess(this, this.dataSet);\n            this.notify(VariableEvents.SUCCESS, [this, this.dataSet]);\n        }, () => {\n            config.onError && config.onError(this, null);\n            this.notify(VariableEvents.ERROR, [this, this.dataSet]);\n        }).then(() => {\n            this.notify(VariableEvents.AFTER_INVOKE, [this, this.dataSet]);\n            return this;\n        });\n    }\n\n    public navigate(params?: {}, onSuccess?: Function, onError?: Function): Promise<NavigationAction> {\n        return this.invoke(params, onSuccess, onError);\n    }\n}\n"}}